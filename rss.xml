<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星光light</title>
  
  <subtitle>星光light的blog</subtitle>
  <link href="https://xglight.github.io/rss.xml" rel="self"/>
  
  <link href="https://xglight.github.io/"/>
  <updated>2025-10-29T14:35:50.077Z</updated>
  <id>https://xglight.github.io/</id>
  
  <author>
    <name>星光light</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2025.10.29-NOIP</title>
    <link href="https://xglight.github.io/posts/d98fae2/"/>
    <id>https://xglight.github.io/posts/d98fae2/</id>
    <published>2025-10-29T13:00:00.000Z</published>
    <updated>2025-10-29T14:35:50.077Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="fe94a0d8c1a7911d1bf880e6abb357c7e04a46b84e5ff2eee0aa91ebaa8dadd5">93024cf999deb8d8b2919f7e109263d4fa4f22b5a6d5f2a46597c1ea59cef215f2fb6074b217f6d1d837246605c722979219760661120bad378ee841db1d6ece06b715dc2ec3e418211e4ac040af43a52585d4be41aad0352b96f107ff167c660c7473800697740c5f8d4f36c0a7797358ec23557d0a4551a246fad8ba24a2d60a6c6db4949ea496d54435c59b5667e1765c2b4f2609eaad0a02ae00fbf44cc8bbe682507298e6fa7f33ea286aea7273f04d390170745b943ee40ddbbfa46acd1522920d7ba3ef2390f777a724b88cd9dd0186372461b04c5a340733e0ee48a682d6a151beb0c7aa776de6fe86d1ba589dfb7b0a70bad0a6245955f94b5fc397525e1f60b0b14d2449133c01cc16394b052434bc36bb90c2b01ac0d2b9d2d6c7217962339d18164e84f656cc8f5c2f63d4dbb50b40fe43bd1ff1c5a6c8be7fdee906e039689ac7197fb53844896ec4bfa31227a3efd28165f16f4780ceb3dd21ba73af4e032bfcf83c3590ba48cb00005830f8a35c29538ce4ce0a9f074e77b096f1404503a210ddde5855eeff8ebd886daa558c4e83be9de27c5fe0bcd6fc074e18076dc0fd619ff9402257b152138b2c0afebc4937bbc9e991b265ea3ae9b54d62d886984b4ee01adc2537abedbd723d1d4245e1b7de334d90eed4b486fa6663e0c1ff803a1a2fd8f234ef6bd1b4491605c6cb09879da207e9d9a3b957538428f41e30e9e902035cc0d858fe147a5d889506e4f65d96daebcddd80fa24ea5bf1dd3ae6d27b71033411a64dfe3e59a7edb56dce23f8ede608d075900a1fef6f4d1080aa21bb2f911c9f66edc149956569427bb092e0a57a30007f52b7d9146a1b5ef430bd128c2e0129ae074c2d9b96546b5fd57a8b69992f6da4eb0ace29f23a719284537165d35ad7022d1ee121e5a3cb0161edf9ef943b04c283788e7574c7b627d54b4c966bf3ca7e8d3faf178e9ef8a98ad69d1dd8b8793276f60f4c7dab3dfcb45cad9e6f74f26e7fb4b4e81c5a055469cb3f0d943704f9578714655134ca992a18cbf2bff7d13b37434a82a5349a8aef7a7135c71af4a3d0b714a1a766a2e522af67fa0203f08c3dd424e70fbccf9e5de37b8f754dd26679a3608208571844e3be8be547bd9599fbe20a6acb4b43f95bb6ed8f89babc8ec03e791f324831a76779e102578ef4df7d5935887445967ccd7ad97603794821ec78f3c1a53eaf5311ffef3a196777e0ba3c1c689669fd8b36301ea50321e57c323e90579f412223fac9edbda88b56c0038fc78f1928ea5e2dbba323687bd3740ebf42a38d8c66412b535a6bd2639eac4b448e22b01f9b4fa471ab40d2ea9dec9cf0db219dd82b4bdcfce403fedc19f9c75399f3cbe26d616b5d2cadc9074f67cfd078c29ff71f13c688785076fc13928b4bcd352f1b9b99f43a66aaa5a09a6a39092abd7f1676ffe78e54202a3ce67aae85f3e9a4a8b27c924abeb6cbdf9b1dac6ba591ec8b2f1b3f595d37e0825e270b5df78d1970017e3e2dbac7d94997dac12555877862c7a16c92d50360a1d570b8116e4191868b7bbd875b4f889cae12db9d509a45b2cb6d3f64ba7e0eb8796f237f76f305cc6d0b7b03908f0340cfbab6aa03f6598c4ca8da879772e6da26d8b18bfec008ba28763bf78be80a37a5ecb5ebc7725255af239f08323b55a995b13faba1e0c7bf49fc09aff89f0181a9de4d2a08ad5eae3b5c495a00f086299a2723b697ace2a62527a58a17f9e50577bffd58d6100eee22330b2c4d4f763d68eef8bd57975294f93b2b37bef6c95fb5c1f1d2d3d3352e90c7ee6d019e040b1f5f9246adaf3c7948a546c083fa7602e45eced1988b84bba839bdc1bcf70fd36b6c47cbdb7a88caa1e45ee7838088e7694884013b9cd240bf2332e88a79f8e8809cb893231da453873722d7e946b556003517f8f3580da6e311d1f09ef5499b3ffd6b54cfcabdb4b79f5b414a222509996c1120663b3a9ae49500ef9046f4ffb912348f225cbae10fb6e3b2e4a76f7327006bdcf2e9818cac3b41451f99c2fa034c64cd48e583427596e7d83569e8b46fef8a65c427dd3a1885e89f831f9fe9ef2ef89902ba912951699ef2b296a7cd0454c2cc226022dafa47c4f965c560a8c122f391785808a454a535218f3c310cf98af1399daaaa13ae858a9221f23d2afa9171ce2860a7dd5cdbd7a6d0101406a978a1e71964bb6b8834b77bf0ce3e478255dd31e4cff34b254b08c41d2f5d60087ae733b57841e0d5c04587d40f140076991963e35305d6820d36f67371d258fe98ccbde6a3d212123043a9003fdcc42d8255fa109a7ee2113ff60f7d34e492cb80f1ad236be55e57d2b148d5e549725b72c85416ba5d97282bed6ab97bdd8f249a6676172eaec0024fdd108cf7c8355383c45a82ddd1764d2fe59c22c3979e4aaaef46c824795659c057c2d4e41669868c91be434ab9725241a5d189e06b26a823be4ee673b4c9d2540a6eb790dcecd310bcec050945cb68a197f96b4ab6df271cb4a4469f38eceb46effce333a6e0ef17aec7c41b4e990112d77cdc343f2f0164ab0a4ba455562af824aa5ae0c1d78e457868037db2cc9794682034fec1d77bf030b3c6731a69af46f9c581e7bf6ee7af4646a99c6c017bc9a369fd89f97aef2ef24a8af88253163fa28436b356dd5fa8f9697c1e189f79ce30d4662f301f05c121f0dad0a678773b44e659257564ae7541c2b45901c8fafec337f66b797fc2972eebbeddccb3f418646fa05d7e5e106b32727c2b44bc502a21a02ae8a065b5e25a6d7bfc92906a628fb5b191dc9115fb2efca87a500c7f148d84469f87a81a840000b15ecfd0babba6bdc76ad9f31aa978665cb2cab250161a46828accbb24552784baccd126dafc4dcdd88bd02a5bd0187445a738f2bc39f661a9b768a119feac0d20ed7bb164032f839a64068b1dd6ea90e64bcff322a52b444d53f64d33a376fe1303736c487c176aaabbdd5e1ce856d6ff046f32a6430a180715536c08f67f89c9f50db09627feb181e4d5c3c492a6a5486fa688c0807ab25428fcf943f3afbf78808f4357284809665b43c0b7e6ef220855ca8d7b6f357120ecfad93dad1a73811a8a01c2f66af643cd793c628212659c8d16269135ad46a0e1d8368716252eaeaf350a4ff19c338439b9479cf49f1bfddf24c50c2068f0460ff4ca851571058e36c40ab324f837a1de33e706eca9762c851e2a13c440d6e19076ae6afa4bf997ee27fc337c00dc6b04616a63bc3870f4550d86f024958626c93607fcf74431d36c4abc3a7ce92130349aad5dd70e6353622f46bf9f26a1470af8a0bb97c490fbbed91446463e3dc4883ad7a96eebce90a88b6a0fe09e6cb2a99633ebd567ac33f2d3c81eadfd9412aa800f52d90538ef093179afcb37886a844922b34ddf62eee2625095e2ab7925904e2c49bdaf21dc62622dc3a26a3d0cef4c219ed7139548dc23bcc67c66163f911049d4c6353d1e85046f203f3855594dbc296dbefdee6bd835f6447592206e02c2f9b5c53e68640d5dbfdeda8b76f2ba6f2b5fb4030e8856c1be9e37be7bd884048d9f8278762801066d05a4c9904973ab0a61beef9458df2ac9bb4dfbf8d13e6face16dbdeff8632a9435674ee89198c544f49c8a61fe84cfeb3981ed43707de6b8b64ce838cab2ccac33389500e6b02fef64d534e7e8162eb963a5c5ea6c636eb40b2494bff7e27a23f920f1a134877db6a77720fccc8309047825b8a4c26dbe9d546b7c29016302979cc16bbc320ab7b8bd2ceb71e34b18</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">2025.10.29-NOIP 比赛总结</summary>
    
    
    
    <category term="solutions" scheme="https://xglight.github.io/categories/solutions/"/>
    
    
    <category term="school" scheme="https://xglight.github.io/tags/school/"/>
    
  </entry>
  
  <entry>
    <title>2025.10.28-NOIP</title>
    <link href="https://xglight.github.io/posts/c6c42947/"/>
    <id>https://xglight.github.io/posts/c6c42947/</id>
    <published>2025-10-28T13:00:00.000Z</published>
    <updated>2025-10-29T14:35:50.077Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="dec0042d1f56cfa55af20cf344cf904f22961e78ae583d7b8292730f79facf47">93024cf999deb8d8b2919f7e109263d43aacb93126eeadb1d972d22e8288c18d69f7655a7188b53a112604ace5a033b742b1c431e404f4cf710d5d1a1e6ed002736b292260860974a002ad0b193f3b4b155bba22c79570884a02df86937a901c78d4377ea05682e55c57c4b18d82b3ef5bd813e25c31efd4361fd0ce9563bd96556a387090e95e1032d4942bdb28a4333c04602840d13f9445615f00dff6b50331d0b95a1b2312fe6a919c05a519b42cdbff18237b1300241b4bc9799827af1918b0d911125c0548229d08c133a7ba79f94983bb13e6b01d82c4132e6cb716a6254d7641772f65831c9eb0919ae3f9376a060de19af1ef42d1f0b2c5a8e39f14f5fd53d9f59c243eef15325585e819f76482362753663045633345e16b2fff88b290e90da17934a3052865ee5ecb705767e2ec77ee564ca6cc45244e76b188500859c40d2ee7d90a6aa226f42c580e77ae8b65b333c392e0382f9e3646416fa8e866333c9de00b5792b8b26fb6f83cad7435e0462f5b6bae1138467df9c775b31d543dc85a14130940b6d054eef3e1d0f001028f8acd030b5265dd76216eedd00102a6b071f0e3f9d0415d8554544b28c99553af5063dbd0363d445cdcd7f4dbbbab8fdeff7ff1d1c7de6338f11c5807bbf9e68816fcdd657b1ad878e786efcd3b08108366968dbdfeca2c474fa5f69c52e58b6031b4d8915fce1a940b58c3e52138325184ca82fd3e40ae65dc2b0ec9fcdbf8aae1e45e05bc9b36b1a4141dbc0e00513c399a2356e8c433c0eb7ffd300323b7cc2d7469ae6e32a1857c06c9614eba4a8f06999cd3ccfc6a165854be184b31f1215e6b291d58fd6f9dba37407eb46efd2547999446e348b18906d16bd3f30f6a3a77311abe5cc9293b42e3e73c52600f062e5024ba1999e89f18a71b05b03897716d338ab01751338441337fd8a99f2872c796378cb951e89417e00e77cc1d1d4693208720d0b6aa151dc7e21f73eb4bd4ca55e05aac9f0eb44b87be54d786f596d71307d043a8a8115d68523698b700f6525e82512da2ff1b82a8d722563ca84e3b104329826cc4fd09599908f02b67cdd8007ed675f205581416d9d82fc35b9a57e5eb9e293d76d88508e932ab399f1c836e23bdf4a90546cf9cccd4d7ef2e85ec11474a6c63ed6771d105d50118492e54c5040e540cbc61694d921bb1ecb8a1d06f1b2d33bb8d8a6c8884f379f798ddf024cf984aa56f58e94b80130d899bf1a7928027b8bce64c0797caaad617d2d4328b2e210cb76787b03fb120b0e6c8ef380ebbec85c9e88b0ffd19b35a7ab8b421e81c580b72682eba24f015f99179cba91e934378c5eda86921a6c349adb88f4826336c51d5fceb5409e0b4fdb0707bd9d769d2ffc0631b9a5ab560e4781a852711137c7c8568019e6a609e6ebb2239b22fb1cff23574fb5b29029f0c3788a3c4860c39d8a4dd30dc4c883b03decfa66b03aff331120469dbec8c9d1867c850ec27e75cec23587c168afb12dc12eed7a47e8b9f7f5dbb53f4fa7bb0369f40efcc25518abaad52ad3f04dbc49e3f053793fea55830a1fe6a48c256d99278f8e6baeb876f8d2db93a967480655eea96754e5b745ec114542152c41395999826484ccf45b485273b20decbfb4c90c8427abc726aa4c58f52f1b85f082384d45da029140f8c063c19b4284eeedc0902814a8573ac1046244502812f62f5c95cc5e88d89538eacfae2aeeae1b26a898c604d3f57109d81e10635ae1304e63b1a604f29f6f5880655eefe36816d447b14e4bcc86c7273315f906d7e4c7bddbbd7b0485fed56d777495cfe92294be956be6431c36fa0b38262223227cb0d5e3353063e1bd7a13cf4abe574ea8e1390f738d67a1f980d3af7fd53dd67850c95d7caa4e1ee8f6241dcc3bae7922d7650cad53b59e1dcb76bbb78c0c0541c865a2994104b4911b5652dc3483b5d47a520dd2edfd4419ba7e730efa6620dd806eea621098cdcfb3312f276caec92fc0b264851fb201e6bcc5ca42ba3ecaa8d7f61dee2c5d851e712a9efb471fc97d1b18e48bf01033834d9fd373889661afd53ef8238e81ca0547160e5a0b18419a2f52daa9ba6562fdbe3267a4d3f73248c27905e09dd7edaff4d858fa6bc675d91be1603750aaab523dc3a0908ef799edf6efe88b95d292bdb9c915549723a292cdef5188fed6e0ad53156cbbfefcdbbc789c2809b87b04dc86aac9dbec963ebcadadaed3e09e5141399a2ec030224ed43a634f120f69816b41b07f05087c135160e4774184b19f9118954b35e986e3bdf7b5b3c1fca03f355561831e30947265ece07bf0a6224bc7ba5d3f684af6637eaea71282b672746d646d1c2352711a710dde8288037a8c080091c76794d20727e98329075eea538473d02e5341aab334dcefbbd7bc47f84f71ec51db0aa34225c24dff0991c92e7cc3fb3186b75ed2f6d0b5d6096873409b0306244e16f46d008e4a565ecb39518dbb2b8b4cf33f1071c246dd60bc84aa19d4949068ca5956dda60a2c8aa46b17aacabc979c45c8dd0fce259a54a863b18871a9d0695311e5a7b95481fc27eda97965db1ada782090b2b581ac63ef777ec560d7ada15c4e7c2208996c520352515852c2f7835ade210df8fee249abddfd6582fe462341c227cd54310cdeab15a457e1b8b4d1b347c4f1e272a1663219c7c3ec9d0387a68b1deb4e4f3a07a46f1ac1c295a18a04ee70f77118d6419fc97bb197420d10e36cb1430305e3206b20c2ec76fa74a367db9cff3631a17e221f1d5be6acf8238b39e93785cb2f7bf61173b8fe4a528cc8243676f63db202475f28643a40da9a241b6eda9fd58b390a53a20ca1ecdb20dbfea5b5bd3e12d297e1ad833abf2ff6c1341d765c620f64d30a9c27c0ff7cf403d9cdb2c554e56dbaaf811070a1aef3d36dd2bb3fe1e1f0f5bc1c5fff8d65ff02c431a34bf659c195c8d0160aeeaa64ee0d2af2fddadf44e192b2d98867f01482900b3b9c86b05baa4ca2f3e2abb48ec69056433a747a33545ba7259d438ea8d8d68e5e8c5711d0597b6e531dd70934b350dbd1217b65f7e8248531d5b15636614748312bc0f9e741d2a25bc8afe52f6805b7a7e220ea52c94b3d51d8486eeafe9a80b426c304b139c3e2e9cd35dcdaa81d056dab4f78cfef736a68b363e8814a8b8d400096296cc9ab0658fb7b6bdbaa3c54cb2e0a06ee7319af37994264296141136fbabe33389f83568f5c11b6fd83da62a560af61f5d3fc745b1e92387fb772c2e1705c6d9f75e232297e2f8854f31872ecdedb9d8da5fc6e3f3dee301411aea557793fa58268988b8655aa96aa2057e40032f9aad07bcb137db29d944303a4a286251528abdd8fb16fa6c085f104c6503e84d70ea3cd436f376a46950e173de6a848e9baaebb9ec29f3cd89a37535a059f9dfc1c0088626123a94c5b74f65cbd1aa9cdb34b32d9109c6365ebaa63aac5daf4077164ed0cb6fd52980afcc15f2fedad2fcb150a9b6407937c0a6e2af374d8ac9c33248a7c95bc89dddaf3f72c9505a96e3d1e88a185ba78612f361f6eef462355165d85f7d32e3f7496d80ae4df3622b1b9fa3f9533c297319bcfeade54d61edb259f3e4b49739c5d2d48f8e41d342c892019267e40e996acc7a4968e74f6b1932a4040e53d4274d3b38d31b0605a55ff925f290981cb591b8e849f7d48bc9bf16640267d5158fcf754e3ac562a16e346b118d12bd507da84c81f8d0ac47697846041453801521d7a4520cd450e4a035688195e54f59d3fd9aad1aae62cfd937540226bc0fa6321a18a0b29c6fda895f80b1e9a3d338905e785dea9a5e2cb901afc0d50d8ec51df6c0b15eb13b51e33cb0415a6f2147a0418b62b2e63221018ed6034e60d6d6b131b8614b6e9a0e6d710c5417b136f452c967a0cb8b258c48e11866d3bc81df686c4cc598e76184057281d0b0745470d8881658a5a4c817c8da8d84133d6aee8aa51e4b128e7b1b4a9a015f7df4400c65e580d9ba80eb7a691ff7ca4bfbc25cb901ad51ed859d5176507645e1bfc894562c75090c8cb18f9d053aa343b1f3e769a50ed0c13c3dce262cc746e8064968e482a97cc856acbb9959ce1de7cfc58e16c86a1c86664aee50f14088a5025bfdeedc020b5edd6eb912a20f527b8781834c67042bc453049613dd4edd195ce626d03147eb84feab3cb1ff883cd8aca55523f5d7398fe5b20296bc19a52a2282d8c5b8b389f070a3102e65a46bb63305fd78aaee979d82d99bb1403c5448f97a359c8e29643d0f69abe91d7d8a2aee7caeaf32f5c40a5279dc23ebb999ac77e6980f88c5ce6770308ebf0999fb311498473638f55d4d13b90d13e1d9ef1a73f1e598ee85ede3628a3ff93e617875ddebe2d93adbd88e90d3cda7da2df45cb2427d62befaa9b9134d32fe51084725c014769305353525007083101fd642619f79d402eefbb64707658e68d12be32bbce5e304fa3a1940cdf21806bf9a9a4adfa154ff67ef6626da324a71cc28a37a3fe610992840a56766c61f65f91f6734103882362bda52bb1be97b72a1d5b85a7c0401462b8e7ab7fc406a6ad2cf08758db52796b6b03501ff9332d24d048b3ecba59316009e8f063fd9c3558c22a75823375e6fff44829e2cd11d77bcb23700b087a57fd7a75942e8d2df2fb6626e9c52e46a8f3ad7916edaf90110cfbb32687f2fde6aaf78a9be4f0af9ebfab2c1b46d4f424acd8b941dc46ab604d2bf400b6e87fdae7d43a1fb37ab0f767fb6bcaf11d073a75a485b0701d14cc2394796aacaae88c816a8725b0a52e3297aea737bf36310495b98e9c8a3f223336b6171351f0cbb185c9eab05a05c289bbf5d370d9736b82571e4e5701f4499344521d7c641c7020faaa32f0bf4e00c44db67129b16b54bb884fa24161af9ddb09899b0153482f4bddb432249e1878dd56d3299a5fa2bef0aac2a1493f7e6863f6443b8da146e3e1584d029413b2f4b136eda931106edad1b6621f5c7cd75ae30f3a1d6eb8fce5aba4273e80446ddd27a9f54de01816b0d966286e8899ed8fad678cce27c1cbfb8b6d1248ba0890b405983f29673dc57ff1a9d1387a38b2bad1735c05aa6a96bb6f2615e9dd2a83682c7fb8f872953f7323845d7140b098cbce79bd1397443f490ee62be57e0046f11e1db6a09a31d6c993d2844ea6879d7480795d5fa205d89ab82a0b6f86cb40d375000e581e1ffeb5f56a5a735905566bd6b9d1a4696b902eb74dff920171c2d4d2821129dd7c2f10dd48e21e8658ec3e0bbb0e97e9c88d9aabf03aa816efb539063690e594eaffdcc9a6d4f990b1cd734c6443028e59a13a7f78304e16022f13bdb6db32749b9117e93991e49b453bb1d24d156c04031e92c60e9ed4d2a5cb310b9537d89db690191aa9c9b52903cf8e51300c59a4e81b1e4176fc9f33b724af9588082f391fa92ca94ca9eafeaaf39f56b0783f22be6d248373e63ef55f0a29116d6d93a5b8c0ffbe4ae2164fa80618fbbac6b4b37a4fb36903c0e728eb6ccce38efc0f0df667b4fb3be60c607b72a8ac1d4001a421008f94bec4f9df880355a0b84af5c3e83116553fae0f11b67e5e98cc1c7815ef1b8604a7a01a7730e28b1df30fec7b1602092bd1136b6126a7c91677bf8eeeea65da81b9fb485c299fe732ab99e824ac11a8b88d29554a7370520be3a76035e54481360b70b5fede13aa5196dc82ab63153b578967d5940bcc980d2ea5fe78bfaa14e0d0cd672946bddc85ca458a019e5d725d89633b55905ddf7bf31da953e5a41c60f03d6b7b985f3c085525e8b004f8fd91fef7b47836dd8c0c9463f39b0eb6f685a36629b52e015e36eca7f1b08770c97c25eaa9bcf919e2bfbaeca7e1d49616b2f958a1287a05ea7a4bca54d5861695d8f76a7e06e4b5265a4d284c88cfef7e1786c0b80a707724bb5dd25c8632950396882fef0a5d6a81ea568fe73115c91b756fb4e1eb2cdaf7e15a395158561f8aef3f9737ee3709f33c7c68bd5dd76e68e618f470eb1cdcd65a4af41210afdb40666412afa5ea4e65146d1d6e84467a4556cbfb25db800d07b9cb1f5eaba121ab4f06a2d4c752e60c59a445fe2c4ba5209b1d50806fb2e626d0ca2a3032078ee2b6701413dd56c80d59beddd3778a77a5fba97d31298fbdf51b7d2eb5d16995700c1bf3866f180f397fd420a89b47ea2e12bc0fd52a9c9dd48a9818799400216101bb92e0eead69d5006ebf2697ee90448b312fcac5203a49b44214e25e31dc15fa67125ab329acb036df4b6a8e8f069190c8aaf4c18626c202871bf65ca1aafa3799a5efecde7187c0ffe06002e027423a2b6d4ab1a0ccf60a5135fea82126d7058dfd4850e69f030d44839</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">2025.10.28-NOIP 比赛总结</summary>
    
    
    
    <category term="solutions" scheme="https://xglight.github.io/categories/solutions/"/>
    
    
    <category term="school" scheme="https://xglight.github.io/tags/school/"/>
    
  </entry>
  
  <entry>
    <title>ABC 429 总结</title>
    <link href="https://xglight.github.io/posts/5c4fe895/"/>
    <id>https://xglight.github.io/posts/5c4fe895/</id>
    <published>2025-10-26T14:00:00.000Z</published>
    <updated>2025-10-29T14:35:50.079Z</updated>
    
    <content type="html"><![CDATA[<p><sub><sub>我也不知道为什么没有 428。</sub></sub></p><h2>A,B,C</h2><p>简单题</p><h2>D</h2><p>一眼前缀和二分。</p><p><sub><sub>但是赛时二分就没有一发过的，还要调很久。</sub></sub></p><h2>E</h2><p>一眼宽搜，维护每个点到安全/危险点的最大值，次大值。</p><h2>F</h2><p>略微思考，发现是线段树维护矩阵。</p><p>但是赛时线段树打挂了。</p><h2>G</h2>]]></content>
    
    
    <summary type="html">ABC 429 比赛总结</summary>
    
    
    
    <category term="solutions" scheme="https://xglight.github.io/categories/solutions/"/>
    
    
    <category term="atcoder" scheme="https://xglight.github.io/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>CF 2135</title>
    <link href="https://xglight.github.io/posts/2d1c6871/"/>
    <id>https://xglight.github.io/posts/2d1c6871/</id>
    <published>2025-10-24T14:00:00.000Z</published>
    <updated>2025-10-29T14:35:50.079Z</updated>
    
    <content type="html"><![CDATA[<p>赛后 VP Div.1，感觉还行。</p><h2>A</h2><p>一个挺容易想的 DP，维护每中数字的位置，多了就删前面的。</p><h2>B</h2><p>交互题。</p><p>按照一贯思路，先考虑极端情况。把机器人移动到右上角，即往右移动 <span class="math inline">\(2e9\)</span>，再往上移动 <span class="math inline">\(2e9\)</span>。</p><p>此时绝对值可以去掉，设距离为 <span class="math inline">\(dis\)</span>，即：</p><p><span class="math display">\[dis = x+2e9+y+2e9 - \max\{x_i+y_i\}\]</span></p><p>再把机器人移动到右下角：</p><p><span class="math display">\[dis = x+2e9-(y-2e9)+\min\{y_i-x_i\}\]</span></p><h2>C</h2><p>赛时挺快想到思路，但没调出来。</p><p>树一定可以随便涂色。</p><p>考虑奇环，一定只能全为 <span class="math inline">\(0\)</span>，偶环上所有数一定要一样。</p><p>因此先把所有奇环找出来，填数，再跑边 <strong>双连通分量</strong>，填偶环上的数。</p><p>最后的 <span class="math inline">\(-1\)</span> 一定有 <span class="math inline">\(V\)</span> 种填法。</p><h2>D1</h2><p>还是交互，但赛时没时间想了。</p><p>一样考虑极端情况，先问 <span class="math inline">\(10^5\)</span> 个 <span class="math inline">\(1\)</span>。</p><p>设答案为 <span class="math inline">\(l_1\)</span>，容易发现此时能求出 <span class="math inline">\(W\)</span> 的范围：</p><p><span class="math display">\[W\in \left[\left \lceil \dfrac{10^5}{l_1}\right \rceil,\left \lceil \dfrac{10^5}{l_1-1}\right \rceil-1\right]\]</span></p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>因为 <span class="math inline">\(l_1 = \left \lceil \dfrac{10^5}{W}\right \rceil\)</span>，所以 <span class="math inline">\(l_1-1 &lt; \dfrac{10^5}{W} \le l_1\)</span>。</p><p>推得：<span class="math inline">\(W(l_1-1)&lt;10^5\le Wl_1\)</span>，两边分别变形即可。</p></div></details><p>我们记 <span class="math inline">\(W\in[L,R]\)</span>，可以证明 <span class="math inline">\(2L &gt; R\)</span>。</p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>首先肯定有 <span class="math inline">\(\left \lceil \dfrac{W}{L} \right \rceil  = \left \lceil \dfrac{R}{L} \right \rceil\)</span>。</p><p>假设 <span class="math inline">\(2L=R\)</span> 时，<span class="math inline">\(\left \lceil \dfrac{W}{2L} \right \rceil = \left \lceil \dfrac{\frac{W}{2}}{L} \right \rceil = \left \lceil \dfrac{\left \lceil\frac{W}{2} \right \rceil}{L} \right \rceil \neq \left \lceil \dfrac{W}{L} \right \rceil\)</span>，不成立。</p><p>因此 <span class="math inline">\(2L &gt; R\)</span>。</p></div></details><p>考虑神奇构造：<span class="math inline">\(\{L,\ 1,\ L,\ 2,\ L,\ 3,\ \cdots,\ L,\ R-L\}\)</span>。</p><p>序列每组形如 <span class="math inline">\((L,i)\)</span>，若 <span class="math inline">\(W\in[L,L+i-1]\)</span>，则造成 <span class="math inline">\(2\)</span> 的贡献，否则为 <span class="math inline">\(1\)</span>。</p><p>所以 <span class="math inline">\(l_2 = (W-L) + 2(R-W)\)</span>，即 <span class="math inline">\(W = 2R - L - l_2\)</span>。</p><h2>D2</h2><p>延续 D1 的思考，考虑如何缩小查询的大小。</p><p>将第一次查询换为填入 <span class="math inline">\(N\)</span> 个 <span class="math inline">\(B\)</span>。</p><p>若回答 <span class="math inline">\(l_1 = 0\)</span>，说明 <span class="math inline">\(W &lt; B\)</span>，容易发现 <span class="math inline">\(\left \lceil \dfrac{m}{1} \right \rceil，\left \lceil \dfrac{m}{2} \right \rceil，\cdots，\left \lceil \dfrac{m}{\sqrt{m}} \right \rceil\)</span> 这 <span class="math inline">\(\sqrt{m}\)</span> 个数互不相同。</p><p>因此询问 <span class="math inline">\(B^2\)</span> 个 <span class="math inline">\(1\)</span> 即可。</p><p>若回答 <span class="math inline">\(l_1 \neq 0\)</span>，同 D1 一样，我们也可以求出 <span class="math inline">\(W\)</span> 的范围。</p><p><span class="math display">\[W\in\left[\left\lceil\frac{C}{A_1}\right\rceil\cdot B,\min\left\{10^5,\left\lfloor\frac{C - 1}{A_1 - 1} + 1\right\rfloor\cdot B - 1\right\}\right]\]</span></p><p>证明与 D1 类似，不再展开。</p><p>这种方式的询问次数为 <span class="math inline">\(\min\{C+B^2,C+2(R-L)\}\)</span>，写一个暴力找出合适的 <span class="math inline">\(N\)</span> 与 <span class="math inline">\(B\)</span> 即可。</p><p>接下来步骤同 D1。</p><h2>E1/E2</h2><h2>F</h2><p>不知道为什么，总感觉 CF 的最后一题没有倒数几题难。</p><p>先考虑每个点的 <span class="math inline">\(f_u\)</span> 会是什么样子。</p><p>定义 <span class="math inline">\(X\)</span> 是 <strong>能级数</strong> 当且仅当以下两个条件其一成立时：</p><ul><li><span class="math inline">\(X=x\)</span>。</li><li><span class="math inline">\(X=x^{X_1X_2X_3\cdots X_n}\)</span>，其中 <span class="math inline">\(X_i\)</span> 也是 <strong>能级数</strong>，并且 <span class="math inline">\(n\)</span> 是一个常数。</li></ul><p><span class="math inline">\(f_u\)</span> 就形如 <strong>能级数</strong>。</p><p>考虑比较 <strong>能级数</strong> <span class="math inline">\(X = x^{X_1X_2X_3\cdots X_n}\)</span> 和 <span class="math inline">\(Y = x^{Y_1Y_2Y_3\cdots Y_m}\)</span> 的大小。</p><p>将指数从大到小排序，按照类似字典序比较即可。</p><blockquote><p>证明略，本人数学不好。</p></blockquote><p>接下来我们可以发现一个事实，一个父亲的 <span class="math inline">\(f\)</span> 一定大于它的儿子的 <span class="math inline">\(f\)</span>。</p><p>所以我们按照拓扑从叶子开始计算每个点的 <span class="math inline">\(f\)</span>，维护一个堆，每次拿出一个最小的 <span class="math inline">\(f\)</span> 更新。</p><p>用 vector 暴力维护 <span class="math inline">\(f\)</span> 即可（排序，插入）。</p>]]></content>
    
    
    <summary type="html">CF 2135 做题总结</summary>
    
    
    
    <category term="solutions" scheme="https://xglight.github.io/categories/solutions/"/>
    
    
    <category term="codeforces" scheme="https://xglight.github.io/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>自然数的 k 次幂求和</title>
    <link href="https://xglight.github.io/posts/31a2dedc/"/>
    <id>https://xglight.github.io/posts/31a2dedc/</id>
    <published>2025-10-23T13:00:00.000Z</published>
    <updated>2025-10-29T14:35:50.079Z</updated>
    
    <content type="html"><![CDATA[<h2>简介</h2><p>自然数的 <span class="math inline">\(k\)</span> 次幂求和，顾名思义，即求：</p><p><span class="math display">\[S_k(n) = \sum_{i=1}^{n} i^k\]</span></p><h2>待定系数法</h2><p>我们观察几组式子：</p><p><span class="math display">\[\begin{align*}S_1(n) &amp;= \frac{n(n+1)}{2} \\ S_2(n) &amp;= \frac{n(n+1)(2n+1)}{6}\\ S_3(n) &amp;= \frac{n^2(n+1)^2}{4} \\ S_4(n) &amp;= \frac{n(n+1)(2n+1)(3n^2+3n-1)}{30} \\ \end{align*}\]</span></p><p>总结规律，我们可以大胆猜想，<span class="math inline">\(S_k(n)\)</span> 的求和公式应该是一个 <span class="math inline">\(k+1\)</span> 次多项式。</p><p>所以可以直接列出 <span class="math inline">\(k+1\)</span> 个方程，解线性方程组。</p><p>证明在下一节给出。</p><h2>差分法</h2><p>可以得到： <span class="math display">\[S_k(n) = \frac{1}{k+1} \left[ (n+1)^{k+1} - 1 - \sum_{j=0}^{k-1} \binom{k+1}{j} S_j(n) \right]\]</span></p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>考虑相邻整数的 <span class="math inline">\(k+1\)</span> 次幂差：</p><p><span class="math display">\[(m+1)^{k+1} - m^{k+1} = \sum_{j=0}^k \binom{k+1}{j} m^j\]</span></p><p>对 <span class="math inline">\(m\)</span> 进行求和：</p><p><span class="math display">\[\sum_{m=1}^n[(m+1)^{k+1} - m^{k+1}] = \sum_{m=1}^n \sum_{j=0}^k \binom{k+1}{j} m^j\]</span></p><p>左边易得：</p><p><span class="math display">\[(n+1)^{k+1} - 1\]</span></p><p>右边变换：</p><p><span class="math display">\[\begin{align*}&amp;\sum_{m=1}^n \sum_{j=0}^k \binom{k+1}{j} m^j \\=&amp;\sum_{j=0}^k\binom{k+1}{j}\sum_{m=1}^nm^j\\=&amp; \sum_{j=0}^{k} \binom{k+1}{j} S_j(n)\end{align*}\]</span></p><p>因此得到恒等式：</p><p><span class="math display">\[\sum_{j=0}^{k} \binom{k+1}{j} S_j(n) = (n+1)^{k+1} - 1\]</span></p><p>分离 <span class="math inline">\(S_k\)</span>：</p><p><span class="math display">\[\begin{align*}\binom{k+1}{k} S_k(n) + \sum_{j=0}^{k-1} \binom{k+1}{j} S_j(n) &amp;= (n+1)^{k+1} - 1\\(k+1) S_k(n) &amp;= (n+1)^{k+1} - 1 - \sum_{j=0}^{k-1} \binom{k+1}{j} S_j(n)\end{align*}\]</span></p><p>因此：</p><p><span class="math display">\[S_k(n) = \frac{1}{k+1} \left[ (n+1)^{k+1} - 1 - \sum_{j=0}^{k-1} \binom{k+1}{j} S_j(n) \right]\]</span></p></div></details><p>这样我们不仅得到了一条递推式，还证明了 <span class="math inline">\(S_k(n)\)</span> 的求和式是一个 <span class="math inline">\(k+1\)</span> 次多项式。</p><p>直接递推，复杂度 <span class="math inline">\(k^2\)</span>。</p><p>还可以用分治 FFT，复杂度 <span class="math inline">\(O(k\log^2 k)\)</span></p><h2>拉格朗日插值</h2><p>我们知道 <span class="math inline">\(S_k(n)\)</span> 的求和式是一个 <span class="math inline">\(k+1\)</span> 次多项式，当然可以用 <span class="math inline">\(k+2\)</span> 个点进行插值。</p><p>取 <span class="math inline">\((0,S_k(0)), (1,S_k(1)), \cdots, (n,S_k(k+1))\)</span> 作为 <span class="math inline">\(k+2\)</span> 个点，得：</p><p><span class="math display">\[S_k(n) = \sum_{i=0}^{k+1}S_k(i)\prod_{i\neq j}\frac{n-j}{i-j}\]</span></p><p>暴力是 <span class="math inline">\(k^2\)</span> 的，考虑优化。</p><p>分别考虑积的分子与分母。</p><p>对于分母，考虑 <span class="math inline">\(i\)</span> 已确定：</p><p><span class="math display">\[\begin{align*}&amp;\frac{1}{\prod_{i\neq j}(i-j)} \\=&amp;\frac{1}{i(i-1)(i-2)\cdots1\times(-1)\cdots(k+2-i-1)(k+2-i)} \\=&amp;(-1)^{k+2-i}\frac{1}{i!(k+2-i)!}\end{align*}\]</span></p><p>预处理阶乘与逆元即可。</p><p>对于分子:</p><p><span class="math display">\[\begin{align*}&amp;\prod_{i\neq j}(n-j)\\=&amp;n(n-1)\cdots\{n-(i-1)\}\{n-(i+1)\}\cdots\{n-(k+2)\}\\=&amp;\left\{\prod_{j=1}^{i-1}(n-j)\right\}\left\{\prod_{j=i+1}^{k+2}(n-j)\right\}\end{align*}\]</span></p><p>维护 <span class="math inline">\(n-j\)</span> 的前缀积和后缀积即可。</p><p>复杂度 <span class="math inline">\(O(k\log V)\)</span>，<span class="math inline">\(\log V\)</span> 是逆元复杂度，也可以 <span class="math inline">\(O(n)\)</span> 预处理优化。</p><h2>伯努利数</h2><p>有公式：</p><p><span class="math display">\[S_k(n) = \frac{1}{k+1}\sum_{i=0}^k\binom{k+1}{i}B_in^{k+1-i}\]</span></p><p>其中 <span class="math inline">\(B_i\)</span> 是伯努利数，定义为：</p><p><span class="math display">\[B_n = \begin{cases}1 &amp; n=0 \\-\frac{1}{2} &amp; n=1\\-\sum_{k=0}^{n-1}\binom{n}{k}B_k\frac{1}{n-k} &amp; n\equiv 0 \pmod 2\  \text{且}\ n&gt;1\\0 &amp; \text{otherwise}\end{cases}\]</span></p><blockquote><p>作者太菜了不会证明，可以参考 <a href="https://oi-wiki.org/math/combinatorics/bernoulli/">OI-Wiki</a></p></blockquote><h2>第一类 Stirling 数</h2><p>这次我们对 <span class="math inline">\(S_k(n)\)</span> 多加一个 <span class="math inline">\(0\)</span>，即：</p><p><span class="math display">\[S_k(n) = \sum_{i=0}^k i^k\]</span></p><p>根据第一类 Stirling 数定义：</p><p><span class="math display">\[\binom{n}{k} = \frac{\prod_{i=n-k+1}^n i}{k!} = \frac{1}{k!}\left[\sum_{i=0}^k(-1)^{i+k}{k\brack i} n^i\right]\]</span></p><p>变形得：</p><p><span class="math display">\[n^k ={\sum_{i=0}^{k-1}(-1)^{i+k}{k\brack i}n^i}-k! \binom{n}{k}\]</span></p><p>累加求和：</p><p><span class="math display">\[\begin{align*}S_k(n) &amp;= \sum_{j=0}^n\left[k!\binom{j}{k} - \sum_{i=0}^{k-1}(-1)^{i+k}{k\brack i} j^i\right]\\&amp;=k!\sum_{j=0}^n\binom{j}{k} - \sum_{i=0}^{k-1}(-1)^{i+k}{k\brack i}\sum_{j=0}^n j^i\end{align*}\]</span></p><p>上指标求和：</p><p><span class="math display">\[S_n(k) = \frac{\prod_{i=n-k+1}^{n+1} i}{k+1}-\sum_{i=0}^{k-1}(-1)^{i+k}{k\brack i}S_i(n)\]</span></p><p>预处理 <span class="math inline">\(O(k^2)\)</span>，询问 <span class="math inline">\(O(k^2)\)</span>。</p><p>但是不用除法。</p><h2>第二类 Stirling 数</h2><p>考虑这样一个式子：</p><p><span class="math display">\[ i^k = \sum\limits_{j=0}^k \begin{Bmatrix}k\\j\end{Bmatrix}\dbinom{i}{j}j!\]</span></p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p><span class="math inline">\(i^k\)</span> 可以看成将 <span class="math inline">\(k\)</span> 个互不相同的球放进 <span class="math inline">\(i\)</span> 个互不相同的盒子里。</p><p>那么枚举现在有 <span class="math inline">\(j\)</span> 个非空的盒子，自然乘上 <span class="math inline">\(\begin{Bmatrix}k\\j\end{Bmatrix}\dbinom{i}{j}\)</span>，因为这样是无序的，所以乘上 <span class="math inline">\(j!\)</span> 才是有序的。</p></div></details><p>考虑求 <span class="math inline">\(S_k(n)=\sum_{i=1}^n i^k\)</span>，即为：</p><p><span class="math display">\[\begin{align*}&amp;\sum_{i=1}^n \sum\limits_{j=0}^k \begin{Bmatrix}k\\j\end{Bmatrix}\dbinom{i}{j}j!\\=&amp;\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\sum\limits_{i=1}^n\dbinom{i}{j} \\=&amp;\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\binom{n+1}{j+1}\\=&amp;\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}\dfrac{(n+1)!}{(j+1)(n-j)!}\\=&amp;\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}\dfrac{\prod_{i=n-j+1}^{n+1}i}{(j+1)}\end{align*}\]</span></p><p>预处理斯特林数，还要注意 <span class="math inline">\(j+1\)</span> 在 <span class="math inline">\(P\)</span> 下不一定存在逆元，但分子的某个数一定可以整除它。</p><p>预处理 <span class="math inline">\(O(k^2)\)</span>，询问 <span class="math inline">\(O(k)\)</span>。</p><p>也不用除法。</p>]]></content>
    
    
    <summary type="html">自然数的 k 次幂求和</summary>
    
    
    
    <category term="solutions" scheme="https://xglight.github.io/categories/solutions/"/>
    
    
    <category term="math" scheme="https://xglight.github.io/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>2025.10.22-A</title>
    <link href="https://xglight.github.io/posts/67529007/"/>
    <id>https://xglight.github.io/posts/67529007/</id>
    <published>2025-10-22T13:00:00.000Z</published>
    <updated>2025-10-29T14:35:50.077Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a1f482d654b867fc6554187b41dbc84f15e96f90c5fc333d267008d02a4772e4">93024cf999deb8d8b2919f7e109263d436f7768a67e3b41578a0afeefd292b2dcabffd9739f059a2eaa848e67bc2889b57bfb598838a4c2cbce13f193ad9658485b0ade317e39803c6adfa9faf0bb122f3a1e263204a24e236fd8d13e2a5bbd2f7b3ec86f006a093f42b62517007f99cf14c87c45ae705bc88d3c79bcba14b9f3c8bf7d2baa2ea19996962d56ba9f5a785050b019b588616880e56edddbd7946c24c1b0ce965d81b2b28ee2b829db32831e690a46edb44a6d240c2cfd8665ed855b3ef4f024399100a528e612e5ea70f55c1ef4cb1912b612cb787143029019d079f6531fc244bac38eededc5433459cdf3396d42f7a4fe0adabe710ad903bc468806d7ec77ac7b068c08b45f130ba938e6f9e29423ee5244e749971735f9c4b791030f630bcc5ff4bffe558041e724a2893da21d92522ad58c6e44c3ebc6c73472cfdc98862a400da84c9ca0ef8eb5172afcc92fdf4e21db221992200b4b5024aae44135f6fb14e894a446ae933a593aac06c8e6ea1a653fffe58a08ebba6b61b5ebaa34632af51c7d954e44b132fa21d3d79ec1360909bd61f625ed41c4d1cc43e5b8dcb8f4cdbee76e7d44075ad44fff4257321c176f16f9161a97d80d3b71aebf1c512442976706f881666996991bbf55cc9586f46e7ee86dfec06fa80493707d0cc2b684569e13bb0b6831e73cf3e01a0a9c620929117328684ccc21fb8e58af2ed3c663bed22b1239052aebc904c1ae437aaecb7cf503fbf315a26568f47de536de6a220faec26f16eaf1a45c531d7c5d8469186e16082ce8120bef5ea7acce465d53088fe6ca9a86f0dfb5da4c228dc669b8216f266136a438264b05ff6eb248081f94d9042e9cb9c948d7b5e64ea507921514b4b730a99a97eee56fe90df3086aca51e7eb7d6e1d13b6062c23cd62debe8e2bf452d60fcf6cd6bd1389c443b94d1ac0a44821a634ebb900c35c55be29c788a76b75734ed5230f0330b91810bff81624a86e7e066b73339fb6a2c25ad7ea13b416edf1ce7637b190437ecdcc416d946d085775e37dd59e2c8226332ada621a65d68a3070a7e4fd13065b1bebe59fb4bd1cedb3ae47fc438b64ed6535a0e0c06880b8179aa776c6fe198324961b15f9903a57d3663c1c1f57d659abbee40d0a7b0729b43dcad34237d3a7172a39b48e32e1bb1732e492921221855acd1d870b349df497eb866539772c5f2d7c465c786c72a0ebd8dfdcf8a032b5ca6aa152978d23b72bed2fc7e712276cf9c3150f44c20d5d9cf2eeac5a0b0bcd1ca8d56682828c0affbf18e67c5b3c6fd4c14403629955b7b500d532ef0bdf2c5c19f3ab5408279a77cc25fea196438cbfbc740fb14b100a25963d04794b6dec12c23ab2ac54c0ebb6f6eb04a07b90f89075a3a19a03630c29877c503c6af49c3c278ca57e85cdb4cf69442bbb9182062703c239f774c6f8ec249ca9ea5a1e641f24073a159926c193a565673d62b8d20c3f06ecb74aec4e822f9a8780700a101d97fb6c145e9c0595fb8f8a8795a17cb540867e80447b490afa984b9a5bb6b4948945da8f90750573ed8c70b036007a93fbb890360cf2f73b9e0f87e233f56cc90b681043cc82a63dfc5ee3caada7863138fda2f0abadd4c3bb747541cd767f54db8636eaa0bb2ac57aff0d21932364016d6e352b0a7cda09e0578691abc2e6ea5e5f0d2196ce0bc73ddca3aae816bbaedfc5428870dc2dc37edede063a4e862b8297bb86763179e8142167312c67520a5fdbbdfc74e649c054deb74954350571e978670d10eaf7cc7fbb8c744c3d376bb524f0892475b2fba75a912600252455c2bd209f986d38ed2be3097584d94e8462952e2f362b16392a37d1327ffa300f18bec23ba9ef2ece63a848fe70539e8bb4fc7d43e23b6ec4855a77c5fd19f4278bdf4153a91da72b18bf57d2d2f885255f31ef4e9a3b6939c4c4cfa505dc82e99e26a91160d8420400d6bc157a60a389384c8dc07e26c297f466cfc98caf8041495bcb5d9544bcd315f8644dcbcb418842b853d2ac48fe0c71ce0ab2fafb9dd9944f751839713816fca99304dcc6791f034b7960dcc8148e81dcb97fa6f86e0af89f701b02092b37bac791ef36e19980fd62846009dca99345a8d6e953b8799c892e9ea399b1d52add9213f90f1060fdb6730247b76b81cae42405da93a489f19dc267c5a640b73d782c647a9fdae70f5361d2d6f88a7c14411e36df877e44bd7d91343c04a8f3a26cbed58faa4073f7c37ad4acb3d5f73f8fbd7a3f89f7f6ab8cf61756218669ecc66d71f9ef95e9bd6962dd2569c504d3cec0116e71c2c757714037fa18e7de4a7cbfc8fb6e03abff90f356bd63ff3dc8e369dcebfb24e68d9a9f6730cf7001a4d8c56d5fcfa659a63d6964fe22c1530a7494431aa35b9813689a25397c2dcb54c3866231eccbdf675e0e7f7d847f8a79fd641b82cc0ba5e3e71a17e89b3fcbb250fb42495c92bf8ef8a960dda55a38e80c538d34c1dcc52aea7674dbdc845df9af0fcd73f52c0e563d6ac63ebd1389105d6f8d6a1458a61cc0fa871211a582ef229a8adb3665c359d5b0c385e412e2c494cbc1e4be85841aa29b4ec01bb9ad666d00b014ec7a76a52dc47554692d6659cf970cca9a416be66760cfc908d58e284fc7e53d3034a108da4865b989dd213460c698ac0fa6cad85163ebbfc722d04b26d40a097e8cbe7b22bb11345345dc47155fd7be87d43fe220cf20152e40b2bea822daa8ec3ca22f6bd4063ca016bc89967be8abc71504997f592d9f574be31173acde8e87b18e0543cbdb6af95124116de51fa7626b8ca4d70a2aa4dcc53f155c35e07830d874534878f0fd6562bde56db8258de432da69c2f763b927c78308162b32e5c92aa6dd59f34015ec4938f4dd5eb06d68f7dd93a416b23e2568ed35d78f76a773da225e8392d67d1d631cae2ce02c4e63ea862c6dd975e33388e7159bc4de662d35a323f6df95b7d9bc4a78bec4dc92b5187989bf78c0efa25439fcc1401c84de6d67c7b9692151b0b2058f2dba56ba2142d38b7ea2503ec9a92795c1c7f485397fe430f919327ad5d5454fed3c85b68500a2aeb0b26a454824091713c7ed7c7c8d53176bdec818f1f8d2a1278f7d7df59f7144b0b3cf746660f9774c8e81248fbfc780b8de1ec81804d82cd76760829adcae7d015b5cbc52188496539f8a29cef2b54fc79fad88b4a36c19b0e579595bbaf0111bf5d7a785aad153f2c1508677d16ee5af819cbcf21f3d7c0efd46b8733e712ed2942b90d919ce15cf843fade7e9c0300b9fca07ec9fc2a32aeb911e65a5ae7395b75a3bb59a8a3dc2cd3185d639ee6e34e7e8cf85cf5ec5757cb4d6b8c29ce3673ceeed29ebb6f52b74582b1c789118bb84d936327f43e36ad5eb8a587445ca46325bc03f919771727f70e2a3bd55fa0f2b18c2694cb18fa27257ab144d4e14520ef35613b9e81828d8683415724784282b557aa70b709042b32ce275adf7b19a9074f9b968a1b3272c53716496b273a3827eef3fdfc0f2415ecc0fe6043fb33873ce88bcb2ec50b94f6b7fb6f5c625b2a03d83c5ec6dfc38593c8d0e60757c2283f6d22bb1b34e059051972111d3e9f2cd6555e596de1bbb6b27721aa745481af533ef0a6c48079b4fa8f5633070e284067d13411fb182070fe4484cf36ffdd228af657203a86920b413a85576550bd04f1988c3eb7eb9ac2d849393f45ed611a9b0f6e2d56f07ec77c2a94557e7e3bb32af27e09ae39daafca984f5a396e11a94d5fd8c4214ee8d66d2aacf7336aedfe436e3c88803f2c29f68da1aae487d68dcc43c46777993fde1a429469bd0fa9c3bf060e092a4fa5f25c3b29d3eb5b21596287574d714b479c256824f42152c8d5cd0ce836fb0997a6a18a0f52fb357c45bbf1765ef18a1bb2b5938dc65cab51cf523ac5c9b0a4eca1c17b5b98fce0633594bee248d045632b61459d7e09cf55cea9e67f3555a7c957ac43fc5c9cf9ec839a1b87146fd27beee118014884cec51e172a15e9afb890fd3804fe8d4fa802eb04045b456220d7e6a7e950aa3f9cff942aaa975c90ba8213e65a2e3b5549fdf29c8014ae7a873a89ad12f0cc6d1a8873a570df5cf8d50b3de0486064a352fe50af6fedf937ae10bd13c6333cded5bb207c3ac395240c80ba53d9aac70faf487fbdfd7123eba4a87737a5038bfa6846ecdabb20dbe6bf6b7bc3804fae272771c9ac0f9f08f10aeaf118f3687c3b1be1cabca1253d8f82437a70dfa27715cc372504fd186cfe81eaaa771aba7ae225d2ef8bffb200c2c62bb8b7c2b672272fd10e8bd54ff1f4b292fc342ad9097b545be7956522fa270eb86555c3ccf6997b75693c7e548a3ffb3ee5fa3c1f1eb03142469f1e0d4dab36f13917bbf79cfa7b2b2e8c27e69b41434debd99e8100f16c81742c56e90b4532e73ea692714b50efabf0a363c90e9d7fa86e39eddfe265336cccfb18acd04f6a6317a8be50c261a6935312d75eb89cd0b9678cfab632335cd9911ba54ba193fba806b7dfd96580bffd5fa779420cbbd66079ebf3f97aa8bfee667d876b463707f170e2bd3b42927d4eed1ccf02a372d35a1f8aff98f1ff5f4a8de9de8b99841fb7e3e078e61d8e902ce37e37a21d10ac57c92ab07db5030ecefa2638cd2c7a8fd4bf41c146fa2651421ee830c49e5e1bb3db809f717a295078fb2cefbc223893ddc6501113647656e8a3baefe284571cbf2bac5fd733ad365f0ec90f0da5c9b4c1e7e7750c62e8673b7a792fdb6c9360d3257e5ae0c86dac00201d35227f25a63c8875ea7c0a853135a88545a29edcc7a320cf7d8cfcae4db98be4c6b9714bea1094ac6bd5cc734d5549cdb602ef839c820b1c5bd1c64f7874c1d26cac80b64c18d33ccc189327c78a08e537a5f5d59b7b5e661c2120decd1fa53bf1d67f0f06726de06ca67092c4e493f2bb4ee7ec8f0891d33afdeb16927cc39916d8aca288f89f29fd29dcdb347c0a9fa65c11e5f1dfaec828662402a6b30e8d49abec6dc72f8406b508b6b7de96ea914b14823b3f90e3726e0ec8c73d428e8204c9997b07407df8e5466c914339c18129e0af29c3ee83bd03fcde3165a720a5bca52067bc14564a764d45c4e1c296eb71311b7c89646776116951ebe9c4a91954047b196ad820e25b614a79a0a8e56f58e0d7f42d4b4c09c3c7b4b8b732a215ce5c8ac17d7ca01e0ec4fb9305e28beb55788c63c81eead0322c829513a5097ef24c4b869199f19d32af2e8286938b8b946f446ab5dd9600e473c6e6949904043a7e0d8e4701bd72e8ff7cdbb278fa89a21ec86dd3ba79ac6d8a7f39be326c0c2287f55204bfb519bff8aeab4c06421ef21e6699064452df94ac3a651595928b576b1c4e4e715ce7c4aaa906bca49c0e6851ca1be45851bbf507de1dca2ebaad6e76cf66f207468eb6459a9713bbb718bd9db7e078afd6e6ee077b92b4a8725419d96d391efec984d0198cf886dfa6ad5c3395551df06ccadd927838</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">2025.10.22-A 比赛总结</summary>
    
    
    
    <category term="solutions" scheme="https://xglight.github.io/categories/solutions/"/>
    
    
    <category term="school" scheme="https://xglight.github.io/tags/school/"/>
    
  </entry>
  
  <entry>
    <title>c++11 的多线程</title>
    <link href="https://xglight.github.io/posts/151b1912/"/>
    <id>https://xglight.github.io/posts/151b1912/</id>
    <published>2025-10-16T04:00:00.000Z</published>
    <updated>2025-10-29T14:35:50.079Z</updated>
    
    <content type="html"><![CDATA[<h2>多线程编程</h2><p>多线程编程，并发编程的一种，即在同一个进程中执行多个线程，每个线程都有独立的栈、指令计数器，但共享同一个内存空间（堆、全局变量等），可以让程序在多核 CPU 上并行执行，从而更快更高效喵！。</p><p>但是由于缺少系统的保护机制，多线程编程容易出现数据竞争和死锁等问题。</p><h2>C++11 中的多线程</h2><div class="note info flat"><p>编译器版本：Clang 21.1.1</p></div><div class="note info flat"><p>C++ 标准：C++11</p></div><p>多线程在 C++11 被引入，其工具集在 C++11 已经比较完善，主要分为五个板块：</p><ol type="1"><li>线程管理：<code>thread</code></li><li>互斥锁：<code>mutex</code></li><li>线程同步：<code>condition_variable</code></li><li>原子操作：<code>atomic</code></li><li>异步操作：<code>future</code> 和 <code>async</code></li></ol><h2>thread 线程类</h2><p><code>std::thread</code> 单个执行线程的类，用于创建和管理线程。</p><p><strong>构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::thread t1; <span class="comment">//  默认构造函数，默认不执行</span></span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(func, arg1, arg2)</span></span>; <span class="comment">//  构造函数，传入函数和参数，执行线程</span></span><br></pre></td></tr></table></figure><p><strong>成员函数</strong></p><ul><li><code>join()</code>：等待线程执行结束，阻塞当前线程，直到线程执行结束。</li><li><code>detach()</code>：将线程与 <code>thread</code> 对象分离，允许线程独立执行（守护线程）。</li><li><code>joinable</code>：检查线程是否可被 <code>join()</code>，即在运行且未被分离。</li><li><code>get_id()</code> ：获取线程的唯一标识符。</li><li><code>hardware_concurrency()</code>：静态函数，返回系统硬件支持的并发线程数。</li></ul><h2>mutex 互斥锁类</h2><p><code>std::mutex</code> 保护共享数据，防止多个线程同时访问导致数据竞争。</p><h3>std::mutex</h3><p>最基本的互斥锁，不可递归锁定。</p><p><strong>成员函数</strong></p><ul><li><code>lock()</code>：获取互斥锁，如果互斥锁已经被其他线程锁定，则阻塞当前线程，直到互斥锁被释放。</li><li><code>try_lock()</code>：尝试获取互斥锁，如果互斥锁已经被其他线程锁定，则立即返回 <code>false</code>，否则获取锁并返回 <code>true</code>。</li><li><code>unlock()</code>：释放互斥锁。</li></ul><h3>std::recursive_mutex</h3><p>允许同一线程多次锁定同一个互斥锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::recursive_mutex rec_mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursive_function</span><span class="params">(<span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lock</span><span class="params">(rec_mtx)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (depth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">recursive_function</span>(depth - <span class="number">1</span>); <span class="comment">// 可以递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>std::timed_mutex</h3><p>带超时功能的互斥锁。</p><p><strong>成员函数</strong></p><ul><li><code>try_lock_for(const chrono::duration&lt;Rep, Period&gt;&amp; timeout_duration)</code>：尝试获取互斥锁，如果互斥锁已经被其他线程锁定，则在指定时间内阻塞当前线程，直到互斥锁被释放或超时，成功获取锁返回 <code>true</code>，超时返回 <code>false</code>。</li><li><code>try_lock_until(const chrono::time_point&lt;chrono::system_clock, chrono::duration&lt;Rep, Period&gt;&gt;&amp; timeout_time)</code>：尝试获取互斥锁，如果互斥锁已经被其他线程锁定，则在时间点之前阻塞当前线程，直到互斥锁被释放或超时，成功获取锁返回 <code>true</code>，超时返回 <code>false</code>。</li></ul><h3>std::lock_guard</h3><p>RAII 风格的锁管理器，构造时锁定，析构时自动解锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 代码块 </span></span><br><span class="line">&#125;<span class="comment">// 自动解锁</span></span><br></pre></td></tr></table></figure><h3>std::unique_lock</h3><p>更灵活的锁管理器，可以选择手动锁定和解锁，也可以选择超时时间。</p><p><strong>成员函数</strong></p><ul><li><code>lock()</code>：手动锁定互斥锁。</li><li><code>try_lock()</code>：尝试手动锁定互斥锁，如果互斥锁已经被其他线程锁定，则立即返回 <code>false</code>，否则获取锁并返回 <code>true</code>。</li><li><code>unlock()</code>：手动解锁互斥锁。</li><li><code>release()</code>：释放所有权，不解锁。</li><li><code>defer_lock</code>：创建但不锁定互斥锁。</li><li><code>adopt_lock</code>：接管已加锁的互斥量，避免重复加锁。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx1, mtx2;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1, std::defer_lock)</span></span>; <span class="comment">// 创建，但不锁定</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2, std::defer_lock)</span></span>; <span class="comment">// 创建，但不锁定</span></span><br><span class="line">    lock<span class="number">1.l</span>ock(); <span class="comment">// 手动锁定 mtx1</span></span><br><span class="line">    lock<span class="number">2.l</span>ock(); <span class="comment">// 手动锁定 mtx2</span></span><br><span class="line">    <span class="comment">// 也可使用 std::lock(lock1, lock2) 一次性锁定</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">    lock<span class="number">1.</span><span class="built_in">unlock</span>(); <span class="comment">// 手动解锁 mtx1</span></span><br><span class="line">&#125; <span class="comment">// 自动解锁 mtx2</span></span><br></pre></td></tr></table></figure><h2>condition_variable 条件变量类</h2><ul><li>允许一个或多个线程等待某个条件成立。</li><li>其他线程可以通过 <code>notify_one()</code> 或 <code>notify_all()</code> 来唤醒等待的线程。</li><li>等待线程会自动释放锁，进入阻塞状态，直到被唤醒并重新获得锁。</li></ul><p><strong>成员函数</strong></p><ul><li><code>wait(lock)</code>：使当前线程阻塞，直到被通知。</li><li><code>wait(lock,pred)</code>：使当前线程阻塞，直到被通知且 <code>pred()</code> 返回 <code>true</code>。</li><li><code>notify_one()</code>：通知一个等待线程。</li><li><code>notify_all()</code>：通知所有等待线程。</li><li><code>wait_for()</code>：等待指定时间，直到被通知且条件满足或者超时，条件满足返回 <code>true</code>，超时返回 <code>false</code>。</li><li><code>wait_until()</code>：等待到指定时间点，直到被通知且条件满足或者超时，条件满足返回 <code>true</code>，超时返回 <code>false</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知消费者</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> !q.<span class="built_in">empty</span>(); &#125;); <span class="comment">// 等待队列非空</span></span><br><span class="line">        <span class="type">int</span> val = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>atomic 原子操作类</h2><p>用于在多线程环境中执行无锁的原子操作，从而避免数据竞争并提升性能。</p><p><strong>构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">void</span>*&gt; <span class="title">ptr</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>成员函数</strong></p><ul><li><code>load()</code>：获取原子变量的值。</li><li><code>store()</code>：设置原子变量的值。</li><li><code>fetch_add()</code>：将原子变量的值加上指定值，并返回原值。</li><li><code>fetch_sub()</code>：将原子变量的值减去指定值，并返回原值。</li><li><code>exchange()</code>：交换值并返回原值。</li><li><code>compare_exchange_strong(expected, desired)</code>：如果当前值等于 <code>expected</code>，则将原子变量的值设置为 <code>desired</code>，并返回 <code>true</code>；否则，返回 <code>false</code>。</li><li><code>compare_exchange_weak(expected, desired)</code>：基本同 <code>compare_exchange_strong</code>。</li></ul><details class="toggle" ><summary class="toggle-button" style="">`strong` 和 `weak` 的区别</summary><div class="toggle-content"><div class="note warning flat"><p>某些平台的硬件指令（如 ARM）在实现 CAS 时可能会偶尔失败，即使值匹配。</p></div><p><code>compare_exchange_strong</code> 不允许虚假失败；但 <code>compare_exchange_weak</code> 允许，即值相同也可能失败，但同时性能更高。</p><p>所以 <code>compare_exchange_strong</code> 比较适合用于确保原子操作的成功，而 <code>compare_exchange_weak</code> 适合用于提升性能（在循环中使用）。</p></div></details><p><strong>内存序</strong></p><p>在多线程程序中，编译器和 CPU 为了优化性能，可能会对指令进行重排，这意味着你写在前面的代码，可能在执行时被放到后面，或者被其他线程看到的顺序不同。</p><p>内存序（memoryorder）就是用来控制这种重排行为的机制，确保线程之间的操作顺序符合预期。</p><table><thead><tr class="header"><th style="text-align: center;">内存序</th><th style="text-align: center;">同步相关</th><th style="text-align: center;">重拍相关</th><th style="text-align: center;">应用场景</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>memory_order_relaxed</code></td><td style="text-align: center;">不同步</td><td style="text-align: center;">允许重排</td><td style="text-align: center;">高性能计数器、无依赖场景</td></tr><tr class="even"><td style="text-align: center;"><code>memory_order_acquire</code></td><td style="text-align: center;">同步之前写入</td><td style="text-align: center;">禁止后面的重排到前面</td><td style="text-align: center;">读取标志位后读取数据</td></tr><tr class="odd"><td style="text-align: center;"><code>memory_order_release</code></td><td style="text-align: center;">同步之后读取</td><td style="text-align: center;">禁止前面的重排到后面</td><td style="text-align: center;">写入数据后设置标志位</td></tr><tr class="even"><td style="text-align: center;"><code>memory_order_acq_rel</code></td><td style="text-align: center;">同步前后</td><td style="text-align: center;">双向禁止重排</td><td style="text-align: center;">读写结合的同步点</td></tr><tr class="odd"><td style="text-align: center;"><code>memory_order_seq_cst</code></td><td style="text-align: center;">同步所有线程</td><td style="text-align: center;">全局顺序一致</td><td style="text-align: center;">默认，最安全但性能差</td></tr></tbody></table><h2>async 异步操作类</h2><p>标准库引入了一整套用于 <strong>异步操作</strong> 的类和机制，使得多线程编程更加现代化和易用。</p><h3>std::async</h3><p>异步执行函数，返回 <code>std::future</code>。</p><p><strong>构造函数</strong></p><ul><li><code>std::launch::async</code>：立即在新线程中执行。</li><li><code>std::launch::deferred</code>：延迟执行，直到 <code>std::future::get()</code> 被调用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;T&gt; f = std::<span class="built_in">async</span>(std::launch::deferred, func, arg1, arg2);</span><br><span class="line"></span><br><span class="line">f.<span class="built_in">get</span>(); <span class="comment">// 阻塞，直到结果可用</span></span><br></pre></td></tr></table></figure><h3>std::future</h3><p>提供对异步操作结果的访问，表示一个尚未完成的异步操作的结果。</p><p><strong>成员函数</strong></p><ul><li><code>get()</code>：等待异步操作完成，并返回结果。</li><li><code>wait()</code>：等待异步操作完成。</li><li><code>wait_for()</code>：等待指定时间，直到异步操作完成或超时。</li><li><code>valid()</code>：检查异步操作是否有效。</li><li><code>get_future()</code>：从 <code>promise</code> 或 <code>packaged_task</code> 获取 <code>std::future</code> 对象。</li></ul><h3>std::promise</h3><p>存储值或异常，供 <code>std::future</code> 读取。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt; prom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">perform_calculation</span>();</span><br><span class="line">        prom.<span class="built_in">set_value</span>(result); <span class="comment">// 设置结果</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        prom.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>()); <span class="comment">// 设置异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>(); <span class="comment">// 获取 future</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(producer, std::ref(prom))</span></span>;</span><br><span class="line"></span><br><span class="line">fut.<span class="built_in">get</span>(); <span class="comment">// 阻塞直到结果可用</span></span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><h3>std::packaged_task</h3><p>将可调用对象包装为异步任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(compute)</span></span>;</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; fut = task.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在单独线程中执行</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task), <span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> result = fut.<span class="built_in">get</span>();</span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><h2>实用函数</h2><ul><li><code>sleep_for()</code>：使当前线程睡眠指定时间。</li><li><code>sleep_until()</code>：使当前线程睡眠到指定时间点。</li><li><code>yield()</code>：让出当前线程的执行权。</li></ul>]]></content>
    
    
    <summary type="html">c++11 的多线程详解，包括 thread,mutex,async 等。</summary>
    
    
    
    <category term="algorithm" scheme="https://xglight.github.io/categories/algorithm/"/>
    
    
    <category term="c++" scheme="https://xglight.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>2025.10.14-A</title>
    <link href="https://xglight.github.io/posts/716a435b/"/>
    <id>https://xglight.github.io/posts/716a435b/</id>
    <published>2025-10-14T13:00:00.000Z</published>
    <updated>2025-10-29T14:35:50.077Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="bece7e15bf17339368061e7d9051e99987da8ad659bc92efe9c375cb31092658">93024cf999deb8d8b2919f7e109263d4d6dbe796c1247aec9fe10e82328d6a454f6cf42448d739612e082de9cd02819c836dc28e0e700ac8e34c451c05d201ca2cddc39cf5e37821ad0cc45fe7895e16073899e13291d8640b9960897e17d713c0915a2f9e2d1c1aea437d605b783de82cbef197d197f7d659b8d64aa30f67d49d73792042df59a88026292d95c73fa26d58f3657433324dfc7c56e8f678ef647a81f7c9a884f8348f2b761d47adc7c9a5a0181f2ba1df73f6b82a8d95a9b4fce1f02e0e6d1400f825139d77729077a3aca08f2bbdd0717d376fe380075ae8eafb69bec43eddff5565a330ba2688f5287674d96ffb2b84637c40a9852cd317becbd43a960b5e66f907c2af2faa47eb018e5af2bc5a42ae779efe40ca366661393f4c96fe0025d6cce0a6995e9c8824ef78120143fe88f3e596bc1501e7ee1cc1ada1068617b22aac31f805bd9f265345cf836f86ce2df66746a846f883190a26fc01d6642aae0e397beba959eade650c789d1ddc8048ec25eb84fe44ada3d84611393e2f0d37ddd3b4242a4c09b52195bedffa814dd75fdb126b3fe559d88a9599ffb81da7753c67f0071bfda9506d5f7773e4439936446f20365abeaadd108d41a07e2f8b10804f87eade30f10a6b2995a93c511b62208e00455a11dfba30bf39b92761a18aad20394eb1cf932071de4f94a3e5f2c065f728cadf34bc81925a1caa0716b4a9529e0b5915294746faffd41cd61a012099d2901b42c6595ec83fdf54a18eacf5922c87578567e742098594765d685731513bc0cb4e24f0f055b4e757b3f136c5651925f09464fce1ff84064862e32ad56cb6d36727e2251db865f06524163b33facfb61180cdc9415330c6f7066a69785ef3e2f81f2a4417232cc860097b0ffa430963f501166c759e447502fc98b3c6aa42fe7f509a5e79f0d95ae73da3bedcb14bd51610b28d206de6b8d0e11975a11c6e4d2d668c08962f0c7f811292cb8eaa8bd5fdd57139e97dc9c3221ac21ec06fa21eac23caac1fcb8b9203ba8bc50b93a427e4f89f935f095cc8e15cebcdc716ed7c163965204b1e598b0fb559be339247723d3b69c56bd7bb5fce17c3384a1c3d8e7cbcaa6f532fed109d06ab05301a3cf073f0539d7b8759ba0db25a2abc5fcd1ddc5f21e787ebf7cc2ec58c2ed51c9b86ac4a60b89552b48783a6cd9fd674282dcf7b9587d3b65afedad5dc50dc38d6771535fe2285cfcdeea6dcfeb5ce2b933c7034998c77bf8f0fc1a4864bb5021c1849cc68dc7d6b841233be91fecdbfbaf4d2ac11922737313c8455eb04d8cc49ac177d2473fc593bb041bd69c3852e037501de1f1410f3d96638e5f9d6da85f46d0577bfd7bd1f442be1d10570851bda1288ad07b6292d49eae7c2206b6d4088d6d23ea8d457f9cc363b02f3567c53da106b274d95348c17a4526d8a42cc85faf047d32e42b90249e1f95da6a76a6d311ca5e32557feeba94aaba4dfaea0742feb27d2bf923e35e6a4f27efc0e2b8dafd9bfea7272f55d8f0872f4d2677b4b6b75a697e292961d0efee2ca55001ded71c26cdcd9cffb9a18d933e52203663a055f309c2920010f8177a65f61c39e929531fa119999e6c39211998e459518253d559ce7d86350b37b6fa113c6d8dd6b00f3a26ebc2b27e0bb1eeed662d6ebe4c2d94285c67fa51360814217001d2c1e8e36861550c48accf3b64341e0b22d7db045b49a3cd0aafa2069e29af5c8b33c56e9b24a61969ea17c6b279664159e96c7140d8c9b588cf54dcd13ff1ebc8caa85b4a8171ed5930d9a201f15d1cca58a10980beb74a69529d5b5851f344c38b95d7645dcc2d4ec4a885834200a55ecd1f81fba1cc6b069b9802e426788642cfe7e182e93f581b60c1e70762126de926610838fd99439559869576815d62d1c889dfc25d1dacdeece8b7a83f2cd29cc79efbb229e7b1be2fe1fb036bf92b657d077159d05036c48dc99b6740b52b17521dbe57ace73966cf6c76d359226d972e15de803704a252568c918edc2f045643c3cf86e6d09dfdb86caf83c7accd72f50cfe316f620c5573d4c8db27ef6aad3b3476febd1235f964da187718ebe55a70b9d077a22d2b5a1c7ea744fe7c72c0c24a10798aeebfdadfd8b8868d347b2bf85cbff4aab44e011f12da221d7ac906ea10613403721d468c8aa6e6264f87a29420e6fabab1638208568813afd95e4b1a587c95d78327ff3876c4f85d2c37703ba994ce2645b97a7e80438eacb122dadd08664413c5a89b44973abb4c33db9a5fcb9f064045b47ad19bc5e5d9208e71580b85b0e332c55a522576a12e019568c0988e681a05aa452cc29276cb52f0135f6716af1c46decea1c1d6caf6444984ca8f8bcf02ddabb4bb48ea468c29b5c6e80a344caecccdc890aa9b1b6c6e1786089a07d0a4d0f46d0b12ebd176e1a5ba4b8f48aa0ea87595880c503cd84cdbe3b189725508cc22bfa3125f1ededf49465543a648891c86e3c665145b9ad7cf83d1054833ff164ad8cb44257fd1b763de69c77cb10f311569d97c22e2f1b1c535ff90079bde74a6313a2e5fad315e13d2d5a87ec6aeac57cc238666b1ca9c23a0de6f41004960b6d3be1a5a5590bb9b33b029b24f83c1d110ee2a6b1c20fbc32d29049130899e39ab6354f5cedc47cd77a4a02a9e5edfa330734dfc7505016c12d8cdc6b07d03eb8468387c18ecf35c0596bb8fdda0c8b67cd7af4f3326e8860f13752b4bda267b7d8d58121e13476ca8e02115080415bb2ed8f8b520f75dee83ae7f78b1005106d077f1d627b67524a59f54fd651b8ceb6b57448667625f75dd8d6197c17f863fd7b2a38a9708465c9cf665684d5e998e6a6e166ad78bbb17b4d0d0c1f41d9a758c822fc804044143a23368b577e2f638ae01b197ab386ad224c74ca777b134416c67fbd34c136b2042e995118b736ee62b5a08edfcc19697d22470ed9900bb4dd87336eb457822042f5836424fb4d95a23d85d6a265cbf4237476628913bc1e36de692ef03f0664979bf0e769e5f8be506f551dc2e77c226eda62c2b6a65c52f7f8dcf99fc768537805c74be94116f8ee3900c74d2719b59ee6c77e0c73682700f9e9bdf58195a3ffbe6586d5d5042ddde58bc3210d2b15fb6d591be03867b5c4dff7ee3d9362b5fce85dee6310599aa5d30f27057d36819edaf3d28a35ee9b4e1eda0c2793b6c76a4d64462494c2922d1dd081b83ddfbd5712854dc14bd71897fd52feb875715dd1c432848ab32bcba570c07deb6cf147015159241d884dc4eb3a53220940ad97f3338b730d2b3320cf7f83d1678fec796a28bf827a2dd1eadf8a140676e288a555ddbb5fb1a0e7f7585d079cb787800c8bd1e73608ecc7e7bc06d9a1720a5372be7d5d6b166df92685378f76cbbca2ad4deb4831d022f5674eac4921a67870db6feaf2c780088a4a9774264c44c7cd758292f70453e1889a5405aab5ff4e62bc4fc5dfcf678dd95e32fe441d1bd361558fb590dffbbdfb41f824b589b43ba6ad3704d5fab251fbe26380cf5cb3594fa0f459a4ecab6b7ba4fc317342c82d61a28625050a2949277ee602dd40fb643a2aff45412941d4666d054b5aea533f960bc1844556096c1b4508591f11c162c8c53a42bf8cf4d452cd9d18c064a8293959481a229d595608dfb3f929ba2cf865a9a51bc42c833ef0f7201fcb2a702141c72ec92cccdc2a171a1af3553df47e6f7aa2bc2bf46b1cbad937be6d8a625fc2364250fe905d2b93496eca1fea0f4f29850a2e874c8e9ee0ee940eb74c7d5f1629ccc2aa1bf4dc18802bee71570a5d1325dcfdd157dca88b576fb6222c02ccbb30192c84e323bab3a38eecc60dcf6b5ccd839e440ddeada329635ac15436760395adce0a5dc6f2188f2a504c2aa65d4967405b7a2dbd9044c073ed84cfad18895ef6572305b41854b19443606ebec6ab9cf5ee033661fdcbeccfd3ce4290352be60f58d2c8481d71093ce28ac4d7bfd9babfcf096ecf86e73c39b25d6e01091aecd4da9f4b1ccd78e9e22cee80e080467ed1f684a037774388f4f365aabea6657e24e343ecac738d8d5d5bde7c917f7bbf15e562b6bce6eea0f76018edc862fd87869d9476b2ab2513babe46dbd713bcad2aa7d6e0d40a577cf1ccb04494306e57cd2d97b2c683506643f6d7acd9d0f8f655756128ba941aacdf0734a900778e0c3573ec5c0181965b39133a3b542da1828fdcd1187a6215d38dae82cbe37b546b5f8fd0dadd3b409e641402cc52f66cf8117781f83d5e7b901c7724f4116d4e2860dcb884e850beb8dd8aa0f7013bf2a9a2933e74edf37a740327f282e52acab362d8535251482f8ab982acc8a306c2649123f20f299ddb12cfc0d221e48442b075b79f02c62c40378cee677552c5b8ba4fb84d11c30102cfab9cfa9c3966221685da0653812696f39b8bc6fa5296677348d73ff7aaf24171d0a509f7af286ecc50aabbe65133e8551fdd24d333c60a2d0abe76af05fc5fb0220e225712d760a8b2629647babd9678e6fe4b77f96b43aa13f65e52a10707c32e46b920c06a4ebbdc6660c36d9588a57a448562ca842047a88df79ad4978482fed9a46bd7853c1d8864e79b44ac683fa797db1d6fb5afb015866e2c27d86bb86cdcaa1080297ded56f9029164d9947b890dce50bd2182a9a6f848fafc0f4257511f1ee8254eef23a34b86047c65e6fbc58245a0b604022bd828fe766774257e8750bc4539a9bb317fd7b080f7957167aa7090e1c27ae3f76c1c904323568563c96d5f8deabcbc632f715756645cc2f08485b869a649189870f39da520d4809e507b35cccbbcd0c6a2b1bcfa4240111b58a4e798242f372081043265702c20c1a7f90dbca65c441fb628f7e6d2e61f6e881ad0202464181d47cb3306e1df0a0f5a1459d81501aae01de0f25f0f234858826fafadd459a044229a782b16150f714e55a5d0de9e15f8e3a130c452538ecd4633f040353943736cbbdae822eed661d758ace40351410d6891cad01049fcd7c9e3e064bd13aa002d366d7accc3c0f371159a218ffaa0df09db076a9940ce0e54f8a33341b0a0fbcd3e1a555e6ea45dfbde3620bf6d1b2e6d7868b8a1d858b9026f3ff528b47b4b1f19efef4860c682b06eafc805d32102e8dfbdd5b1310b0b86a88ec58eb2c704b6fcb26c70335cf062f70175dc732ecd85cf40504d1d88c0822eba46f8378c69c7e423459d2824c04b00bf73d0ed7aeda295818cd9b69ef4f9a76c7d29ce1aec6364d37e10e3c6b87ff2950343ef8ead298a439bba2edda06a358f0abe88abb117fc2ae78ce1287482394fb31128d5665680b08d7473d9b8855b2de4420576a77179bc909c762ca1451efc2ea82ce44de9b8b7b0f896635213341c4702a8249ed1eb7e7d9e7d723b8a57de32fed37eed833eccffc13d53234f0e31f933dd9db58e2827f56313bc71a8d5dec48fe8d56df6aa0b7c8372ae39e85c15c7574d4395bc527cde533f7605ac9995ffdbbcb0731ef8349b9fcbf4dc8efeee692e8848319c49a6f5a3d2d62b23e81ab334f03191b40106e90ade2aa4f3ce1c3bbd8239fade591902b82d269662680fd55498fcaa91d969212d760050c609267ed95e775ec14bd188d50db1299aed198b541f3152324d64f2a6e4ba8c13b8c3ce577b6810390fc74f76ff44b33bc5afdd6a7914c8ae11f5f9e20ec7b31b5375cb9977f1236617cc6df30785f4ad61f83d3f2ec263ae080cfb88fde49c6b8d5933a9ae0bc5e8bd9207645c64cfdf8b4616a0e323464a76a2e0bfe02d2d1e50cda6b5f941231bbd4a036a26e0aca947f067f3d715968f799451118d36adab7d18cb21d7fe45052471009be5cbff22baf9b45086b86c338da19d5240d4f23b6909d91c8b92fe1591ec07b301a859d01f5c06d541fc955ee132ad817bada5bf3d77411cb1134e7e34013369999544817e8dd7468db88639a835cc2658afc428f73c10573c4e36f49f9dc217dd2ee87b4b12b4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">2025.10.14-A 比赛总结</summary>
    
    
    
    <category term="solutions" scheme="https://xglight.github.io/categories/solutions/"/>
    
    
    <category term="math" scheme="https://xglight.github.io/tags/math/"/>
    
    <category term="school" scheme="https://xglight.github.io/tags/school/"/>
    
  </entry>
  
  <entry>
    <title>ABC 427 总结</title>
    <link href="https://xglight.github.io/posts/49c5faa7/"/>
    <id>https://xglight.github.io/posts/49c5faa7/</id>
    <published>2025-10-11T14:00:00.000Z</published>
    <updated>2025-10-29T14:35:50.079Z</updated>
    
    <content type="html"><![CDATA[<h2>A</h2><p>简单题。</p><h2>B</h2><p>简单题。</p><h2>C</h2><p>简单题，可以枚举二分图的左部点。</p><h2>D</h2><p>简单题，DFS 即可。</p><h2>E</h2><p>赛时考虑移动 <span class="math inline">\(T\)</span>，但死活调不出来。</p><p>赛后用 bitset 存整个图，一遍过，而且打的飞快。</p><h2>F</h2><p>双端搜索，用 <span class="math inline">\(f\)</span> 存前 <span class="math inline">\(\frac{n}{2}\)</span> 个数可能的子集和，<span class="math inline">\(g\)</span> 存后 <span class="math inline">\(\frac{n}{2}\)</span> 个数可能的子集和。</p><p>不过要分别记两个，中间不能同时选。</p><p>排序后二分计算，不过可以用 <code>equal_range</code>。</p><h2>G</h2><p>赛时没想到。</p><p>记 <span class="math inline">\(t_P(T)\)</span> 表示初始心情为 <span class="math inline">\(T\)</span>，按顺序收到 <span class="math inline">\(P\)</span> 礼物后的最终心情。</p><p>定义一个 <strong>好的</strong> 序列 <span class="math inline">\(P_1, P_2, \cdots, P_n\)</span>，当且仅当 <span class="math inline">\(\forall i \in [1, n),P_i + A \le P_{i+1}\)</span>。</p><p>对于一个 <strong>好的</strong> 序列，一定存在一个整数 <span class="math inline">\(x\)</span> 使得：</p><ul><li><span class="math inline">\(\forall i \in [1,x)\)</span>，收到礼物 <span class="math inline">\(P_i\)</span> 一定 <strong>失望</strong>。</li><li><span class="math inline">\(\forall i \in [x, n)\)</span>，收到礼物 <span class="math inline">\(P_i\)</span> 一定 <strong>高兴</strong>。</li></ul><p>对于两个序列 <span class="math inline">\(P,Q\)</span>，若 <span class="math inline">\(t_P(T) = t_Q(T)\)</span>，则称两个序列是等价的，不难证明两个等价序列的长度一定相等。</p>]]></content>
    
    
    <summary type="html">ABC 427 比赛总结</summary>
    
    
    
    <category term="solutions" scheme="https://xglight.github.io/categories/solutions/"/>
    
    
    <category term="atcoder" scheme="https://xglight.github.io/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>STL</title>
    <link href="https://xglight.github.io/posts/3006dc10/"/>
    <id>https://xglight.github.io/posts/3006dc10/</id>
    <published>2025-10-11T09:00:00.000Z</published>
    <updated>2025-10-29T14:35:50.079Z</updated>
    
    <content type="html"><![CDATA[<h2>简介</h2><p>C++ 标准模板库（Standard Template Library，STL）是一套功能强大的 C++ 模板类和函数的集合，它提供了一系列通用的、可复用的算法和数据结构。</p><p>STL 分为多个组件，包括容器（Containers）、迭代器（Iterators）、算法（Algorithms）、函数对象（Function Objects）和适配器（Adapters）等。</p><p>使用 STL 的好处:</p><ul><li>代码复用：STL 提供了大量的通用数据结构和算法，可以减少重复编写代码的工作。</li><li>性能优化：STL 中的算法和数据结构都经过了优化，以提供最佳的性能。</li><li>泛型编程：使用模板，STL 支持泛型编程，使得算法和数据结构可以适用于任何数据类型。</li><li>易于维护：STL 的设计使得代码更加模块化，易于阅读和维护。</li></ul><h2>容器</h2><h3>vector</h3><p>vector 是 STL 中的动态数组容器，定义在 <code>&lt;vector&gt;</code> 头文件中。</p><p>特性：</p><ul><li>随机访问：支持随机访问，可以快速访问任意位置的元素。</li><li>动态数组：可以动态扩容，可以根据需要增加或减少元素。</li><li>连续存储：支持连续内存存储，便于与 C 风格数组交互。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;        <span class="comment">// 空 vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;    <span class="comment">// 10 个默认值为 0 的 vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 10 个值为 1 的 vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(v2)</span></span>;   <span class="comment">// 拷贝 vector v2</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(v<span class="number">2.</span>begin(), v<span class="number">2.</span>end())</span></span>; <span class="comment">// 利用范围构造函数</span></span><br></pre></td></tr></table></figure><p>注：vector 的构造函数默认为空。</p><p><strong>成员函数</strong></p><div class="tabs"><div class="nav-tabs no-default"></div><div class="tab-contents"></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note warning flat"><p>请注意区分 <strong>容量</strong> 和 <strong>大小</strong> 的概念，vector 实际占用的内存空间相当于容量。</p></div><ul><li>容量：指的是 vector 预留的内存空间大小，可以动态增加或减少。</li><li>大小：指的是 vector 中实际存储的元素个数。</li></ul><p><strong>释放 vector 内存</strong></p><ol type="1"><li><code>vector&lt;T&gt;().swap(v)</code>。</li><li><code>v.clear(), v.shrink_to_fit()</code>。</li></ol><h3>deque</h3><p>deque 是 STL 中的双端队列容器，定义在 <code>&lt;deque&gt;</code> 头文件中。</p><p>特性：</p><ul><li>支持 <strong>两端</strong> 高效插入和删除。</li><li>随机访问常数较大。</li></ul><p><strong>成员函数</strong></p><div class="tabs"><div class="nav-tabs no-default"></div><div class="tab-contents"></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2>迭代器</h2><h2>算法</h2><h2>函数对象（functional）</h2><h3>函数对象</h3><table><thead><tr class="header"><th style="text-align: center;">类名</th><th style="text-align: center;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>plus&lt;T&gt;</code></td><td style="text-align: center;">加法</td></tr><tr class="even"><td style="text-align: center;"><code>multiplies&lt;T&gt;</code></td><td style="text-align: center;">乘法</td></tr><tr class="odd"><td style="text-align: center;"><code>divides&lt;T&gt;</code></td><td style="text-align: center;">除法</td></tr><tr class="even"><td style="text-align: center;"><code>modulus&lt;T&gt;</code></td><td style="text-align: center;">模运算</td></tr><tr class="odd"><td style="text-align: center;"><code>negate&lt;T&gt;</code></td><td style="text-align: center;">取负</td></tr><tr class="even"><td style="text-align: center;"><code>equal_to&lt;T&gt;</code></td><td style="text-align: center;">等于</td></tr><tr class="odd"><td style="text-align: center;"><code>not_equal_to&lt;T&gt;</code></td><td style="text-align: center;">不等于</td></tr><tr class="even"><td style="text-align: center;"><code>greater&lt;T&gt;</code></td><td style="text-align: center;">大于</td></tr><tr class="odd"><td style="text-align: center;"><code>less&lt;T&gt;</code></td><td style="text-align: center;">小于</td></tr><tr class="even"><td style="text-align: center;"><code>greater_equal&lt;T&gt;</code></td><td style="text-align: center;">大于等于</td></tr><tr class="odd"><td style="text-align: center;"><code>less_equal&lt;T&gt;</code></td><td style="text-align: center;">小于等于</td></tr></tbody></table><p>还有一些，可以自行查阅头文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> c = std::<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;()(a, b); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 降序排序</span></span><br></pre></td></tr></table></figure><h3>function</h3><p>一个 <strong>通用函数包装器</strong>，可以保存函数指针、lambda、函数对象、成员函数指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f = add; <span class="comment">// 保存函数指针</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; endl;         <span class="comment">// 输出 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>bind</h3><p>一个 <strong>参数绑定器</strong>，可以将参数绑定到函数上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123; <span class="keyword">return</span> a+b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">bind</span>(add, <span class="number">10</span>, placeholders::_1); <span class="comment">// 固定 a=10, b 为参数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(<span class="number">5</span>) &lt;&lt; endl;                     <span class="comment">// 输出 15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>哈希函数</h3><p><code>std::hash&lt;T&gt;</code> 可以获取对象的哈希值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string,<span class="type">int</span>,hash&lt;string&gt;&gt; mp;</span><br></pre></td></tr></table></figure><h2>适配器</h2>]]></content>
    
    
    <summary type="html">STL（Standard Template Library），中文名标准模板库，是一系列模板类和函数的集合，是 C++ 的一种编程范式。</summary>
    
    
    
    <category term="algorithm" scheme="https://xglight.github.io/categories/algorithm/"/>
    
    
    <category term="c++" scheme="https://xglight.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>C++ 库 chrono</title>
    <link href="https://xglight.github.io/posts/7b504e68/"/>
    <id>https://xglight.github.io/posts/7b504e68/</id>
    <published>2025-10-11T09:00:00.000Z</published>
    <updated>2025-10-29T14:35:50.079Z</updated>
    
    <content type="html"><![CDATA[<p>C++11 引入的 <code>chrono</code> 库，用于处理时间、计时和时间点，主要提供三类核心概念。</p><h3>duration（持续时间）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::chrono::duration&lt;Rep, Period&gt;</span><br></pre></td></tr></table></figure><p><code>Rep</code> 表示持续时间的类型，<code>Period</code> 表示时间单位。</p><p>常用别名:</p><ul><li><code>std::chrono::seconds</code> 秒</li><li><code>std::chrono::milliseconds</code> 毫秒</li><li><code>std::chrono::microseconds</code> 微秒</li><li><code>std::chrono::nanoseconds</code> 纳秒</li><li><code>std::chrono::minutes</code> 分钟</li><li><code>std::chrono::hours</code> 小时</li></ul><h3>time_point（时间点）</h3><p>表示某个具体时刻。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::chrono::time_point&lt;Clock, Duration&gt;</span><br></pre></td></tr></table></figure><p><code>Clock</code> 表示时钟类型，<code>Duration</code> 表示时间间隔类型。</p><h3>clock（时钟）</h3><p>提供获取当前时间的函数。</p><ul><li><code>steady_clock</code> 单调递增，不受系统时间调整影响，适合计时。</li><li><code>system_clock</code> 系统时间，可转换为日历时间。</li><li><code>high_resolution_clock</code> 高精度计时。</li></ul><h3>使用</h3><p><strong>获取当前时间点</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br></pre></td></tr></table></figure><p><strong>计时</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="comment">// 代码片段</span></span><br><span class="line"><span class="keyword">auto</span> end = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> duration = <span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Time used: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p><strong>返回 <code>epoch</code> 到当前时间点的偏移量，并把这个时间间隔以整数形式表示</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrono::steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>(); <span class="comment">// 常用于初始化随机数种子</span></span><br></pre></td></tr></table></figure><p>不同 <code>Clock</code> 类型的 <code>spoch</code> 不一样：</p><ul><li><code>steady_clock</code> 的 <code>spoch</code> 通常为 <strong>系统启动时间</strong>。</li><li><code>system_clock</code> 的 <code>spoch</code> 通常为 <strong>1970-01-01 00:00:00 UTC</strong> 。</li></ul>]]></content>
    
    
    <summary type="html">在 C++ 中，正确使用 chrono 库计时</summary>
    
    
    
    <category term="algorithm" scheme="https://xglight.github.io/categories/algorithm/"/>
    
    
    <category term="c++" scheme="https://xglight.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++ 中的 Lambda</title>
    <link href="https://xglight.github.io/posts/eeb037c6/"/>
    <id>https://xglight.github.io/posts/eeb037c6/</id>
    <published>2025-10-11T09:00:00.000Z</published>
    <updated>2025-10-29T14:35:50.079Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <summary type="html">在 C++ 中，正确使用 chrono 库计时</summary>
    
    
    
    <category term="algorithm" scheme="https://xglight.github.io/categories/algorithm/"/>
    
    
    <category term="c++" scheme="https://xglight.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++ 中的随机化</title>
    <link href="https://xglight.github.io/posts/ced3a8ad/"/>
    <id>https://xglight.github.io/posts/ced3a8ad/</id>
    <published>2025-10-11T09:00:00.000Z</published>
    <updated>2025-10-29T14:35:50.079Z</updated>
    
    <content type="html"><![CDATA[<p>mt19937 是 C++11 引入的伪随机数生成器，使用 <strong>梅森旋转</strong>（Mersenne Twister）算法。</p><p>相较于 <code>rand</code> 它的周期更长（<span class="math inline">\(2^19937 -1\)</span>），生成的随机数更加均匀，速度更快，<strong>但仍然是可预测的</strong>。</p><h3>定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::mt19937 <span class="title">rng</span><span class="params">(seed)</span></span>; <span class="comment">// 这里 seed 为任意整数</span></span><br><span class="line"><span class="function">std::mt19937 <span class="title">rng</span><span class="params">(std::chrono::steady_clock::now().time_since_epoch().count())</span></span>; <span class="comment">// 一般用当前时间作为种子</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::mt19937_64 <span class="title">rng</span><span class="params">(seed)</span></span>; <span class="comment">// 64 位版本</span></span><br></pre></td></tr></table></figure><p>调用 <code>rng()</code> 即可生成在 <span class="math inline">\([0, 2^32 - 1]\)</span> 范围内的随机数，<span class="math inline">\(64\)</span> 位版本的 <code>rng()</code> 则在 <span class="math inline">\([0, 2^64 - 1]\)</span> 范围内。</p><p>一些成员函数：</p><ul><li><code>.seed(unsigned)</code> 重新设置种子。</li><li><code>.discard(n)</code> 跳过 <span class="math inline">\(n\)</span> 个结果。</li><li><code>.min()</code> 和 <code>.max()</code> 返回随机数的最小值和最大值。</li></ul><h3>random_device</h3><p>如果不想使用伪随机，可以使用 <code>std::random_device</code> 来获取硬件随机数。</p><div class="note warning flat"><p>C++ 标准规定 <code>std::random_device</code> 可以退化为伪随机数</p></div><p>但一般来说，在 Windows，Linux，macOS 上，<code>std::random_device</code> 都是硬件随机数生成器。</p><p>可以通过其成员函数 <code>.entropy()</code> 来获取硬件随机数生成器的熵，如果大于 <span class="math inline">\(0\)</span>，一般都是真随机数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::random_device rd;</span><br><span class="line"><span class="function">std::mt19937 <span class="title">rng</span><span class="params">(rd())</span></span>; <span class="comment">// 用硬件随机数生成器初始化 mt19937</span></span><br></pre></td></tr></table></figure><p>请不要滥用 <code>std::random_device</code>：</p><ol type="1"><li>它的速度更慢。</li><li>有研究指出，在熵池耗尽后，<code>std::random_device</code> 可能退化为伪随机数，并且性能急剧下降。</li></ol><p>关于 <strong>熵</strong> 的更多内容，读者可以查阅更多资料。</p><h3>均匀分布</h3><p>mt19937 还提供了 <strong>分布类</strong>，用于生成一定范围内均匀分布的随机数。</p><p><strong>均匀分布整数</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(a, b)</span></span>; <span class="comment">// [a, b] 范围内均匀分布整数</span></span><br><span class="line"><span class="type">int</span> x = <span class="built_in">dist</span>(rng);</span><br></pre></td></tr></table></figure><p><strong>均匀分布浮点数</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">dist</span><span class="params">(a, b)</span></span>; <span class="comment">// [a, b] 范围内均匀分布浮点数</span></span><br><span class="line"><span class="type">double</span> x = <span class="built_in">dist</span>(rng);</span><br></pre></td></tr></table></figure><p><strong>正态分布</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::normal_distribution&lt;<span class="type">double</span>&gt; <span class="title">dist</span><span class="params">(mean, stddev)</span></span>; <span class="comment">// 正态分布，mean 为均值，stddev 为标准差</span></span><br><span class="line"><span class="type">double</span> x = <span class="built_in">dist</span>(rng);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">在 C++ 中，正确使用 mt19937 进行随机化</summary>
    
    
    
    <category term="algorithm" scheme="https://xglight.github.io/categories/algorithm/"/>
    
    
    <category term="c++" scheme="https://xglight.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>2025.10.10-A</title>
    <link href="https://xglight.github.io/posts/7663eb87/"/>
    <id>https://xglight.github.io/posts/7663eb87/</id>
    <published>2025-10-10T13:00:00.000Z</published>
    <updated>2025-10-29T14:35:50.077Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="5c692f22b4c38982a94584fd569357d8b700fa9b63730787088a56622edbd854">93024cf999deb8d8b2919f7e109263d436f7768a67e3b41578a0afeefd292b2d4999fc90f8999d6616be736d318b4686c019a080f804dc58f7f397fdc0e0aed4859adc7170991ee7d6ab2abf9f680a77d18728f5d743cbe3c1f19f805b99f8f33434949cdaa14bdc0eff774a5dac66dacbb2a06185373e71d4bafc33751a44439a2314186e85f523aea94e7035e39553745aaa25ba82881030bf79ddb084dfa57d342cbeb1af99637a787a02dddd9c3948b2fae9767174fa139bfe96361c92674eb7be550a2b78854cf202803fd2b702cb8769425adc04a3f3fdaf9087c8f0d0414a99bbc664dd70c6dab46d35ebfbb8814a3b7e551cbc10940214350b0e35cfa791087719ed29fb3207ce1b0a59fe21956e27551669b842142afc33c14af8ce9397ed6fa5c9b11c1ecd97b88e88912ac8bc0135cd250a70a06ceec9f504873eb344ac0e8a4a7345ce553ac1456917f7aaa50904b001179f46c9e8946874af08d33b3766566c568340e2d4bf7eeb89857ad02b1f05b69b0ecf953ef498b88095348915830d35b81eb774fea783b52f9557875ad76317f013225e85f538318127c5c5b81e26b3a3a9f74bf321f1690985c1d97d5c80d995380c2b17e455cb4277e87ebe70d5bf14959ebde14683854881037f36ccecace3fae159c354a978d17ba6b4c7032d87a8a59be1151bb916138a16dbffea2cf2b2e14a89a8bfbd69da6f3ac11b7186e8c199bb46407eedad4bf4aa6b532c8e816909e416ced093d61c4384236b3cd07d1a82680da30b0ed585f402a532a16cf7b7ec9a6bed91eef2b930544cb86a8fae9e653140ffc1464d307a47fa44293c339c87b1012766bf90ecb4caa17e0d1d7b9f89341ec29fd49cbf740c8f3c8d0eef2d75fe412fd29a9a2b6908214c978731347642970a29848a6dfda3411354ad7151dcf845da6bf1ebcb7d3f8d9e4b436ba919f45b2ce328a76a39afe31fb0a0ef4be41b63e1b279ba01cb17296bfc33f6941deaffac8e20870bd6fc32ddae0e1dc86833bd42d429b8fa6d9e6572a26f819d31aed1cc480bc883beab9adb13a942304f4ed03105e65a2347073c068dfb13c1e0b5d4bd6490ca6f6cc6a68f14f224cfbfb576fb883b7908121666ef98e6dfa277ea783ef79a8c151d457ce416b70dc15341cee326b6f4e12a2af2c6a382ce0b80f77e01c0490d496cb8c87e334a5867d3d16a68a69d5e6ea8d4e9e88fd3abfa1253b422b3f550a1e3cb3bca8373728b7c1f5d13c82de8c5cc42991ab37dd6fb5ab24765782c2113644910adf9f725adb1462d65f4ea66505e6e49d27148fb639af3f52202e5b535b41abacba5ced7c8aec0b749b6618376fcd1bec36232b4c2abe3da766d17b4029fbf6d0cef77eb1fd77d245addac40156c2b47511683bcfbca48f9c41aa1c92abaa5bc9d12766217e0c8eb87f6a7238c7d0b274daaf8755da0897671f5845a094717882381bf62d1a5b4ed1934533686514af7b6caa841de0d6d01df726ed6b0ae1b95f94860b6329660a4a65056bbed507edf67f2907176c68e3ef3514c4b5216426adbbf89376979458daa1f592da4bed09a06bca21f7834480a680af57fb9aed269c7ba44b4aac701210e620944b31de08ead73d3284248f4e4dfbef8c3854c5dcab256d287dcc25954982b41bd987125c3e831fa7c10480d8b3f7f89a4ac25a47bc29ca7814438d5dadaef93856b74467044e178d945f9b5614034e1da0a4ef27bf12a627d64c43e286798974ceabf14dac77c195b6682562626251f9b22962e1d6a7aa6e9a99070774f66bf0e5c954a43b185e00c12ab75d6ff05a09934b748b61afbee25efd3ebabdc32bf6107f25091223ad75721030ab574d05bacea74366955cfbc9bb2f19ab27255c7ce740c897b75ecdec079cca7b9e924cf1f16e459d221a024517ced832c294e9cdd0d83ec3a4ef224d2f34e7fbd228350beb7708c6398db26ddfd723e41bf6cb7014ad2d39ed3b8482e2bc85d35cd1d13bcd6348295467d7553766af496243d5d820aee083b60d7a4c09574cdba29075f879c88ec82d739a09c936659dd7e8439f4dae74a1260f3d99009a4758df4e6a1007889c93227c02266dd9b61cb80429364543fc8333f9939a9d69a0f4b06d87b16b2abea95d4ba052ab807681fce86c0e0306d93682204473f961f24626e97c59da458cafaa307f22041d4a267dc2dbfbdd658ca9d671fd7dfcd8a60a354942c3db8666ae9eaca3d7872c129cff59b1c8c8845fd2a94cb71e89761047e84442ae8e10dd33cdc98d3c588f514e8b6ce339e75d5961762984494c315d02d2e1b627e182700488b3e3427edbccc3b1aa9cd44ffe0e569864c0f46712003da9b6ecf5d70422f1bb68e87c7c47009eed43ac07e7f668e6da2b9b70cf679efd9bab54a9d5f446d3305e8f274207ad98bf8fb6652c212629fd834fa174f10410830802d11596d3affb5825cd9ff4b691fdb07edeb43fdde3bf50794bafc996128e5eba6f5077a1a7c3809ee5299efc2e32047c7f7affbf28ac15719bca02238ce4678bf2913badd5700585b413d505e8914880ff3a2b207c36566988f231e8d46cd26f5e104b3581bdbbe757f54a6c934fcd2bf8f2ed34c0370c1818d8d3cd770a1bf7be25cd5cdd1d9138c2371fc937295a8d816e263219faa265b430435dd043e75efe4fa4a948005d0b46e57f432c4017944b4559f74da2c3923f043256bf4e63f012770647d6b2edb94e9355777c5cb2bf2ff1abda821c88fd783ab54421e225d0f0eedf5d1c48522cab1b3b3c11db1f5f1c88ac7cb6f2bb1590f47b08e1f2bd21c45723c1023036cf06be329c7224158a06e15e845c1ee6664c176fe3fa2bce5ac76e97bb72a3bca57eb849dd87352b899453db9584289658650903403fc10406f7512d419b3298afc0657448187527df33307bc32a000550dbc9e5fbe1552e6bdb7a56e0dac8366f0282d8a2d0c9c1c3f037033934560e6d2134a463719a0439ecea3fbef3847ed3d244e71e6cc10b2bbeef8c329f37a518b7e3dfbce7f786d2b6ee85de7544472f966f4cfc293271fbe0238a1f3ceefbd9e8837f777e2f4f6adb6d307832bdd243a20d01275407ed9fe435399fafb83f25714855fcf50a696eaa31431f03f637c526c499cb6f01f4e487cc277cf7ec2e215729b93167e6467d53dd1622ff0f58957519966aed274c7b603ae877594b61ef947132f1886abe811372d93bdff33b01ec83bceb64e4d57c4f213f4eb385631f13e5c1dd2b10e2bf7aa433113ebf6f67c06298c894da489cf8d2a68a6dc35d33a2d8dfa37fffb4d2753e07929adf107fa01e028afd19e52ba9f7981686459f3b9a70c866fbf0e751df6bf5c66c56fad18d7b03a9229edd43c201c5fa2a378025027505e1f300c42f6dbca1607b294a9fdcb192ee3277581e671b3316151a3ba1a736c9cdef75fd3b3c0007e2ccde12eb926e16f74b968358f47b0f02d6f258fc57fc1f86508dc3a382741240aec571dfeac169d8071986e95826f99a943d8c171cc6209d6480236f61cd72d054facad1254312de958942d5af31dc4e0391b2e8304576f4bbf49359003aa5d56118b53396cf77ba14a804c88cc8f6260876cf59db1fcce7bd9988897fe6b136da8a7bda1b2a7ab978c674e7bd4a9b79bc7a0e1f63805d00e668dc699db60934cc3033e708727e70538f4a71630fc9230ffa3019894d663727f4d5bb2eff3d7d7bccf97c57a9baa8b6b6eab0e083317c477b9bd51572a0eda49404f5df73dba51a4c1d044a00d29f82e1a585fb8dd8f059187f674110f3af195617e5a824b80c64b4674d71a6e9a67c6cb01add010534d384dc750eb2c98d1777090e8df691fc2781a3022608cae98a3aeb39e204d6d8e20a8d54d2ea884cf1c979c6b42169d2df009c0d762efb3122ac3ce801b02686a056447ab5671fbd0e1c02b6d423f4fd8335570cb604d5c7fc0e40082597db09f37874ce41de98b8191734fe0a715a6598c10b715f0a9d194dcc9361d703befa50ee773a6a2fe50df91ad6fe1ee04f5c48b3b59a5c7c6420b5ed874567c1763b5a185528bb87c1afe53cadfebe855887d2291a807ffaff8b39fb3c5555946a6dc750f01bbbde65693da87c7d3eb1bd6faf1608d1d914ff3c1630ed41157f3c361585c9898520988a7e4a33bfff67fe34cea8d8ef5554b8670006954632aad934bf486d1f4975291ddd78144eb598b9bb411850c6830259cd67363669daa3d93d2423fed673bde2fedea1ca2d9a693faf9b4eb0f16792623d8710242823fd858d2022ad9244ee2570ce3044ddb0dbb99f63eb59037f3bb211891e9b086c68771905940368b86f1fca1830f7833eb089f93287709dc2a6b03e801653e2668ae722dd972bbac72b13485232fd08b1b3765c1b9b58454b9ad84bce4a6ccfa0a5da61696314c29f6f8064ef9cc5ff96b2c764428534a0b0cd2b113904a2cb270712d5254d35b5e93af800a917d689b7c7ab29403eb26c6c79c527f640c9e53e5d0d5046278cf1f23c9fe9244416d8c7648e7897faa65a161d6c37c67f6efbee645798988efbad4388eddb7567f39491bb64e6994c15717a9a598343379c6573ce16d3f55a8fb59c2e668228516358d88d37a813f9d2c681c800d39c2707496d4fe026a3d7f3f998ed6f435fcadf998142c31656d50aca2af90bebefe43543ad1968228b7fc25f6f3358f71e91db0aefbb0535dfafde2b43ec12ddb80c39d5d72091391efa837863dabb9df5dccfdfe40df7fa7ffdb8104efe1a6caa92570a4e721b337c0e751337a49003708ac9e55763910ce8fd93355260feaca98bf725436329c7e6416b103a28540401975ad0a1061ca2e800b4b29d1aa24f370b208e724ba43cca5bdc0e72db9d79cfcb8710dfa35cae44313cfdd353bd4e216a7cef57c0475c28b6e9097bf997c8c918bcc9ef2913445e667b9ba97c822d4c7ed97764dadcb103b9ab786647bcb679e188956ab4d475fdab678e2bd13215fa1b56f7d9f9263517dcbff955f6100b9ba754eb13af9703f8c0a9a7959be8a1cef52d770530c65d1eb9a85a039508f415b5600bb0b05c9fe556ad81ba7fb5f1b13c8d3e1b56f679a5c9d89284d2fc397e412f370039aded673e7eb665e18686065b4df6607ff5f05500641e3745880f141496ab3a777f8cedbf14f56a5a943f9810ebb816add3439338efb814657132e66dd416bb58b2ce7d1202c666c57c65ee163a4ff085f5351364d36c5703d8d0fd1d6cfb18591f38da846c3aa0632696b96c68af9532adedeaf81edf107d22932359cc6c7c90feecbc2139804eeb80a05bcaab1bd97eb3abc62c2f3ceeb8d9026c6b49a74f7ee19a3636e7dd7f652a5c05ef5822e90179800d25c3007ef7fb66e1a80813f20cb5fd71c91c96a4f8d7c046f94735aed2408a526e0d1bddddd87df434d3f35b370cd06e2ae765d69cd3a9b6d93eb1b89c0dec50049a6654c35d8d2051fab353d6733b8447ad9c684625810ab9916da0ea3dc81660aeca64aeedcd4b878d86dbd9ec299a067d24e8fb511e3d7ab778d307d9753678599c0ad4075d402a48ee160644d15fec6159ee5e52774f885152c690c97ba97a91871c7965dcb61baa32fe8262a5e08ca1510b702307d77b91676034739674f083b92c3428e2519039f2c02dd4cdab57366bf5ad81ea9d6e02f5046c61477d87696c968cc0bf294ad677fa7d823d61518f2eeaef850a27f8d668b006ffaf553512e30b0080aef120aa8dce59bb29d9d9df3fb970a6247455f1394a90ec0245412bbedf1815f417eec7ba0decf1ab12d29185f158b785b5fb22983ea6e0f14b34a23d44c3bf4eb4daeee735d94e446879895dbb7049e50a63ca2d2c551176c182438426d81df89c27e2e2de017c27439535e6641560ba99eae89f07fd2d661ea154f09e816b79c833c4306f01108093f81b110f60f08322534030b458a9b6b9e1b33086970f4656d007341d35dfc636fa31e43fce54ae81304555c0c76894be8e53001e643132819181123fe7387b597fe8092ab6ff915bd850c70db74f5dea8d00b32067d19ca02289572dafb32060a634f63851eccd50ccb6328b98f6460ad3954d41a1d6943c2ceef72c4addb225d2f098c8a2fd3bc3a4e98aa4c41b76b05cbf0509424d501ceb953ebd21b158b3b1bb978f4650214469d3b2537df1a809733b32d3d25197483642b62e771015f870b1f855d8fad976949b40c8c539e4ffeb5d4c187e49ff1f729ff5e84f741eb6c6c11249568013020f7238783b3d4f50d7dabce919eac9c131d8adb85cd5489f811118bc7eb431ac3977b5dccb58e5215d333403d6c23bc0e28cce2768028d30591f424cd53a949a9bc6c953f5a0d1caa6a4e3b3592040922f5b3fdb07dca01c814b9b5ec5eb086b629c08f366d6050c417857f9b369d3f662c2ed318228b4910c6c67d569d82ba56323d4d70d8c8dfe1e8e075d93d15d500521a0665e29914deabf45d226a555bb3c38dd05e47ec46ff56487928d46bf2190cc6102b1f2638ea9074b263bc354620e69dfde80d30fcd23bb0ea17d19c645fd13482484ece55c576dc13f4fb63fdbf261eb65c7737c3932c03d6ab05dc6597f9a369c7bfa4fa96026d6084f9859c63a32e679935af49e12d69c8accd9bf5e5427f5ff99489dbaf98db4c328d4bc08666455c04265f7792d1133b864877e98f8b5638a654011c1c4f4795ed2b5d3b3c22d767c01727594979bc650696753f4b6973301b939ee2703789bf1176ad764a9be45e69c542fbf983bc3705e22c912861ef0571c5661167c9b44eb0a13a4feecbd28098ad830b07f91ea30a66f7522f369b6fcc94363012329e7458c4e8c6d34cf63d7cf0e79e93a3dc67f9d612b24e0d4f66f7d42b58772f24c4bac64c82b9569e602d120718af47e0c191b34dfb91fb654b443e10e3edef9b26f0f48ce28138c9608049efbedd560c1b334cbd9522440da357c7f78270d14b0cf4358c73413b81808dfa696843be3380f81fbcacad56c7a8f71185c3baa8f195fcb8ff61c4b5f3b05f6e4c0feeb0e1b75a02204d9392a6a100cf2969afc2cfbf38b74a533da0fa79eeeb73cf51f94dcec130e5255098106302e4b2ec31bd1338844d618e31b9e89f720e4adfc7612d6d2a5ae7a6da8a81c3e4d72926a012702f701ee39c9a8f0810d59e155017ce3cbf0f1c30289eaef22056f33abdce7f62c90feed9f32caffcf45a486ef01a1a78f338c7a5c8fdaf08ecb79558a5a6a1cb6c5f5e30e08161ec96a964c39b373a058b2366bcdfa0e108144f269582e56b98e8e0bd4f6f16fd8fa1225891343933d1aef14e5ef3a7ab2d3c1bbeb9132aff0259638964e971631650c2872af6663af9d833a8bc2654781feb5894fb8969cff58f236e7c1f34d68ebf2380a07ef592275543fa573ee9203a26d9746f96c484f91ba9d89eca39706e038da6ea869c7f2ae6442a7af929df2be0295bda52e607de79cc11f740e15cd41957bafc1526345dbc133828fcdba940e28921fe2584dcbf8ec94929c00b891346fc25fe7473aae36c1309b0c973938b00061de9e51800a91df1093cb90fee88b3e2c7ff2d5e3f26454d011325361856c36debe54f89e719df51ad24285edfb168d3f5b17ddbbbd4f6e3f7a2020f4e7673dc52d9e0ac54759857802b369bb75589043a923c2cf925d6b70c91b9889beacbc631f25a3827a0910ab0c8f3e80f0615d3b5684a54629d924f9b0b58017c25598e641cb56608d75f46c5f933ee8a31e726ca71053a4e7a1ae0d7525ca2d1e2f67dbd5ef5a3518ce96d03273306cae365cc22fb0582790526e4c09f5ebbd2c4588f83bef39e45cd43781acd294ea8dc1bc612e302c78c48f9e0d03a80680038f0e05dda012966cb367280e1b520d48c1e6e9ef9b6d4e8087c953bee9ead8f645453ed7d1a3133217f86c506b3fcbd4df48c1bdd5fc4fa488079c3312df5e6a0fca8a01015c181b75d7f9d597665debd9a1bb6b3b206f224dd2631c804308683533584c62af25c497bc74a4b0951899c809f2d2e80c933389913e52e2142c2d446992082767efe9f43e85acdd6b69b40b61755d4ce4389848eba6db5d8eaf8a42a09f24bb874437d4f75d6e336ebad1c0376b91c2a73af4c817e84cb4e7ff3bb5fcaebe468b6ce280e1b643df6e0f3a6c8a376ec0590f9566be580ccb39c03169a31c65f0bc17194fdbe4f9863132d87d472fc9c5effdbf32d760591363d48fdbb653ec85d39eac58198beece86caa2af99b972e06d2d5fb4d898f7af5aaa01935bb286b77d25ac819ba54b3437872bd6ef2b99109945d94dff5d06ee3247e1d152752116b4be46f04063f22dccbfccb3024c189475e548cdefe2e77adc68ac178e8239575d3ad1af47ea7170a1a32660ef16fb6d5c92be34123184fd8be355e4cb3f1c0211aa6e47a6ebbc092fe3f8980af47a8148f2d2e8601341282f3ab88ebc0c21cf7138468023987acbb4a88853b2a79e5cb85267bd0819dafddd106e7c397e99a40ba0b1d60f6f3970ba38729b9d3e5b6356e600a404f414d7cf36378039e93e2d78804922c8861decfae2ef858edff12f7ae89e680855e4c2531ffe52aa5b615bac7bb8eaca20e1c0ad04bf08aad3fbb87b6ffe0d25e9014e3de907ec2293ac462ac39881469fdfa795b8881fc6f5cc41084e4eb854ea64b371c138a873103825a783e4bc05dabae803930896dcd954e0c42dcb10a3e0f98c36e988ee5f249b75ce021878cc80e33fd09a6ab19fd7a0c1ca5804cf8c9d017340b8ea3708e98ea9e14a7543e33a67e8585e4623bcc078ef2cb0cca22f7dba91c3ae20008f30777c85dc6ba43fd70ce098f32288808cbff0dcfe862be40dc80de4b15afd7158807c695a11c75492d5289956ba09a79d235313af100284439d7af47734099559c892d2654bb4e99063e0bcbf88b93ca42cdddf86868160a7ee611ddc164d288ec706a26f4f4338e630f5f517eb68af739b98e318e0eb1abf83610a5ee8538c9d29be226073e312f15614caa919a4df01c188e6cb93dc19391691e2bd53dfafb49d499e8d5e95b4a31f7dfa5f9bc798104328678fac5f07a12c7c2a50a8f01bf193c719a77b5d22e4022a8f2a9ed12b7c7eab361ff7dccc0c48b0ce9127019b7745518f6740116ceb4d53530f85edff5867937520900a640fecb0538d32149a2ca8625df443334f80c5c93b0a1b056085c6eff5141353f1f84b7b7a3a0b143637e082925d0b912bbfae3999c04426a686563fb79cef723b21b50fbc00a5e5c6a42e17985cbdc6906629949a57983841b49a1bcf50d6e6d9cdc098f7447cfa0c90d3d11d20244a44eb7f33ff06d188d5281945dd87202637363dedeae80ff84734d5dc5bf5865b15e668bfb98da7a53c6025ed7a9e4792397d07b9dcf6ff8cf444cbf8f65e804eed707c5c2ef7f136c6ddf5baba7dfb5b0dd550e3edd2acbe7e051165fbfb11fba0876baa5dcefaddaea89f13d5fd7b0a15ef7715e3daa4cfcfac3219ebe9d55bf85d62c24773062af6b6192c28a12b4a35081848dc7f8694da047e6a778f7ff18fa7da8be7d16c151987673d94115f5891f53a93c887d9c3c6977187881b6e18e1b6b5a5b8e4989181631482f77a5ade4e005849294cd0c1663e20708097d2603c14997220c6fcf306a734c5a63495e55dc61c9f5f99d09aa6a49fd4fd1b840ca33deffa9c36abed6715288e641d8bed4c1acbcb7547e167e25c959582a8cc83a6392f900de97142efc1c1bc259e142ee1d8b2c850d12d940add9c18fbdaacc084001ff7a4a4156b00a00fdd5089df331318c879abf5f963229fd9670d4036f3b59d577cef11f952453e3bc6f756dcdb87cd16bba1f1696dfefc20d6c61df2ed4df0687e9f22f12bd27c8812e8008dbe44177aeb550a4cb7ed6d502bd6e39070b328a0cbbda644c32ce8c2347e156e16700d3474cb3d231390cfdcacfd86e132845f3c9c9c3a84a4d016265bdbe18ac92c63328b8842c885a7d102931cb3f3c2a273c026ba940b8622c3fefa3f37e94f2e5df7a5f5ae77f0e16404d413797438dcfcaa73874313b78d2d10874f0421a671e169251aacd7003f938e1a14e8e771f59ebd8bec115435f56237f021a9b8039f2bab9cc6c1e3a80b21ea1fcdac8d3b1ab2c480a7687c895728611cfb543807c9e7dd36ad514c79e93cf9e63857db2551417c8afcb9abd8753fb54b06e9da1f5acc97fee09505bc216115ee48abe3bd051c294f6e8a816394180a8295db58d8a1879de15f574e94d44cf7e14c47b5e26feee5891d32d629381e8fd3de0735553f47a2ec20b5c74e9df81bf5b9caf5e1c03a19e1311c665dcbfbb0784431d2451426aa729f14f9f91bd8e6b2a3a93bdd81898b63c16fc25e1370cfa038c0af1f47ae114339055fba8c10f5f98b70ecf7ba55f0d45aafb1f1368f0559376392f5c2281ebd5e1781302ab438e964580dcaecfba442754f4339535d6db937e525cb8bb4b4871fcde2693f68aa19a1dffbbab3bf2cc8eb87b8ae4ee3fbd656730f25b220f71587f0c2611bc81d41dff8921b454a4b3f9028229c6100b0768da7cc124411999d93d7202c8b736d5e98116b028c7a3877a81cd0239a3a82fd60d4a2ede08e34993376cbc4b125197d7d6b3ce933d57576082e70c6785de28b03a7752db00e765872146d5126f45349619077cfa151b4d6a28562ee6fb01304710ff49f1cb8eed0627dd4074ce611503d8dbefff7ecf2a5027cc0e3bbfc0a8aa1012a64c1796b837965e2d65f5f0459711fff140a24883203732ece793dbdf22daf6ae98131c100b2600f017d5540f481badb97280f88a1319212c1bfa5f7f3b7c5138c8a7b0188ddcd7f3214c83e1006baafc6c333b528094e419442b80147329a62a9b6ef09e58e41c8bb185290deeb5e3fe83eb42bdbb8d9c7175bb79bb7a577eac85921b25cf4e7ef100880e5a0cdf4b0013a80af7609a6dc5a2bb0f139b053f944747ff3ac39d0767ba76c6664c57b3d360693b30ddd2c4f57aa1c4cd08251b0627ce84d965b3d379363074256e681ecdd19aa9acf7e33f49caaee249cfa99e1c9b7d9d5f5612f543518600e2b4896bd33909a3cdf0dd9ffeab6645d4438046dba07ea6ded71c67c665e9f3bddac4a32afbff531a1d1bb9f37e0b689ccfaf0c7442c8f96fa146dea36043a88d428d5ec3e86e7027b99fa0971eab00d9819b3730d827a2df5ff8e8afb1e61f161d2962e9c3af4fd5457eca0d77a85ef91b92311edc940af93104597ea8c85b0f463b245017655914c5ff3eb0e99d6904fef804a55a26520aa20172f0a019aa951408105ebf71cb0d4e6b790647461a98a7a38652d32ac10574e12d2264c2ba6d72cb227cd773205eff168e3f78881a8abbd908c846a7a864511dfa25427a657657b469ac1e01e1daafe2887f0c7dfdaf29ff15a178b8131608617d11a14d8ec2d5b539800a6a55c9cb00601bb73b15abb7c4ff65183479bd3cfbb6c278587d344a09d5de93f251ce8074a05497719d0aba9e597eb412d67c66b2fb326aefdb474bc17183497bf827af2a286c9b82e78ee1ca2f1359f6b99c3b36eb8cfd33cb1b03fe31271d7c29dc5751b1c6d1f5584c46734cb57f6f5cc68a72d844b1e76ca977fec3beb262702fb184d9e66a9a1f1a695cac238bc5968dd70911fb6c65e3c82ab7e5e16ef60c8d378cc61133d89c6ef8a790f901c724cf6e70ba6d2d9a375326591aa44afe31e9d7b8d942f4c4a6d76437ad2415d72dce24efab54772ca048a034c18bfd3d9e93901d8e4c0a876538876a2c510abfd9a7c2c3fbd84d52ebd141d21dec406e6bd1e30983b6b03fecbb769179285298e6135b566c20270f5eba20c5616062a8d921ce4861ba13606a987f4ece464e5e783f672768c1f70d34843c48d87ff8855b0ef2ce128e02d816f69c5412f574ad51ca92562d10ef8aee36c607491add3f8bb715a22a4a711781c22f18b5a3d2428b3648214f1f2b01b26fa81cb35c4bd119df789911fa9d7826ff7876d8a9147e6fc97ea137013d5c4686cd8e16b7410f6a513b818d0cadc87a088c6a547e8db2bf76055da29985281cbe50548cb5a3fdeb25eed3defad42856c2f36b19eff2fb893a9c79030b95e34dfb143775d0314dae1f3088be70cc5990bdaeb6eb64df6a0db8113efeb258ecf25a42041e25b3b252715a6b9a667339da8bfb6c9296b622350f146115d104900db51d1db27b970348e0e37c12ea176979093d5633f4d965201e5d6e3c152b48b44b1b79b26f838d2c28a2fe665259e196d98a93b95451cd4667c354a317b1e4dd00</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">2025.10.10-A 比赛总结</summary>
    
    
    
    <category term="solutions" scheme="https://xglight.github.io/categories/solutions/"/>
    
    
    <category term="math" scheme="https://xglight.github.io/tags/math/"/>
    
    <category term="school" scheme="https://xglight.github.io/tags/school/"/>
    
    <category term="dp" scheme="https://xglight.github.io/tags/dp/"/>
    
    <category term="trie" scheme="https://xglight.github.io/tags/trie/"/>
    
    <category term="manacher" scheme="https://xglight.github.io/tags/manacher/"/>
    
    <category term="hash" scheme="https://xglight.github.io/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>CF 2152</title>
    <link href="https://xglight.github.io/posts/e5225a54/"/>
    <id>https://xglight.github.io/posts/e5225a54/</id>
    <published>2025-10-09T14:00:00.000Z</published>
    <updated>2025-10-29T14:35:50.079Z</updated>
    
    <content type="html"><![CDATA[<h2>A</h2><p>简单题，大胆猜结论，答案为不同的数字个数乘二减一。</p><p>但是赛时离散化忘记指定特值。</p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>把目标数组去重后降序排列，令其为数组 <span class="math inline">\(a\)</span>，长度为 <span class="math inline">\(m\)</span>，对于 <span class="math inline">\(i = 1,2,\dots,m-1\)</span>，执行以下操作：</p><ol type="1"><li>增加 <span class="math inline">\(a_i - a_{i+1}\)</span>。</li><li>对于所有 <span class="math inline">\(a_j \neq a_i \text{且} j &gt; i\)</span>，清空。</li></ol><p>最后增加 <span class="math inline">\(a_m\)</span>。</p></div></details><h2>B</h2><p>简单题，博弈论。</p><p>最优情况一定是 Krug 被逼到了边缘，所以 Doran 也要走到边缘。</p><p>根据 Krug 和 Doran 的相对位置取 MAX 即可。</p><h2>C</h2><p>难度不大。</p><p>考虑一个数列如果不全是 <span class="math inline">\(0/1\)</span> 交替的，那么每次操作一定会有两个相邻的 <span class="math inline">\(0/1\)</span>。</p><p>如果全是 <span class="math inline">\(0/1\)</span> 交替的，只存在一次操作没有相邻的 <span class="math inline">\(0/1\)</span>，即答案会多 <span class="math inline">\(1\)</span>。</p><p>前缀和预处理即可。</p><h2>D</h2><p>赛时卡题了，观察结论题。</p><p>首先不看增加的操作，将一个数清到 <span class="math inline">\(1\)</span> 需要 <span class="math inline">\(\log_2 a_i\)</span> 次。</p><p>对一个偶数加 <span class="math inline">\(1\)</span> 没有用，立马除就可以。</p><p>如果一个数在不断除 <span class="math inline">\(2\)</span> 的时候，出现了不为 <span class="math inline">\(1\)</span> 的奇数，然后对这个数执行 <span class="math inline">\(+1\)</span>，那么怎么除都不行，所以贡献会多 <span class="math inline">\(1\)</span>。</p><p>所以除了 <span class="math inline">\(2\)</span> 的幂外，其它数贡献都会多 <span class="math inline">\(1\)</span>。</p><p>但是，还有一类特例，对于 <span class="math inline">\(2^k + 1~(k\in \mathbb{Z}^+)\)</span>，如果先除贡献就不会多，先加贡献就会多 <span class="math inline">\(1\)</span>，先手最多除一半的数，所以贡献会多一半。</p><h2>E</h2><p>赛时没做出来，构造题还是做少了。</p><p>看到构造想到询问特例，于是先询问所有点。</p><p>然后每次询问除了已经回答过的点。</p><p>如果某次回答长度大于等于 <span class="math inline">\(n+1\)</span>，直接输出。</p><p>否则，从每次询问向前面询问的点连边，跑 DAG 上 DP 即可。</p><h2>F</h2><p>思考题。</p><p>转换条件，满足 <span class="math inline">\(\max\{x,y,z\} - \min\{x,y,z\} &gt; z\)</span>，贪心的想，相当于满足 <span class="math inline">\(a_{i+2} - a_i &gt; z\)</span>。</p><p>所以我们可以选区间开头的两个点，<span class="math inline">\(l\)</span> 和 <span class="math inline">\(l+1\)</span>，两个点不断向后跳满足条件的点。</p><p>我们就看成后面的点向前面的点连边，树上倍增优化即可。</p><p>但是两个点可能会调到重复的点，即两点的 <span class="math inline">\(lca\)</span>，此时显然要从 <span class="math inline">\(lca\)</span> 和 <span class="math inline">\(lca+1\)</span> 重新开始跳。</p><p>于是再维护另一个倍增，表示跳到重复的点。</p><p>查询时先跳第二个倍增，如果区间还有剩余再跳第一个。</p>]]></content>
    
    
    <summary type="html">CF 2152 做题总结</summary>
    
    
    
    <category term="solutions" scheme="https://xglight.github.io/categories/solutions/"/>
    
    
    <category term="dp" scheme="https://xglight.github.io/tags/dp/"/>
    
    <category term="codeforces" scheme="https://xglight.github.io/tags/codeforces/"/>
    
  </entry>
  
  <entry>
    <title>c++ 奇技淫巧</title>
    <link href="https://xglight.github.io/posts/78aab76b/"/>
    <id>https://xglight.github.io/posts/78aab76b/</id>
    <published>2025-10-09T04:00:00.000Z</published>
    <updated>2025-10-11T09:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p>编译器版本： gcc 15.2.0</p></div><div class="note info flat"><p>C++ 标准： c++14</p></div><h2>前言</h2><p>本文介绍了 C++ 中一些有趣/神奇的函数，虽然不一定用的到就是了。</p><p>STL，lambda，随机化，chrono 均有另开文章。</p><h2>__builtin</h2><p>以 <code>__builtin</code> 开头的函数均为编译器内置函数，效率极高。</p><p><strong>位操作</strong></p><ul><li><code>__builtin_clz</code> 计算前导 <span class="math inline">\(0\)</span> 个数（<span class="math inline">\(32\)</span> 位），<span class="math inline">\(0\)</span> 是未定义行为。</li><li><code>__builtin_ctz</code> 计算尾随 <span class="math inline">\(0\)</span> 个数（<span class="math inline">\(32\)</span> 位），<span class="math inline">\(0\)</span> 是未定义行为。</li><li><code>__builtin_popcount</code> 计算 <span class="math inline">\(1\)</span> 的个数（<span class="math inline">\(32\)</span> 位）。</li><li><code>__builtin_parity</code> <span class="math inline">\(1\)</span> 的个数为奇数则返回 <span class="math inline">\(1\)</span>，偶数则返回 <span class="math inline">\(0\)</span>。</li></ul><p>上面函数结尾加 <code>ll</code> 即 <span class="math inline">\(64\)</span> 位版本，例如 <code>__builtin_clzll</code>。</p><p><strong>内存操作</strong></p><ul><li><code>__builtin_expect(expr, value)</code> 告诉编译器 <code>expr</code> 最可能为 <code>value</code>，用于分支预测。</li><li><code>__builtin_prefetch(addr, rw, locality)</code> 提前加载内存到缓存，<code>rw</code> 为 <span class="math inline">\(0\)</span> 表示读，为 <span class="math inline">\(1\)</span> 表示写；<code>locality</code> 为缓存层级。</li><li><code>__builtin_memcpy</code> 同 <code>memcpy</code> 函数。</li><li><code>__builtin_memset</code> 同 <code>memset</code> 函数。</li><li><code>__builtin_memmove</code> 同 <code>memmove</code> 函数。</li></ul><p><strong>数学</strong></p><ul><li><code>__builtin_abs</code> 绝对值。</li><li><code>__builtin_sqrt</code> 平方根。</li><li><code>__builtin_add_overflow</code>,<code>__builtin_mul_overflow</code> 等，检查溢出，返回 <code>bool</code>。</li></ul><h2>强制内联</h2><p><code>__attribute__((always_inline))</code> 不管优化级别，都尽量内联。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> __attribute__((always_inline)) <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>分支预测</h2><p>C++14 只有上文的 <code>__builtin_expect</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(x &gt; <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">  <span class="comment">// x &gt; 0 更可能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++20 新增了 <code>[[likely]]</code> 和 <code>[[unlikely]]</code>，用于分支预测。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>) [[likely]] &#123;</span><br><span class="line">    <span class="comment">// 这里分支更可能被执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> [[unlikely]] &#123;</span><br><span class="line">    <span class="comment">// 不常执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>constexpr</h2><p><code>constexpr</code> 在 C++11 引入，表示一个变量为常量表达式，<strong>必须</strong> 在编译期求值。</p><p>相较于 <code>const</code> 的仅保证只读，不保证编译期计算，它的速度会更快。</p><h2>algorithm</h2><p>这个库东西很多，这里只列举好用但大家不一定都知道的。</p><h3>排列</h3><ul><li><code>partial_sort(first,middle,last)</code> 只排序前几项，即保证 <span class="math inline">\([first,middle)\)</span> 是最小且有序的，复杂度 <span class="math inline">\(O(n\log k)\)</span>。</li><li><code>nth_element(first, nth, last)</code> 找到第 <span class="math inline">\(n\)</span> 小的元素，保证小于等于 <span class="math inline">\(nth\)</span> 的元素都在 <span class="math inline">\(nth\)</span> 的左边，大于等于 <span class="math inline">\(nth\)</span> 的元素都在 <span class="math inline">\(nth\)</span> 的右边，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>is_sorted(first,last)</code> 判断是否有序，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>next_permutation(first,last)</code> 产生下一个字典序排列，复杂度 <span class="math inline">\(O(n)\)</span>。（CSP-S 2025 初赛）</li><li><code>prev_permutation(first,last)</code> 产生上一个字典序排列，复杂度 <span class="math inline">\(O(n)\)</span>。（CSP-S 2025 初赛）</li></ul><h3>查找</h3><ul><li><code>find(first, last, value)</code> 返回指向第一个等于 <code>value</code> 的元素的迭代器，如果找不到，返回 <code>last</code>，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>find_if(first, last, pred)</code> 返回指向第一个满足 <code>pred</code> 的元素的迭代器，如果找不到，返回 <code>last</code>，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>count(first, last, value)</code> 返回 <code>value</code> 在区间 <span class="math inline">\([first, last)\)</span> 中出现的次数，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>count_if(first, last, pred)</code> 返回 <code>pred</code> 判定为真的元素在区间 <span class="math inline">\([first, last)\)</span> 中出现的次数，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>binary_search(first, last, value)</code> 判断 <code>value</code> 是否在区间 <span class="math inline">\([first, last)\)</span> 中，复杂度 <span class="math inline">\(O(log n)\)</span>（<mark class="hl-label red">必须有序</mark>）。</li><li><code>equal_range(first, last, value)</code> 返回一个 <code>pair</code> 表示一个区间 <span class="math inline">\([lower_bound, upper_bound)\)</span> 满足区间内的元素等于 <code>value</code>，复杂度 <span class="math inline">\(O(log n)\)</span>（<mark class="hl-label red">必须有序</mark>）。</li><li><code>minmax(a,b)</code> 返回一个 <code>pair</code> 表示 <code>a</code> 和 <code>b</code> 的最小值和最大值。</li><li><code>minmax_element(first, last)</code> 返回一个 <code>pair</code> 表示区间 <span class="math inline">\([first, last)\)</span> 中的最小值和最大值，复杂度 <span class="math inline">\(O(n)\)</span>。</li></ul><h3>修改</h3><ul><li><code>copy(first,last,out)</code> <strong>复制</strong> 元素到另一个容器，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>move(first,last,out)</code> <strong>移动</strong> 元素到另一个容器，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>fill(first,last,value)</code> 用指定值填充区间，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>rotate(first, middle, last)</code> 将区间 <span class="math inline">\([first,last)\)</span> 变为 <span class="math inline">\([middle, last) + [first, middle)\)</span>，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>replace(first, last, old_value, new_value)</code> 用 <code>new_value</code> 替换 <code>old_value</code>，复杂度 <span class="math inline">\(O(n)\)</span>。</li></ul><h3>随机化</h3><ul><li><code>shuffle(first, last, rng)</code> 将区间 <span class="math inline">\([first,last)\)</span> 随机化，复杂度 <span class="math inline">\(O(n)\)</span>（请不要再用 <code>random_shuffle</code>）。</li></ul><h2>numeric</h2><p>这个库提供了一些数值计算的函数。</p><ul><li><code>accumulate(first, last, init)</code> 累加区间 <span class="math inline">\([first,last)\)</span>，<code>init</code> 为初始值，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>inner_product(first1, last1, first2, init)</code> 计算两个区间 <span class="math inline">\([first1,last1)\)</span> 和 <span class="math inline">\([first2,last2)\)</span> 的内积，<code>init</code> 为初始值，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>partial_sum(first, last, out)</code> 计算区间 <span class="math inline">\([first,last)\)</span> 的前缀和，结果存入 <code>out</code>，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>adjacent_difference(first, last, out)</code> 计算区间 <span class="math inline">\([first,last)\)</span> 的相邻差，结果存入 <code>out</code>，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>iota(first, last, value)</code> 用 <code>value</code> 填充区间 <span class="math inline">\([first,last)\)</span>，复杂度 <span class="math inline">\(O(n)\)</span>。</li></ul><h2>initializer_list</h2><p>C++11 引入的一种新的数据结构，支持用大括号初始化列表，注意定义后不能修改。</p><p>常与 STL 容器一起使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; l = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::<span class="built_in">max</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><p>或者用于循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>iterator</h2><p>C++11 引入的一些迭代器相关的函数。</p><ul><li><code>distance(first, last)</code> 返回迭代器之间的距离，复杂度 <span class="math inline">\(O(1)\)</span>。</li><li><code>advance(it, n)</code> <strong>移动</strong> 迭代器 <code>it</code> 指向的位置 <code>n</code> 步，复杂度 <strong>依赖迭代器类型</strong>。</li><li><code>next(it, n)</code> <strong>返回</strong> 迭代器 <code>it</code> 指向的位置 <code>n</code> 步后的迭代器，复杂度 <strong>依赖迭代器类型</strong>。</li><li><code>prev(it, n)</code> <strong>返回</strong> 迭代器 <code>it</code> 指向的位置 <code>n</code> 步前的迭代器，复杂度 <strong>依赖迭代器类型</strong>。</li></ul><p>时间复杂度：</p><ul><li>对于 <code>vector</code>，<code>deque</code> 和 <code>array</code> 等，支持 <strong>直接跳跃</strong>，复杂度 <span class="math inline">\(O(1)\)</span>。</li><li>对于 <code>list</code>，<code>map</code> 和 <code>set</code> 等，时间复杂度 <span class="math inline">\(O(n)\)</span>。</li><li>对于单向迭代器，例如 <code>forward_list</code>，<code>istream_iterator</code> 等，时间复杂度 <span class="math inline">\(O(n)\)</span>，且只支持单向移动。</li></ul><h2>nullptr</h2><p>C++11 引入的 <code>nullptr</code> 关键字，用于表示空指针。</p><p>主要区别于 <code>NULL</code>，因为 <code>NULL</code> 被实现为 <code>#define NULL 0</code>。</p><h2>decltype</h2><p>C++11 引入的 <code>decltype</code> 关键字，用于获取表达式的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decltype(expression) var;</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> y = <span class="number">2.5</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) a = x; <span class="comment">// int</span></span><br><span class="line"><span class="keyword">decltype</span>(y) b = y; <span class="comment">// double</span></span><br><span class="line"><span class="keyword">decltype</span>(x+y) c = x+y; <span class="comment">// double, because (x+y) is a double expression</span></span><br></pre></td></tr></table></figure><h2>auto</h2><p>C++11 引入的 <code>auto</code> 关键字，用于自动推导类型。</p><h3>类型推导</h3><div class="note warning flat"><p>必须初始化，否则无法推导类型。</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">10</span>; <span class="comment">// int</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2.5</span>; <span class="comment">// double</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="string">&quot;hello&quot;</span>; <span class="comment">// const char*</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p>注意默认去掉引用和 const。</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> c = a;        <span class="comment">// int</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;a;       <span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;b;       <span class="comment">// const int*</span></span><br><span class="line"><span class="keyword">auto</span>&amp; f = a;       <span class="comment">// int&amp;，引用类型必须显示加 &amp;  </span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b; <span class="comment">// 返回值类型自动推导</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>循环</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : v) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : v) &#123; <span class="comment">// 如果要修改元素</span></span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>结构化绑定</h3><p>C++17 引入，但 C++14 可用，应该会报 warning。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> [x, y] = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; mp = &#123;&#123;<span class="string">&quot;a&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [key, value] : mp) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>if / switch 初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(key); it != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>C++20</h3><p>模板参数中使用 auto：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">auto</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; N &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>&lt;<span class="number">42</span>&gt;();  <span class="comment">// N 被推导为 int</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">c++ 的一些好用/神奇的函数</summary>
    
    
    
    <category term="algorithm" scheme="https://xglight.github.io/categories/algorithm/"/>
    
    
    <category term="c++" scheme="https://xglight.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>2025.10.8-A</title>
    <link href="https://xglight.github.io/posts/4791dc7/"/>
    <id>https://xglight.github.io/posts/4791dc7/</id>
    <published>2025-10-08T13:00:00.000Z</published>
    <updated>2025-10-29T14:35:50.077Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="6840ab164d716b2ab0474f519b7cc9406ed5cb88a1b12a39abb022c2939efa5b">93024cf999deb8d8b2919f7e109263d436f7768a67e3b41578a0afeefd292b2d6d5ddece01699d8f2cc04bccc4405b947a3fe5037bbcf5d47d5d5ad930b4c7b9ab9f5f3238dd5d9a4aceac8cd69ee0c215b9f27f78b0855917c24355aaec56e5b845932cf02de320468e98d727a4cb63092dae35430e3acf77d7bfed27e543578f37f6bb3d64e7c66f3506bbf2b6c265de9662030fe50805ab561444180ea5ad7a824c55e4a83dc107219baf57abb6d10e474ddec526ef5842d4c6bde6d9179d8da847f513069a9f4fab06d04a2c2d5d3c66877815116cebd1d82817f0b3eecefb87aa899039db9828a9b492976cec01527832224b8f3beeac886c98bf2c5a26668e1769419c16e29a29afebd3968609d233041f96f01a4d353ed720a82c42cb80cd3981a4ad6c06549f1253107a94d72b5b56f0db26fa4b15b5c0a1b7366f47e28eae47aac342f1e5cba30d6800d6a40801265497629d6a2019a6fd22e3f8067ad118ed9a63f289bd9dabf81f93303367c4c1e324e0312f649bad35104a55d0d2317474b848efd3059b96be7e5f36fd2243679aa06b02695bdae683aaa6d2e64db25936100324ec463ef96210dc6807f0218e33aa344830050d7ec54ca9ebe0cf46906a8e1bb6136169b9f9086d22b4cf4b20865bc673128b2910f8ddb03df213b7ddc7dc8e5e6460a682dfb01d37825664c8f49e26c6a22a301eb8658c354d98f216b571952b606ea6d400a7f66f2f543ade1f80e73f34c5baa64b2d9565632df9430d7ae897d90d395d94899000a0b6a6980c577b2011a9952bfbe95abe90f56732028116ac58f56c1e5fa2d6a37021d3518fbf55ce791c73b2b7c3f0f6b8dbb8aa08cc7a1a311bbaaeca547c4f01de1fe3e9add146f82f6f24cb1d6bf3b2b93915b08438e25187154dfeef118779ccf3522099a86ac92f921e60ee6c5d944f07c0aaeb8006abe1a7b1dd0fde5fe83100a6758169d4f504b92ed74a4d908af75e6de7b9d7892c9067c9e4438a1c6546ecf4dc4d58be96f42666b6bf95b0ede5e888f6ed7537988e08c0c4e562db58f4c383be1b6a01eb71b005b5c913e3ae2d595c712a020c2728194173da8c5e454e28f89f1c7425d72af8e884800938fa4c51b4e52aa954f2ddddc5e51bc36fb973b013f44d106ea184cac03f652396e0b9a6d8bd400671454921c712f98fce2a1f61ade72199412355208b0ad88bfa7756d47a4056d17d750724f8337aecf2de7196a8ea3dd2bd6241da4b1e7a1204e8107387728f55c80cb06fa199257680b1949751236d2904ad867f7f51dd6fd19aedb24efd9647570d249bc3a799faa5404b30de57ce7e38a73498e26cca573bd88a3270117fb6531fd16c7ff00b18e0886f13a22a0b5d61cc8fa81cae0628f73debbc04c43ee969b4a9ff455dba8e368b23dea987743b092e6a2b9688d3df05d1207e77eefb9bb8767caa06362dff6c27762ae4e670312c224db0ecf22ee94dde0c5bf85afafdd6231c5d42eacd75392c0838f3a245303a9d7020c127fe9b3ad42b4490f958e5310fe9c2592303b25f41073b48484f352c1b5dc66593af217fab5836d52ca640b5486778ddba515511a500d614303c3872847f7c30a5397e8d86f881b66261ced8dfe614dd814fe7bbaba062efc3d4c61c38e7d117cf986e67bc7974fb703539746c425e2304d1722fdf123f16f8e6c44a8627681f1c7cc7b593e35c48f4645c1be6768044aebe62d40b1ae1c79d6ee5c8573cc9ea2efc598b7bdb43d5011224a7827506983182900a561b28e4a0ad9631987d3dcbcb07595854052cdbd0bcc4f5eba0ae53ec9b31f309076efa8e2ef422c85b2bf667f5cb7fd57ca4bf83305605f277ba7b1d966902ad1bfcd12210a70f7c5eec05c778f58ba7c9deed9168ba338859c608e648e50800dad9508b23a0fc9b809a8715970ca638467e9198a7adca289c4fdba0e3f4608745a9cca4a7815620b467ac63cdbda1e056185cbc54524fca34ab999febe69d189fcc493b38c15377728d6f5ed647735776b6df358556058216d4af92c7092e1809ce8c2745d9a45e8b348ce10e7e7acb2f8178817d3a6e00f03c9bbf720754c22de123b3a8a268cb6d1065c9f2922c932e52e476a1ba68ac0473a64447d55eb78f486fde1c7c0f39594ac263df11994480ccbb8f56dbbf04a9376472f6f58f1cc8a8657e253a52fd5de10e0bba9aa9e7b69b1da3ffcc2d13ed9336a129fc8ebdfdeb11fa0b0f368d9b7d91cde570d3a08e181f52ea121441c0329cf23e2745d45025e345b4bb90e0ab6477fd381cf3c7aa185176352241acbe3ec34fe0776c19b9e585770a92e942f2ef5624fabccfcefb6bf6243c7d21e1f5a5f9586bc03c87320a7c886ff5cc737b2ff138042319b9a76a34783fe10e4487e38310142d9c35af7540f8691f084c08202bc5c3c44ac9fb805a7790f5ba2ea83fe685a1c9386211c025e2de7f7064a027456a519fa62e4dd6902106436e41329af134cfe1d47f169aaf6b3f26912fd8867863be0359a7b7bc4be0e85fe644f15bcf418ed934e241497dff0b28f04a0c648d22ab2ab005f5b888308fc1d1d7579698ec8afd10a5895c353ed45c198fa73f73df7f9de7ec7d158e64a989e0a75566cc71cf2d26713b7fb9c745f7d6d702a7100d8e4a9a4b2af210d26a59e5d4ccd4bb694ea74a182a53839d0887bccd8d1161b9129dbc87c11496aa2c712f51be7ca4d459ce128e28505c7e577dc4db1045b670bdffcfa14cfd5fed55e4189bd4713fd26ff0f7bf74aa7b18491bdb3fff12d2ebec6c8211ff3e755b8c7be07e843e55531c78cf4a6932c6fbe9656560ad02eac3035ef52d5401f542b9bafb8741da2492279945a46e76bf4bd8765bc55d975b6ec9fdc6d96b7e5048cbf47debccc0304b6a71d575f6eb12c7a5db18cdb6e8ff2137d40a65c6be1480832a0cdeafa208dc48e91482df1ec7a032e2532ac6b492c03f9d126d5c1021520379aa0698b463340a9da00032d8afe7cec825b5a37f2c4fcc3fd0f1cf313c00942b5a96c8a9373a6dc43e1ab1992853f4237a8776664aa14ea8fa62a52637889bff2a47eedf908c31e02007b71f71e10f96cd3cab8a537bd6e8c2969ab158dadbc2b565ab2270a07003828862aab5b06226e3ddbe4ba2d45becf7032c567a76c608c6df9d90499051c1a6793ae48efb30c2ff2b1932f4fb3fbb5f9346b196f6fa5cf74d166910b38ad38bc5a55638cddda4dd4e356cc0dfa39c4ef32bfb6c6cf8dbb6b3b222228ddb9c908183030b1e7b108fc8d5b866235be1944230a5527e13f4ff10bebaca5e0f427ec5e9edb3a05f3eefbe9518a95334325e409c5738c8a10ba3188985cb0b4cca81308b90c5f1aa31daf96980cf734ab831aafc166e71939c07f96849cc8cf370dea6c6f5c801147113c93c42ae3f26ba10e54611ab09272dc6c94daf5f16e237535b0c5229e977980e3bf33062d95736dda47e3649d341d146fe18f32dcadda393e90b989a44ff9973095fe1f1664a3632ab161c912ef7fe87d2f7087e4cad591a366c193280d69aea2f0586b579ce0c04d64e968bbf495e93b10ef782a71f8f30bcf7ec4e39bae6cd044db77559f131ad91bc5fdfabeacdcc2d977a6dc5c3be19571f7c5ea4dc1c3422041d0f12c897a0adcbed2f453da1200418b06621866ad1ca09f283b8dd6919f9adae758718a260f946cec5b1bb827b1814de8975aacff327a891841a248ba3248227291b3e0079bc67320843fb54f2e64079c1f444e771e3bbab5b253773aba8560af78837c2f6ca412ab83c00de2ed1d884d5a63d1cab6e4da920ef31cf4e5695f212ad2733a684183ea0cdb0316c262d93647d03a2063ab0929bec44e09d25062582e399ddce6a160c1892a49c88ba85be960fd5b8840806adf64e74bd03b4c619fdb6637ae17be25a35b49aa0328630a7b6f32e5f6fc2ab92651af85fd20a1bd4463d7cced4cfbbd39fe4d154c4cc870c0b2a5756cf4d0c70a61398e79b118ea7c28b2e10f90572c61a0c547d41ba6f8085f382799a2aaab23cd8782cc6bd63330b9777a10cf89702eeb5b1685498fb6ec530599aab8c4ae49f9fe152060572a4071bb1619e277d4bd871d39ff8449e4f1615f4d84ffe773cf1981c91da2eaa1820e71de2ae3d0713e9a02a04d4bed4d16e3a41441141c889d46ef3db61772e576b7777d9c85e2f596fcce181ee2f3bde7b1163a471f2dc4926c0e26c7f65079065c5ae95478be12557d42a5d4c4cdf81587590f06bb765867914a24a72d75a75eb37611660f0706e680a65d7940bbe8bd6187093b24f2b8a9ec7ff570bbf96a073d5c264c95736d8a41c2fb654c1a21e74edeab6b13ba87eae6ad8d894710569c178fc21a31807fe9eb9d8ee8427951ccdc2efc9baaec8b1830339c529f91c5f13bd1d41f8898132148fa598054b64e165b0d5481a682ca98e0e7c5fb3dbacb120615a1286ca164b8e1f9c59592ecf4ba74b2a9615d8181e8a3c0b30d1270783e2da6a1a7adb9fb7c17d53a58d6f99553fe692cd416cddc6409e391865f2449602e2bbef35db7957efa6523c3d7f82c1fbaaeb8b39b600d4519d3e6d0727fad8089c4128b0758258c0cbab41c9ee375e339e2179b9068f172dcc3bbb30e3ed295823c3bee8153e6082731e09dcfe7c368ee0e0c04a387f8628866f23508e164a78d6ccfb5ba65f2b3d5987d137cb106018d25ded64c340c3d5995ba385171f635cc060ae6386d34e26eb3cb3f2ae2d56dc72b35332d0b73aff05eb36da4ce0a2483c307a296093a53b290373d4f7649dce4b364714c533fb151ad538f0c5102640219cc6a16f0261b222ffd9f8aee8f5f109800a0592cc924fbf7a3996b23604fa1d16fb0dee</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">2025.10.8-A 比赛总结</summary>
    
    
    
    <category term="solutions" scheme="https://xglight.github.io/categories/solutions/"/>
    
    
    <category term="school" scheme="https://xglight.github.io/tags/school/"/>
    
    <category term="dp" scheme="https://xglight.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>2025.10.7-NOIP</title>
    <link href="https://xglight.github.io/posts/25373191/"/>
    <id>https://xglight.github.io/posts/25373191/</id>
    <published>2025-10-07T13:00:00.000Z</published>
    <updated>2025-10-29T14:35:50.077Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="f1b882435f86db8fbcbfda042724273de975bd115e2174a1774c7aed6b4874c6">93024cf999deb8d8b2919f7e109263d412754b53667526e793dc67267e2d6266d79ba8c61f62ab2dd142a6a62265aa43e2e075283f78c2c579e1aa0c37f65c5ea3aee0ebc8487a9498f0b42890ac07503b1be67fc0482f8d56d3dd1c93e545561ee9086807dd53b13629d3ea11fd9dc2d8b33215199acf07f6f3a55ba29277661a71145ef6063e6e398902e578c6a43843861154915a20b7b2dcf536ce3a2d1aa2766e83cb46c6ded31485b7156dce62abdcd8f0de1851d282050b22c9c6e0e4a5afd9591c3006f082fdcf220d9cfc0f5ba747a9765fe2b5ec72b809ef6530ad7582da55ae24160b45ce2d7cee571b98082b6b75dcc5a5dae438e5e0fcc2a9bf59408f53a458feb8a38f277399a74dcf229c9171fcb0756225a199d76d7dcabd14addd155d825da9735d9081b4cc26af01de957035c60053d6e6962b3e954b956dbaf366ec582dc4af9a7f25b39e51f6ac64553a4a690025087bb9c40a4e4ae7d22db9021b015dd7bbb744f11512b940ba9eaaf60667ca1b4dee768087f903a5153c66f55187f2888a5e4bc6eabdb1d42e40058ac86d6c4f8db4c9ec28f4cb99871f10c6a9e3e2c2a5e11257873624d352da2dd754df15e3cef1a6dc42f4d48a006880c8ca7abd28e8e13956ce73de319a85039be316c16ca35c78b0683fba1608e52f4cd4865114c3e3d402f5e26ca183c075f0f0191dc939235fb3c30e4c92d75ac9a46aced0b17ed03c0ca67875ed5da0114d7d5d1d00f2dd62e33344d08efe43f26533058e53cd7559e4f08f294599af7f7a716190c76fd778ab919e9cceb854b768d18123b39aed7e0c8e6f7d23caa1225040b85b8c5ad2b778913ddb7d4d6bf3305fd0b25fc15e2d08ae0b722c11332d4a54252d77f91b42abbcb3529bec2ace834827f70c2b8a63506161ca386450627ebc5b3141f6e93eefc9af254d9f692e02cf4f834faeffd579396e4957586d1f71457956afe6a061b67baea613f62d9423d8d7257ff23a62139112d3624dc45a3043f385a98e718b965a719cd5f257f3afc07ccf896b86fabe0e8bf2cfeb5de0ac0ffc9b04c806aeb76b144e0bd101fa847282b405abb847c6972e9901aefe695c9bbee2406c3f74ed019ade29eb1eef899ca6424f1d0cc6695f36a861e64d9ebc320e3b6c3885c76a0b66cbf8e65fe73a16d10237b604f33758bed12f8f90afccc73db33c0e5f9e231fdb5fbe9ebb51ef46ce230a8fbc1dd91127c989113fe6680b2c593cd5b03b5cb5333efdd68caf7995fa969c0869dab401e7aa2aca7588405fdbc628353e30c160cb8f49c6c2f257654d3162ce2a29f6cdb807b825d0b8c7feb5bc48f2cc68fe477998692665264dc91a1b200efd0979440a84d87e6e0f9cb872961da4cf2c537e34d52180a2bb4bfc5d1b3bf9c9d45652a3b23110d6ca87f27cf776004e73ed03bda6d1f390b069b09157bd6a182af1fc9d132a059b0d49db206add5a562c9e8392fb7afc4729b5b06218f13d4ac3a49df73ace64cca1201b1ebfcd1428d00627cf8a585c33988bc98a803e7bdf6bcc774d37290af26ed8eca0997755dd6ec91842229e7b16ed6776fae51167f388a06f4b4cfd753406d2519988963a0f204a0108b57212255dc2241606821764074d7a6907388bbccce3f90530150044cbbc2dffbd2c00849af1237809a8ed577a3a4e3a5ed502d0281e909f21ee2fb05dc63f2ea33ab8a8a3f271a2385ff55809e022629bcafbaf899e699eb4b9183a173008fff25d7d3fb8fec2763ab10da7068e72ce999c23b909b9250baff18ba85e095dbabd1f0a54b90ec5dc5f4947bec1809fc0ce36ce69541cc4ec0a7ac81111da487ad1ed5c6647ef7630f547cfe393992a17d50bb420b13ebafbe3d7e4221a48dac81973f394265db5247b8cbc564b51791227433735369a4c64d0ec4d72b1bf1faabe0cb7c45a5521215a740c96e17efe299ea4e0106ac6e001e5683dd2206066eb87d552099a0ae2764ebe6e8c66a3ac4d9e57c704391442c4cc294ea7391e7616772c05245a2d6eaedf418088db1f626b24c75373aaf919c91264872f6ef1db7e50d8ae3bbb5c1d799dd2882da8987c7acd5e66b8ea3594139374306f0c9344b9786a887f83fd015ab4d87df80bba53176f75901080a90e74212cf8293f5ee4bceba76d498a4940f457bdb4caf543821369c1258f17f487555fc2c2d84279baf6a924e3a676bc0a5479b30ea0d49d5249d4ff66600fc26c9a754cfe9a4e07f6664bbfb36b9c19fdbc64942f2e86aea33ece608b3e9e933446f50d9d41a2b83df3adf5adbb646c1218c5d597a3be6c159aa7f029a51c0dee1ac141b62b7682ddffdf07a940468cf234c24df3374267d97b916eff25b89cb681b90b2b41d98a8bbc76f0b8dc0ad8c74086d7cdc632513591cac411d5dda634576f5ea5ad96317333d374ca8652ce38778555e219c1e93fb8e2600a10b1d24888ce3b4403ebf92eec0b1f413d18291cdfc8908ded3e47acf6aedf46d07768a466be0567362360e48c53270981808fb6057fce8ea46665f14ab1aeb3b114a8cf6cf6286cb3fe49818b08c7b0597e6088f43ed9fdf5356f3dcfebe76506ed4f204e438fdfb5f612869da80f3cd7f0a8497a995aea6d9ac609e7fc348a02bbedccdc98383349378cfbd6985f0a24122d53a69e0c493a08f2db2183dbbf93b4e1d1efa02ada53ac161f5ce98e9b6ec267eb73bbe3fee94ab494c407332d5551fc7ecf3746983b95576de3ca31c80b476d2681abf2e483295550e30ebe1cec9ecfc8fc912c1b9038b1df13d6a8c256f181ee78df3e23fb603b83a4460512048305baaff2eec586ac4da62a7772101d198caa457af3bff21e2e8c41b5cedbf9c4785e46200f9db56bcfcaa9cfd507030ead453b524730650fc038617cd4a4c1c0890ea7a4359dcd08c874a8f336cdf767878903fcc1984ab2fd11fdaf13e7cb537eeae6be61c0e17489fc88d4c56190ef005f5fc6feda200f390df0c1659f31eae74b14fed63258a6da070070ed8cdee64cf9b3f57280399c37dba7304d171d4620e6df30d3af9783cb79a5e7c00dcac396a156a27b7562048cb4bc8acb3c0aaa9cc48f86feae4013b8546e94021f7c1bf866f6a36e47ef5df91aed2e1f4386834d05172e8e38ca46b1d54d1a62f502559e9158d95df5cccdd8015abce743a606ff67876c14598e39720efdd3bb1c4efe38f1fdce306a0ecf1daea403298a7b57b8d4945dad94cb7ef250c3f3443e11da506af45e2fe37a9068aa69954fe08dc32bf43a162070b975d221672ee179594fc01edd965b5785b57c8d9a598e0fada8a3f9c6bbb77eb4f183f0d17e46ea0ee9f2d896f2b09776ec89668673402cb8b91c6a1e8f38ca8b1b7b3342139263140660c0c5df171b383e2ffd9f4cd601a4b20df8b0732376fd920955c08224f948289e39f690c5d8cc07eaa0d2905804b5df64d55f70cfb4c34c9514d00c26798d15c0cf60cec78e3e1a4b8259d669c6175f7decd687f573e83507d0c067781721198d305eef2621355572ca48635b22b8a6625bd049c02f119a2e9f7ec793d3291631140c144b22a7e8c6b1b5f369052300e6e7cd20eacf7213687c352bcd403f60f065e0a855a50343233db8f200e9880e371df761a2b18ac31d30141495eb92f04ba9945feb07a7c6a5a2f86c76eba513f6fc7632eeb70fa1da5b472e94b9408d6df43f6770eb6101f83828d5ec90c55dec7da9ecc167c8bfc3e31139db7f023509e766c333cb43dfeb7d13597be72e0ec49956bc0034bd1045364149c88f29a6b40d007002af1c64167b62c0eba69076cac5cae169185fabf0b133d19d62f6eeb75f607458ec506e21105735fa4be84dba1294b6d4358f5942080ab9ddef516bbbcb7eb05ecf1360e3e5574855ec66d518d7da56b3179acef8564301174e12178aebad8f3c56f7f170cfae956eca0208344cf2455c38091e10ce77bea0027cc27f4a3ce741726ae60cc2f0fe5c0d117981c7e01e8710fd8584288c5313c9c0b90a58b00fbaaa8cfa9f72dec6e8222134120214c2a4c63fb51628a7c2c64e53c91b9fa9abb9747384205d0b2c6dd14fa29a44541792fa89799afa9605bac876c801bdb142f2e7e42d03eccadc48cce6f63b4cd49e81779439b81cf54f191cad783464f83282928c4a07208fb9eb2903e871c5da06d174bc297aff5341301222618e7d54c6b499ae589c9a7e8add6fcaf0c957a57897a2398f26d6336003d728891ca1dc1c4c82f04eede3d178fbb66f3d8db66a5ed46250e4548999e909212ea692ba1ddb78ac482d2d6072d71af4bc89f452985ed0ced7f7436ed5d4dcc14cf352cd1e5b4f6acd7e85f40529b49a91d778d87e976fbfeffda2c9eb28fa27a9cf74b943d4365b90584ade680fcfb9dd27b95a7a7e2b62158ab6ee11fcf92c0eefab60b1b72f7afd7878c3c7261b780996d504579e18392d17f6a3600d33e623ba344439eace1c521187b65f52a240b1895d969a8b480267e17ad263e4b529fd489e79c67ec675ea1eb0baf62ebc929e369647e22b52462a08126ac08390de0583a37bd318ff90d412ebc1d207bb3ec42f35c06f531a05cf2690baf930ee5fd438ae7c9ccdda352264f6afa81af78d71cbb937e7223813c551d30d969331ecea9ccaf12d4f88fb19056435ffea926e272c5813b6ade739088db845129c4596b4a1ffe10fdfb96832f40883a816eaa7dcaa717e298179a942f1723e5dd20fa680d9e0ececd68db38f12b0cd0f969ddd789e9807188c5549f743c06bc355bf82bc3ba8dd3fec4144b005404beb06ba73b009fd1547816d06411ab8ddc3578c821a4018286d6fa939e1e13ed74c955f0178087aaa8a12da5b049244353294988ccf13e41d8aaedd142aaf73f79cb427af4ed20237ed1d3512a2ec15d55e411e406b6cfff087c8b1cf1e3856e4468601912cac35988002bca3c525f987db8fa63b2a7bb693f7771c43a02e31284f768768328c1ddc63ac94bfea202878e5a90525434e163ab9b2b7512c3a8a8460c41906c4aa6f6475fb8c4ea25821e3b0c195171a53491aaa37ccc719bbb026e0a29b3f933c54c8942439674329512118169d7b3f8593135f37e06202be8cde1d1cf313cb32ed76ba6f3662d40e5c85cf28361f93a6a5d35a4a108dd8bbbf662c0fa52a04e3e856008072d3bf02fbb499c3fc654ae909e4a6943c47ede02c1314b0ec563f7abc0bea655023445b8848f8172b39887974108c531beadab689f6cd88253a8dceb77f8f07eb19a7302b9247822cc2367e7b6ec10154905d67445882cec729c727482439da2d8a06f40f887271cc72bd4ed1cffea6a95393bd81c7a9ebbec59f7f4eba0b2b8114cf30b76ef670f5327448a1366887522674e6b66049f73f5585605704b5382a356e72577878ec918d8441f2acc93ffb68d777e80af7a1ede0d2bbcc6f7c0aa00581d6d6672f5c6397df2198b89fd71df2459cedd0fa8c3b6e155f38b9f2975cedf8cc2854c840a0da19f57eab5cd359d3072b40e560822824cfce1ec72c23c4f08bdbff545f50fe719d337760eddf1e039991af09e9f571277800dd19131cbc939d8ef23ad72374f47d63cce99983e030b5b6af95673aa11eeba07213ec2ba621efc77a92e8d0e8e846cb0dcfaa590dbba9eea72a441ce00465d5d543625d7ca0d0442027e3af33700a176f062dc02a6c8c3d4ecb8feb51c863cf081a04959cf2282c58485d4f7b3d24057b5fd32c235ea98911fdeccd0f25f34e9d9669e0c7412da3661dcbf385e786713cac9809fe7a805230c9943f95</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">2025.10.5-NOIP 比赛总结</summary>
    
    
    
    <category term="solutions" scheme="https://xglight.github.io/categories/solutions/"/>
    
    
    <category term="math" scheme="https://xglight.github.io/tags/math/"/>
    
    <category term="school" scheme="https://xglight.github.io/tags/school/"/>
    
    <category term="dp" scheme="https://xglight.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>提供给 Duel 的 Rating 计算方案</title>
    <link href="https://xglight.github.io/posts/486bb1c0/"/>
    <id>https://xglight.github.io/posts/486bb1c0/</id>
    <published>2025-10-06T04:00:00.000Z</published>
    <updated>2025-10-29T14:35:50.078Z</updated>
    
    <content type="html"><![CDATA[<p>本方案基于加权 Elo 模型，并结合团队表现系数，客观反映选手实力。</p><h2>比赛模型转换</h2><p>难度权重设为：</p><p><span class="math display">\[W_t=\frac{D_t}{100}\quad(D_t\in\{100,200,\dots,1000\})\]</span></p><h2>队伍评级与期望胜率</h2><ol type="1"><li>队伍平均评级 记 R 为选手的评级。 <span class="math display">\[R_A = \frac{1}{n}\sum_{i=1}^n R_{A,i},\quadR_B = \frac{1}{m}\sum_{j=1}^m R_{B,j}\]</span><br />其中 <span class="math inline">\(n,m\)</span> 分别为 A、B 队参赛人数。</li><li>期望胜率 <span class="math display">\[E_A = \frac{1}{1 + 10^{(R_B - R_A)/400}},\quadE_B = 1 - E_A\]</span><br />若 A 队首解题目得 <span class="math inline">\(r_t=1\)</span>，B 队则得 <span class="math inline">\(r_t=0\)</span>；都未解或同时解则 <span class="math inline">\(r_t=0.5\)</span> 。</li></ol><h2>表现系数 <span class="math inline">\(f(P)\)</span></h2><ol type="1"><li>表现指标 <span class="math display">\[P_A = \frac{\text{A队实际得分}}{\text{理论最高分 }(100+200+\dots+1000)},\quadP_B = \frac{\text{B队实际得分}}{\text{理论最高分}}\]</span></li><li>映射函数 <span class="math display">\[f(P) = \alpha + (1-\alpha)\,P,\quad \alpha = 0.5\]</span><br /><span class="math inline">\(\alpha\)</span> 为保底系数，此处为 <span class="math inline">\(0.5\)</span>。</li></ol><h2>个人 Rating 更新公式</h2><p>对于第 <span class="math inline">\(t\)</span> 道题，第 <span class="math inline">\(i\)</span> 位选手的增量为 <span class="math display">\[\Delta R_{i,t} = f(P_{\text{其队}})\;\times\;K \times W_t \times (r_t - E_A)\]</span></p><ul><li><span class="math inline">\(K\)</span>：基础调整系数，此处为 <span class="math inline">\(K=32\)</span>。</li><li><span class="math inline">\(W_t\)</span>：题目难度权重</li><li><span class="math inline">\(r_t - E_A\)</span>：胜负偏差（胜为正、负为负）</li><li><span class="math inline">\(f(P)\)</span>：表现系数。</li></ul>]]></content>
    
    
    <summary type="html">本方案基于加权 Elo 模型，并结合团队表现系数，客观反映选手实力。</summary>
    
    
    
    <category term="other" scheme="https://xglight.github.io/categories/other/"/>
    
    
    <category term="other" scheme="https://xglight.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>2025.10.5-A</title>
    <link href="https://xglight.github.io/posts/ca18e94/"/>
    <id>https://xglight.github.io/posts/ca18e94/</id>
    <published>2025-10-05T13:00:00.000Z</published>
    <updated>2025-10-29T14:35:50.077Z</updated>
    
    <content type="html"><![CDATA[<h2>T1 misspelling</h2><p><a href="https://www.luogu.com.cn/problem/P9522">[JOISC 2022] 错误拼写</a></p><p>先刻画题目，<span class="math inline">\(T_u \le T_v,u&lt;v\)</span> 相当于 <span class="math inline">\(S_{[u,v]}\)</span> 全部相等或 <span class="math inline">\(\forall k\in [i,p),S_i = S_k \text{且} S_i &gt; S_p\)</span>。</p><p><span class="math inline">\(u&gt;v\)</span> 同理。</p><p>这样我们就从后向前转移 DP <span class="math inline">\(f_{i,j}\)</span>，表示已经处理完 <span class="math inline">\([i+1,n]\)</span>，其中 <span class="math inline">\(s_i = j\)</span> 的方案数。</p><p>假设枚举一个 <span class="math inline">\(i&#39; &gt; i\)</span> 进行转移，表示 <span class="math inline">\([i,i&#39;-1]\)</span> 全部相等，<span class="math inline">\(s_i&#39; \neq s_i\)</span>，如果存在 <span class="math inline">\(i \le u &lt; i&#39; \le v\)</span>：</p><ul><li>当 <span class="math inline">\(T_u \le T_v\)</span> 时，<span class="math inline">\(\forall i&#39; \in (u,v]\)</span>，一定要有 <span class="math inline">\(j &gt; j&#39;\)</span></li><li>当 <span class="math inline">\(T_u &gt; T_v\)</span> 时，类似</li></ul><p>也就是说，假设固定 <span class="math inline">\(i&#39;\)</span>，在 <span class="math inline">\(i\)</span> 不断前移中，必然有一个位置让 <span class="math inline">\(i&#39;\)</span> 不能产生 <span class="math inline">\(j &gt; j&#39;\)</span> 的贡献，也必然有一个位置让 <span class="math inline">\(i&#39;\)</span> 不能产生 <span class="math inline">\(j &lt; j&#39;\)</span> 的贡献。</p><p>设 <span class="math inline">\(g_j\)</span> 表示 <span class="math inline">\(f_{i+1} \sim f_n\)</span> 的 <span class="math inline">\(j\)</span> 的贡献。</p><p>现在枚举到 <span class="math inline">\(i\)</span>，只考虑和 <span class="math inline">\(i\)</span> 有关的贡献（<span class="math inline">\(i=u&lt;v\)</span>）：</p><ul><li>若有 <span class="math inline">\(T_u \le T_v\)</span>，<span class="math inline">\(\forall i&#39; \in (u,v]\)</span>，且仍产生 <span class="math inline">\(j &lt; j&#39;\)</span>，删去该贡献，即 <span class="math inline">\(h_j\)</span> 减去 <span class="math inline">\(\sum_{j &lt; j&#39;} f_{i&#39;,j&#39;}\)</span>。</li><li>若有 <span class="math inline">\(T_v \le T_u\)</span>，同理。</li></ul><p>更新完后更新 <span class="math inline">\(f_{i,j} = h_j + 1\)</span>，<span class="math inline">\(1\)</span> 表示全部相同的情况。</p><p>再更新 <span class="math inline">\(f_i\)</span> 对 <span class="math inline">\(h\)</span> 的贡献，即 <span class="math inline">\(h_j\)</span> 加上 <span class="math inline">\(\sum_{j \neq j&#39;} f_{i,j&#39;}\)</span>。</p><p>可以用链表维护仍然存在的贡献。</p><h2>T2 ski 2</h2><p><a href="https://www.luogu.com.cn/problem/P10432">[JOIST 2024] 滑雪 2 / Ski 2</a></p><p>性质观察题，DP 解决。</p><p><strong>结论一：</strong> 贪心的思考，一定是选高度最低的点建造酒店，如果1高度相同，就选建造设施最便宜的点，</p><p><strong>结论二：</strong> 如果要提升发高度，最多只会提升至另一个点高度 <span class="math inline">\(+1\)</span>。</p><p><strong>结论三：</strong> 如果一个点建造了连接设施，那它就一定不会升高。</p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>若现在有 <span class="math inline">\(H_x &lt; H_y\)</span>，现在将 <span class="math inline">\(x\)</span> 提升到 <span class="math inline">\(H_y+1\)</span>，并且向 <span class="math inline">\(y\)</span> 连边。</p><p>若 <span class="math inline">\(C_y \le C_x\)</span>，则 <span class="math inline">\(x\)</span> 连向 <span class="math inline">\(y\)</span> 一定优，还可以将本来连向 <span class="math inline">\(x\)</span> 的点改连向 <span class="math inline">\(y\)</span>。</p><p>若 <span class="math inline">\(C_y &gt; C_x\)</span>，就可以放弃提升，将 <span class="math inline">\(y\)</span> 连向 <span class="math inline">\(x\)</span>，将本来连向 <span class="math inline">\(x\)</span> 的点改连向 <span class="math inline">\(y\)</span>，也一定更优。</p></div></details><p>所以，考虑 <span class="math inline">\(f_{i,j,k}\)</span>，表示当前在高度 <span class="math inline">\(i\)</span>，该高度上一共有 <span class="math inline">\(j\)</span> 个可用的接口，有 <span class="math inline">\(k\)</span> 个节点现在高度为 <span class="math inline">\(i\)</span>，且准备抬升到 <span class="math inline">\(i+1\)</span>。</p><ol type="1"><li>可以新建一个链接设施，<span class="math inline">\(f_{i,j+1,k} = f_{i,j,k} + minc_i\)</span>，其中 <span class="math inline">\(minc_i\)</span> 指在高度 <span class="math inline">\(i\)</span> 新建接口的最小花费。</li><li>可以向 <span class="math inline">\(i+1\)</span> 转移，设高度 <span class="math inline">\(i\)</span> 原本有 <span class="math inline">\(cnt_i\)</span> 个节点，<span class="math inline">\(f_{i+1,j,max\{0,k+cnt_{i+1} - j\}} = f_{i,j,k} + K\cdot k \cdot (H_{i+1} - H_{i})\)</span>。因为 <strong>结论三</strong>，所以新的 <span class="math inline">\(k\)</span> 有 <span class="math inline">\(j\)</span> 个节点一定不会再升高。</li></ol><p>我们发现这样时间复杂度是 <span class="math inline">\(O(n^2\max H)\)</span>。</p><p>考虑将 <span class="math inline">\(H\)</span> 离散化，注意不止要加入 <span class="math inline">\(H_i\)</span>，还有所有可能经过升高到达的高度。</p><p>时间复杂度 <span class="math inline">\(O(n^3)\)</span>。</p>]]></content>
    
    
    <summary type="html">2025.10.5-A 比赛总结</summary>
    
    
    
    <category term="solutions" scheme="https://xglight.github.io/categories/solutions/"/>
    
    
    <category term="dp" scheme="https://xglight.github.io/tags/dp/"/>
    
  </entry>
  
</feed>
