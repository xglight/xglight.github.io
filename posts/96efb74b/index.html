<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>On the mathematics behind rolling hashes and anti-hash tests | 星光light</title><meta name="author" content="星光light"><meta name="copyright" content="星光light"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="搬运"><meta property="og:type" content="article"><meta property="og:title" content="On the mathematics behind rolling hashes and anti-hash tests"><meta property="og:url" content="https://xglight.github.io/posts/96efb74b/index.html"><meta property="og:site_name" content="星光light"><meta property="og:description" content="搬运"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://t.alcy.cc/fj?postid=7"><meta property="article:published_time" content="2024-08-19T01:54:00.000Z"><meta property="article:modified_time" content="2026-02-28T08:11:33.346Z"><meta property="article:author" content="星光light"><meta property="article:tag" content="hash"><meta property="article:tag" content="math"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://t.alcy.cc/fj?postid=7"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "On the mathematics behind rolling hashes and anti-hash tests",
  "url": "https://xglight.github.io/posts/96efb74b/",
  "image": "https://t.alcy.cc/fj?postid=7",
  "datePublished": "2024-08-19T01:54:00.000Z",
  "dateModified": "2026-02-28T08:11:33.346Z",
  "author": [
    {
      "@type": "Person",
      "name": "星光light",
      "url": "https://github.com/xglight"
    }
  ]
}</script><link rel="shortcut icon" href="/img/home.png"><link rel="canonical" href="https://xglight.github.io/posts/96efb74b/index.html"><link rel="preconnect" href="https://cdn.bootcdn.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/7.0.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/node-snackbar/0.1.16/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/6.0.29/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=t,btf.activateLightMode=o;const a=e.get("theme");"dark"===a?t():"light"===a&&o();const n=e.get("aside-status");void 0!==n&&document.documentElement.classList.toggle("hide-aside","hide"===n);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,pagination:{enable:!1,hitsPerPage:8},languages:{hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"已切换为繁体中文",cht_to_chs:"已切换为简体中文",day_to_night:"已切换为深色模式",night_to_day:"已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},infinitegrid:{js:"https://cdn.bootcdn.net/ajax/libs/egjs-infinitegrid/4.12.0/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"On the mathematics behind rolling hashes and anti-hash tests",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><link rel="stylesheet" href="css/loading.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/rss.xml" title="星光light" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{const e=document.getElementById("loading-box"),d=document.body,o=()=>{e.classList.contains("loaded")||(d.style.overflow="",e.classList.add("loaded"))},t=()=>{d.style.overflow="hidden",e.classList.remove("loaded")};t(),"complete"===document.readyState?o():(window.addEventListener("load",o),document.addEventListener("DOMContentLoaded",o),setTimeout(o,7e3)),btf.addGlobalFn("pjaxSend",t,"preloader_init"),btf.addGlobalFn("pjaxComplete",o,"preloader_end")})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/skirk-head.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:toRandomPost()"><i class="fa-fw fas fa-bus"></i> <span>随机文章</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友联</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://t.alcy.cc/fj?postid=7)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/home.png" alt="Logo"><span class="site-name">星光light</span></a><a class="nav-page-title" href="/"><span class="site-name">On the mathematics behind rolling hashes and anti-hash tests</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i> <span>返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:toRandomPost()"><i class="fa-fw fas fa-bus"></i> <span>随机文章</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友联</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">On the mathematics behind rolling hashes and anti-hash tests</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-19T01:54:00.000Z" title="发表于 2024-08-19 09:54:00">2024-08-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-28T08:11:33.346Z" title="更新于 2026-02-28 16:11:33">2026-02-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/algorithm/">algorithm</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2026-02-28 16:11:33&quot;}" hidden></div><p>This blog assumes the reader is familiar with the basic concept of rolling hashes. There are some math-heavy parts, but one can get most of the ideas without understanding every detail.</p><p>The main focus of this blog is on how to choose the rolling-hash parameters to avoid getting hacked and on how to hack codes with poorly chosen parameters.</p><h2>Designing hard-to-hack rolling hashes</h2><h3>Recap on rolling hashes and collisions</h3><p>Recall that a rolling hash has two parameters <span class="math inline">\((p,a)\)</span> where <span class="math inline">\(p\)</span> is the modulo and <span class="math inline">\(0\le a &lt; p\)</span> the base. (We’ll see that <span class="math inline">\(p\)</span> should be a big prime and <span class="math inline">\(a\)</span> larger than the size of alphabet.) The hash value of a string <span class="math inline">\(S = s_0 \cdots s_{n-1}\)</span> is given by:</p><p><span class="math display">\[ h(S) = (\sum^{n-1}_{i=0} a^{n-i-1} s_i) \mod P \]</span></p><p>For now, lets consider the simple problem of: given two strings <span class="math inline">\(S,T\)</span> of equal length, decide whether they’re equal by comparing their hash values <span class="math inline">\(h(S), h(T)\)</span>. Our algorithm declares <span class="math inline">\(S\)</span> and <span class="math inline">\(T\)</span> to be equal if <span class="math inline">\(h(S) = h(T)\)</span>. Most rolling hash solutions are built on multiple calls to this subproblem or rely on the correctness of such calls.</p><p>Let’s call two strings <span class="math inline">\(S, T\)</span> of equal length with <span class="math inline">\(S \neq T\)</span> and <span class="math inline">\(h(S) = h(T)\)</span> an equal-length collision. We want to avoid equal-length collisions, as they cause our algorithm to incorrectly assesses <span class="math inline">\(S\)</span> and <span class="math inline">\(T\)</span> as equal. (Note that our algorithms never incorrectly assesses strings a different.) For fixed parameters and reasonably small length, there are many more strings than possible hash values, so there always are equal-length collisions. Hence you might think that, for any rolling hash, there are inputs for which it is guaranteed to fail.</p><p>Luckily, randomization comes to the rescue. Our algorithm does not have to fix <span class="math inline">\((p, a)\)</span>, it can randomly pick then according to some scheme instead. <span class="math inline">\(A\)</span> scheme is reliable if we can prove that for arbitrary two string <span class="math inline">\(S, T\)</span>, <span class="math inline">\(S\neq T\)</span> the scheme picks <span class="math inline">\((p, a)\)</span> such that <span class="math inline">\(h(S) \neq h(T)\)</span> with high probability. Note that the probability space only includes the random choices done inside the scheme; the input <span class="math inline">\((S, T)\)</span> is arbitrary, fixed and not necessarily random. (If you think of the input coming from a hack, then this means that no matter what the input is, our solution will not fail with high probability.)</p><p>I’ll show you two reliable schemes. (Note that just because a scheme is reliable does not mean that your implementation is good. Some care has to be taken with the random number generator that is used.)</p><h3>Randomizing base</h3><blockquote><p>This part is based on a <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9ybmctNTguYmxvZ3Nwb3QuY29tLzIwMTcvMDIvaGFzaGluZy1hbmQtcHJvYmFiaWxpdHktb2YtY29sbGlzaW9uLmh0bWw">blog</a> by <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9maWxlL3JuZ181OA"><font color="red">rng_58</font></a>. His post covers a more general hashing problem and is worth checking out.</p></blockquote><p>This scheme uses <span class="math inline">\(a\)</span> fixed <strong>prime</strong> <span class="math inline">\(p\)</span> (i.e. <span class="math inline">\(10^9 + 7\)</span> or <span class="math inline">\(4\cdot 10^9 + 7\)</span>) and picks <span class="math inline">\(a\)</span> uniformly at random from <span class="math inline">\([0,p-1]\)</span>. Let <span class="math inline">\(A\)</span> be a random variable for the choice of <span class="math inline">\(a\)</span>.</p><p>To prove that this scheme is good, consider two strings <span class="math inline">\((S, T)\)</span> of equal length and do some calculations：</p><p><span class="math display">\[ \begin{aligned} h(S)&amp;=h(T)\\ (\sum_{i=0}^{n-1} A^{n-i-1} S_i) \mod p &amp; = (\sum_{i=0}^{n-1} A^{n-i-1} T_i) \mod p \end{aligned} \]</span></p><p>Therefore,we have:</p><p><span class="math display">\[ \sum_{i=0}^{n-1} A^{n-i-1} S_i \equiv \sum_{i=0}^{n-1} A^{n-i-1} T_i \pmod p\\ \]</span></p><p>Let us let <span class="math inline">\(P(A)\)</span> denote a polynomial in <span class="math inline">\(A\)</span> of degree <span class="math inline">\(\le n-1\)</span>:</p><p><span class="math display">\[ P(A) = \sum_{i=0}^{n-1} A^{n-i-1}(S_i-T_i) \equiv 0 \pmod p \]</span></p><p><span class="math inline">\(P\)</span> is non-zero as <span class="math inline">\(S \neq T\)</span>. The calculations show that <span class="math inline">\(h(S) = h(T)\)</span> if and only if <span class="math inline">\(A\)</span> is a root of <span class="math inline">\(P(A)\)</span>.</p><p>As <span class="math inline">\(p\)</span> is prime and we are doing computations <span class="math inline">\(\mod p\)</span>, we are working in a field. Over a field, any polynomial of degree <span class="math inline">\(\le n - 1\)</span> has at most <span class="math inline">\(n-1\)</span> roots. Hence there are at most <span class="math inline">\(n - 1\)</span> choices of a that lead to <span class="math inline">\(h(S) = h(T)\)</span>. Therefore：</p><p><span class="math display">\[ Pr[h(S)=h(T)]=Pr[P(A)=0] \le \frac{n-1} {p} \]</span></p><p>So for any two strings <span class="math inline">\((S, T)\)</span> of equal length, the probability that they form an equal-length collision is at most . This is around <span class="math inline">\(10^{-4}\)</span> for <span class="math inline">\(n = 10^5, p = 10^9 + 7\)</span>. Picking larger primes such as <span class="math inline">\(2^{31} - 1\)</span> or <span class="math inline">\(4\cdot 10^9 + 7\)</span> can improve this a bit, but one needs more care with overflows.</p><h3>Tightness of bound</h3><p>For now, this part only applies to primes with smooth <span class="math inline">\(p - 1\)</span>, so it doesn’t work for <span class="math inline">\(p = 10^9 + 7\)</span> for example. It would be interesting to find a construction that is computable and works in the general case.</p><p>The bound <span class="math inline">\(\frac{p-1} {p}\)</span> for this scheme is actually tight if <span class="math inline">\(n-1|p-1\)</span>. Consider <span class="math inline">\(S=ba...a\)</span> and <span class="math inline">\(T=aa...b\)</span> with <span class="math inline">\(P(A)=A^{n-1}-1\)</span>.</p><p>As <span class="math inline">\(p\)</span> is prime,<span class="math inline">\(\frac{\mathbb{Z} } {p\mathbb{Z} }\)</span> is cyclic of order <span class="math inline">\(p - 1\)</span>, hence there is a subgroup <span class="math inline">\(G \subseteq \frac{\mathbb{Z} } {p\mathbb{Z} }\)</span> of order <span class="math inline">\(n - 1\)</span>. Any <span class="math inline">\(g\subseteq G\)</span> then satisfies <span class="math inline">\(g^{n - 1} = 1\)</span>, so <span class="math inline">\(P(A)\)</span> has <span class="math inline">\(n - 1\)</span> distinct roots.</p><h3>Randomizing modulo</h3><p>This scheme fixes a base <span class="math inline">\(a \le |\sum|\)</span> and a bound <span class="math inline">\(N &gt; a\)</span> and picks a <strong>prime</strong> p uniformly at random from <span class="math inline">\([N, 2N - 1]\)</span>.</p><p>To prove that this scheme is good, again, consider two strings <span class="math inline">\((S, T)\)</span> of equal length and do some calculations:</p><p><span class="math display">\[ \begin{aligned} h(S)&amp;=h(T)\\ (\sum_{i=0}^{n-1} a^{n-i-1} S_i) \mod p &amp; = (\sum_{i=0}^{n-1} a^{n-i-1} T_i) \mod p \end{aligned} \]</span></p><p>Therefore,we have:</p><p><span class="math display">\[ \sum_{i=0}^{n-1} a^{n-i-1} S_i \equiv \sum_{i=0}^{n-1} a^{n-i-1} T_i \pmod p\\ \]</span></p><p>So:</p><p><span class="math display">\[ X = \sum_{i=0}^{n-1}a^{n-i-1}(S_i-T_i) \equiv 0 \pmod p \]</span></p><p>As <span class="math inline">\(X \equiv 0 \pmod p,p|X\)</span>.As we chose a large enough, <span class="math inline">\(X \neq 0\)</span>. Moreover <span class="math inline">\(|X| &lt; a^n\)</span>. An upper bound for the number of distinct prime divisors of <span class="math inline">\(X\)</span> in <span class="math inline">\([N, 2N - 1]\)</span> is given by <span class="math inline">\(\log_N (|X|) = \frac{n\ln (a)} {\ln N}\)</span>. By the prime density theorem, there are around <span class="math inline">\(\frac{X} {\ln{N} }\)</span> primes in <span class="math inline">\([N, 2N - 1]\)</span>. Therefore:</p><p><span class="math display">\[ Pr[h(S)=h(T)] = Pr[p|X] \le \sim \frac{n\ln(a)} {N} \]</span></p><p>Note that this bound is slightly worse than the one for randomizing the base. It is around <span class="math inline">\(3\cdot 10{-4}\)</span> for <span class="math inline">\(n = 10^5, a = 26, N = 10^9\)</span>.</p><h3>How to randomize properly</h3><p>The following are good ways of initializing your random number generator.</p><ul><li><p>high precision time.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrono::<span class="built_in">duration_cast</span>&lt;chrono::nanoseconds&gt;(chrono::high_resolution_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">chrono::<span class="built_in">duration_cast</span>&lt;chrono::nanoseconds&gt;(chrono::steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Either of the two should be fine. (In theory, <code>high_resolution_clock</code> should be better, but it somehow has lower precision than <code>steady_clock</code> on codeforces??)</p></blockquote></li><li><p>processor cycle counter</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_ia32_rdtsc();</span><br></pre></td></tr></tbody></table></figure></li><li><p>some heap address converted to an integer</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">uintptr_t</span>) <span class="built_in">make_unique</span>&lt;<span class="type">char</span>&gt;().<span class="built_in">get</span>();</span><br></pre></td></tr></tbody></table></figure></li><li><p>processor randomness (needs either pragma or asm) (Thanks <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9maWxlL2hhbHlhdmlu"><font color="red">halyavin</font></a> for <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9ibG9nL2VudHJ5LzYwNDQyPyNjb21tZW50LTQ0MzA4Mw">suggesting</a> this.)</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pragma version</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC target (<span class="string">"rdrnd"</span>)</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">rdrand32</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">uint32_t</span> ret;</span><br><span class="line">    <span class="built_in">assert</span>(__builtin_ia32_rdrand32_step (&amp;ret));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// asm version</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">rd</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="type">uint32_t</span> ret;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"rdrand %0"</span> :<span class="string">"=a"</span>(ret) ::<span class="string">"cc"</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>If you use a C++11-style rng (you should), you can use a combination of the above:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seed_seq seq{</span><br><span class="line">    (<span class="type">uint64_t</span>) chrono::<span class="built_in">duration_cast</span>&lt;chrono::nanoseconds&gt;(chrono::high_resolution_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>(),</span><br><span class="line">    (<span class="type">uint64_t</span>) __builtin_ia32_rdtsc(),</span><br><span class="line">    (<span class="type">uint64_t</span>) (<span class="type">uintptr_t</span>) <span class="built_in">make_unique</span>&lt;<span class="type">char</span>&gt;().<span class="built_in">get</span>()</span><br><span class="line">};</span><br><span class="line"><span class="function">mt19937 <span class="title">rng</span><span class="params">(seq)</span></span>;</span><br><span class="line"><span class="type">int</span> base = <span class="built_in">uniform_int_distribution</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, p<span class="number">-1</span>)(rng);</span><br></pre></td></tr></tbody></table></figure><p>Note that this does internally discard the upper 32 bits from the arguments and that this doesn’t really matter, as the lower bits are harder to predict (especially in the first case with chrono.).</p><p><strong>See the section on ‘Abusing bad randomization’ for some bad examples.</strong></p><h3>Extension to multiple hashes</h3><p>We can use multiple hashes (Even with the same scheme and same fixed parameters) and the hashes are independent so long as the random samples are independent. If the single hashes each fail with probability at most <span class="math inline">\(a_1,\cdots, a_k\)</span>, the probability that all hashes fail is at most <span class="math inline">\(\prod_{i=1}^k a_i\)</span>.</p><p>For example, if we use two hashes with <span class="math inline">\(p = 10^9 + 7\)</span> and randomized base, the probability of a collision is at most <span class="math inline">\(10^{ - 8}\)</span>; for four hashes it is at most <span class="math inline">\(10 ^{- 16}\)</span>. Here the constants from slightly larger primes are more significant, for <span class="math inline">\(p = 2^{31} - 1\)</span> the probabilities are around <span class="math inline">\(2.1\cdot 10^{ - 9}\)</span> and <span class="math inline">\(4.7\cdot 10^{ - 18}\)</span>.</p><h3>Larger modulo</h3><p>Using larger (i.e. 60 bit) primes would make collision less likely and not suffer from the accumulated factors of <span class="math inline">\(n\)</span> in the error bounds. However, the computation of the rolling hash gets slower and more difficult, as there is no <code>__int128</code> on codeforces.</p><p>One exception to this is the Mersenne prime <span class="math inline">\(p = 2^{61} - 1\)</span>; we can reduce <span class="math inline">\(\mod p\)</span> by using bitshifts instead. (Thanks <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9maWxlL2Rta3o"><font color="blue">dmkz</font></a> for suggesting this.) The following code computes <span class="math inline">\(a\cdot b \mod p\)</span> without <code>__int128</code> and is only around <span class="math inline">\(5\%\)</span> slower than a <span class="math inline">\(30\)</span> bit hash with modulo.</p><p>For the argument, the condition <span class="math inline">\(0\le a,b &lt; mod\)</span> should hold.The return value then also satisfies this.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">uint64_t</span> mod = (<span class="number">1ull</span>&lt;&lt;<span class="number">61</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">modmul</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span></span>{</span><br><span class="line">    <span class="type">uint64_t</span> l1 = (<span class="type">uint32_t</span>)a, h1 = a&gt;&gt;<span class="number">32</span>, l2 = (<span class="type">uint32_t</span>)b, h2 = b&gt;&gt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">uint64_t</span> l = l1*l2, m = l1*h2 + l2*h1, h = h1*h2;</span><br><span class="line">    <span class="type">uint64_t</span> ret = (l&amp;mod) + (l&gt;&gt;<span class="number">61</span>) + (h &lt;&lt; <span class="number">3</span>) + (m &gt;&gt; <span class="number">29</span>) + (m &lt;&lt; <span class="number">35</span> &gt;&gt; <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    ret = (ret &amp; mod) + (ret&gt;&gt;<span class="number">61</span>);</span><br><span class="line">    ret = (ret &amp; mod) + (ret&gt;&gt;<span class="number">61</span>);</span><br><span class="line">    <span class="keyword">return</span> ret<span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>A smaller factor can be gained by using unsigned types and <span class="math inline">\(p=4\cdot 10^9 + 7\)</span>.</p><p>Note that <span class="math inline">\(p=2^{64}\)</span>(overflow of unsigned long long) is not prime and can be hacked regardless of randomization (see below).</p><h3>Extension to multiple comparisons</h3><p>Usually, rolling hashes are used in more than a single comparison. If we rely on m comparison and the probability that a single comparison fails is <span class="math inline">\(p\)</span> then the probability that any of the fail is at most <span class="math inline">\(m\cdot p\)</span> by a union bound. Note that when <span class="math inline">\(m = 10^5\)</span>, we need at least two or three hashes for this to be small.</p><p>One has to be quite careful when estimating the number comparison we need to succeed. If we sort the hashes or put them into a set, we need to have pair-wise distinct hashes, so for <span class="math inline">\(n\)</span> string a total of <span class="math inline">\(\binom{n} {2}\)</span> comparisons have to succeed. If <span class="math inline">\(n = 3\cdot 10^5\)</span>, <span class="math inline">\(m 4.5\cdot 10^9\)</span>, so we need three or four hashes (or only two if we use <span class="math inline">\(p = 2^{61} - 1\)</span>).</p><h3>Extension to strings of different length</h3><p>If we deal with strings of different length, we can avoid comparing them by storing the length along the hash. This is not necessarily however, if we assume that <strong>no character hashes to</strong> <span class="math inline">\(0\)</span>. In that case, we can simple imagine we prepend the shorter strings with null-bytes to get strings of equal length without changing the hash values. Then the theory above applies just fine. (If some character (i.e. <code>a</code>) hashes to <span class="math inline">\(0\)</span>, we might produce strings that look the same but aren’t the same in the prepending process (i.e. <code>a</code> and <code>aa</code>).)</p><h2>Computing anti-hash tests</h2><p>This section cover some technique that take advantage of common mistakes in rolling hash implementations and can mainly be used for hacking other solutions. Here’s a table with a short summary of the methods.</p><table><thead><tr class="header"><th style="text-align:center"><strong>Name</strong></th><th style="text-align:center"><strong>Use case</strong></th><th style="text-align:center"><strong>Run time</strong></th><th style="text-align:center"><strong>String lenth</strong></th><th style="text-align:center"><strong>Notes</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align:center">Thue-Morse</td><td style="text-align:center">Hash with overflow</td><td style="text-align:center"><span class="math inline">\(O(1)\)</span></td><td style="text-align:center"><span class="math inline">\(2^{10}\)</span></td><td style="text-align:center">Works for all bases simultaneously.</td></tr><tr class="even"><td style="text-align:center">Birthday</td><td style="text-align:center">Small modulo</td><td style="text-align:center"><span class="math inline">\(O(\sqrt{p}\log p)\)</span></td><td style="text-align:center"><span class="math inline">\(\approx2\log_{|\sum|}p\)</span></td><td style="text-align:center">Can find multiple collisions.</td></tr><tr class="odd"><td style="text-align:center">Tree</td><td style="text-align:center">Large modulo</td><td style="text-align:center"><span class="math inline">\(O(2^{\sqrt{p\lg p}})\)</span></td><td style="text-align:center"><span class="math inline">\(O(2^{\sqrt{p\lg p}}+1)\)</span></td><td style="text-align:center">faster; longer strings</td></tr><tr class="even"><td style="text-align:center">Multi-tree</td><td style="text-align:center">Large modulo</td><td style="text-align:center"><span class="math inline">\(O((2^{\sqrt{2\lg m p} }+\log_{|\sum|}m)\cdot m\log m)\)</span></td><td style="text-align:center"><span class="math inline">\(\approx O((2^{\sqrt{2\lg m p} }+\log_{ |\sum |}m))\)</span></td><td style="text-align:center">slower; shorter strings</td></tr><tr class="odd"><td style="text-align:center">Lattice reduction</td><td style="text-align:center">Medium-large alphabet, Multiple hashes</td><td style="text-align:center"><span class="math inline">\(O(length^3)\)</span></td><td style="text-align:center"><span class="math inline">\(\approx \sum_{i=0}^{n-1}\log_{|\sum|}(p_n)\)</span></td><td style="text-align:center">Great results for <span class="math inline">\(|\sum| =26\)</span>, good against multiple hashes. Bad on binary alphabet.</td></tr><tr class="even"><td style="text-align:center">Composition</td><td style="text-align:center">Multiple hashes</td><td style="text-align:center">Sum of single runtimes</td><td style="text-align:center">Product of single string lengths</td><td style="text-align:center">Combines two attacks.</td></tr></tbody></table><h3>Single hashes</h3><h4>Thue–Morse sequence: Hashing with unsigned overflow (<span class="math inline">\(p = 2^{64}\)</span>, <span class="math inline">\(q\)</span> arbitrary)</h4><p>One anti-hash test that works for any base is the Thue–Morse sequence, generated by the following code.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Q = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1</span> &lt;&lt; Q;</span><br><span class="line"><span class="function">std::string <span class="title">S</span><span class="params">(N, <span class="string">' '</span>)</span>, <span class="title">T</span><span class="params">(N, <span class="string">' '</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    S[i] = <span class="string">'A'</span> + __builtin_popcount(i) % <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    T[i] = <span class="string">'B'</span> - __builtin_popcount(i) % <span class="number">2</span>; </span><br></pre></td></tr></tbody></table></figure><p><span class="math inline">\(S\)</span>, <span class="math inline">\(T\)</span> form an equal-length collision, regardless of the chosen base.</p><p>See this <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9ibG9nL2VudHJ5LzQ4OTg">blog</a> for a detailed discussion. Note that the bound on the linked blog can be improved slightly, as <span class="math inline">\(X^2 - 1\)</span> is always divisible by <span class="math inline">\(8\)</span> for odd <span class="math inline">\(X\)</span>. (So we can use <span class="math inline">\(Q = 10\)</span> instead of <span class="math inline">\(Q = 11\)</span>.)</p><h4>Birthday-attack: Hashing with 32-bit prime and fixed base (<span class="math inline">\(p &lt; 2^{32}\)</span> fixed, <span class="math inline">\(q\)</span> fixed)</h4><p>Hashes with a single small prime can be attacked via the birthday paradox. Fix a length <span class="math inline">\(l\)</span> and the size of alphabet <span class="math inline">\(d\)</span>, and pick <span class="math inline">\(k\)</span> strings of length <span class="math inline">\(l\)</span> uniformly at random. If <span class="math inline">\(l\)</span> is not to small, the resulting hash values will approximately be uniformly distributed. By the birthday paradox, the probability that all of our picked strings hash to different values is:</p><p><span class="math display">\[ \sum_{i=0}^{k-1}(1-\frac{i} {d} ) &lt; \sum_{i=0}^{k-1}(e^{-\frac{i} {d} } ) =e^{-\frac{k(k-1)} {2d} } &lt; e^{-\ln 2} = \frac{1} {2} \]</span></p><p>Hence with probability <span class="math inline">\(&gt; \frac{1} {2}\)</span> we found two strings hashing to the same value. By repeating this, we can find an equal-length collision with high probability in <span class="math inline">\(O(\sqrt{p} )\)</span>. In practice, the resulting strings can be quite small (<span class="math inline">\(length \approx 6\)</span> and <span class="math inline">\(d=62\)</span> for <span class="math inline">\(p = 10^9 + 7\)</span>, not sure how to upper-bound this.).</p><p>More generally, we can compute <span class="math inline">\(m\)</span> strings with equal hash value in <span class="math inline">\(O(m\cdot p^{1-\frac{1} {m} } )\)</span> using the same technique with <span class="math inline">\(r = m \cdot p^{1-\frac{1} {m} }\)</span>.</p><h4>Tree-attack: Hashing with larger prime and fixed base (<span class="math inline">\(p\)</span> fixed, <span class="math inline">\(q\)</span> fixed)</h4><blockquote><p>Thanks <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9maWxlL0thYmFuLTU"><font color="red">Kaban-5</font></a> and <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9maWxlL3BhdmVsLnNhdmNoZW5rb3Y"><font color="red">pavel.savchenkov</font></a> for the <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9ibG9nL2VudHJ5LzE3NTA3P2xvY2FsZT1ydSNjb21tZW50LTIyMzYxNA">link</a> to some Russian comments describing this idea.</p></blockquote><p>For large primes, the birthday-attack is to slow. Recall that for two strings <span class="math inline">\((S, T)\)</span> of equal length:</p><p><span class="math display">\[ h(S)=h(T) \]</span></p><p><span class="math display">\[ \sum_{i=0}^{n-1}a^{n-i-1}(S_i-T_i) \equiv 0 \pmod{p} \]</span></p><p>we set <span class="math inline">\(\alpha_i = S_i - T_i\)</span> satisfies <span class="math inline">\(-|\sum| \le \alpha_i \le |\sum|\)</span>.The tree-attack tries to find <span class="math inline">\(\alpha_i \in\{-1,0,1\}\)</span> such that:</p><p><span class="math display">\[ \sum_{i=0}^{n-1} (a_{n-i-1} \mod p) \cdot \alpha_i = 0 \]</span></p><p>The attack maintains clusters <span class="math inline">\(C_1, ..., C_k\)</span> of coefficients. The <strong>sum</strong> <span class="math inline">\(S(C)\)</span> of a cluster <span class="math inline">\(C\)</span> is given by:</p><p><span class="math display">\[ S(C) = \sum_{i\in C} (a_{n-i-1} \mod p) \cdot \alpha_i \]</span></p><p>We can merge two clusters <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> to a cluster <span class="math inline">\(C_3\)</span> of sum <span class="math inline">\(S(C_1) - S(C_2)\)</span> by multiplying all the <span class="math inline">\(\alpha_i\)</span> from <span class="math inline">\(C_2\)</span> with $ - 1$ and joining the set of coefficients of <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span>. This operation can be implemented in constant time by storing the clusters as binary trees where each node stores its sum; the merge operation then adds a new node for <span class="math inline">\(C_3\)</span> with children <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> and sum <span class="math inline">\(S(C_1) - S(C_2)\)</span>. To ensure that the <span class="math inline">\(S(C_3) \ge 0\)</span>, swap <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> if necessary. The values of the <span class="math inline">\(\alpha_i\)</span> are not explicitly stored, but they can be recomputed in the end by traversing the tree.</p><p>Initially, we start with <span class="math inline">\(n = 2k\)</span> and each <span class="math inline">\(\alpha_i=1\)</span> in its own cluster. In a phase, we first sort the clusters by their sum and then merge adjacent pairs of clusters. If we encounter a cluster of sum <span class="math inline">\(0\)</span> at any point, we finish by setting all <span class="math inline">\(\alpha_j\)</span> not in that cluster to <span class="math inline">\(0\)</span>. If we haven’t finished after <span class="math inline">\(k\)</span> phases, try again with a bigger value of <span class="math inline">\(k\)</span>.</p><p>For which values of <span class="math inline">\(k\)</span> can we expect this to work? If we assume that the sums are initially uniformly distributed in <span class="math inline">\([0,p-1]\)</span>, the maximum sum should decrease by a factor <span class="math inline">\(\sim 2^{k-i}\)</span> in phase <span class="math inline">\(i\)</span>. After <span class="math inline">\(k\)</span> phases, the maximum sum is around <span class="math inline">\(\frac{p} {2^{\binom{k} {2} } }\)</span>, so <span class="math inline">\(k\approx \sqrt{2\lg p}+1\)</span> works. This produces strings of length <span class="math inline">\(n=2^{\sqrt{2\lg p}+1}\)</span> in <span class="math inline">\(O(n)\)</span> time. (A more formal analysis can be found in the paper ‘<a href="ftp://ftp.inf.ethz.ch/pub/crypto/publications/FlaPrz05.pdf">Solving Medium-Density Subset Sum Problems in Expected Polynomial Time</a>’, section 2.2. The problem and algorithms in the paper are slightly different, but the approach similar.)</p><h5>Multi-tree-attack</h5><p>While the tree-attacks runs really fast, the resulting strings can get a little long. (<span class="math inline">\(n = 2048\)</span> for <span class="math inline">\(p = 2^{61} - 1\)</span>.) We can spend more runtime to search for a shorter collision by storing the smallest m sums we can get in each cluster. (The single-tree-attack just uses <span class="math inline">\(m = 1\)</span>.) Merging two clusters can be done in <span class="math inline">\(O(m\log m)\)</span> with a min-heap and a <span class="math inline">\(2m\)</span>-pointer walk. In order to get to m strings ASAP, we allow all values <span class="math inline">\(\alpha_i\in[-|\sum|,|\sum|]\)</span> and exclude the trivial case where all <span class="math inline">\(\alpha_i\)</span> are zero.</p><p>Analysing the expected value of <span class="math inline">\(k\)</span> for this to work is quite difficult. Under the optimistic assumption that we reach m sums per node after <span class="math inline">\(\log_{\left |\sum \right |} m\)</span> steps, that the sums decrease as in the single tree attack and that we can expected a collision when they get smaller than <span class="math inline">\(m^2\)</span> by the birthday-paradox, we get <span class="math inline">\(k = \sqrt{2\frac{\lg p} {\lg m} }+\log_{|\sum|} m\)</span>. (A more realistic bound would be <span class="math inline">\(k=\frac{\lg p} {\lg m}+log_{|\sum|}m\)</span>, which might be gotten by accounting for the birthday-paradox in the bound proven in the paper ‘<a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly93d3cuc2VtYW50aWNzY2hvbGFyLm9yZy9wYXBlci9Pbi1SYW5kb20tSGlnaC1EZW5zaXR5LVN1YnNldC1TdW1zLUx5dWJhc2hldnNreS8wOGQ5MDFhOTQ1OTlhYjk1YjExMzhmMGVlNjhjNWQwY2RhMzFiZDY4P3AyZGY">On Random High Density Subset Sums</a>’, Theorem 3.1.)</p><p>In practice, we can use <span class="math inline">\(m \approx 10^5\)</span> to find a collision of length <span class="math inline">\(128\)</span> for <span class="math inline">\(|\sum|=2\)</span>, <span class="math inline">\(p = 2^{61} - 1\)</span> in around 0.4 seconds.</p><h4>Lattice-reduction attack: Single or multiple hashes over not-to-small alphabet</h4><blockquote><p>Thanks to <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9maWxlL2hlbGxtYW5f"><font color="orange">hellman_</font></a> for mentioning this, check out his write-up on this topic here. There’s also a write-up by someone else <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9nYWxoYWNrdGljdHJlbmRzZXR0ZXJzLndvcmRwcmVzcy5jb20vMjAxNy8wOS8wNS90b2t5by13ZXN0ZXJucy1jdGYtMjAxNy1wYWxpbmRyb21lcy1wYWlycy1jaGFsbGVuZ2UtcGhhc2Uv">here</a>.</p></blockquote><p>As in the tree attack, we’re looking for <span class="math inline">\(\alpha_i\in[-|\sum|,|\sum|]\)</span> such that:</p><p><span class="math display">\[ \sum_{i=0}^{n-1} (a_{n-i-1} \mod p) \cdot \alpha_i = 0 \]</span></p><p>The set:</p><p><span class="math display">\[ {\alpha_0,\cdots,a_{n-1},\beta} | \beta \equiv \sum_{i=0}^{n-1} (a_{n-i-1} \mod p)\cdot \alpha_i \]</span></p><p>forms a lattice (A free <span class="math inline">\(\mathbb{Z}\)</span>-module embedded in a subspace of <span class="math inline">\(\mathbb{R}^n\)</span>.) We’re looking for an element in the lattice such that <span class="math inline">\(\beta = 0\)</span> and <span class="math inline">\(|\alpha_i| \le |\sum|\)</span>. We can penalize non-zero values of <span class="math inline">\(\beta\)</span> by considering:</p><p><span class="math display">\[ \beta = 10^5((\sum_{i=0}^{n-1} (a_{n-i-1} \mod p)\cdot \alpha_i)) \mod p \]</span></p><p>instead, then we seek to minimize <span class="math inline">\(\max\{|\alpha_0|,\cdots,|a_{n-1}|,|\beta|\}\)</span>. Unfortunately, this optimization problem is quite hard, so we try to minimize:</p><p><span class="math display">\[ \alpha_0^2 + \cdots + \alpha_{n-1}^2 + \beta^2 \]</span></p><p>instead. The resulting problem is still hard, possibly NP-complete, but there are some good approximation algorithms available.</p><p>Similar to a vector space, we can define a basis in a lattice. For our case, a basis is given by:</p><p><span class="math display">\[ \{e_\beta+10^5(a_{n-i-1} \mod p)e_{a_i} | 0\le i &lt; n\} \cup \{p\cdot 10^5e_\beta\} \]</span></p><p>A lattice reduction algorithm takes this basis and transforms it (by invertible matrices with determinant <span class="math inline">\(\pm\)</span>) into another basis with approximately shortest vectors. Implementing them is quite hard (and suffers from precision errors or bignum slowdown), so I decided to use the builtin implementation in sage.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""Anti-rolling-hash test generation by lattice reduction</span></span><br><span class="line"><span class="string">original code by Hellman_, modified by dacin21</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">anti_hash</span>(<span class="params">PAs, string_length, sigma, block_size = <span class="number">0</span>, MULTIPLIER = <span class="number">100000</span>, sigma_base = <span class="built_in">ord</span>(<span class="params"><span class="string">'a'</span></span>)</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(PAs)</span><br><span class="line">    N = string_length</span><br><span class="line">    As = [a <span class="keyword">for</span> p, a <span class="keyword">in</span> PAs]</span><br><span class="line">    Ps = [p <span class="keyword">for</span> p, a <span class="keyword">in</span> PAs]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">s</span>):</span><br><span class="line">        <span class="string">"""polynomial hash modulo &lt;n&gt; primes"""</span></span><br><span class="line">        v = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            v = [(x * q + <span class="built_in">ord</span>(c))%p <span class="keyword">for</span> x, q, p <span class="keyword">in</span> <span class="built_in">zip</span>(v, As, Ps)]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tuple</span>(v % p <span class="keyword">for</span> v, p <span class="keyword">in</span> <span class="built_in">zip</span>(v, Ps))</span><br><span class="line"></span><br><span class="line">    mv = matrix(ZZ, N, N)</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> xrange(N):</span><br><span class="line">        <span class="keyword">for</span> x, q, p <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(n), As, Ps):</span><br><span class="line">            mv[y,x] = <span class="built_in">pow</span>(q, N-y-<span class="number">1</span>, p);</span><br><span class="line"></span><br><span class="line">    m = matrix(ZZ, N + n, N + n)</span><br><span class="line">    <span class="comment"># submatrix with terms</span></span><br><span class="line">    m.set_block(<span class="number">0</span>, <span class="number">0</span>, MULTIPLIER * mv)</span><br><span class="line">    <span class="comment"># modulo reductions</span></span><br><span class="line">    m.set_block(N, <span class="number">0</span>, MULTIPLIER * diagonal_matrix(Ps))</span><br><span class="line">    <span class="comment"># term coefficients</span></span><br><span class="line">    m.set_block(<span class="number">0</span>, n, identity_matrix(N))</span><br><span class="line">    <span class="comment"># 4th submatrix is zero</span></span><br><span class="line"></span><br><span class="line">    m_reduced = m.LLL()</span><br><span class="line">    <span class="keyword">if</span> block_size &gt; <span class="number">0</span>:</span><br><span class="line">        m_reduced = m_reduced.BKZ(block_size = block_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> m_reduced:</span><br><span class="line">        <span class="built_in">print</span> row[:n], <span class="built_in">min</span>(row[n:]), <span class="string">"~"</span>, <span class="built_in">max</span>(row[n:])</span><br><span class="line">        delta = <span class="built_in">max</span>(<span class="built_in">abs</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> row[n:])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">set</span>(row[:n]) == {<span class="number">0</span>} <span class="keyword">and</span> delta &lt; sigma:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">"Found collision!"</span></span><br><span class="line">            s = [<span class="literal">None</span>] * N</span><br><span class="line">            t = [<span class="literal">None</span>] * N</span><br><span class="line">            <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(row[n:]):</span><br><span class="line">                a = sigma_base</span><br><span class="line">                b = a + <span class="built_in">abs</span>(v)</span><br><span class="line">                <span class="keyword">if</span> v &gt; <span class="number">0</span>:</span><br><span class="line">                    a, b = b, a</span><br><span class="line">                s[i] = a</span><br><span class="line">                t[i] = b</span><br><span class="line">            s = <span class="string">""</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, s))</span><br><span class="line">            t = <span class="string">""</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, t))</span><br><span class="line">            <span class="built_in">print</span> s + <span class="string">" "</span> + t</span><br><span class="line">            <span class="comment"># print h(s)</span></span><br><span class="line">            <span class="comment"># print h(t)</span></span><br><span class="line">            <span class="keyword">assert</span> h(s) == h(t)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">"Failed to find collision, try a larger string_length"</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">"For lengths &gt; 30, setting block_size to 10 or 15 is recommended"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"hash.in"</span>, <span class="string">'r'</span>) <span class="keyword">as</span> infile:</span><br><span class="line">        n, k, sigma = <span class="built_in">map</span>(<span class="built_in">int</span>, infile.readline().strip().split())</span><br><span class="line">        PAs = [<span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, infile.readline().strip().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        anti_hash(PAs, k, sigma)</span><br></pre></td></tr></tbody></table></figure><p>Input is taken from a file named <code>hash.in</code> in the format. To use the BKZ algorithm, set the <code>block_size</code> argument.</p><p>Input format:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n length sigma</span><br><span class="line">p_1 a_1</span><br><span class="line">...</span><br><span class="line">p_n a_n</span><br></pre></td></tr></tbody></table></figure><p>Sage offers two algorithms: LLL and BKZ, the former is faster but produces worse approximations, especially for longer strings. Analyzing them is difficult, so I experimented a bit by fixing <span class="math inline">\(|\sum|=26\)</span>, <span class="math inline">\(p = 2^{61} - 1\)</span> and fixing <span class="math inline">\(a_1,\cdots ,a_n\)</span> randomly and searching for a short anti-hash test with both algorithms. The results turned out really well.</p><p>LLL algorithm:</p><table><thead><tr class="header"><th style="text-align:center"><span class="math inline">\(n\)</span></th><th style="text-align:center">minimal length</th><th style="text-align:center">time spent (seconds)</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">1</td><td style="text-align:center">12</td><td style="text-align:center">0.02</td></tr><tr class="even"><td style="text-align:center">2</td><td style="text-align:center">23</td><td style="text-align:center">0.04</td></tr><tr class="odd"><td style="text-align:center">3</td><td style="text-align:center">34</td><td style="text-align:center">0.08</td></tr><tr class="even"><td style="text-align:center">4</td><td style="text-align:center">48</td><td style="text-align:center">0.18</td></tr><tr class="odd"><td style="text-align:center">5</td><td style="text-align:center">60</td><td style="text-align:center">0.34</td></tr><tr class="even"><td style="text-align:center">6</td><td style="text-align:center">77</td><td style="text-align:center">0.75</td></tr><tr class="odd"><td style="text-align:center">7</td><td style="text-align:center">301</td><td style="text-align:center">5.14</td></tr><tr class="even"><td style="text-align:center">8</td><td style="text-align:center"><span class="math inline">\(&gt; 1500\)</span></td><td style="text-align:center"><span class="math inline">\(&gt; 990\)</span></td></tr></tbody></table><p>for <span class="math inline">\(n = 8\)</span> the algorithm couldn’t find a collision of length <span class="math inline">\(\le 1500\)</span>.</p><p>BKZ algorithm with <code>block_size = 10</code>:</p><table><thead><tr class="header"><th style="text-align:center"><span class="math inline">\(n\)</span></th><th style="text-align:center">minimal length</th><th style="text-align:center">time spent (seconds)</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">1</td><td style="text-align:center">12</td><td style="text-align:center">0.02</td></tr><tr class="even"><td style="text-align:center">2</td><td style="text-align:center">23</td><td style="text-align:center">0.04</td></tr><tr class="odd"><td style="text-align:center">3</td><td style="text-align:center">33</td><td style="text-align:center">0.09</td></tr><tr class="even"><td style="text-align:center">4</td><td style="text-align:center">45</td><td style="text-align:center">0.21</td></tr><tr class="odd"><td style="text-align:center">5</td><td style="text-align:center">57</td><td style="text-align:center">0.58</td></tr><tr class="even"><td style="text-align:center">6</td><td style="text-align:center">72</td><td style="text-align:center">1.12</td></tr><tr class="odd"><td style="text-align:center">7</td><td style="text-align:center">88</td><td style="text-align:center">2.59</td></tr><tr class="even"><td style="text-align:center">8</td><td style="text-align:center">108</td><td style="text-align:center">5.33</td></tr></tbody></table><p>BKZ algorithm with <code>block_size = 15</code>:</p><table><thead><tr class="header"><th style="text-align:center"><span class="math inline">\(n\)</span></th><th style="text-align:center">minimal length</th><th style="text-align:center">time spent (seconds)</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">1</td><td style="text-align:center">12</td><td style="text-align:center">0.02</td></tr><tr class="even"><td style="text-align:center">2</td><td style="text-align:center">23</td><td style="text-align:center">0.04</td></tr><tr class="odd"><td style="text-align:center">3</td><td style="text-align:center">33</td><td style="text-align:center">0.09</td></tr><tr class="even"><td style="text-align:center">4</td><td style="text-align:center">45</td><td style="text-align:center">0.21</td></tr><tr class="odd"><td style="text-align:center">5</td><td style="text-align:center">57</td><td style="text-align:center">0.52</td></tr><tr class="even"><td style="text-align:center">6</td><td style="text-align:center">70</td><td style="text-align:center">1.24</td></tr><tr class="odd"><td style="text-align:center">7</td><td style="text-align:center">85</td><td style="text-align:center">2.41</td></tr><tr class="even"><td style="text-align:center">8</td><td style="text-align:center">102</td><td style="text-align:center">5.20</td></tr></tbody></table><p>BKZ algorithm with <code>block_size = 25</code>:</p><table><thead><tr class="header"><th style="text-align:center"><span class="math inline">\(n\)</span></th><th style="text-align:center">minimal length</th><th style="text-align:center">time spent (seconds)</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">1</td><td style="text-align:center">12</td><td style="text-align:center">0.02</td></tr><tr class="even"><td style="text-align:center">2</td><td style="text-align:center">23</td><td style="text-align:center">0.04</td></tr><tr class="odd"><td style="text-align:center">3</td><td style="text-align:center">33</td><td style="text-align:center">0.10</td></tr><tr class="even"><td style="text-align:center">4</td><td style="text-align:center">46</td><td style="text-align:center">0.58</td></tr><tr class="odd"><td style="text-align:center">5</td><td style="text-align:center">57</td><td style="text-align:center">1.14</td></tr><tr class="even"><td style="text-align:center">6</td><td style="text-align:center">70</td><td style="text-align:center">3.67</td></tr><tr class="odd"><td style="text-align:center">7</td><td style="text-align:center">84</td><td style="text-align:center">6.96</td></tr><tr class="even"><td style="text-align:center">8</td><td style="text-align:center">96</td><td style="text-align:center">26.70</td></tr></tbody></table><p>Note that this attack does not work well for small (i.e binary) alphabets when <span class="math inline">\(n &gt; 1\)</span> and that the characters have to <strong>hash to consecutive</strong> values, so this has to be the first attack if used in a composition attack.</p><h3>Composition-attack: Multiple hashes</h3><blockquote><p>Credit for this part goes to <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9maWxlL2lmc21pcm5vdg"><font color="red">ifsmirnov</font></a>, I found this technique in his <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9naXRodWIuY29tL2lmc21pcm5vdi9qbmdlbg">jngen</a> library.</p></blockquote><p>Using two or more hashes is usually sufficient to protect from a direct birthday-attack. For two primes, there are <span class="math inline">\(N = p_1·p_2\)</span> possible hash values. The birthday-attack runs in <span class="math inline">\(O(\sqrt{N})\)</span>, which is <span class="math inline">\(\approx 10^{10}\)</span> for primes around <span class="math inline">\(10^9\)</span>. Moreover, the memory usage is more than <span class="math inline">\(\sqrt{ (2 \ln 2)N}\cdot 8\)</span> bytes (If you only store the hashes and the rng-seed), which is around 9.5 GB.</p><p>The key idea used to break multiple hashes is to break them one-by-one.</p><ul><li>First find an equal-length collision (by birthday-attack) for the first hash <span class="math inline">\(h_1\)</span>, i.e. two strings <span class="math inline">\(S, T, S \neq T\)</span> of equal length with <span class="math inline">\(h_1(S) = h_1(T)\)</span>. Note that strings of equal length built over the alphabet <span class="math inline">\(S, T\)</span> (i.e. by concatenation of some copies of <span class="math inline">\(S\)</span> with some copies of <span class="math inline">\(T\)</span> and vice-versa) will now hash to the same value under <span class="math inline">\(h_1\)</span>.</li><li>Then use <span class="math inline">\(S\)</span> and <span class="math inline">\(T\)</span> as the alphabet when searching for an equal-length collision (by birthday-attack again) for the second hash <span class="math inline">\(h_2\)</span>. The result will automatically be a collision for <span class="math inline">\(h_1\)</span> as well, as we used <span class="math inline">\(S, T\)</span> as the alphabet.</li></ul><p>This reduces the runtime <span class="math inline">\(O(\sqrt{p_1}+\sqrt{p_2} )\)</span> . Note that this also works for combinations of a 30-bit prime hash and a hash mod <span class="math inline">\(2^{64}\)</span> if we use the Thue–Morse sequence in place of the second birthday attack. Similarly, we can use tree- instead of birthday-attacks for larger modulos.</p><p>Another thing to note is that string length grows rapidly in the number of hashes. (Around <span class="math inline">\(2\log_{|\sum|}(\sqrt{ (2\ln 2)p_1} )\cdot\log_2 (\sqrt{ (2\ln 2)p_2} )\cdots \log_2(\sqrt{ (2\ln 2)p_k} )\)</span>, the alphabet size is reduced to <span class="math inline">\(2\)</span> after the first birthday-attack. The first iteration has a factor of <span class="math inline">\(2\)</span> in practice.) If we search for more than 2 strings with equal hash value in the intermediate steps, the alphabet size will be bigger, leading to shorter strings, but the runtime of the birthday-attacks gets slower (<span class="math inline">\(O(p^{\frac{2} {3} } )\)</span> for <span class="math inline">\(3\)</span> strings, for example.).</p><h2>Abusing bad randomization</h2><p>On codeforces, quite a lot of people randomize their hashes. (Un-)Fortunately, many of them do it an a suboptimal way. This section covers some of the ways people screw up their hash randomizations and ways to hack their code.</p><p>This section applies more generally to any type of randomized algorithm in an environment where other participants can hack your solutions.</p><h3>Fixed seed</h3><p>If the seed of the rng is fixed, it always produces the same sequence of random numbers. You can just run the code to see which numbers get randomly generated and then find an anti-hash test for those numbers.</p><h3>Picking from a small pool of bases(<code>rand()%100</code>)</h3><p>Note that <code>rand() % 100</code> produced at most 100 distinct values <span class="math inline">\([0,99]\)</span>. We can just find a separate anti-hash test for every one of them and then combine the tests into a single one. (The way your combine tests is problem-specific, but it works for most of the problems.)</p><h3>More issues with <code>rand()</code></h3><p>On codeforces, <code>rand()</code> produces only <span class="math inline">\(15\)</span>-bit values, so at most <span class="math inline">\(2^{15}\)</span> different values. While it may take a while to run <span class="math inline">\(2^{15}\)</span> birthday-attacks (estimated <span class="math inline">\(111\)</span> minutes for <span class="math inline">\(p = 10^9 + 7\)</span> using a single thread on my laptop), this can cause some big issues with some other randomized algorithms.</p><p>Edit: This type of hack might be feasible if we use multi-tree-attacks. For $ p =10^9+7,|\sum|=26$, running <span class="math inline">\(2^{15}\)</span> multi-tree attacks with <span class="math inline">\(m = 10^4\)</span> takes around <span class="math inline">\(2\)</span> minutes and produces an output of <span class="math inline">\(5.2\cdot 10^5\)</span> characters. This is still slightly to large for most problems, but could be split up into multiple hacks in an open hacking phase, for example.</p><p>In C++11 you can use <code>mt19937</code> and <code>uniform_int_distribution</code> instead of <code>rand()</code>.</p><h3>Low-precision time(<code>Time(NULL)</code>)</h3><p><code>Time(NULL)</code> only changes once per second. This can be exploited as follows</p><ol type="1"><li>Pick a timespan <span class="math inline">\(\Delta T\)</span>.</li><li>Find an upper bound <span class="math inline">\(T\)</span> for the time you’ll need to generate your tests.</li><li>Figure out the current value <span class="math inline">\(T_0\)</span> of <code>Time(NULL)</code> via custom invocation.</li><li>For <span class="math inline">\(t = 0,\cdots,(\Delta T) - 1\)</span>, replace <code>Time(NULL)</code> with <span class="math inline">\(T_0 + T + t\)</span> and generate an anti-test for this fixed seed.</li><li>Submit the hack at time <span class="math inline">\(T_0 + T\)</span>.</li></ol><p>If your hack gets executed within the next <span class="math inline">\(\Delta T\)</span> seconds, <code>Time(NULL)</code> will be a value for which you generated an anti-test, so the solution will fail.</p><h3>Random device on MinGW(<code>std::random_device</code>)</h3><p>Note that on codeforces specifically, <code>std::random_device</code> is deterministic and will produce the same sequence of numbers. Solutions using it can be hacked just like fixed seed solutions.</p><blockquote><p>本文选取自 <a target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9ibG9nL2VudHJ5LzYwNDQy">Anti-rolling-hash test generation by lattice reduction</a></p></blockquote></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/math/">math</a><a class="post-meta__tags" href="/tags/hash/">hash</a></div><div class="post-share"><div class="social-share" data-image="https://t.alcy.cc/fj?postid=7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" media="print" onload='this.media="all"'><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/79d6ca4/" title="splay"><img class="cover" src="https://t.alcy.cc/fj?postid=1" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">splay</div></div><div class="info-2"><div class="info-item-1">三大平衡树之一</div></div></div></a><a class="pagination-related" href="/posts/951dcf71/" title="关于滚动哈希与反哈希测试背后的数学原理"><img class="cover" src="https://t.alcy.cc/fj?postid=2" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">关于滚动哈希与反哈希测试背后的数学原理</div></div><div class="info-2"><div class="info-item-1">搬运</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/951dcf71/" title="关于滚动哈希与反哈希测试背后的数学原理"><img class="cover" src="https://t.alcy.cc/fj?postid=2" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-11-15</div><div class="info-item-2">关于滚动哈希与反哈希测试背后的数学原理</div></div><div class="info-2"><div class="info-item-1">搬运</div></div></div></a><a class="pagination-related" href="/posts/837dcf3e/" title="FFT 学习笔记"><img class="cover" src="https://t.alcy.cc/fj?postid=4" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2026-02-25</div><div class="info-item-2">FFT 学习笔记</div></div><div class="info-2"><div class="info-item-1">FFT 学习笔记</div></div></div></a><a class="pagination-related" href="/posts/cfd8ddf5/" title="数论合集"><img class="cover" src="https://t.alcy.cc/fj?postid=1" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2026-02-28</div><div class="info-item-2">数论合集</div></div><div class="info-2"><div class="info-item-1">持续更新</div></div></div></a><a class="pagination-related" href="/posts/7d16c0e9/" title="矩阵"><img class="cover" src="https://t.alcy.cc/fj?postid=6" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2026-02-28</div><div class="info-item-2">矩阵</div></div><div class="info-2"><div class="info-item-1">矩阵的基本的基本</div></div></div></a><a class="pagination-related" href="/posts/1c8a7eaf/" title="NTT 学习笔记"><img class="cover" src="https://t.alcy.cc/fj?postid=8" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2026-02-25</div><div class="info-item-2">NTT 学习笔记</div></div><div class="info-2"><div class="info-item-1">快速数论变换（FNTT） 学习笔记</div></div></div></a><a class="pagination-related" href="/posts/31a2dedc/" title="自然数的 k 次幂求和"><img class="cover" src="https://t.alcy.cc/fj?postid=2" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2026-02-28</div><div class="info-item-2">自然数的 k 次幂求和</div></div><div class="info-2"><div class="info-item-1">自然数的 k 次幂求和</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/skirk-head.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">星光light</div><div class="author-info-description">星光照耀，灿烂前行</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="external nofollow noopener noreferrer" href="/go.html?u=aHR0cHM6Ly9naXRodWIuY29tL3hnbGlnaHQ"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="mailto:xglight0@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a><a class="social-icon" href="/3762892980" target="_blank" title="QQ"><i class="fas fa-solid fa-q" style="color:#e50036"></i></a><a class="social-icon" href="/go.html?u=aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3VzZXIvNzU1Mzcw" target="_blank" title="Luogu" rel="external nofollow noopener noreferrer"><i class="fas fa-solid fa-l" style="color:#5b9bd5"></i></a><a class="social-icon" href="https://xglight.netlify.app/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color:#f60"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">主站：<a href="https://xglight.github.io/">https://xglight.github.io/</a><br>镜像站：<a target="_blank" rel="noopener" href="https://xglight.netlify.app/">https://xglight.netlify.app/</a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Designing hard-to-hack rolling hashes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.1.</span> <span class="toc-text">Recap on rolling hashes and collisions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.2.</span> <span class="toc-text">Randomizing base</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.3.</span> <span class="toc-text">Tightness of bound</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.</span> <span class="toc-text">Randomizing modulo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.</span> <span class="toc-text">How to randomize properly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.6.</span> <span class="toc-text">Extension to multiple hashes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.7.</span> <span class="toc-text">Larger modulo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.8.</span> <span class="toc-text">Extension to multiple comparisons</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.9.</span> <span class="toc-text">Extension to strings of different length</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Computing anti-hash tests</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.1.</span> <span class="toc-text">Single hashes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.1.1.</span> <span class="toc-text">Thue–Morse sequence: Hashing with unsigned overflow (\(p = 2^{64}\), \(q\) arbitrary)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.1.2.</span> <span class="toc-text">Birthday-attack: Hashing with 32-bit prime and fixed base (\(p &lt; 2^{32}\) fixed, \(q\) fixed)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.1.3.</span> <span class="toc-text">Tree-attack: Hashing with larger prime and fixed base (\(p\) fixed, \(q\) fixed)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">Multi-tree-attack</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.1.4.</span> <span class="toc-text">Lattice-reduction attack: Single or multiple hashes over not-to-small alphabet</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.2.</span> <span class="toc-text">Composition-attack: Multiple hashes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Abusing bad randomization</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.1.</span> <span class="toc-text">Fixed seed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.2.</span> <span class="toc-text">Picking from a small pool of bases(rand()%100)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.3.</span> <span class="toc-text">More issues with rand()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.4.</span> <span class="toc-text">Low-precision time(Time(NULL))</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.5.</span> <span class="toc-text">Random device on MinGW(std::random_device)</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/24055d74/" title="operator浅谈"><img src="https://t.alcy.cc/fj?postid=3" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="operator浅谈"></a><div class="content"><a class="title" href="/posts/24055d74/" title="operator浅谈">operator浅谈</a><time datetime="2026-02-28T08:11:33.348Z" title="更新于 2026-02-28 16:11:33">2026-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/31a2dedc/" title="自然数的 k 次幂求和"><img src="https://t.alcy.cc/fj?postid=2" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="自然数的 k 次幂求和"></a><div class="content"><a class="title" href="/posts/31a2dedc/" title="自然数的 k 次幂求和">自然数的 k 次幂求和</a><time datetime="2026-02-28T08:11:33.348Z" title="更新于 2026-02-28 16:11:33">2026-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c1988da5/" title="炽声音节旋题解"><img src="https://t.alcy.cc/fj?postid=7" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="炽声音节旋题解"></a><div class="content"><a class="title" href="/posts/c1988da5/" title="炽声音节旋题解">炽声音节旋题解</a><time datetime="2026-02-28T08:11:33.348Z" title="更新于 2026-02-28 16:11:33">2026-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ced3a8ad/" title="c++ 中的随机化"><img src="https://t.alcy.cc/fj?postid=4" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="c++ 中的随机化"></a><div class="content"><a class="title" href="/posts/ced3a8ad/" title="c++ 中的随机化">c++ 中的随机化</a><time datetime="2026-02-28T08:11:33.348Z" title="更新于 2026-02-28 16:11:33">2026-02-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/79d6ca4/" title="splay"><img src="https://t.alcy.cc/fj?postid=1" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="splay"></a><div class="content"><a class="title" href="/posts/79d6ca4/" title="splay">splay</a><time datetime="2026-02-28T08:11:33.348Z" title="更新于 2026-02-28 16:11:33">2026-02-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(https://t.alcy.cc/fj?postid=7)"><div class="footer-other"><div class="footer-copyright"><span class="copyright">©&nbsp;2023 - 2026 By 星光light</span><span class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div><div class="footer_custom_text">This is 星光lightのblog.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.6/translate/tw_cn.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/6.0.29/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/instant.page/5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.bootcdn.net/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><div class="js-pjax"><script>(()=>{const t=()=>{if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typesetPromise();else{window.MathJax={loader:{load:["[tex]/mhchem"],paths:{"mathjax-newcm":"[mathjax]/../@mathjax/mathjax-newcm-font","mathjax-mhchem-extension":"[mathjax]/../@mathjax/mathjax-mhchem-font-extension"}},output:{font:"mathjax-newcm"},tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"none",packages:{"[+]":["mhchem"]}},chtml:{scale:1.1},options:{enableMenu:!0,menuOptions:{settings:{enrich:!1}},renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const a=!!e.type.match(/; *mode=display/),n=new t.options.MathItem(e.textContent,t.inputJax[0],a),m=document.createTextNode("");e.parentNode.replaceChild(m,e),n.start={node:m,delim:"",n:0},n.end={node:m,delim:"",n:0},t.math.push(n)}},""]}}};const t=document.createElement("script");t.src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}};btf.addGlobalFn("encrypt",t,"mathjax"),window.pjax?t():window.addEventListener("load",t)})()</script><script>(()=>{const e=()=>{const e=document.querySelectorAll("#article-container .mermaid-wrap");if(0===e.length)return;const t=()=>(e=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";e.forEach((e,n)=>{const d=e.firstElementChild,a=`mermaid-${n}`,r=`%%{init:{ 'theme':'${t}'}}%%\n`+d.textContent,i=mermaid.render(a,r),m=e=>{d.insertAdjacentHTML("afterend",e)};"string"==typeof i?m(i):i.then(({svg:e})=>m(e))})})(e);btf.addGlobalFn("themeChange",t,"mermaid"),window.loadMermaid?t():btf.getScript("https://cdn.bootcdn.net/ajax/libs/mermaid/11.11.0/mermaid.min.js").then(t)};btf.addGlobalFn("encrypt",e,"mermaid"),window.pjax?e():document.addEventListener("DOMContentLoaded",e)})()</script><script>(()=>{const o="shuoshuo"===GLOBAL_CONFIG_SITE.pageType,t=null,e=(e=document,n=location.pathname)=>{twikoo.init({el:e.querySelector("#twikoo-wrap"),envId:"https://xglight-hexo-talk.netlify.app/.netlify/functions/twikoo",region:"",onCommentLoaded:()=>{btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))},...t,path:n}),o&&(window.shuoshuoComment.destroyTwikoo=()=>{e.children.length&&(e.innerHTML="",e.classList.add("no-comment"))})},n=(o,t)=>{"object"==typeof twikoo?setTimeout(()=>e(o,t),0):btf.getScript("https://cdn.bootcdn.net/ajax/libs/twikoo/1.6.44/twikoo.all.min.js").then(()=>e(o,t))};o?window.shuoshuoComment={loadComment:n}:n()})()</script></div><script>window.newestComments={changeContent:e=>(""===e||(e=(e=(e=(e=(e=e.replace(/<img.*?src="(.*?)"?[^\>]+>/gi,"[图片]")).replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi,"[链接]")).replace(/<pre><code>.*?<\/pre>/gi,"[代码]")).replace(/<code>.*?<\/code>/gi,"[代码]")).replace(/<[^>]+>/g,"")).length>150&&(e=e.substring(0,150)+"..."),e),generateHtml:(e,t)=>{let n="";if(e.length)for(let t=0;t<e.length;t++)n+='<div class="aside-list-item">',n+=`<div class="content">\n        <a class="comment" href="${e[t].url}" title="${e[t].content}">${e[t].content}</a>\n        <div class="name"><span>${e[t].nick} / </span><time datetime="${e[t].date}">${btf.diffDate(e[t].date,!0)}</time></div>\n        </div></div>`;else n+="暂无评论";t.innerHTML=n,window.lazyLoadInstance&&window.lazyLoadInstance.update(),window.pjax&&window.pjax.refresh(t)},newestCommentInit:(e,t)=>{const n=document.querySelector("#card-newest-comments .aside-list");if(n){const a=btf.saveToLocal.get(e);a?newestComments.generateHtml(JSON.parse(a),n):t(n)}},run:(e,t)=>{newestComments.newestCommentInit(e,t),btf.addGlobalFn("pjaxComplete",()=>newestComments.newestCommentInit(e,t),e)}}</script><script>window.addEventListener("load",()=>{const t="twikoo-newest-comments",{changeContent:e,generateHtml:n,run:o}=window.newestComments;o(t,o=>{const i=()=>{twikoo.getRecentComments({envId:"https://xglight-hexo-talk.netlify.app/.netlify/functions/twikoo",region:"",pageSize:6,includeReply:!0}).then(i=>{const a=i.map(t=>({content:e(t.comment),avatar:t.avatar,nick:t.nick,url:t.url+"#"+t.id,date:new Date(t.created).toISOString()}));btf.saveToLocal.set(t,JSON.stringify(a),10/1440),n(a,o)}).catch(t=>{console.error(t),o.textContent="无法获取评论，请确认相关配置是否正确"})};"object"==typeof twikoo?i():btf.getScript("https://cdn.bootcdn.net/ajax/libs/twikoo/1.6.44/twikoo.all.min.js").then(i)})})</script><script src="/zhheo/random.js"></script><script src="https://cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script>(()=>{window.pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"],cacheBust:!1,analytics:!1,scrollRestoration:!1});const e=e=>{e&&Object.values(e).forEach(e=>{try{e()}catch(e){console.debug("Pjax callback failed:",e)}})};document.addEventListener("pjax:send",()=>{btf.removeGlobalFnEvent("pjaxSendOnce"),btf.removeGlobalFnEvent("themeChange");const t=document.body.classList;t.contains("read-mode")&&t.remove("read-mode"),e(window.globalFn.pjaxSend)}),document.addEventListener("pjax:complete",()=>{btf.removeGlobalFnEvent("pjaxCompleteOnce"),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),n=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(n)),e.parentNode.replaceChild(t,e)}),e(window.globalFn.pjaxComplete)}),document.addEventListener("pjax:error",e=>{if(404===e.request.status){window.location.href=e.request.responseURL}})})()</script><script async data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据加载中</span></div><div class="local-search-input"><input placeholder="搜索..." type="text"></div><hr><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script data-pjax="">function butterfly_categories_card_injector_config(){var a=document.getElementById("recent-posts");console.log("已挂载butterfly_categories_card"),a.insertAdjacentHTML("afterbegin",'<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover1.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/solutions/&quot;);" href="javascript:void(0);">solutions</a><span class="categoryBar-list-count">14</span><span class="categoryBar-list-descr">solutions</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover2.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/notes/&quot;);" href="javascript:void(0);">notes</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">notes</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover3.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/technology/&quot;);" href="javascript:void(0);">technology</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">algorithm</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover4.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/algorithm/&quot;);" href="javascript:void(0);">algorithm</a><span class="categoryBar-list-count">23</span><span class="categoryBar-list-descr">summary</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover5.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/summary/&quot;);" href="javascript:void(0);">summary</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr">technology</span></li></ul></div></div>')}document.getElementById("recent-posts")&&"/"===location.pathname&&butterfly_categories_card_injector_config()</script><script data-pjax="">function butterfly_footer_beautify_injector_config(){var e=document.getElementById("footer-wrap");console.log("已挂载butterfly_footer_beautify"),e.insertAdjacentHTML("beforeend",'<div id="workboard"></div><div id="ghbdages" style="overflow:hidden;max-height:90px;height:auto;text-align:center;margin-top:10px"><div class="swiper-wrapper"><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架Hexo_v8.0.0"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v5.5.0"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.bootcdn.cn/" style="margin-inline:5px" title="本站使用Bootcdn为静态资源提供CDN加速"><img src="https://img.shields.io/badge/CDN-BootCDN-green?style=flat" alt=""/></a></div><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本站项目由Github托管"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></div></div></div><style>a.github-badge:hover:before {display:none}</style>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_footer_beautify_injector_config()</script><script async src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax="" src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify/lib/swiperbdage_init.min.js"></script><script data-pjax="">function butterfly_swiper_injector_config(){var s=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),s.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/78aab76b/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://t.alcy.cc/fj?postid=8" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-10-11</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/78aab76b/&quot;);" href="javascript:void(0);" alt="">c++ 奇技淫巧</a><div class="blog-slider__text">c++ 的一些好用/神奇的函数</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/78aab76b/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/244d3e22/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://t.alcy.cc/fj?postid=8" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2026-02-28</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/244d3e22/&quot;);" href="javascript:void(0);" alt="">毒瘤题收集</a><div class="blog-slider__text">也许是一个很不错的题单。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/244d3e22/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/151b1912/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://t.alcy.cc/fj?postid=6" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2026-02-28</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/151b1912/&quot;);" href="javascript:void(0);" alt="">c++11 的多线程</a><div class="blog-slider__text">c++11 的多线程详解，包括 thread,mutex,async 等。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/151b1912/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/516cc39d/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://t.alcy.cc/fj?postid=2" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2026-02-28</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/516cc39d/&quot;);" href="javascript:void(0);" alt="">好文收集</a><div class="blog-slider__text">也许有用</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/516cc39d/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/5a717bf0/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://t.alcy.cc/fj?postid=3" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2026-02-28</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/5a717bf0/&quot;);" href="javascript:void(0);" alt="">更新日志</a><div class="blog-slider__text">更新日志</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/5a717bf0/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax="" src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script></body></html>