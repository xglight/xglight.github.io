<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>gmoj5740 幻想世界题解</title>
      <link href="/posts/dcb74c5b/"/>
      <url>/posts/dcb74c5b/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e4bae39f1aef0b62274ba24a5d12486396d9db36948cacf32617bef8524a60c7">93024cf999deb8d8b2919f7e109263d49a1df121389bd9d39d5a7d794df35ca890b34809ff92d89d0c5e0dd499287389538ba882847b5203ee6030c183b1ca17baf287ee612b2a776192572d1ca18322de023374f4cb8d14f768974b44b2ed551515672bbeea243c8bcdb9f5bef040dc57fa455608a1478e49e41923e98728d9806b4873e52ee54faef2ff400d84b1ac902074e290108debad7c144bc8f55fee453704b003d0be61ba4d5fba0b11e6bb52de655f6b77bb817f7b210f895fa048df64650f5b1782381fb5a64daf3b3a0d007179f137fd5ea3c85644a88a25c035017a862236a87e1e5f88c7f976f87a61b68d7fb1ee0ffa54cf93032da94a2aa62915472de9c0c6ddec15ec9fc7ef8fce62b9f71934a2f11a903310d08e300a76893cd1657963cc63d0c0f95a05c3de1b347e48939baa7871aa5b1d6700ce7042b19540c851abab39e2f87146a8e9523111e30d2b02401275152996e511a5572c2a39276003325adc7366bd3749c5067f6a2e1a13c9a53bcd96c4b99b1ceb3d6e7fe7ddca9d0a994376c116bdb2d65565ccfaf583ff86fd9865dc11e1cfbd347d71da2004fddbee5c823fafc70647011cf611a62044847622c14fcfdff124271c758623f51f83c2d6e5f988d169726c861cac02cf741841aa3983f0b2e255c800050d48083f40ddaca4bd0704c84125f47b170d960c98525f96d7757b4e03c1e6220a29e94798b29c2c786135f7a738cec6732c1279d9805b2f3089ff001eb9cb18da5e9e553ca9a66848a57216f76486d1893254202615dff4d1f02e5dd318bfb2557d5e077617d2630ece0f10a673ade27c1b3c52989d457b1be5d00c2b361241e58812d6aa7ed2f85c050687e670fcf8ed79e5b6f206094eeea9d4330b603160c546316309d558e4f190ecfa94f12f6f35bc9579c6695972f7fae3afbe237e7111827bc6d912594ecb77651036490d3dfa23ee70cdb5585fb586aa3deb4e2bb8fc20d0d7a55826681f81b1071387d35cf10ae707cd5585cce1f563c0c64dde4e190ebf8195c47e756141d26ac6220bc3302beabc3b1ee0cd746d8a50e267205577d9556208d32a646e95d3f1d8e99f3aedb1624a68f18eaaed32637c5b72f15053920d5850a7f715a608c884c8cb889de8654e37cd368ccb0e96fa0b641018e228e822cc2021b9bce08975e85bbdf3f8570111e32a2907c1b7cf00f503643ae0df8f96d272453769c1b575889d1145b286b89aa8a6497ba87fe5ead45ea8865e6903de22ba97617ee84c657b87254bcc41dcc52cceff1d9f5a1ae74723cdf5d27638feb4a89d99d595d9b9751c70e68a7790231df2c47ab72e1d3055d20069e93e8e409ebaae4a44a5face13c425242d11280cd0382e6ae5eb73ba08cd52c03bd649a9a92eccf8c0f3f38ae782f8478e8a15bf0366e0ddb4043e31634a7e0092a1950a31db3c5f903b15823e0f30571486cdffe101321f026d11e488e1e906c52c23c04dfbed5f3e65e1ea510a8a86f2bb2bf797e7052905571e2ade3630b8e929737d6fcb31673432d6f9b75a5f33e5a940b828300237d30091dfcee308cbc2df62944f28375762c9f6ec307f0b0f3d630e651ed87cdd1d2748bc56a18a39acf4f8920fd4e393314e879237871916c57be27e5763c44fa8a50f3511d7c09a434459e835323680abadc4af802c5f1b4e658c5739bfa4c01af4c45051d6c7a0d8c5e3674a2c9a438b2eb9252e1718e178feb105494ed352deced7f33ee3f73da09b7b7ba4ec777f903f9dc960c5718e1d4ebb56072a87bb198a090985085d5bea515c658adf8d51d35f7013e579881326b6e2af2b0dbcf51abfd74243e94e02aff2ea8f09069e1edf5d02eaec0f337a82cf71c0ab23b20abecde2752e8a485c4a4ece28aecd2cad06f05aa9fc506185957a30e0e339f6e17285a26cf84d68cfb7f7c4c9785b1b20d314d5f81ccbe879836af47db74f98d363c0442ceebe05dde2fae7455c47e5baa6bc9bbcc66acbb90dc81076967edc0c8fc71d7a3ea10030fce523009c41cbc04ad94f56dadbfc0a1140546345b23e7c0fb811e83d90e0942fecb54fe1860833bb25fd6355bea9c1560ae179775dc27d39eeb3996e2b6c95d2f7392e0bb675e07207dce828ebc34332b991a620dc47398147d6ed4dd8b0902b59e59026329d017b5335b7aeb6e3728fd43fe6409cd3aac3960153915bf13e7a197afbc126519db5d140278ac1a0067deb094dd38c0ff2b3d1c0ea4d08706fc13c09d5af177e0dbfe9e0fe5a16a22bb2af1088642ca6be1b1bfa7669664a80c8c5b4a968f08a31ff3a868d25e5963a9a2155d1dd9d3ac65e1a55b5d2d9d475c6f4efbdb9d23fc8cf3d8b46f85f3bea301299b409e6b0b14ed0a039cc9827258e01cdc83c11d7044ff57cbca30ccf652fac7b1fd062b913fd4f21a48812cc82ee4a402f5d22219a838819f4cfc70a12c498e29d0a8d3eaff77645d256cba6779052d70bbacf5ec7eb6a401ebed1542da41546b1ec8c7ed8afd63bed8a1b1afd19778792907642691ee1dcbf40b8e5908c37f54680dde0c404d31f0dfbd7ed18c3e74f1a38486129efe9f73965424d51452fcbe0b7ff74ba801de814af1fe548c54733b424b0532bf6df2d1691d815a422c1e73d49506ecf61bf0258cb41b2caf90209748df007b08eb185b742c796912aa175722bb5419b3eeed91c93dba9361d52276a8160205e085bfb18ce0bcb6a7644e6f68c9c8cbf85ba239987e837eaffe33e8ba8786d26b7821b73d7f714e81793ce85a455084cde5f9abd9bc2ce8bd225ed4332036f2c4597df695063a8a20c7eac53672bc4f2f1f1031c5fc4e27dedd4906476024ccf60a00f141803e6ddc2f251a9d82a4fe0118357ff717b2f6cd8dbdbafaf9b95a2d90d61ff97ab7f4fa1a74e1578fae0356c89d1eddc929a4ba2d8af953b46394e90d22f510bdccc1ab7e96f8588021164278ab2b934780cd81c0532e18813f289a6921df68ac46f7430b3f31d7940bc9433a831ffb2da72fbf79c46dd005230829ee402a65bd8b80a8ae3d01c42138d07bad85472a87f1c9e576d440760666ae43b3f73ad1daf1b8f01edd89acae654b06c4890017404e9d6988067f365b15846023bc5d709f3a9225d5727dcfbd87c1be5116ba30843e86dd75e58cf31190754e4fedbe2fae4e07a1f9c740b31e3ea522cca63eb9cde757f6ffa00bebf6a058d1e550e41b35b88ba2ea1fee3616de6d87376cf56ff7bed1b03a77eb622efdaba1f36c7132c0b620127e8c9981365a8e3240dd91b28c3feb6ad66f429efd9e3afb9abafe8378c15b519037dbb7163fb0e6c2607f5425b0fa138a831d280d7a564cf2e56ce346e5c247e61694e4b1b5fb41ef643b2816b5c6476e1583070de3b73487c8218043e5cc40d27663fb5e51a8239f683f11a5dc6b312a590b81077f6ace8c365365288556be44f812e73f15847002d31b2cb9faeeecf1c76c67322d46e8a5b9cb19b7962365c351955a91f817e93bce7c69821705634ca3df4c47168022193d82fe65043aef370be930b7af8648aff5f77799bbdb6827a9675b145e19160a31fe361aaed69a656420a392ae3db6d7820db2408ca9582beaa4987f16bd8788db2904384aa52c272235fcc3e7eb437e0d9c45b12bbdecae48403df0328b08ca375ada820bdbf26ee51f3f6053e0bb6fc631ff760eb43b2503dd15e89ccaafc3a2f494e42cf47f9ca5b275d2ddd0f401afe236b16a1e2c668133ef4ca78dae3893df6c9633dea853aab723f4c3603fdb625e3f44449dd2f37e334831945cef93a7da82fbcbc5293bf7e1e11a63c3f97f6f25e268f115681ec34dc7ae498cc859167bf546db5f4f8b4f8697e8d2eabb31dc66707eaae909d0fcd1d457efe539f6a735254f01a5ba6955617465d3d1a2945a4a792c495b3ce33d3c70fb217c1850cc2e1a0d663fe0ff3f2e61bb52f9eae278ab3d086084d1296e0a246de965231d5e0114d7c9394ae1e939bbf68ed579d0e83bb2423b58eef9d377cd66485da3614c1a87555106176f177f734d296dab9fa0e3cffb72536687ad2712f31c062dbe2d5c9a04559120f3e0bc63053d5ff9221add7accb71466514fdef6fe0925377b575a1033deb277999fc4cb34b3448bd703ee512ca5fe04ef30b94836c5bd91e1e96a269a8ef5517efb27373b6aa7e595bee58b7426323129aa7a646f3d4e6b70c8145f6a2e362d08eccb5912f5a246f1a87daf7ae4264540b7f74ea0e0e5610a0cdd93a069c22aaa24bc772ed139f63af4a2bd7112b1e23faeda37e9193605dbe5944f3f3043c383694bf7b5801c1ecf7f0409eb64adf6c4595be2857e0bfe78d088cb0fb7d6fab98f13d85e0c4060f036127aea60787db6ec6028a17aa6b4ba1ea3423ca630b9a9963ef465b0d6f9a99a901d8ab18f05e78ae4ee6c662882b87a29ee274ea5d6bb668af81d9f1da0a3bc104f468113e879d51cd775ba0cd2c8c9cb0ddbae5ff6115b598487df4dc8f76c17aad3f60abc00030f72df502805a7b73be0cde7eb40a13859cc781bfba302d1b55bbafdb82091207e0c4e0561c31ef439aeb48bc06c61d00d337e04d5a31fd447a1ed94bbb0627e5eeac022a508eaaa246d075d57179beba383c8ec69e6b4517b1ad9a4b1db2fa3ab3bb0759d983fdf925e52f8e2dd7d7b5643b1f58caf50a4b2281921ea6a3b94b3945490b496dc6148d46eabf2f0d70b5231ea0f9196e629cde5376b5f794ec0da0bee2f5a277161d04d56b7aaa6daa3b3822c97f0ef151e54cdef70a3dbbd35cf86e759ef987e86362781dc7ab5be688b054e2d5b3f4ec4086820a0f0199b2da09c3b1c0985d2f6ea9641312e1c9bf3c8fd2a703ed9bddfe13bf23c507a3deaf8ab45748afc7e30a0814d9050e5d1ffd01574af40fe1c28a5258d11e4fab693b60e5eb8f4012c9ade07b34863c03c884cdb29aec2ea24fb29af283cd8ca0ffa1b9d96af383ec89809c4b2485a25b951e428ba783889a66252583b1ab38edd94f81650268435545feb2eaea60689363e5b6958e81d57d72469e19efa7074ab9e6deecd8b7d73054c8fe363fc81cf44b917a4293152f9b676eed81fa850bbea0750b6f642852463d992ef463e5e9a1751a24af942d8b9492592e9bb32e2c63992abda0429be06e9e2f33fc291d6ab1863c4473a3273e6f7399cb8e0dd7446aafae97131c87a5a367ab500faa38df50576d1c711898b7272bbaf7062105c21f930ae36e82b3967a4c2d2d1c134d7c83aa4c7a0374bf468b99c6382130d9b41fca602369d0d147dee024709ee41cce7c45643a693d7c5fa211b52c2b1f188508e7c3c580ad2c6a10cf07a8b8bb7009d2765d1e611e48e48563e9f85805207ebe9133d08ddeec4c00d8a5928082cdbf40b58fc84b836995c3691deceeccd5496f94d963460bfb6a8a468d47f8cfa54311e71e9f7512b9512df1899b81d55e990f20421c35f8106f449e5c33da1c14b5db652df2ffdd3242249fbd6f2f888b488e05ceba8b68c08ff5225812905d114a478b58791f30f0c6f307d2c20710cbd5ff270749969117182c9ac64245ae16b476138727a29355d6ef08b9a86919b10662e66b22ddc45c3da8917d79867dff849df6daa954f2679c9ac6fe8d7f33944d109bec4620d96f8a3b49cb3460918a79834a66e639132285c3c4c19693bcc0a057680b421d0d5e0ef78fb5d5448cf342819fe2639f496096d4a8d754d6012f92df9de484b2321632d57cb60f1b4762fc4430549bbad160f9d42f86d582a34ab89fe49dfbe00fcdb2855ea68d76059cd0ea0687c2503d06e9becce37f4b8064f0404da173b2827c3a5b00856f4b9b2db2f5bf2197f60f4ac8f444ace17e4897e2a9b87e0b9f4b1227a28a057fd9a55169d1f71c5dc5dbc5c46459b01a6ff424e12cb4b88cae2a120b283636265ab2caa3d23fd24329abc959da1adae8c42eae3a996a739519a3bb903a13c4edfeab397bc8fd94d052f727faf34ac6bfd37f648c9485abb19e49d2725c2948112525e322a6013e9744af96d672fbcf0a2718c2ea0353a2d9796f6e9f318910502fff36c4a894fafe051d4dac67aa7a954bca869e8d61d9f82e55784b777532b5a95909e2923c26d5f5cc1cac5812a5830b07ff0317c333ddbf349222c91d7dad5234e7ac17d3d3176836229b2d14a788f4e2f0de2503bc99a5363bc47fe02621e73ecd151e431882d29d74763657f8ceda814a9baa6014e43ac6cfc37e54b36a30958849b026149bab148cf71d6c591d7a99ba0d8bc895d08612358642ab453e3b81bf5de07908066e196e802233f7e2776e01a3ea908e35b0fd612fc9d7600c27ff2a372bcb682212dd353591bd8bd793f31a1491a41f851bcc2ca4c25ba226ca938049a0fd0ac0af6fb559017b5d53b25bd018f715c80e70c7345ad20e485186b4208ecd96f46b548ec15c83c7eda824c73ee28623492dab7caec98e6e7eddfd509bd1ffbaec755c4de111e5f65447e051dbf424d87c01b93bbbb9bae78b9157b839a3c27cbe584c02a29e674598393f700e61cb985a2b8302becc7eaf44e84f4d441cdf0f144009c4040cbb9b3bcca6bb9ac91fcd02ef355cc1280ed25aaffee6e932cd80a6a45535b82cf43799359892b59d657b49ecd032cbd037a91552780380d0e9f4dc5588a0495d00ad6b3a0b708a0221b9152cc7ff3103d412418015604c7db8dbdddbffbcb38b29fc48f4e4ffb36753fc877570842370784e42b8576956e34cc1ac58d5c34012a262dc1c79771900fe3366e2f7bd25be883051ff3b702798705547495d4a25fc8a17467300b3b243d522486955776a429a558026c277f937866d41ce3df2fe91d92044e9622a56dc61e6c1adf7a9fcbb28cbc47b79816e02e4eb387f5cd32fd7bb95d080fb75bc754afd9fc250dc79db559dc3eaaab472c2de4cdcb69f4094cfef6950e21ebf50354b17993cdc9b1552542f8a19ef7993459107d4d941449fb9b8b296694790196d8191c67ced0273b8e4a56e3e4062afafb719fd537a33296c108d7de8b9692db48677ff07758848dc6b8b8113873148ce9ed3ec7514be1b47effd6581b35219aa778ce78bb703495e3d4ee55849468b077807789433a532788092793eb0437696782100911b7af4b4f133735d2a98be9e5737d5e9b67df7ca9eacfa585741af1ef1b46e8ed413f8dc6cdbea65692395788b8a11af1b154d5db3d118dc02116767871e9e5aaa5ec3f7e790e694d5503b8746798af8deee5d23693a13d640f02d368a41949a362d4ae1c9eb0898f6d74a05c3e774f2aca00d9b1c7d2a2d0ab438fdcd4b005d68199c8b17f5691fb7fb37179004df8d150f302454069a4639c44c05b423f412b4f88ea1ab46c12f5043f2ae037c62a4308c088cd4e0f1433c94b93311da8ca451b499aaa655a75d8de6ecdc5f75476a37ab45d9857509bb91364fb316301423215e3ce70dae70b8ac3e651a110d257f8276de7264a8303f57c6842d4c96949aefd04a97fb30e0842e01a0592d77f4141414d7ceaeb267d99035af9299b1283e2b0114d3bccc8d23abafefacfd33a48ca8c04f94bb2c4ee313896a292e977310b75d8fd0ebceb72eb769708e941c39b0053526bccdb590506462bf5fe4bcb485e5d5d647de207eba7739754f39e3609199acd08d0c5397cc9a0a47a6e304b9c3b80c81bfc19ef2c88a2ff05bd1e6a2880ce84479dacad103d168e6ffddf2fd3679c8c90b0862ca9ee0aa78f867a215b547727a03e79196f48e4728bf350e2fdfd633f57a4e0eea6a52f0a1d607b9ff82bbcf4e7b43b94292aaae08e448c93498b29ad0148cacb96fd6685297bb560b90ff885bf90feda7c021a8a28a65aa50d08518b5302e404ff58fb95a3c259d5faf873da3b67361be694bf6ddb2a2c8da54eeb1575c4cde77a6374948644f4e3cfa377b8ecee501b0fe93e5910573df5e7a8549e8df15e86ba7d9763aa2debc4037709da6e7ac9b8793e8e0943500318dd69e565470835b59a125c7d993165350b27d283a367c2ab660f4b0e665cdcc569d6553ecdf8192bc3a51d47c6222d1cce5550781c183590832e41809428c1ccdd22dc5f58699c108370400027cd8270fa425b1d5271d42d5e0e2e23166ecefa3fbbd97a63eef78401d275253bf61e63d4a88139b82756749949c35c71f6f8b5f30fbaed2bda75b19598cd7079057c5cd14871f53e426c031eec27c063f0b814609c4da654ea8ab22f241581219c91ff406a6dfc0ece748bee8602e596b3fe0b02e6b77dbefda6cdeaedb442265923155c66bb29a514b58688d386342d882201d32fa5891ffa28a13fee1a5aac30976e6d6f61cc9849ea7a620118db84eecd5a88a48fe2b6de523b2f65bb67083b49067b189faac5b5ba69e377fc9d7ef9f44f4dc89b684fede7938420d65f93e93f55b7e46ab404bafa8815b9654ca446f3005ff0135657425e46209a8a37c054befa391117040ade3fb4d849e042efcac0fce65bf67071dcfebf6d8913631eb8bebcebc63456302583a63f60d0fa4c32567611401bbde66b3ffeae53f68b4ba52ab5f1df5094443215aca569f0890e7829284b73892bca261a97ee33d03e89d4f562a523648fbba1ca8b441f5a476686c164a96f61a65d3705457b7021ac5786660ae5f851895aa50543bf5cb663eb75ea3cd33074fe4f5c021545ac956087935dc8a49ddba13dbc7d674ff8c42b9b24289bb25eb5c5f3aebc33352830bc20c02b44ca5918dd5a72653364f1f38c2b429946d2639311b69e8fc0904158aa2b9320883ba782ba0211125160860f533f97fd2733007ee428a31c0ac502916ac5445d3b0822fbe19431cbf03a392e1cf84615cb9c1916761b5705ef81b149dc8f35e132ce5d4803675cc298eab1af9e4864bf3c75b92daff8c802943f80e0a66f7a3488a5697bcd661826e2c1b7dd284bcefb0c655ebc50e9228c3a049433a10b94488ec5dcdcf35ec53f451ae92d8f7aaa35fc2380b6f8c8fa661bab660b63bd96db6b3bd2a8f82f43069d156688d1ee75d8293be8ceda96160a851564f5d8012474fcd67d103e64578e676e2b8859628d9b4373553989dd9fbc916466951e3d4fa29af30b3a3906d515be8ef5e3fcd8a3987e7e5e45b4829ef8578c7c3d3b4d32dd32327b661df73b0fc917c6a8047e34e98436e99f503cfe2219f2a8e255649f0f219ba5e7dcd37b96119b7a443ec6df8359f7a6ba5a3daa2a1126740900e0960f498cd08521e4f8f5a30ce1b05da4afbb1a5c26f30b19f760e411661f2688aba18e2756938aacf95f67efff4a2b87c62d45f8320cd961d44b0bb4475ff3e2547333ffbe9fd8c85fe53cce48862ae9812410d7d6cea2c74e26dd36ce4d3f92b733013dfc4dabd57bd7971ca4a663aeb088fc255dda9f3f6ec5690d88ef5fffc92089780ab75a2ea14a74c039474aa64222b1a15391ef892529e3ee742fa94b1ef2f25261f51144062689606753e546f8a058e799c314f7929beb9413f5fde6a0550c176647272a65f357cacb29b65596791879a53b41b36caa000242e3dcbd70ec9577a185675b6ffb5235654204544d7b61db2447e6adab9bf29fd62d2301f6c4398a70b663611f6bddaa3573857964f9cc72e19c6181ad53ac4f16b0e08e63343374c50a7bbd1617cc4a666eb7e7e609246c906b1e12ec417c76ff6de2a627ea37d25ebedfc4f7af7d3af15e4b93cd2fe16b9477425a0efd32e089a0dc7b03e0ccef27abf637286a3701487dc99b6de092c682c27c8977bc9af38acb4c634a9a2cb16da8244237e04153ba18109b80c6be1ccb2c7bb5b43bf14f7a627448cac9770c46642af02f0878c15d60b50acbd75d3151dd22c2c996a43bcaaafffd1eb0f3595a3fcdcf1ebaffdc246176609be28f0f803e1a04a97f5c2da7c5204cda8e3328543db57614a11c242c1e81eb16aa8921e87f83e0d817198053bd7f5c904f616ede38a866ad98472114b5d1cad5a278b0c9c4dff4dc37b14353321c5309da0cb51bd54045434a215cf1f8df762431235a55002be0c408cbbd145dab84255cbb82606ee653daccec32bbb37b28b659086098f38aac51b682fdb05744c3c8c07ef95e6cff62d7360f7ca8ebefa069f3d0ed818d6af30ac2ae7bed1716bb11c09e5a4fceb2f9c4584ae70fe9262aeee1b6ddd6420fd089c61dd281f2ee968b88f433c502264bf5321cd2212ffaac594a77c4ac81ce90a1f6b96fb73c45ba7245fe10cffc3e53e7c0fbe6f097df1d657818c11ed6cdd57e2859bd3d997fcf084635245a49567383beb68281d1c0bfdcb95627eb976b325d3af31851f8aedf12ec69197bdc90c9511f57e8faff2dc4089a367b22a311f1755abe33a768bb9d5f6e416c38d84c947e109987d1820bd8673ef7e23a797ada825d43fe4917303ace54b9351f67ffbb82ebc028bca8aae7e5002d703ad48278509a725f750e1756cfd7ff3a59653c239a40c386863482c170c819546f4d728774425d9852307bd0c871aae917068aabba363c9e176a7fbabd9976ec8a2ae434009fc16cbcd6f2aab9f573452dcae4973d0ecb088181fed534aadeb489499e046cc629e047f64f3817ef5c095e8d029daf12bb2c5738fca1fea9e40b0fe5d3487921f0e773f42f24774fb504b0b66039b1626c57b0601645004ee8e9bf229f86ab34839907c9e9331e39db5146a98369c7b30084ea79a100cf79a2c4b76a7d7b4bf94ebd3ca8756feb47aa3db67e3efe346bcf2e086e23951fc765937312b4437f24e1dcabccc949485e2d1990fbbe2a396053d84fdb53aea6d98a5ddd0c746e304c5fba9495221c8cc823ec6539a2c6c8a193dd1c898e7209ae5c28963bb677191821dc0664943ac240c00dd0c39047efc3ee3fe978dc868bbec3aa720534fa6ded9b80dfb90ef30aed74d8ac1e21019372c5596edaac95696231d15935e54bf29023c6483090a6ec0db09c5b672997f186bb27fea9cdf0604deef5d0f07a392d650403eb56f80590b25edc1f36fa1b6d9b04693e37804e9000c6ae6976c959bfe35eb5e1dcf7c16405b54432e3bd037c7651e95eabfd02d80e31dca5f297271604799cc11988f1a50b343daefa5e5b63edd3dcaa7ecbc988eb429efbedc809e6a0b5c356138987ef441f0fe754ffb5026ccfbd99fcc39c25e5674e83a792eaecd3025fe11a21efddbd86d8b809db49824df0d79e6f3df60d81e7d6fdd49330f90e6c30053e7d9fd32ae0e36911203086b915abdf0e8c7a204facde3c01e37e97d7e9664827f4b6081d1b8397a163f6df3f7bc021e81f1d74ceaea32fe05884b885d6c1a67b8136160f86f1e21d105fe4fb8fc32924bb79f15d1e4c846bfc01e37b1c27bbd7a698017dd34d3a429a7189cec6487480e3f3688878e40a417bce3ed8aff03bf801e9301e112838569a5aff0ce5ded788b9ba6cd140cf4a60bbd71be8915558566ee421041a2bdbb4e80118024ff3ba9e52882d1ff13bfee12b3a815753b35c1dc7df3b86486bf9b43da0c560104967f83eb1699a4f7ecbfef99f4bba29cc89c29170ce697dccb1a70e718cdba4b5f3eb860f2bf01d1de562d6f32c42a0a579d16cde93fbd1e9988003bf471d6e292ba49164871f12a2076f6709c10aa02fc2008684f3850dc019529f520840a24c9303767f80e6b83efad36e615be859533bd1a1e7f6b8632513a8f84d8d0775078f30ecc84a93b43655e8402c45e4ab733f0486b3ade3a1868053168bba55df9fc968d0cb1b0c731e9322fea29e7d74c413c3c7bee236ed08ab5106d8109ee838c6da0872474d7152b1790921119136b376950e50746128e87b737878e9d1755a21f7a2af500029d8c53e9914597b6887ccf959abccd2db6ebe67d7cdb7236bfe66dca1a50efa8cf1206b42609412152178f4843a50f3765bc8b11a27e4bc202683e28cf758233390f90baa447583f0cfba79dff3ab57ed7b3d59316098c02717d8f9ce5588ac670e59c03fbd3147127735f6a9d4d4c92d58c061f974cd8a4e8e4397a7ed7c31881f24680c0a4083eca42ff5cac60350c4c95132bb06bd8c9c2a20239292a4425815a7445bd3a0497f2af98f15dcb080c961d263e52632bedd9d30519dac4b7985af24f48edbac1d99938bc8098fac11d06f4ada562f72924a7328486cf36841761060e5aab61e081acc2b2f3386901bdf14d84c5670727d215b576e5660605ba3fe3aefdd56c1e024c84515e7ba3804268060844913f5314842b13688c797d0d1c33865f76b0a8b6edbe01961e54cc811b54ef7e5d989b424b633106e198fccc5573559c5ddabdf1413b077c494be8707e89e2f7196dc463f5363fd9d49ab38bfc85ca2f709470a057112b5b9ac0ed039c8dc66ddb6a4bc750462e7a3eed3f83059b40c83d40885347d4c49f306da416c826d72419de6c72dad5392f9fadc70e9f89cd03f3619cf41217fa814d131a07b123109776f8fd6a51e78308b3cdac5cdf7113cc4611a2e59c08de55480d90a108c7828a2b3d605a8b61c242fcbf76b014735fbeab561915d8be6e5d5f11bc3d9a515ce83ca1df97641498cbc4ae88e911e2a70c6e83901e28ed3915df044ebe6f3e1f9b9ee74fe741fb47337dfc0ab633bf41a5e3f9654e030aa1bf0fd84ebba967bab49338a99b79aed042c2447a2b7d6ccedf9f70ebb1cfde0e6100290d9b7b8dc376b0f8e94f4efb0172c7d431fbe95a7c52a283a320a7bd22456b03de7fe92359b01f5bc2d210213a62e933938030145ef4e069396efe2d40bbc48be09ed88d6d06da93243ef64005bcae48df6e8dc86833f29794697da3d0b555e542fd571038691a70871ffe1f3e95594aa22ade14828611b7c799f841f32f8cbc36455a5e13ab813066b7fae94c6c903eb5294069283cd209139e9ac826189f0070945780b3074794cec715c074e5c16977ccef042df6b42de691722fc1d5c14530403fff1b4d67fcd1250170fe914d1e4ff47204019b1feda3290dc5b763934461d7192899e29d875d214441ae7d8463773ec88569b8a394dea9e6fc1d6e49272bb7de813a5396537ec970eaa0c4840667f44f27b029012211aa7d0b0ee0a133562d7ed610e0690457b1263e20a160f76db18c14c1553211b0830b71477d0f66f9aeeb3d29091ef7405e2c6f79a274806f45333e16ce4aaf338a8ea6e3bf5ecaf3e29f4328223c6cb49ba642c5e279fde3ed3c80f552d6f50b4175b20abf58fe189e490571abe7fb0a8d85a94f26a8152c4e2aad805ecdb897bc3886a1efe6452ca49764c72b189881e4cf6bcf367d178fdb102f17f96ee18ba6e8b810daf665f4924c21a585602c2b588f62c0ee754ee79ff32cec7f218c5380a3bb2cfda6b35552c13d43c08d9faba1d4138970b5edb8baed1283e9e14ecfcac523dd1080b042af20b6d655ccc7836605f1a9540c85bd166acd88d171ed7d86b07c20f46fcd9d7975c0deab77dbf76ebdbddcd0b0a299062138f59afe2f343a75139980f6e7ae93c55e462c4689ba2bbafaa92f80aa4d20976104094c1af99853d03a5ff521e6af5df62d25e59b611f4b89031ae23a894920394124a29e010a6b9551f19e61fc23a8c35cf374fafab5b02fd061e85d796d8bfce24b0793f656696ba22546fe2c12fce0003e1d93669d14ac07e1b434cd9dc9cd4a1ace5cb7ca71eba2d51d37562ca21a83970a5a2c175fb0bd412c130e7f08058cda8c10cc8ed7aca6fd4d4f29a07109d6d7d1c7e6d5d1ff2f1b173e97b51212d60042c8ad08b41e671a193db2aa87efaa53737a3836b516450e742ceee00a03a52d30426ab8c9de1d95a0607f2a887796b9114781961e2fc35ec37e86e5cb2b1e4d28b89dce5b44d922a4060bbba3ad1c61556235664379deb6818033ff57e769bf9ec599dab83ea776c745d4e9ba325c7eb59670509a7324d61fc690e7fa21a7c45b1ecad44fa3ff9d6b411a50eaa78ec578d040736e5e9500a544caedd4a76437986d35eade7f51ae87a7adbf2b36e05f2c2a6092dc9ea3c07c4f62e4d93acca514fe1cda0458446323bfe67cbfbacc08473f362068f42524bcbed1b09400fe94889e27bfffd5164aa8a47fe6365eff48682fe43c4691c8e58474a2a0d50ff6f1f54c38756816888a57ee2af9de039c0645cc6481207d345e1e2ee62ccc5e264de67eb24c3fc2e4332b34ed8359fcffc488ed553afa29eab6d213a2a99e0061a9ee89ebef6c26e1fe199e0b7e3c2b5883fd2bcf863e407f3170a3a6d0c3402ba09904ad0cae357664dd1b0fcade4542f8ac409915abacf4bcaec3b62336b587fbb041ff8626e38d4d6c49728e6ab9231c750c8c07a2c7922411ae4eaf5e7987c4e267dab1b39e97f4b27e6cb8d1bd6f82f2a23c0b1da418d634e3c4d0b5847c30b4572a3baf261a36d2060ac769131b212d1a3da10fed34eb515df65a7bba311b4319d860c072e76c72eed5b52c926809eb33068ed1fa81d262d2d487806367966e8c040b3b3ba28f6ca9589849d8214081f751126e87e2d7a09eff0aa8d5c261f143fa4eef8ce5b9b18e283907a57c13be62cfc9cd430c4b653924539fc99dcbf8d61e9c7580c2733f54f30e0ae1dedef98a57bcfa450ff7364e8e159f6cf4c91b5f264cde8217b8cc42fcf8ee11e457bdbefadc3115148415ee9aae4d16a9b86471d7de2f2bb27c95749f18c85f8d4b5b3c2ad0e2afde77d77a8157886d0be89b043af6fce4329982813673cd7da788b95436a060965cef8c50</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> school </tag>
            
            <tag> simulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NTT 学习笔记</title>
      <link href="/posts/1c8a7eaf/"/>
      <url>/posts/1c8a7eaf/</url>
      
        <content type="html"><![CDATA[<h2>前置知识</h2><ul><li>FFT</li><li>阶与原根</li></ul><h2>介绍</h2><p>数论变换（Number-Theoretic Transform, NTT）是离散傅里叶变换（DFT）在数论基础上的实现。它利用模算术替代了复数运算，从而避免了 DFT 的精度误差问题，并且在整数运算环境下通常速度更快。</p><blockquote><p>实际上，NTT 指的是数论变换，而 FNTT 指的是快速数论变换（Fast Number-Theoretic Transform, FNTT）。但竞赛圈中的 NTT 一般指的是 FNTT。注意本文会严格区分。</p></blockquote><p>在算法竞赛中，当题目要求在特定模数下计算多项式卷积时，我们就需要使用 NTT。</p><p>FNTT 的算法结构与 FFT 完全一致，但其数学基础从复数域转移到了有限域（模算术）。</p><p>NTT 的使用受限于模数的选择。一个常用的 NTT 模数是 <code>998244353</code>，我们在文末会解释其特殊性。</p><h2>阶与原根</h2><p>在讲解 NTT 之前，需要理解原根的性质，因为它将扮演 DFT 中单位根的角色。</p><h3>阶</h3><p>若正整数 <span class="math inline">\(a,p\)</span> 互素且 <span class="math inline">\(p &gt; 1\)</span>，则满足 <span class="math inline">\(a^n \equiv 1 \pmod p\)</span> 的最小正整数 <span class="math inline">\(n\)</span>，称为 <span class="math inline">\(a\)</span> 模 <span class="math inline">\(p\)</span> 的阶，记作 <span class="math inline">\(\text{ord}_p(a)\)</span>。</p><p><strong>性质</strong>：对于 <span class="math inline">\(i \in [0, \text{ord}_p(a) - 1]\)</span>，所有的 <span class="math inline">\(a^i \pmod p\)</span> 的结果互不相同。</p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>假设存在两个整数 <span class="math inline">\(j, k\)</span> 满足 <span class="math inline">\(0 \le j &lt; k &lt; \text{ord}_p(a)\)</span> 且 <span class="math inline">\(a^j \equiv a^k \pmod p\)</span>。 因为 <span class="math inline">\(a, p\)</span> 互素，所以 <span class="math inline">\(a\)</span> 存在模 <span class="math inline">\(p\)</span> 的逆元。两边同乘以 <span class="math inline">\((a^{-1})^j\)</span> 可得 <span class="math inline">\(a^{k-j} \equiv 1 \pmod p\)</span>。 因为 <span class="math inline">\(0 &lt; k-j &lt; \text{ord}_p(a)\)</span>，这与阶的最小性定义矛盾。</p></div></details><h3>原根</h3><p>设 <span class="math inline">\(p\)</span> 是一个素数，整数 <span class="math inline">\(g\)</span> 是<strong>模 <span class="math inline">\(p\)</span> 的原根</strong>，当且仅当 <span class="math inline">\(g\)</span> 模 <span class="math inline">\(p\)</span> 的阶为 <span class="math inline">\(\varphi(p) = p-1\)</span>。</p><p><strong>性质</strong>：若 <span class="math inline">\(g\)</span> 是模 <span class="math inline">\(p\)</span> 的原根，则它的幂次 <span class="math inline">\(g^0, g^1, \dots, g^{p-2}\)</span> 在模 <span class="math inline">\(p\)</span> 意义下构成了模 <span class="math inline">\(p\)</span> 的既约剩余系，即遍历了 <span class="math inline">\(1, 2, \dots, p-1\)</span> 的所有值。</p><h2>数论变换 (NTT)</h2><p>DFT 的核心是利用单位根 <span class="math inline">\(\omega_n\)</span> 的性质。在 NTT 中，我们将寻找一个在模意义下具有类似性质的替代品——这就是原根的作用。</p><p>设 <span class="math inline">\(g\)</span> 是模 <span class="math inline">\(p\)</span> 的一个原根。我们定义 NTT 中的 <strong>主 <span class="math inline">\(n\)</span> 次单位根</strong> 为： <span class="math display">\[g_n = g^{(p-1)/n} \pmod p\]</span></p><p>这个 <span class="math inline">\(g_n\)</span> 具有和 <span class="math inline">\(\omega_n\)</span> 非常相似的性质：</p><ol type="1"><li><p><strong>周期性 (消去引理)</strong> <span class="math display">\[(g_n)^n = g^{(p-1)/n \cdot n} = g^{p-1} \equiv 1 \pmod p \quad \text{(根据费马小定理)}\]</span></p></li><li><p><strong>折半引理</strong> <span class="math display">\[g_{2n}^{2k} = g^{2k(p-1)/2n} = g^{k(p-1)/n} = g_n^k \pmod p\]</span></p></li><li><p><strong>对称性</strong> <span class="math display">\[(g_n)^{n/2} = g^{(p-1)/2} \equiv -1 \pmod p \quad\]</span></p><p>因为 <span class="math inline">\((g^{(p-1)/2})^2 \equiv 1 \pmod p\ \text{且} \  g^{(p-1)/2} \not\equiv 1 \pmod p\)</span></p><p>因此，可以推导出最重要的蝴蝶变换性质： <span class="math display">\[\begin{align*}(g_n)^{k+n/2} &amp;= (g_n)^k \cdot (g_n)^{n/2} \\&amp;\equiv - (g_n)^k \pmod p\end{align*}\]</span></p></li></ol><p>我们发现，<span class="math inline">\(g_n\)</span> 完美地复刻了单位根 <span class="math inline">\(\omega_n\)</span> 在 DFT 中所需的全部性质。因此，我们可以将 DFT 算法中的 <span class="math inline">\(\omega_n\)</span> 替换为 <span class="math inline">\(g_n\)</span>，复数运算替换为模 <span class="math inline">\(p\)</span> 意义下的整数运算，从而得到 NTT。</p><h2>快速数论变换 (FNTT)</h2><p>FNTT (Fast Number-Theoretic Transform) 就是 NTT 的快速实现，其算法结构与 FFT 完全一致，同样是基于分治思想和蝴蝶变换，时间复杂度为 <span class="math inline">\(O(n \log n)\)</span>。</p><h2>快速逆数论变换 (IFNTT)</h2><p>IFNTT (Inverse Fast Number-Theoretic Transform) 是 FNTT 的逆变换，用于将点值表示法还原为系数表示法。</p><p>与 IFFT 类似，IFNTT 的实现只需要在 FNTT 的基础上做两处修改：</p><ol type="1"><li>将变换过程中使用的 “单位根” <span class="math inline">\(g_n\)</span> 替换为其在模 <span class="math inline">\(p\)</span> 意义下的<strong>逆元</strong> <span class="math inline">\((g_n)^{-1}\)</span>。</li><li>变换结束后，将结果数组的每个元素都乘以 <span class="math inline">\(n\)</span> 在模 <span class="math inline">\(p\)</span> 意义下的<strong>逆元</strong> <span class="math inline">\(n^{-1}\)</span>。</li></ol><h2>模数的性质</h2><p>因为 FNTT 的实现依赖分治算法，要求多项式的长度必须为 <span class="math inline">\(2\)</span> 的幂次。而 <strong>主 <span class="math inline">\(n\)</span> 次单位根</strong> <span class="math inline">\(g_n = g^{(p-1)/n} \pmod p\)</span> 要求指数一定要是整数，即 <span class="math inline">\(n | P-1\)</span>，所以 <span class="math inline">\(P\)</span> 必须满足：</p><p><span class="math display">\[P = c \cdot 2^k + 1\]</span></p><p>其中 <span class="math inline">\(k\)</span> 要足够大，至少要大于题目中最大多项式长度的幂次。</p><p>而 <span class="math inline">\(998244353 = 113 \cdot 2^{23} + 1\)</span>，符合条件。</p><p>最后有一些常见的 NTT 模数：</p><ul><li><p><span class="math inline">\(167772161 = 5 \cdot 2^{25} + 1, \ g = 3\)</span></p></li><li><p><span class="math inline">\(469762049 = 7 \cdot 2^{26} + 1, \ g = 3\)</span></p></li><li><p><span class="math inline">\(754974721 = 45 \cdot 2^{24} + 1, \ g = 11\)</span></p></li><li><p><span class="math inline">\(1004535809 = 479 \cdot 2^{21} + 1, \ g = 3\)</span></p></li></ul><h2>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">3e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> P = <span class="number">998244353</span>, G = <span class="number">3</span>, IG = <span class="number">332748118</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> r[N];</span><br><span class="line">ll a[N], b[N];</span><br><span class="line"><span class="type">int</span> limit = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fp</span><span class="params">(ll x, ll p = P - <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>) res = res * x % P;</span><br><span class="line">        x = x * x % P;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">add</span><span class="params">(ll x, ll y)</span> </span>&#123; <span class="keyword">return</span> x + y &lt; P ? x + y : x + y - P; &#125;</span><br><span class="line"><span class="function">ll <span class="title">sub</span><span class="params">(ll x, ll y)</span> </span>&#123; <span class="keyword">return</span> x - y &gt;= <span class="number">0</span> ? x - y : x - y + P; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FNTT</span><span class="params">(ll *a, <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; limit; i++)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; r[i]) <span class="built_in">swap</span>(a[i], a[r[i]]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mid = <span class="number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> gn = <span class="built_in">fp</span>((type == <span class="number">1</span>) ? G : IG, (P - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i += mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">            ll g = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; mid; j++, g = g * gn % P) &#123;</span><br><span class="line">                ll x = a[i + j], y = a[i + j + mid] * g % P;</span><br><span class="line">                a[i + j] = <span class="built_in">add</span>(x, y), a[i + j + mid] = <span class="built_in">sub</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> inv = <span class="built_in">fp</span>(limit, P - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) a[i] = a[i] * inv % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="keyword">while</span> (limit &lt;= n + m) limit &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; limit; i++)</span><br><span class="line">        r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">FNTT</span>(a, <span class="number">1</span>), <span class="built_in">FNTT</span>(b, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) a[i] = a[i] * b[i] % P;</span><br><span class="line">    <span class="built_in">FNTT</span>(a, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + m; i++) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFT 学习笔记</title>
      <link href="/posts/837dcf3e/"/>
      <url>/posts/837dcf3e/</url>
      
        <content type="html"><![CDATA[<h2>前置知识</h2><ul><li>复数运算</li><li>单位根</li></ul><h2>简介</h2><p>快速傅里叶变换（Fast Fourier Transform，FFT）是一种用于在 <span class="math inline">\(O(n \log n)\)</span> 时间内计算离散傅里叶变换（Discrete Fourier Transform，DFT）的算法。在算法竞赛中，常用于快速计算多项式卷积。</p><h2>朴素算法</h2><p>例如有两个多项式，<span class="math inline">\(F(x),G(x)\)</span>。</p><p>设 <span class="math inline">\(F(x)\)</span> 次数为 <span class="math inline">\(n\)</span>，<span class="math inline">\(G(x)\)</span> 次数为 <span class="math inline">\(m\)</span>。</p><p>显然，要求他们的卷积 <span class="math inline">\(H(x) = F(x) \ast G(x)\)</span>，可以用 <span class="math inline">\(O(nm)\)</span>（即 <span class="math inline">\(n^2\)</span> 级别）的复杂度解决：</p><p><span class="math display">\[H(k) = \sum_{i=0}^{k} F(i)G(k-i)\]</span></p><p>但，这实在太慢了，而目前看来都没有什么很好的做法，我们不妨改变一下多项式的表示方法。</p><h2>点值表示法</h2><p>平时我们用的 <span class="math inline">\(F(x) = a_0 + a_1x + a_2x^2 + \cdots + a_{n-1}x^{n-1}\)</span> 被称作 <strong>系数表示法</strong>，它可以用一个向量来描述：</p><p><span class="math display">\[\mathbf{a} = \begin{bmatrix}a_0 \\a_1 \\\vdots \\a_{n-1}\end{bmatrix}\]</span></p><p>现在，我们可以取 <span class="math inline">\(n\)</span> 个互异的 <span class="math inline">\(x\)</span> 值（记为 <span class="math inline">\(x_0, \dots, x_{n-1}\)</span>），并计算出对应的 <span class="math inline">\(F(x)\)</span> 值，那么，就构成了 <span class="math inline">\(n\)</span> 组 <span class="math inline">\((x_i, F(x_i))\)</span> 的点对。这就是多项式的 <strong>点值表示法</strong>，它有许多特点：</p><ul><li><strong>唯一性</strong>：对于次数 <span class="math inline">\(&lt; n\)</span> 的多项式，任取 <span class="math inline">\(n\)</span> 组互异点对，多项式唯一确定。</li><li><strong>方便计算</strong>：<ul><li>加法：<span class="math inline">\((F+G)(x_i) = F(x_i) + G(x_i)\)</span>，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li>乘法：<span class="math inline">\((F\cdot G)(x_i) = F(x_i)G(x_i)\)</span>，复杂度 <span class="math inline">\(O(n)\)</span>。</li></ul></li></ul><h3>瓶颈分析</h3><p>虽然点值表示法下的乘法很快，但是：</p><ol type="1"><li><strong>系数转点值（求值）</strong>：如果我们随意取 <span class="math inline">\(n\)</span> 个互异的 <span class="math inline">\(x\)</span> 值，代入计算一个点的值需要 <span class="math inline">\(O(n)\)</span>（秦九韶算法），计算 <span class="math inline">\(n\)</span> 个点则总共需要 <strong><span class="math inline">\(O(n^2)\)</span></strong> 的复杂度。</li><li><strong>点值转系数（插值）</strong>：从点值推回系数，一般需要 <strong><span class="math inline">\(O(n^2)\)</span></strong> 的复杂度（拉格朗日插值）。</li></ol><p>如果只用朴素的方法，总复杂度依然是 <span class="math inline">\(O(n^2)\)</span>，并没有变快。 我们需要一种特殊的取点方式，使得“求值”和“插值”都能在 <span class="math inline">\(O(n \log n)\)</span> 内完成，这就是 FFT 的作用。</p><h2>离散傅里叶变换 (DFT)</h2><p>专业地说：</p><blockquote><p><strong>离散傅里叶变换</strong>（Discrete Fourier transform，DFT）是傅里叶变换在时域和频域上都呈离散的形式。 —— OI Wiki</p></blockquote><p>在算法竞赛中，我们可以简单理解为：它是一种选取<strong>特殊的点（单位根）</strong>，将 <strong>系数表示法</strong> 转到 <strong>点值表示法</strong> 的变换。</p><p>它是一种 <strong>线性</strong> 变换，可以用矩阵乘法来表示。</p><p>设系数向量为 <span class="math inline">\(\mathbf{a}\)</span>，变换后的点值向量为 <span class="math inline">\(\mathbf{y}\)</span>，则 <span class="math inline">\(\mathbf{y} = V \mathbf{a}\)</span>：</p><p><span class="math display">\[\begin{bmatrix}y_0 \\y_1 \\y_2\\\vdots \\y_{n-1}\end{bmatrix}=\begin{bmatrix}1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 \\1 &amp; \omega &amp; \omega^2 &amp; \cdots &amp; \omega^{n-1} \\1 &amp; \omega^2 &amp; \omega^4 &amp; \cdots &amp; \omega^{2(n-1)} \\\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\1 &amp; \omega^{n-1} &amp; \omega^{2(n-1)} &amp; \cdots &amp; \omega^{(n-1)(n-1)}\end{bmatrix}\begin{bmatrix}a_0 \\a_1 \\a_2 \\\vdots \\a_{n-1}\end{bmatrix}\]</span></p><p>其中，<span class="math inline">\(\omega = \omega_n = e^{i\frac{2\pi}{n}}\)</span>（<span class="math inline">\(n\)</span> 次单位根）。</p><h2>快速傅里叶变换 (FFT)</h2><p>快速傅里叶变换（Fast Fourier Transform，FFT），并不是一种新的变换，而是利用单位根的性质（周期性、对称性），高效计算上述 DFT 矩阵乘法的算法。本质思想是<strong>分治</strong>。</p><h3>分治法</h3><p>FFT 的核心思想是分治。我们就 <span class="math inline">\(n\)</span> 为 <span class="math inline">\(2\)</span> 的整数幂的情况进行讨论（若不足则补 0）。</p><p>我们的目标是计算 <span class="math inline">\(x\)</span> 取所有单位根 <span class="math inline">\(\omega_n^k\)</span> (<span class="math inline">\(k=0, \dots, n-1\)</span>) 时 <span class="math inline">\(F(x)\)</span> 的值。</p><p>对于多项式： <span class="math display">\[F(x) = \sum_{i=0}^{n-1} a_i x^i\]</span></p><p>我们将系数按照下标的 <strong>奇偶性</strong> 分类：</p><ul><li>偶数项系数：<span class="math inline">\(a_0, a_2, a_4, \dots\)</span></li><li>奇数项系数：<span class="math inline">\(a_1, a_3, a_5, \dots\)</span></li></ul><p>将 <span class="math inline">\(F(x)\)</span> 重写为： <span class="math display">\[F(x) = (a_0 + a_2 x^2 + \dots + a_{n-2}x^{n-2}) + (a_1x + a_3x^3 + \dots + a_{n-1}x^{n-1})\]</span></p><p>在奇数项部分提公因式 <span class="math inline">\(x\)</span>： <span class="math display">\[F(x) = (a_0 + a_2 x^2 + \dots) + x(a_1 + a_3 x^2 + \dots)\]</span></p><p>如果我们定义两个新的多项式 <span class="math inline">\(G(x)\)</span> 和 <span class="math inline">\(H(x)\)</span>，大小仅为原来的一半（项数为 <span class="math inline">\(n/2\)</span>）： <span class="math display">\[\begin{align*}G(x) &amp;= a_0 + a_2 x + a_4 x^2 + \dots = \sum_{i=0}^{n/2 - 1} a_{2i} x^i \\H(x) &amp;= a_1 + a_3 x + a_5 x^2 + \dots = \sum_{i=0}^{n/2 - 1} a_{2i+1} x^i\end{align*}\]</span></p><p>那么原多项式就可以表示为： <span class="math display">\[F(x) = G(x^2) + x \cdot H(x^2)\]</span></p><p><strong>这是 FFT 最关键的一步。</strong> 我们可以利用单位根的性质，将求 <span class="math inline">\(F\)</span> 的 <span class="math inline">\(n\)</span> 个点值的问题，转化为求 <span class="math inline">\(G\)</span> 和 <span class="math inline">\(H\)</span> 的 <span class="math inline">\(n/2\)</span> 个点值的问题。</p><p>对于 <span class="math inline">\(k &lt; \frac{n}{2}\)</span>，我们要计算 <span class="math inline">\(F(\omega_n^k)\)</span> 和 <span class="math inline">\(F(\omega_n^{k + n/2})\)</span>：</p><ol type="1"><li><p><strong>代入 <span class="math inline">\(x = \omega_n^k\)</span>：</strong> 利用性质 <span class="math inline">\(\omega_n^{2k} = \omega_{n/2}^k\)</span>（折半引理）： <span class="math display">\[\begin{align*}F(\omega_n^k) &amp;= G((\omega_n^k)^2) + \omega_n^k \cdot H((\omega_n^k)^2) \\&amp;= G(\omega_n^{2k}) + \omega_n^k \cdot H(\omega_n^{2k}) \\&amp;= G(\omega_{n/2}^k) + \omega_n^k \cdot H(\omega_{n/2}^k)\end{align*}\]</span></p></li><li><p><strong>代入 <span class="math inline">\(x = \omega_n^{k + n/2}\)</span>：</strong> 利用性质 <span class="math inline">\(\omega_n^{2(k+n/2)} = \omega_n^{2k+n} = \omega_n^{2k}\omega_n^n = \omega_{n/2}^k\)</span> 和 <span class="math inline">\(\omega_n^{n/2} = -1\)</span>： <span class="math display">\[\begin{align*}F(\omega_n^{k + n/2}) &amp;= G(\omega_n^{2k + n}) + \omega_n^{k + n/2} \cdot H(\omega_n^{2k+n}) \\&amp;= G(\omega_{n/2}^k) - \omega_n^k \cdot H(\omega_{n/2}^k)\end{align*}\]</span></p></li></ol><p>也就是说，只要知道 <span class="math inline">\(G(\omega_{n/2}^k)\)</span> 和 <span class="math inline">\(H(\omega_{n/2}^k)\)</span>，就能推导出 <span class="math inline">\(F(\omega_n^k)\)</span> 和 <span class="math inline">\(F(\omega_n^{k + n/2})\)</span>，即：</p><p><span class="math display">\[\begin{cases}F(\omega_n^k) &amp;= G(\omega_{n/2}^k) + \omega_n^k H(\omega_{n/2}^k) \\F(\omega_n^{k + n/2}) &amp;= G(\omega_{n/2}^k) - \omega_n^k H(\omega_{n/2}^k)\end{cases}\]</span></p><p>注意到分治左右两边长度应当相等，所以长度只能是 <span class="math inline">\(2\)</span> 的幂，不足要补齐。</p><p>另外单位根是复数，由于 STL 提供的 Complex 常数巨大，需要手写。</p><h3>倍增法实现</h3><p>假设你轻松的写出了分治法的 FFT，你会发现你 TLE 了。究其原因是递归的常数太大了，我们考虑不用递归。</p><p>我们考虑递归到最底层时，系数数组的顺序是怎样的，以 <span class="math inline">\(8\)</span> 次多项式为例：</p><ul><li>第一层：<span class="math inline">\((x_0,x_1,x_2,x_3,x_4,x_5,x_6,x_7)\)</span></li><li>第二层：<span class="math inline">\((x_0,x_2,x_4,x_6),(x_1,x_3,x_5,x_7)\)</span></li><li>第三层：<span class="math inline">\((x_0,x_4),(x_2,x_6),(x_1,x_5),(x_3,x_7)\)</span></li><li>第四层：<span class="math inline">\((x_0),(x_4),(x_2),(x_6),(x_1),(x_5),(x_3),(x_7)\)</span></li></ul><p>观察其二进制表示：</p><ul><li><code>0 (000)</code> -&gt; <code>0 (000)</code></li><li><code>1 (001)</code> -&gt; <code>4 (100)</code></li><li><code>2 (010)</code> -&gt; <code>2 (010)</code></li><li><code>3 (011)</code> -&gt; <code>6 (110)</code> 可以发现，最终序列的下标恰好是原序列下标的 <strong>二进制位翻转</strong> 形式，我们称这个变换为 <strong>位逆序置换</strong>（bit-reversal permutation）。</li></ul><details class="toggle" ><summary class="toggle-button" style="">简单证明</summary><div class="toggle-content"><p>每一层奇偶拆分，等价于根据当前下标的 <strong>最低有效位 (LSB)</strong> 进行分组。LSB 为 0 的分到左边，为 1 的分到右边。经过 <span class="math inline">\(\log n\)</span> 次拆分，原下标的最高位最终决定了它在新序列中的最低位，反之亦然。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">补充</summary><div class="toggle-content"><p>这里补充如何快速知道其二进制位的翻转形式，设 <span class="math inline">\(r_x\)</span> 为 <span class="math inline">\(x\)</span> 二进制翻转之后的数。</p><p>显然，<span class="math inline">\(r_0 = 0\)</span>，我们从小到大求 <span class="math inline">\(r\)</span>。</p><p>我们只要把 <span class="math inline">\(x\)</span> 右移一位，翻转，再右移一位，就能得到 <span class="math inline">\(x\)</span> 二进制下除了个位的翻转结果。</p><ul><li>个位如果是 <span class="math inline">\(0\)</span>，反转后最高位为 <span class="math inline">\(0\)</span>。</li><li>个位如果是 <span class="math inline">\(1\)</span>，反转后最高位为 <span class="math inline">\(1\)</span>，因此加上 <span class="math inline">\(2^{len -1}\)</span>。</li></ul><p>即：</p><p><span class="math display">\[R(x) =\lfloor \frac{R(\lfloor\frac{x}{2}\rfloor)}{2} \rfloor + (x \bmod 2) \cdot 2^{len -1}\]</span></p></div></details><p>容易发现我们可以 <span class="math inline">\(O(n)\)</span> 获得最后的系数顺序，我们就可以从下往上依次合并，我们还需解决合并问题，回到这个式子：</p><p><span class="math display">\[\begin{cases}F(\omega_n^k) &amp;= G(\omega_{n/2}^k) + \omega_n^k H(\omega_{n/2}^k) \\F(\omega_n^{k + n/2}) &amp;= G(\omega_{n/2}^k) - \omega_n^k H(\omega_{n/2}^k)\end{cases}\]</span></p><p>观察使用位逆序置换后：</p><ul><li><span class="math inline">\(G(\omega_{n/2}^k)\)</span> 存在数组下标为 <span class="math inline">\(k\)</span> 的位置，<span class="math inline">\(H(\omega_{n/2}^k)\)</span> 存在数组下标为 <span class="math inline">\(k + n/2\)</span> 的位置。</li></ul><p>那么我们可以：</p><ul><li>将 <span class="math inline">\(F(\omega_n^k)\)</span> 存在数组下标为 <span class="math inline">\(k\)</span> 的位置，<span class="math inline">\(F(\omega_n^{k + n/2})\)</span> 存在数组下标为 <span class="math inline">\(k + n/2\)</span> 的位置。</li></ul><p>这样我们就可以直接覆盖，而不用额外数组，我们称这种方法为 <strong>蝶形运算</strong>。</p><h2>快速傅里叶逆变换 (IFFT)</h2><p>快速傅里叶逆变换（Inverse Fast Fourier Transform，IFFT）是 FFT 的逆过程，其目标是将 <strong>点值表示法</strong> 还原为 <strong>系数表示法</strong>。</p><p>从线性代数角度看，DFT 是一个线性变换，可以表示为 <span class="math inline">\(\mathbf{y} = V \mathbf{a}\)</span>，其中 <span class="math inline">\(\mathbf{a}\)</span> 是系数向量，<span class="math inline">\(\mathbf{y}\)</span> 是点值向量，<span class="math inline">\(V\)</span> 是 DFT 的变换矩阵：</p><p><span class="math display">\[V_{jk} = \omega_n^{jk} \quad \text{其中 } \omega_n = e^{i\frac{2\pi}{n}}\]</span></p><p>那么，IFFT 就是找到一个逆矩阵 <span class="math inline">\(V^{-1}\)</span>，使得 <span class="math inline">\(\mathbf{a} = V^{-1} \mathbf{y}\)</span>。</p><p>幸运的是，这个 DFT 矩阵的逆矩阵具有一个非常优美的形式。设 <span class="math inline">\(V^{-1}\)</span> 是一个矩阵，其元素为：</p><p><span class="math display">\[(V^{-1})_{jk} = \frac{1}{n} \omega_n^{-jk} \quad \text{其中 } \omega_n^{-1} = e^{-i\frac{2\pi}{n}}\]</span></p><p>也就是说，逆矩阵 <span class="math inline">\(V^{-1}\)</span> 只需要将原矩阵 <span class="math inline">\(V\)</span> 中的单位根 <span class="math inline">\(\omega_n\)</span> 替换为其共轭复数 <span class="math inline">\(\omega_n^{-1}\)</span>，然后将整个矩阵除以 <span class="math inline">\(n\)</span> 即可。</p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>基于单位根的一个关键性质，有时被称为 <strong>求和引理</strong>：</p><p><span class="math display">\[\sum_{k=0}^{n-1} (\omega_n^j)^k = \begin{cases} n &amp; \text{if } j \equiv 0 \pmod n \\ 0 &amp; \text{otherwise} \end{cases}\]</span></p><p>发现相乘为单位矩阵。</p></div></details><h2>实现</h2><p>由于 FFT 和 IFFT 的转移矩阵只有正负不一样，所以我们在编写 FFT 函数时，可以多加形参 <code>type=1/-1</code> 来区分 FFT 和 IFFT，给单位根取不同的符号。</p><p>记得 IFFT 最后要除以 <span class="math inline">\(n\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">4e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> _x = <span class="number">0</span>, <span class="type">double</span> _y = <span class="number">0</span>) &#123; x = _x, y = _y; &#125;</span><br><span class="line">&#125; a[MAXN], b[MAXN];</span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span>+(Complex a, Complex b) &#123; <span class="keyword">return</span> <span class="built_in">Complex</span>(a.x + b.x, a.y + b.y); &#125;</span><br><span class="line">Complex <span class="keyword">operator</span>-(Complex a, Complex b) &#123; <span class="keyword">return</span> <span class="built_in">Complex</span>(a.x - b.x, a.y - b.y); &#125;</span><br><span class="line">Complex <span class="keyword">operator</span>*(Complex a, Complex b) &#123; <span class="keyword">return</span> <span class="built_in">Complex</span>(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;       <span class="comment">// 多项式次数</span></span><br><span class="line"><span class="type">int</span> l, r[MAXN]; <span class="comment">// l: 二进制位数, r: 位逆序置换数组</span></span><br><span class="line"><span class="type">int</span> limit = <span class="number">1</span>;  <span class="comment">// limit: 补齐 2 的幂次后的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FFT 主函数</span></span><br><span class="line"><span class="comment">// type = 1: DFT (系数转点值)</span></span><br><span class="line"><span class="comment">// type = -1: IDFT (点值转系数)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(Complex *A, <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 进行位逆序置换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; r[i]) <span class="built_in">swap</span>(A[i], A[r[i]]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代模拟分治，mid 表示待合并区间的长度的一半</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> mid = <span class="number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">Complex <span class="title">Wn</span><span class="params">(cos(Pi / mid), type * sin(Pi / mid))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R 是区间长度，R = 2 * mid</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; limit; j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="comment">// 枚举左半部分，进行蝴蝶变换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; mid; k++, w = w * Wn) &#123;</span><br><span class="line">                Complex x = A[j + k];           <span class="comment">// 左半部分 G(k)</span></span><br><span class="line">                Complex y = w * A[j + mid + k]; <span class="comment">// 右半部分 w * H(k)</span></span><br><span class="line"></span><br><span class="line">                A[j + k] = x + y;</span><br><span class="line">                A[j + mid + k] = x - y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) cin &gt;&gt; a[i].x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) cin &gt;&gt; b[i].x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (limit &lt;= n + m) limit &lt;&lt;= <span class="number">1</span>, l++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++)</span><br><span class="line">        r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FFT 变换</span></span><br><span class="line">    <span class="built_in">FFT</span>(a, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">FFT</span>(b, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点值相乘 O(n)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) a[i] = a[i] * b[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IFFT 逆变换</span></span><br><span class="line">    <span class="built_in">FFT</span>(a, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + m; i++)</span><br><span class="line">        cout &lt;&lt; (<span class="type">int</span>)(a[i].x / limit + <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ATDuel - 为 Atcoder 打造的在线编程竞赛平台</title>
      <link href="/posts/d3c453cc/"/>
      <url>/posts/d3c453cc/</url>
      
        <content type="html"><![CDATA[<h2>前言</h2><p>自从有了 <a href="https://algorithm-duels.online/home">CF Duel</a> 之后，你是否一直想要一款基于 Atcoder 的 Duel？</p><p>那么 ATDuel 就是为你而生。</p><h2>简介</h2><p>项目已在 GitHub 上开源，欢迎 Star 和 Fork。</p><p><img src="https://img.shields.io/badge/node-v22.13.1-blue" /> <img src="https://img.shields.io/badge/npm-v11.1.0-blue" /> <img src="https://img.shields.io/badge/LICENSE-GPL3.0-green" /></p><p>后端：<a href="https://github.com/xglight/ATDuel-Server">ATDuel-Server</a></p><p>前端：<a href="https://github.com/xglight/ATDuel-Client">ATDuel-Client</a></p><p>采用 Node.js 环境下的 <a href="https://koajs.com/">Koa</a> 框架开发，使用 <a href="https://www.mysql.com/">MySQL</a> 作为持久化存储。</p><h2>功能特性</h2><ul><li>精美的 UI 设计：卡片式布局、亮暗色切换。</li><li>用户管理：用户注册、登录、权限管理。</li><li>题目获取：根据 <a href="https://clist.by/">Clist</a> 获取 Atcoder 题目，并参考 <a href="https://github.com/kenkoooo/AtCoderProblems">kkenkooooo-AtCoderProblems</a> 的题目难度。</li><li>提交记录：记录用户提交的题目，并提供提交历史。</li><li>比赛系统：房间管理与比赛初始化，多人在线讨论，判题与 AC 状态同步，团队 ELO Rating 计算系统（ <a href="RATING.md">RATING.md</a>）。</li><li>管理员界面：提供用户管理、比赛管理、系统管理等功能。</li><li>安全性：采用 <code>bcrypt</code> 进行密码哈希存储，基于 <code>uuid</code> 的 Token 管理。</li><li>易管理：提供 <code>atduel cli</code> 工具，可快速初始化。</li><li>易开发：提供全套的 API 接口文档，详见 <a href="API.md">API.md</a>。</li></ul><p>作者太穷了，提供不了在线 Demo，就给几张图片吧。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/sklovqrz.png" /></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/w202jfki.png" /></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/is7a5y9o.png" /></p><p>相信大家一定感受到了，更多功能欢迎自行部署探索（<sub><sub>有人帮忙部署在线 Demo 吗？</sub></sub>）</p><h2>欢迎参与</h2><p>我们欢迎各种形式的贡献，提出新功能请求或代码改进建议！</p><p>详见 GitHub 仓库。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2026 年训练总结</title>
      <link href="/posts/8f5b0fb8/"/>
      <url>/posts/8f5b0fb8/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a97e6abd37b4a00fe7e1bd01f8183e43e9ab014d09aaafa716fc970bf296aa2e">93024cf999deb8d8b2919f7e109263d48b8ddef76bd60d090b7778bf0c7a532710788e18657544eeb7c6dca5e0e06e6960e49001068b4c7d403274b24088e3bbcd57e4d0b5c335ad5db52a98a902b94c36d63f064fce9c445ffeee0ed0c09d857677d805e207561053bbf3687bec2fdc920ab7711ee396f1b2c0782f96dc138c2487a57476b132ccf06e209eb4a53c1b522a0b500387457f32603ee936d87d4674e4c91e2f5a26210556ffad76de64882c154d9d610922ef2cd9963e8bf03ef5bdd9526ebab577418985ce078ad87426e5d5abf302ca2042546925f505c95fc5c9093f05978ef8b0f9748293e3e39554c65a6d6c04d50ee1a883fd61b0003c8658c661b8970abd3ac6ab52df425554686784c9c90aed0c8d30f9276216730be43de4ea81d3688824c6af3f2861903b81ac28451646db901b4fa046fd66f1092883b9afc4299cb45f1f4f029ff07b60826159ba788151dc0681968bc2b16ab960f3931732105fb8de915c373c56ee523e500fd372e034ec824956083d51e0a8e9deb58cab1b7071a40a2464d4012e6a426dd6d834a1b14dd985a73b78994f88ab9b6dbf74408eba7722ff085429688f7e2c35d448be6d631a8ab6bbf4482b34bdb13d0a94e0413834aec2aa283811113d57544a649e8d894f42876de602f3510aa29ccd7e22babc65d987079f4cfb34cff08ce64eb0b7dbefbbfbbe856a61564657f74f7502b5f92bae29648f89a028580f110d161ab0ee098a0cb126f01c33dea18ea2199060196ed40713e9cbde27bbcef335af49deab2d4ddcc0b7259d235369651bd4a6189ea6b1d0d71e569df927ef6ba337aa8e8b7792e47aa885de5401412207398e5064e7464d80619269e6c813d94a307767faf07147cb328e593fcd7248e68a76363dec791ab1170a01b39253dcb658b4764b3a508cc34f6f5ffd5318c93df782960f431f172a48e8377da647fcbd1ac4372d7c46cbf135139a3015c7dd8e0358fcc09108fca756663e045db35aa8dc1d3b329a03443184e3876e652389cb152a7ba0303c85b48e71f3886cf56352a1b48b48c5a92d913d873ccd5143c595c2b0c4dc53ef5bb2b151aa7f2ceecb0b26f8736eb34ed3d442f56178d97f314a312acb6983bbb8d06156cebefbf4850813f4859af164f6d454216337d91d8d20a4c341693a2f09dfec5ee01236ce4f6c51effb8b17e0afe17618d01b1cea5dd0ba49a16c40de18f1f1399c10501f261f3e54813ff5a1d30c7f9accfdf0828ae36516af1ed18f804598eb6653b007959738961cafd9688f9eea5dab2d5b2658039074d46115ddb45cc17ef06af4fb5199f14038e0137d50250377315cafdb01efd2ced1f9a6b8a2a35002a792c44937f942b8f8f7d8cbe33601abaaef1d4e70ef3cd0d7df8b501759d54979f9f35dd22a748815799ddab22ab72146f309c30fc9e60b4022420774f84cc0aee51f812573410028cbe08af56345e631e5e2419199c6c54c01cabec77a9cf8bbd20e22fbd17e4b7bca16277cc054558bc9eea8bfe68904c727dee0cecabb480457ac65a76089bbc462d9377d34078f1cc9fb560af071806bf64af2c585f4bfa0f6d00b305b24d1cb4c3398e4a3e40a4c5143d0787896adb696d2892d1efcdf315566be8460c9a8b2f84ff2ab90daefc6e847bd049117d0560ca29448717dc60c3a8ad25e7a48876e21332ad483e8d56f848b13eae02e683519f9124d15ad7e420a5d4bc9faeda7027ab9f34c66cb8a8496fdfbd87f3b4045235b4f223b4887530d67d95aabaa28df447ada8fbabe84c02853ae8ec1d2f5f92ba34ad33e07635c7dc9745c42de625256dd9285d459956c0596cea95ade2f0124a812fae3f3489bb3754e69eb959618d4d0a44fc2a920fd8172e882502a0a7730d98c4d953f50c3e507a1e6fa2e5806cdce175d9f6d2d5c3164b0c5e867583e4370d00264422de596253c26abc1af7e29627420a7fd7478188d5d8d27a1a8664b62b142a84be748e9ce959dee3c0df5c2ebcf6bbc089bf660755d3463699b63d89118ca0d2a458ec977d5337e1c5f724216947987a76e029b6be9907cf211a2d8c41ef0cdf1a363ed2c91311192fb0d0aa7db40373ed854705c71639ec917c02d5b04e82828232797f025f720a9a22633f043a67890d59184b9cfda34883631b3e557b24413a130688b374575274e54520d7485bced8e925973c57820910ecca5b509d87c0b4575cda34fe48d9b780e8ffde88e2e414308ebed3eee39fba0da95e17ec531b1ef41015f8d51c56d79e9061292ba3f5748298e54d85dea880719f128cf15f061f495a42576b314bbd63ee768133866733c51da136ef2f8b2e0e5b370358008fc14b9e784cd7fa402b534951fc6d05484bb091945ebc7f03b5d8f7fc4bb8c9698ed2bfd499d5c3f68ed29efbb50249b3af1e46bb9e82a6f9d02e271b48415a624e81d9e31152d60fadef84087ba7a37ed08f38339ca85e8454fa69142bfebfe98e89619b0fd712749c5016a7e8a88a3e301106586e5bcde48d2c97b3e011a65f9948e1c28e40d3378f321ed600542572d98d241b3710c25068be7f35a17a3479fd4d5a52f7915082f1d5f258773ebede83eca536bb7a7f3054701a14639de9f25a105e096b6fccc893cc93ec66423bc293136bea1576906132e62c40ab0ca1ebb2fca6e50dc8fc981631682f396bbff7d4b13e33c0797c2b52440663a2b1dd2c19d11cbe165ca69669faf22df2fc4ceffa81dda185335cd7f9a3a227dbc8e9799220928eb9cc7405b347f55bddeddd7376f9436b9108eb2c38054a299c103a97e1545e14176757fce6f804cd439737099d6b0e788a072c7b3c0845f913d70f88378beeeb071738d6760584fb0586f01423566c6572464d33367a41cb996406ab6eb515f9e38a6e1c01cb2d5b1a5d4ae314a078e0764b4d24daa58f8aacaf53a9fd7e43dff10a992cb0d85a721d9caaa374d0a49890f7e8c7955625914073dad169e3bd265601b95b4c27aa33b0044faf3f9fcfdad363fec2d7ccc6f108183a0d438e25f7774346464a24805f03d97dd78780c12e80dda33d47431e13728d463be3f931cae1b06b1906f5b290cfbcfe17d2332b0872ae817ee4a07f1553543b85bf1f4ae02898e80bfd695e9c94ffac876e1509fb6a925eea80838a57b8435935705b46b36d41c25b5bc254fb740147d8e97c5e8791f8c19a37d3ab57104e83bdbb18f28c521adf3b4c785a6599f5980a477265687d0f0104402d08ab70798dc08729fd737d28fe49ef6047bc8944c7c47f5b45f0dff82a6815fc68975d6de9c227aa3169e82311076efe6a94372b1e14ccfe53f906f2df360ca8a76fb5b587f8b7ec33e899d4c8feb9b4c8f1a1c56a27ae54d8ba83b09f4c65d7c917260f3ca82f68217dc57d40e22bdfa9bc6fed15e1c1ce99cdefeb6bf5cc7d36d4d1a091e08cf6f56e5c2ec18a6355962e57af99e090f8587d05eae3ba9ea331153869d8f6361123c8aae0d6197cc89ff838c9abefdee6c137efe7ca3dee280459d973580c755e1436775de9b55d7927e863ae33d778263d7d27832a2b1a3996ade24050bd76be394f70d1261b27a17f4ea69f19fd0fade48efea65d4d412bd9ea2e28dd08928f243e7a0d2995941ef1bbc689e95cef286cb75ef07203f8c31edabc65e0cb16cea451e19fcac8f522fa383e327236798c0c50e09a1c7deb98a44f8518ca7475d0cb1220e13f7ead20284a834f8e162fa6e8e9c8afc5bceebf969f19bb9118bae2cf15595100dcbd5ce44a97621f0873aa38e2109fee2d69c6b5b503b707fed644276bf0b812ff995ab64c946229a9ba976c0f20efe8df6385ec7378c66369aa44e792d6a01fa00938f9697b5b61a017cd532a9f214f80d6eefa62b4d262441946cb2ee8c3053a3ef1d5243b4bea6c338c56754b4508e4fb4df5b55241b7a46bcbd988ff93481d0dcc8535f7d4a35bd16725d73ace1794d6489691df7978d66c6e27ab37dcd16258cc665735fa3f1160c33cedacd25f98c02e4a993f8082cfd7d900f8d3615039a4b9ef6f2a94718fa682defbbfd732650861c9f090e013f3d3effd458c95b492be2f294cbb45992780925f055acdf76215e3c870a1d49da35f792663755b33b0b9b9a14e5a190cd142d5db2eb4908c9f066d83114a58b96e8253a038238c7909d9816ae95fc5ff0d26f7bfc9502f03fcf8fe142ee1b572aaa2b30e61c6f5374c480905a892ecba22aeba80cc88c93aec659c0ba5e52871fa7cc79aa7c8475a3dc456f8083588c4a271260c444776e432dfaa32f5ffb93334deae0351554e98860700eb84ce22b9ddbeb69d36c8c374185e3f68fba4f620d4bc52903316b396544574cf9dfc46ce5ed9e1826415899bcb09118c3ebc48faeb7b3534226b7e54f544217100ea0b04aa415cd64ec8e43bc54fa4161ad0346ccfbbde4a2318a070a5fda5ec9c3bf852d25abc685669ad33c78d2a72893ee85b0e540ea1edb1ece416e4f28e0bca8838f069ce946dfe7b3201c3e315eff5ad91c8d6f8d9b3990b9bfa44644f3e187faed2e16ad9b2fbd03335f1e7fc95363967ab46c7b53740b95809bb720d9c7b77d8704d81851df84b6ad38a3c42ec3ffb95d667a04fe203db9d6be62d51fd259197623a25461b76576c32c00ded454d319f0613c36637754eb12bd483d77573ebb3cdbc2c8822e94163c037151ffceed8c0d97797a7c01d4c18b1512f136e206e34e364f73cd052a9f39d4e444028c4a45e887782c8b90ed7cc6efcd1988e94f22da1f77f5accb35b1685888380f3c6fc9d2aa98fde72388b2867ab94b4a68e3233738f96de26120855f696c32b90fe3836f7c8b56a060d819ef8ba272a9e7eb0c13880324d4588dcef8bdc58a333b169d8e27b199de1546bc2045157407ac36f285983a1adac015009975735fd3346e738707c7d764d1e9e9e1d3e2cef6f07950cf89a4c37b62140ef4f522adedd2cb4370307bbb15bb99d54be577ec5bbc5836081f998dc3ecb2798d38faf1b37096083f237a637df80f70b1eef1b7c6c3dee646f87f440cea5a49bade0a531dbefd3286d069e8e83bed665fdb8981ecb7f77b7e6f84b227f516f07de7c9eb5cbdaf059104e21b1413e56b382a709fa9a20ba19319bce97b05c0d5b9ab357d58e458238aeaf40558ef34e82740ae90e17b0688aa47d980027a3793929552676ed539fa75104844cd8c92a323bc4ef164b64ed93257f9d3370d5baad78f201a60f4780debc1574d6fd72c4ec23895d28e71ab86d03dd920a63e423f2ed67f0a481b621c8392e264590717b49113366d9f39431dc94e63dda29988a879764c0ff5f269080c62a20467e2fb174368f136850d72f464f3866e3dd22a5d90cb7c1614ac7ef99eaf11a9ef8a0e9236c2c5287d1f14dc4791e2b4420c5b71e4fdb0333ae864ccea54fbbb4342b8b7f5b31bcaf88ff5b9228a44ecc3dec6ad8ad0fc327f61c522094df7ec24765ebb783f3a50d2fce2bfa96dd06233e363dce03accd3efc9a5b0efa9288b041d7cf45519d89c6292cc46f1770c489772970527f1a8b0fd02457c04f55b84b10e5a6c7240057f73c4b6082c95fb12427c4b85d5633e8273465fb95207dfc161dee5dc368eb92f2ea1f223479827692cd0fa2ed6439d1f490f19a28ab65c32ca15c191c14e411447deae3ede633d773a40e101b7c296bd647844e415e413852700e6fa93fa168405c2b246bc728664220c12811a96d1f658a80da62aaf9695f32b62e6bc5c4a8c7e07e84afeebc3e1d8af294cbabaa1fe4ba23f1e5331d7284bb6a5546f43dd785b5a869de47e019b7f91c1ca86ee3c27823d8ed2089409835838d290c540f8d3acd9d3c5898d59e2c511a223b009ed92c9c27890c2105b7e1e542316d3877fb0ccb0fd439a4425971e085e91c5b6630cf10891d9de9b810677f88777e16809603b7940785fec23b940f435276cfa03988bb6afb3fb6e675c9a121e3f414d6288e67d53b1187ea6b22af8518569ba50348416b94c2ff35d85de1bb015dc2ba01eba1959bac9923deb6299c04027db08aa07a23f0d3600b850426613137a25ee6647042fc29829f8720966c5b464117855926c4a1f5ede870dc5212dff5f63f786d8a30460ed4db6e9b581e34b84274f276ec9c17ed9c41f91224bad33d4abc53470634d46799449672d54b3f4995bb1f669e8647575a124d36cdf515b2b9bdc7b3686aa154709e70c5d5e8be87c9838d5dc04b39514ed690c85ca9c33c8a0c8f421fb6d35da06f2968e0bb882664a98367d15909b0f64e5d5ce8a078c409346708fe0282aa3f98d550c77a9aaf28830554f2bfb8ad4076f365474d1ab4990c4b791bed099d9a4c1aa79c2873b568e9a562d27aed2dbf08a3b0e439e7ef65e9162683003775b381224e1bf871e7d25a73babae8e68f79fdcc3e78afa00fb5da4c292d8293fa46b196b0618cbfe6ec70df386a37499cb663f4371e505e264e14ddfdfd5cab7aa98f90f3fed2e899b6dc3cbbf8847e2f542e4c1536b7a3108c2a4033d857aa052dd0829c99133aad27ab6a1d1f09791c2506272d430a1a1e4c8520ffe657568884facb3b19edba570038456249841fd3c61324cdf5ab44d43a36e7e1340faeab994a58be725a9c543f3bbf840f898c605993d297d5f21b92da94075ddb5da2803afbce958a243483a589c12e00e49a3ab4df20256dd3a7449efc86dbee13792a3e804c90e1c9ec81a574b48ac1220f0901db7e77adb0ad3e688297abf1186e2c9be84180db2ea9b81e0e5e60ac547f66cf3fceeef8c996dcfd05699a79e154d3fc8802800426eb63885880cab4bc15769c9f04c649ea82f0b454a8ea57b7bf4dadded429d474999a8b15c741249b500cdfa0a055d622ac9e74378d3d53c49f01f01515e75de7564a7c18e71f55fa5ab19c7c2fb35b7f2d7409f9056ad3d5cc26e240fd1ba7c62e85c7d56f0c02d861596516843bcb2c8573ffaa8d25b113b3be84cdf37a38cee275ba6b53c5fd2aee7be3c86c89eb676b57b17571efe26e84bca4cc63af48673946c5e24c56d44b98094da01d1e00213ab7d066957d87639b27cfc247a558027c19ae381f344750dd9c462e2dfec20c496d4ef4002af4c9fd2cb708fdee83017c39b02d2e222d086951373a18e78be553f88f11ed7c126ed001e3f04122fc7b033d4c9f09a4a2cd35ffa58fca8a624e09d2366d0bbeffbc9db890c48e158265e23972f0155f87a5052bbcc792708a1bfc52f8afb9bd2af52fdcfaaff6e082e29797b5dc5cad9aa7c29b04010b8a860d1b7e7defa15b36348be27cdcc638916641c818fe659fa0da8122a9b3a3d53d6d3e06ad384a689e1a3e6a52e588258236d0c11cb6b3b8080b6b8d039f959ca9b71856148c623d822003090baf2568f01fd604329e9d95fa70936d17d859b65b046509eb17730a374e4a6d6f01a13c71b1425c460e488d6f85cd7d910482e92426a974691474dac7227b794b37af33544ae25da8cce8cdccef192c3a9b04c24c95f3817e0fdfed1cfa7c997137e3605a944dace8489bc5874f889092701cd1c41826c210882319c23202c1bbc30e437a7b1cb29f2a5c1b6d7e48cd1bf2fb9471b6d6e4b194830ebe499a016ad8eaad07215f4e278b6d90512912145053630ea5753ceda61e8bb40ce3e1ff7db0b185160fc8a7164bfc720e0dac31f13b5932155f74187b5fc1071256d0368809b5fa0f77bec5c7a67dd04c24657270996cdafc91abbf3dd3a63bc21647b455ee41ba2bd493cef4ac48d13e36a97fe9814ff4a52b07b7a3fb03e26b297f3cee2255d3969e4739cba0d7ea3b76e9753506722816d4108c692d1b2dc3342b556c06c5060cc8de34b06aad438db74d742fa1b1b70806e3a5331735c2f6a2466a6fc76c2b5dbe9cc55073fd43cbccc99f426f52842abc4f6f50983cd398e1514700860d1f06cfee86259291a1538a241737e5a8dcead4e3e3e9cef5b22b4cea67e8383921c1316969a0c87f9d0f69e256e308772a6e8714a596c8380e064d1ba471008eb459c13bcfb380ecb5f6e2dc209baa294452ecb9ff0fcd73ccb3ecc53a26a4c94328a775fe55f1e3898c56f6ee959b09f5a74abd0ddfafa55fb3b89c7aa51dad68841c9b8f16c26fa1cb07c7e9ad77d4cd892ad908928fbda25120ef7f58a5b19347f534ed31d84e34420997c6fec88ab8a1fd65bdbfca4cd2bf2b893f3be09053b03fd07a74804b09f7fdebb877dee43527892a80d19439242de582cf46e5791080e478b5d672bf972b795f4bbe2ba12a147a97d47479901f923c058f7bc8a65aa8861b24a3f3b03da8e34d6b89a24b4029ddb25203440c260c2236d6d30fdbea8d3ddcb0fb186bfa44e5e9b696668f1483670574a80215a6a4a86f5b13f0f63f563e95ad69cfff0405f58e2e092c4591e854b613b22d4be29728887ac182a2b17ce08b020a2811a7d5084de5d3d49b4c7236fc4fc0e5dce9bcf392c6c9b9f5cb031f279a58d6583e7eed743d0438028dbfd75254fccf5d9965bd3b87445f471e4b5d77c7eb44931b64baf345558c0eb244badfa56c087f1a769d54176f6b53c25fa1bd60d3660a4e4e385ad6683ce954b3413f84a03528e88b118896f030e98d7320aa9a04e911507bc9e990bb06fd7d3a0e9a32b80146f09fee00fc3fc03e339a0099bb2e44f57c6c59b9bc50e6cf672aebb2b87b997ae0a3da609399d7466e1916216feb1326f236e44402678003d79d21c43345210c82d2b0b126113870f177b73474f5be262d4663c4ae1d1febc7e5aedf6b32720fd98463a88517273a62c98e0a565f9777516d89a9c0ff40cc2fb74283d47bb64bc02c2aae82edb33a7996327127256e408fa44c78c953998453919f68f8b6efc3096b74d6f648dd9e1097d55f3704b263e404d2004d6f4d9b792dd7563a4923cf504830039dc2b48cd5851cb78bc6937c3d66b2347f86e02417b29ce9dce006215bc3ed2ce85bcc421f2320ae5506c65c7bf5dd59cdb5ea3491e06188b76caae092bcf1459ac7fe0e705b1f9512e605708b21d5dfed92d30cec6cd03868dd514612ef68a0ed9bf55d3c9a54acf6a0cff1305ec3795c4bc251e9c70c41317070d2522230dd0d907a3bbded22fe5905dc16e7bb06f41a0354268d40186363f329aa4abda2a2b32bedfd0eac233b631779e3792d57e004fffc82b752742c1b578bebebe24a8d7e20dea7e18357f74e5fa02ff8152b95cf9e497a3c867f8f09adb1fbc9c9dd18067d01f7f3ec063c3c90934db229a5b0b6e939a0fbb043a3b5526d95a20ca7ddffad0065851cc201f3bf7ecb5cae1fa4190dade124989600a0e4ea0b06b6d77dcffb65eb67ee952c4825cb8db67dea10bb6170405a3007f97cbebdc023ae87ad71711d58b79268bc7705320ee1302803e67dfc8f14d356fd3fb2a0b197f8a036cf3a3481f24227269f6f3a37de7c4ce2c0bb25cafcaf71b4f31181a5277a874a1fb1ea3cc431b2ddd7be2bc4d28c1dc847a1cedb30343145fce1a2257fb1e8b0a8c144b37b16702a73280720b98049e2a53a0f8b5419cf33dd7a185f9d628edcbb3ace16e7a73ab4711621995ed69f0f26fbdfd1d01a70ef1ad769cb61c6ead7c916b3fbfbea538ebce7d24af9b661ad4e6d443cafdda34c794964c6245ff85d58de16217df789622a41f77d757a8cb5e8437c67c191f269e00ec194afcc9118fc1690904392ff61d596d739b6303b7fb2c06158cedbb4f50877a32109fd1e2d05a7801e7504440c23bc04a72ffad04cebe20e3ab6338f07b686945b70828a4a5de6d173f02f8c3237b5ba1291c86af3cf575e20a7efcc811ca45adb8f989f6fd0499e6c1502a1a82cbeef9cad6bfcf20dbc8f3b0e49b8f6e478dd3fa4d957ff6d532ee289d79284a124136bb1789cfaab5af3b67f3727dcd9a9000b4725499c8c2b732978664a01533a7b538554476d331df318b169a1f64e025500b40b0798a4f3128a725751f6fb5fe7736d4017270a2a1877a73bd797647b0a55ae7503672ca81f0b27f0decd66530c6ad6e91f0c9ca2bd6ca8cfcd75b0b67bb2e7a0daa51f9daecfb779b4776d0727820d8602eb7c0e731182b4901af36e677605cdf2e7951a9257b976d55c7f8b278d32c8e824f9d7187f38b2e78cd626cc7827939a24521921b7bfdbb3e0cc12f4a5b5ea8de879934ba4ee51324fb7b6afdd3b7202607670315d084b0080bfad50c569d3d383ce5b7088cd3767e15ffa6c17310b29f051405d1290db8781c949939810e2193730ef5945328cbefbf1bfda32b272bb004b9262b8d675d5916ffcc0839e2ba783565942d3854e22169dc87c21268030d7c88d1e16bc5346c03539b8104b1be9637fdbd35adab3d6603b86241209b0b09ad2106cb2d27ef6b9a8209f5edfa834585e57bc8e6a3e14adf386cd10ae64e0a6a1bd43b7f5e624456299cc670093e50835414d91d15d8c370a712b7d0654c275582276367c8c911911a725910378f08e633ff88f063596a8e45acc51dfd296aef76aac8100f4c842606588ca1b36ebfb8e8aeede87bce39d2dddb193774adcd6fd02f77603f1e25984833c029aba66348753fbe0f0b12a296ffa9d276892dd93ccd0e77a5d0b4aa5881581cf5d1a95804082ef6c31be03c39a87fc9ca6cad58f575ac154cca3ac6b517f3717dc7db99fb616be4fd3b2c3dc32c6205a46b2e12cdd9ea4247208238c3988d764305a36612a48fc992ec1f8100a87c7f29e5c6fb4aeb5431b8c07b66c15ec771f52852fc4d7c2fe2733127ecc7b23e23a0931f2a74506e223fad70d37e104a3b6d8ca4ba273c9bbd2ebe6ca141be1bcf0d1f631f8f5b12eeb48b3cea6381d0b28fdee384b19c4911f36bc96379a7c5df2db253327f89319174bfbf2e30e7eee8b466f8911f1e3131a84b9430dd1a35c8d6fc5b0546efcc55364f33b9f87d4617557bbda8a2a86f7b476faad623b2ab5bf9b08e8024ae9971ea8366a2af38b563570b1f25bfb61ee4442ba86e37d2e04d97985957c3e73e9fed43881c6914a808e4514d05f5f2870b5ac05b8fc71581c467b3dcea2ec15b6819d5b4594e98faef1d8ed16bc1afd219f04110c1b7376a7d46c8cce1dfc6782d9c0cc1da8adcff9943446bd16cee51b4b09e3519f845a839075ea9747865940c2e06ed030f95348e621194d8ebf2658b5c845091d0250b328b57a44e2588c1f06da52668e9f8c1bac1287506a7132a3a00a69bb9b94994f353e766e23c3eeb17e2cb920f76f38d40592bc652c3730e4102f7dfb9f8ebc716d0f657f670e3e98ba6485861f1329de93b32263d6b07e653498aab58d9ad1229f2f4f9ffaa732fb9b906f4cc0ed694ec544a3bf7fa8a6c159f9575ec919a3a9092213f9376bacb308cd9a3e953452c188b6122a75f5a0c4f4cc3f4c62458cbaeb1528f5da0cb3030eb4d13173396628d3a4fd02392a84c574177c3bab3dfd4d1d0adf54396c16ed9059bf8dab08862c2eefbd4275e5dfa04596fc4f94044c0a4d340a18e5f71c7ff9dd8728997cd7284083c2fe77fe35b2e5368720ab174186a36e60458221a1678600c718322e9f726b9932ded1974962f23c33fc5ea064712ae2f933927173a132e5c06f6f1dcfdf537eca6b5f438fa6f6a3c6b50d91baad4e48b95f07de92f002803f1b845ae06991d6f60637a294a69e0a1538698f16381d1b7537ec4619ad4051901b5d3f38ed95b5aad35e2b4a30aea318b2caeef132384d68d7144543a98fbfd70102697c0820be1507062cf2c14fbdffdf21838fc84cb3f916e8069c4d471fd4db59d99d890bc1cacd2824d46c31c739ddf387fcdc396f331ba7d30fd60151db9cfe9fffb80bbe8d2d0eb73e0e179ac4da034c90987fabbfc99212254db73e8c2ff0abdbf3fe2c6f0912fdced320ba6adb23d023ab4bfcd49bb75e0b0891722baca626c0032e38a8ec63e9939f56c2c88471f982087d5b111e4b71fe8da120c947f980085b3cc16de0862c1532045fe30b061ffebb970f3b5a0195bae06ef108f5265c2c39151a5d258cd0083198c5f8a7ba83e9c53bcf6a022bbfa5920bec6335bd0c3702d7ee4e24b8a223d424b2dc8088a9bfae5fee963b4dcb0ff40b8a80cf13d8f8b72f6d5c8527c7dd2f4610058a50bcc18f0ea63f71c5aebe82b672f650b74c95eaa45788e576472bea7e42610afa912250fb5f947b1de78779885110edcfbf88d5ec1eb960d020808f86f3d0cde26cc02f9d862f1856873a64129fc2f3b990379a5faa61c950cee9286e2689b450c3e57d5146af3c8cc126eaf687484c68c0e365494a4b7e5ce55895d561861b53993279b6da8b41108d78714a412e3dd81eabaae0d69c9ee10d3c0b1a9d1e7bd1e9c8f2213a9a0fcf87453836450c7e096966a85b8fb1a8eda8559bf487a8b2f0a6b67c980c6ca6fd0037e7259fcae0a9cb2d7ac63a4bbab0b7e123ea38dfecd610985845db49833590fa64f0525c3bfc8f01eef0aed01c77a225c1c8e6d846c8e5ded7724be979432f7b8e12d9a8f5fc127d67bf44675aebebcc603d927d7b7bdfdd1b3f02fb1fb4a10fd3773b2102025a8fe071e3fa19ff1c92b7a21f6fdd4db6233a4ed363c0b1e06179af4edfe58c4547b47f436786a8ce398f9266f492aedf1f2c37ac5269dec8840ca9596965daf701bc27432567c0846503f2fed987ed80361f889897bca7591fe92f83b274ce8f8fee314847b1757aff1b6dbfbf2f5f7a295ff7764fa493698d1e7ba0efbb7addef234f243e4e46a084f2432cbca240f62e94ca6cc6f82e6f9a27d2c10666234fc74fbd81d113870d4324c65ce359a65e5eee1ca401f9e60f5b3a1de0f2aaba488ecd901c4cd073c82745cd85943f825ba54ffbf2cf05b08adaa19fb84cf2217bfa39b9154c086794be267ee70bd58f5755f6e0fece54972ca304abb6e7f74a145af93d79661dbdb65855d51c5b5c9a1e13c23145b8a3dd89310b13dd02c80c10a54afb13cda1c245a6d115b477fcd733db74a518db931366bd1b5ac07973bf3f64173f3511c1762ebf92309e3059654c5d791fdb0c64ade00a906dad0a8286c53be73c16f73789a3977dc17bd67633d6ad98e881a70ac3657db16d882bd60a08e419a1b2af6b4cd2ffc4309c7ed49b8ee03dfc918969659319f38b19a17508bc594e2c2ada380be073e79b90a2c055976c0b14bad7b940bd1f4f3e7cce3620bcae4b2f42dfd587cb519852687e4dffe09d0d8233282f367a705560024249cdee32908756be86875360ae4f3feb51c9a4eaaf4370b0c5a5e8bd0797c4abe4397f84cd8d1e5c80ead34031a09e2d51da962a0348675ae20039bdc8c1005405b25f6397b13e7f5eb27fce93cb300d36bb4ad923f7d16ea1c9022f8b4ede7fce72dc8cd6cbf5227f695b12ffc5d49cda2fb94d411966b625420fb5618844160eac1eea5a58f9eba79ce618369f6e23f3628b10be7f983b5b698a9a96de0c338164ded509d52bfe10d379059c58c7d869565d0f41e72b418b8af5276ec9447e00ccdc3fb82fe0e34ba492207aa086e05661d5b5ba1a900f5ff1a3082260eddf03fe5a8795d6de030cb286b1b55097b1f7b10f99e71713c08e25ede6d35171a637d49c8ec099a79adf7f9e23ecb8ab07e72cb4a1ae60fbb71d5dd751070d6254ee0f732271afd9d2eabb666423d1f5baeaabe2dfdd0e0354474adae0ead54b2838a2c902fa6650bd6bc571a77298d4c061489cd47f1555d7147c76559401273582dd3ad20d1bece66b6c9073844e1618b0e4f9acd6ea48d76a621e65dc6751c4516009c25c20ff950d01311e099c0ab8ac421a884557f3753df56b95c04b66b4cfeb09f72b8a4b17bfdc1fb511673d05bed861163011ad5da26c503dc748a70ed70a5a447ddfbd0805040e178e3ec972df64c503040c3d4e767c348670dcea19f9dae9fad05fdb2a83d3d1a159495665ca8717b672f6a120aecb876a229d7c9ccec35d9888a8ccfe75b6fff02798cbe3fce96ab5c9374be34b92c9fee4e9ceccc3f33907aeaceef84df110b4b062216d8b7fed3e26f5d3c63f2814e053fc0a5d461a4d1b99cb754e7ece3b74ca185bc075b204f6ce0eb435d1b40cd271570a9d7091224f2aa22621cc488d4c5f70eb58b2fab90ae0b1256143770ed07371c185ab6fd61e7882cf6f3ad6518c48a548e96014f9d981bfb2f9240fa7aac10a9ffc6fc7bedf77ddca4105049d949de0dd844e9e59563b7a8fdb15322757ee7a15a8ce450146349a716fb549c059bd9fba2807e9d46c0cd899746bcb0f5dee19880dbb513cde2325c73d1cfcd7e27ab5fe7d84372d4b9bff3adfdfc05a58b1a81181136050e293278a920d1ed2b160507ed06f1255944c524f23c379ebc38833c9e8070d0f221303fc24098fcc66563e20a68dca0046f11b83edc8a7cb6a80620689b1027c36582aa758f3f77f17bc6fb8e85381ba542f9725af4d58915029a663ccf0496dfb07fd864ee010744ac1f360c984548006df8cff9459c7423985a6b9d4e6e4ade700715ae6dcb9d23962db0f2e8092f6bd36aa282f4c3b3cc75209900d2c7cc55865424830d7540b15c39b3c6a54eefd888571fbd0329d670f4e7550368aa18830dce1ceacf565862a45e88409c6a63721eacfcdb2ce3436f94d016d08f7034b98054807256c9734a0737ce12a15a407ecfc9e68b9bc8d73bf871c4859fa66b598ae6b51fc7babde81dbf8f59f547ab71dad8304ed2cce7d8ee2fae87041f0ad0b2bd7341e9518f52781bd8750a9e8c1dd3daf455c72579616a14249e73e4110b17d486598f4d13c5c582037c3373924585fd5ef289ca5fa12c2fc226e2b6ac83c4a037e13c293db7fc46f026f55b3bddd34309f0e66374a625b74c0f52477f797f614b69972ef2e167af560ae51061b4a440a880a6ceafad5418f2af12bd7b2f2bcf650289a94f88dce3f0fd98c566ee25a08f9ed1eb91c81ee0f467a753939db505a09b30f7b91fba27d225f3aebd394c5b86dadf33fb441b141602d4e85468e81dcc166cf1fd315a992e4cfd99c6f4c4bcc30dda1161a85898d2392e0d265c792d577902833e510d9d87366ab9668fa7077246794719c982608363469fd961cc77e61374195becc325bba5587efcdc05424e76c24899fbabfe1b89e4cc2da67ea70f2e4fab0512109f7d7cafc2c1fa103612c239556964b26357797d7be975cf2728a270b48e4c0c2501c1b7432e7bc68ec333df30bd004ab7c23327a19b344caf5e71e1ee5b3a0fe1450723b9b31945f8b853201a70cd448fa04ef147f816db07fb772b4875a6a047eb22c2625885d2000916b6716a36c16657ea8e58a0106c3917212574497ea3b3865a8209de819d6999b4d63f5d285b8a561fb6ea8d72b0ddea42c41ec759669e0fccf2371120f959be91fe15708a7edcd2139304e012a8ab6f40c1153e3a9ba6fd771c2d3b44fbaa9f5846c6deec9efce4812481966f51ad4c2daf097ccfa3619f46f02b9904dd1967ece455897d234473680d0868932010c39049070ca2a5abec23a8e1f833df1aa6340e16c461f8996ed0119456ed63327ada197c0b360ca4811752dc7eb1b45781394678689f8bf9153174e54b7c8dba92c5673634d4c04f3cebc274f04ab492ecd03f6ae65760262d9db19c65d186b076b29292ee577182e7347793a6e3caf458a7a0661c95bfb0cf8bbba9dcaac05ac64e823d8edab6de9ab91fe5034445c116d450c2ff435380b888b9a54f1765e47e1b9650a35ad62fb3a7d26334c90b1704bf8b06744772bd029616550d2dd96db6da2a1cbbd5ee26290d6ecd6259912f30bee233fee72bff06c8d7456e839054278e7987df731da364b9f27e67587621f872c483dea2ec16456fabedbd5562ab5aabf29d4c6571e658c68f4f2431fcc26b7a89f92fb43f0f0da754cf40a6fe519ada5923e961507774e7206045f4869f4c0458675ea89f37e11f1935285e4f78b4aae9590b547de1bf37e43a8e8560f01191bff69ba2e29785bada710d110f0c5fab4b69ed1fd9c8f2b9e506958ff176ddec229f6f20265c38f0489eadc778da56b1c8a59692c1aa9a2c8cce05de05c1bb4cd190b7e0e3194d16b4c8ea8a66079d535c9f3cf40ec19c98f5cc3d6f4f58fcfa595a92f373fa53b7071e13f3c31883a63601aa91992740a756a9d86ab8a9c2c23c40bf8f7c43d4ead0801bad0547c472b29b7a16358be532cf3c2a27cc0cb4690e299b8f757a142dee0028424d8e5a3bfef3e9ca98d527e52f6a5f68c4cfe42362ceda28befd572e5dced9d0ae8936552e5e85732267f295b8a245fe012a1eac8dfecc6dde4f95c33191b69c2d5b72f08c1392ea991e03c6077d503ff7048bf61afbdde4c7bcef24911e3bd971f213a24126496fdd31973141aa188aa86eca7fe371bc76cf8702a27bdc16b319f6020b445453004a27c24baffe5897fff717c35c8751e47c1fe59525ca8e556c8ce5224d32223c2322a660518b119ee5b4ad16fb696d32ee3df5dcddf36f86567f778ab5229fe35be79d3a965626ee202fdba84434a662e166bb69bc910db81728c47b88e1ac66e1109de2cb7454b8652c101dcde1dea174be6fefec940ac13ffe956547c18d749458fe33ae1d36045498cb59e86f72a19364f54429d083e361b66ee69aacd958d8b726cc5a0aaf7486d9eb411be96d545f6d53820a7725f0e301eeeff40661b83de947d9b5aca97ec952eba7e1b0c4a4cb65580617eedccad50d9d08a8585efddd3497c6223b4605bc0a7eaff3042e511c79d481f6d740caf130f91245bbb0d4293fc5dca5eb28524890cbc962cec61decf5f2d118756159d0454a750f4cdf4b8aa2f2ccaa8cf40a77a88bdf6482d274c2fe956bed961e22dc21716010cd84622a4cde0dfc40080a0923f972d270ca93b3fb9bd779fc8bf3aca13679a8d7188263b3e17b253b501f4ad9ed4ea765d4292a25ad4e60780fcba5a1aa13c8ae29bdc47e28e66f54b4331fc42fbbc30444f15633305a91e6f5e5b874a3874118c230f194bc408b04ddde4cc40b4bfab06024ec9456956cc4e71e6dba1a945c59dd36606cc3c2f1cf49503885088b727832abc952ae0658d0bedf5814b9f767445929cbc0df83ab7e0907840e0fe317a5957af89164357a3c0de0aa4fd03299f30558cf7030e10638c11382ed7546b3411b681c818f86a95e6fb3b69e8435afd4358e77e54c72d9ed434ad4c8704a4910f402a494f5e28f40891499a9f33f70021f7396fb0d200acdd78df9265bc26b8baa99099095973a0a5c4102efa79753f8a66bc230c4f156a40472de8a938fecfdd74fb5988aec032627e054ea7efc1d4e378a34d86e1d6d268f14e1ff20ad354aaaf8b569a2aae71ae7b1daeefdd49e2c8d6c284331484b0b83eb52e588a1863b86cb30bdb31f1bcb8e807ae0711f3749a768ee9f667525c0c81824634e6ce86a74530aacd775208626c35b61654fabd6f59a784fd76bb0c2a69e363cf1e9cee5fa11ad07e51d6e3d2346f8030ac9148b188cb73b704b14fe291eceafd9d7e9c9bfa22da9dd76e214a80d77cd03b3a10c7296a37867cfaf0939e7c32177d9558ee06f650d89d4772bb7ff9f07235c49b95c0db856fbde0bd357dd39ba1d72bfb12b378dd36593fc94e0eb0ae3736a29c84bda24f953a776ad4eb66e47bca79864b7e95cc6a9a0b9cd780f927ed342c41ae8914c04ddded5090b8e2ef707ed4e2eba06fbd0b931070733a102e270dd913dfd974004a6ffaba32124ace2d6fa34721afc7b926706241b8da57fbcf6871ead5b8a55c70c148b917f982475264d48224e13f6eb02786b7bf7fb51f014c28736e13b7057f9362401c8a1750810fdaacb14f61dd5202c1702c8dab7dc20bf0fc09137f87a3fef248f2b029c28579226950dc3943420a83d80114033126e0921ffa4e545f89f9c37d5c27f5f3739f7ebdc28b5c86accceeb4731f7c9206cd470cf8d4271f463ab1f00af1a157b1bb65b80aaf715101a43357af34c011aeeb6afe60d9e9107684c0487e2be346a6467520fffb4d27a6e50abc6df185ed8578c14dbd4e29885513e938350ed7c9e8aab589b6a9f080f4bc1a000e041475b74314957b22e7d690c62239d5c090f1fbf0eba483a3f9ff18145746ab9a8e1acb5612e1bccd8ebf36a956afaae2c2af5aebfa343d91dced3ab1231a2025e2b745a530b609cc16e4500c1cd4af052246d461da4feff41380d6e284403330e8c40be292ebe2aa354d1e526732a57c64db33ec61d101542087ffa31771b62d0179e416586c2d76c1f7bef5ed15dec8df9919fba9bdf311955a630139d06e1e984823b65876b9e9d8a14cb6a66a3c720999509eb7e5eb8cf8a4ef7d84bff0bdd755e5d3def8152cf11fb989ac2a8f0c347bfc47a46ee54666237315508a282d3387e23a6387b2c9decec21740aa951d23f8a766059ae95069cc424b8a8b9fb4c7e96342a39b847767ab22ca81846c3718d89d34f51548dbac0cdd7dbeb516918ce8ad3c513591d5aa75f553f74d2d83f45390389209d2b2293580cddc7e4cb03c2010829141398ebc1a9048ae55a35c4db7d34640087de5da1c7721cc0d19c63cb47f5f2d553806ede3ca138ca04d2d9ac9455ff5ddc4f2a00694aee8bc6939e5ccecd67ca11bcbd5fcc7179675aea004beb9b92ea50c5cd49e4271da50595b37dffaa8cebbc7d2ea5580f2c1fb67276eb8a044f23afee831d4d898b61efaa703e6b7ffb3b70469c2c095e6f79be632dade6245ca4cb0fe5a9180f340a1b3949522b282a953307c04cd2b70543705c6fac489ec8ec11d2b04f7e2636bea8378056ecf686bedb3e1a47dfa6baece01f6dd0edd31abbead8676770e265c2b05fe852ad95ea1b6f4216fdd89c00ad69c1dba78045603632c20661df84d3aa94bb90205070b67f363a0aa44d2db3b3c57e83a2c7d3ac401889018e5fc12bff85523419b872832e15d834b6eda921a7d96738db092d01ea5cb57d05981f25b730c28591453b40aa2ae1326c590a65eff4ae121b1240f81a83220a9f7d366016f4860dcbd554fca24fe8597999d4343719312b7f95e08eb9b2fa59e70d592ccb170787ed318de79c918e1442da0c3a12073a25e0d15c6806a8d33c19d08a5bf72cda87e0477b587648f069a39c5014da9a0dc598e10920f5241b13794b4472deacaf64faad20ff7ffad93d434611e6f604d2b249a5cded8852e7a640e55942a46dd38664fb548076425cb6f1359dbd8145553a7672e614847e3cebf4aa568e0dccfcbb1896fd72f349b9729705c16de8c23b6fff61bbcc4ca6ea80956e2775fd684c5db220c5add39427b2a577d24ee68c2bf2bba009ceb120b9e402af8de0f88cd557fe1fdc7fc2a5c7890f0423b628e1c55697f12124b2d6e9dc1d5be7ce7abc0ddc6f0835e02e7970926e5f4d8ab16c764bb9eb87bcbbfa172ee5a805ef4c60f8671fa2ce3b49040d71bf467ca678feb4addfbba6c00f1a8b27a08cddcd6a39ae7dd4675d419f91d1e797587daffb38420e2cdd6e1bc563c635f715a8c20020f7f06fee896b6bc65d7316e0e03cd8729daa1db674529f12e0bdee0039318023e805a9e4f828076446e3a5377d0e3af06d800aeb93143ef10a632b18502913f9e6d6cabf12c214f9889e5523d6d33b67b4dc4eb20db5b89d673981b4e3c536deb058b1c5d2108bdf936c3213402829d794b36f1ddeb72875196b9a1995c418c8043f122dc37328b350cb1f63f52dd35e9536d2bd18a78b420be3b638113d36f3c1160b6f9b6ba26165796872c360d396bf9c37a30345f4ce3d9b9d9c3c747b3027b645a99da768f8828f8904ef0c5c561ccae228934d4a8cb49fb9ce97378d82232901279c60d7a33f85858fc625e6fff8977957e2b7371526b1d2d30d354e1e9c01160e48008391278f86d11c589599d6f31aafd04b75b36a136ba008ef91212d9b9fafad3d0199ea8ff2e86aa558a8f7e2fe1108404de317711a44391616a64f6fa7b0727f7165c4fadddd4cccc8f561eebb2419abaac7fa1f8e365f71c9ccc4a292937d78919ae511de104340b6d913b551d90f6afe14dbc048ce84b429146fb8ab559b3377cc2652ec150bbb0378555e89e219e7a39b8844494ece25de6f1fdfd62038ed8573a725489f693eefd77062d72ce6f054daef2eeecba80ba4ebe5b97d7184d42ee43e9d9daa55511b9b0e9104f04deb361b3d931d6aae8feb372923c4a844d92242c22825a56edb28dcdd56e91a248e2241a1877de4bce620e1379ceb9fdd70804d0221e877c84018f04de02b10b293106cb579e906a249e8212c021bf2ef20ef81ebdca9f2f9ba3d6c127a9d2afd00883964a15c53b7e8f1f35132eb03f097875cbfed2f3604781d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> school </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025 年训练总结</title>
      <link href="/posts/dcc1543c/"/>
      <url>/posts/dcc1543c/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="568884ff5be30eef6f1bfca9fa9062644562d87f8228f933a42a6057cb2dac51">93024cf999deb8d8b2919f7e109263d48b8ddef76bd60d090b7778bf0c7a532716e9b79b5e4e8656d88d8f50b35d5864cf88b8711c378aa8fbe778d621fd7cddb408f5c082e7f14db742a68c2376408a6b04e0baf6028e9aa6984c41a5185466cb5fd9c465cf75ac9c0f41ac6c2eff011fde603552887c7788c6f7e46df3650abbffa5772caa23df24b091f1d512a5159a07bd8ff0b08e33da5faa78bedccb8f32b69446f3e02754efc8b17fb1e67fe1f900c42077a10a6869e469c95e422bdfbf1b71a3a838ae26fde7ccca97732fc671854c03b49fc1510d4eaa31b63b588af93f56441d25aee25b924b1c830c7a7ad2b4d90e06d2a8cade4b85b69cde900abf79dd33b886c5b2debbacfbd2f6a6e3d4b2351d685219dead693dec2fe59178a6771967109eb6fb907dc25da8a5bd796efc2b2eb6df03d78a5567dd7675e3f8bd793dfc2a51e4d965edab7ab6f282a6732ebe161fe4c6cb9517613b65321c44e033efdd1f299e5258572f5520e7b38546fa91ee50035b0b5a35ba9868323d66b97a9c61844afbca90ff56c82f54a82f45f6aa2856428c65bb5ffec37e035436bc29de834878efeb7b0c152cb0a358340cb1caf507ceaf1956778cc53cee66cdfb49a94384d289eac349ffc8450d6ce364c92333423f6a948ac5b77424a43f289920b41919e469a57abf7faa7ae2a146ed1802318a2f8101bb631146f82398e775c26ccaf56cf539c145b875a85a084db13f5f8eabaa17794b1191fb398e6dd69cb6df9b6fd13d57360506df65ba42d712838b4b39f0238c142bd2504a7f46a0cf5dc03fdd87f949dbf938679200ce45d3d4d2426ae07d915743717e127758d1634012f404e68f059b0719d43bb28d8c517ddbf80997976b5fb3b2a60cc0ae966504bc82369508e99ddd4cc96362d79f63abe3542d95d5183f5b854a789e948381f42ed3ca37848c467af05d55512c001d8e768aae10a632775bf1bddc450f007ab09fcb2e0282103ce26fe0b896723acf70a0960a776df5ae839943e19d11cc0c3675f8927ddb9ea673d5dbf6089e490701c8372fff2bf8385d3eb20abc60c4dea15eac55606639fe47b8cd7334bb2693f5afc3a354326ed5d5fea402788cd4de423776d511b325befbb3ccbd8619fbd88b494bccacae390fbdc13f6c2c3bde05a4367cb9796fa45dfdceaa63b5f251801ca2603eaeedb3b5cec5e604822717206388831a3ec7fa4558c4e7ecaf2990dae3346574323f7b4c426b5f6cf7686b92bf1da4c4b7df269adaf5f756b54dbf1285fbf8375780d682a5f31362d5aa1003e5bc64cd695bbb940883cc5d01fe10d93fd8996c5ea29d74cc521d11909e1d48c0ff9495fb1491036933297dad31a1a4e1e39dab03279b7362c7dafcd6ab8c5e82d17e21a55d889ea56fff96d63d6f93941174924e07433c570f7ce73223eba2067a1beb5312d20de0dd86fe8cf1c52142e8a30b181bcc3a9022b90d716be786b544d67250fbd8ed39a9e804260b44225f72a0f4bd9d9307bff1ea66be001d712bd5ad7ae4b3c3ee3ba3bd27c27824e8c9c935d5c3c2f8610f8f9b05d2e6fa09c6108eacd22276e7c4605857482c4def7459ce6af836d804b9a37fec231ceba09ff0570780fefff1a6e95e61206e6c25d79836b0f30e900b7ff83e4b83054990c7da9b184707de7f6fdeb31f4ef6399cbf16638a970274b47ca76acafb1836c11c08ca7cf316c7b83f75e9f9167f19806cbffcc350066ab96233858dc08ea6f8d9f36104305a5f7a109a59ecb23ecccc57469e4e26f4f83cee24d97d40be69cc452f620a1d98515e987b34c4a2863e073e24fb8230a2ff7eeb653b2dfb5cad259dd854579dde5b11a015a4f4c133e34597c51254d3e7c1d2b9171cf670f364c553f937221efc33e17058b70d66d93962ff500d913fb2b79b824d5235341634881e6a4f020feed8313b9febaa654032544fd16f5529a85260ae2bae076329ce15f574844d49a11ad28dea091270d6e7de07a592389d016137b652e99dbcac4c16ae114b1cc54e57a7d5c0ad0f14b639d44575dcf9be630f0bf23a3b1822c07a16e3eda738680952b1499d47b75a8aef89135da22eb75a5bdad51d91d80bc82e87cd0b95d8ecb5f8be51725cf2cac22c8b1482118fae42dc7d83cc6b6267eefcb0889d888a17b35f863f76721d8464ee7e81c2b99cb1018421a60d5dde5426efe93f744b0ed9723884ecb0299c05a8210b8d74275d3ad6790ed55aa6ca76a6ff74ab7432e0d8cb34534528b551488ff91c81f8a256ac6af3725d00026809eea72f0b4dbaa2fd801d5f68caee6bf28e2af6c68e8db38b19b0d053a8099da6f9991cac079854e5f48edbb34b20eb1e8eda432651a61c8e93c643b9d9394928bd850e4a1ca1ea0ab5f1547391d4993f2654649155bd627fdf339fa00c3d7ffd23fa4512ab481c70ca1019a41e8e6989425cd46c14e18e263823b983d96149bc9db041ac29c1986a511d5b24e016311fe2143e0237b3404e28495fb3c77c73b86e8010f45fb516baf1c09792d5cd5138bd43a02ffe140a55e55df089e1cb5f05c66185c875f5d14a3af58829848b251638250981b20700994cb69b43b8883869c01044b066e508ac1d9b8f7e08579e4e749b22137eb98cbeb766e088e8e9b9575b6cea6f9f376adcc4b92b0b3df6ef4c43723d0afa701be9b54d4547e72110b448e544a48a64057d55449f945b4766b62179df44da0903463792166cb2c92560771bd64880a63388e5fac7b928435258630c4da6fae9519c87b9f8de0669f5c84860ae39cbd8ae1df8a306bb70c2154d0e22273bef14245b797b7d425cee5ebf6fca6ea1387f8ddc59cf51eeb11b8a5895ec4165c71a38093c5e6dd921cf4ddeebca85ae720c71009b7fa5f754377020ed6194075efdbeab0d193abff6bf6807672db016f5139473034e473cc3ada9faed88d96524ed39452803f7ffcf7690cb129e92eb770f4addd193aae579be280f4c5f85e69293f3795bc65eb135b20966905450f86556a101be65264e10449ea4a3ebe789a90f0c734923a7d1e17bd5eb898cc11fccbc4255e44d3117f2795d60fff820e99c2fcd8be005a5a8f0f8f1311f8e24c679697ce60d212b07b11386069b2271c064093e6fb961dc1b123a5b9ce4f246af4a6fe5d46822c0f178955a9c3501cddfc9b3c59a1f4db81fe947e14ef04c716cc2382db5a998a7d1cc7a56a5330f6b4a81e7232c13695ef855dc17f2a7b6de6b2ee3734f62391db6a21d7b524b0ed88918ae491e70cbc4134098158e2b33bf1a0c9492ffec2d8dec75c21f7b4a4cc1aa0324a6a4933e415fdd8a2ee7f42a57fb8f97c573b6c54b5701a757fe3755dfb0cd69eff2b12f13b86f5b9eca7bbefa5f92007da373878970c8f22d089e68e4d1acfc7ccb675dac3f4312058fd918e590062e6db1e064542c7e2232a03e7ac940a1bd0ce9f66a9f10e9e81d4419b299c07169b79d12ea540c11af50dd538561bec22bc2ce92b1941da6edbde55eec7bf6be1b98bef2f3210c17742afc967e31faab89e3aa83abfd8092cb32c6a9ad1f21cc4b021d57d40390b6c295a328254bb89654b28f9d89a9d6636dd5ba50117b7e2b4ae004914f552fb315a30b5341922342913483a0e7a6fbfde4e9e40f09e5b4c248616cc0552d3c491926c7c50a1f0fb49248d7598503bbad6180a9f5da7c3f20099dc51ff0388a4a6de62330b0869e290ab48b8bb7760f8244f5d94011919f3c48b7cf7351a14ac020875317db12acfd9106fd0d2b6a49a377353cceaa7efa0c31d947c5ff115500abe371c1c8023e8e27344e7d20b8bc45a74c0db9acf4c06ff56526c8d1b323e4c915cfb92d935760cbaacc20aef8386f43a292d70a04f689b92c581d7a433bf29b99b26b4b2aab224d7ab30c7ba101d5f75adbe897484bbf2ce9129b1799842abd1775737d498780a63fadc402cfa8ee6f2cf2b853807f2dea6ae9d7a9f3dcca6cf8b95008bfc34a726744ea2eb4ea5a918e0794b69855a980a784e7afadedab89ee5f712c5a5d148028dddf2a4cfebab441b833085a14d3ba7b9821bfd2d3b5bbaf00a0aaf75c519884116ad5bac4aad775702a543f4b3df1e4050b9346a90d8a2fe7027326224872abc2035182377b187d699224627692caa1b13fdbb76c7f257e980f42841f1370e8cff86c4caae71278a49fd23649b1ebe93c873c2713fc1317373babe2b89626c3b61183c5caaedd76b9e7b32c3619e5976da26af2c1729d7a77d471887973de19dd6e40d7129b2336a6b47fc648f5d36be52907ac99a78b1220015f5d47b4135c7ebcaff4b35e2689854b0099227a7cabc01c153f53d0ac17004d801854d6a223ee0ca09f944fec3b50234b76675e00a73b89ce73afe37728c5e146326c616f455283172a2b932b3b22d1218bb0446193c0a86c4b32b62e048c7ea1c7775a159a7fbcbbb28e1e49adc721acf4c9cfe6a5bde7a0a15ffc83dfa3b6039af4c1ebb1ad215aea66fb172c692d640927506c69e259b7e707f9af39c10b6bff5dd8abd554c2ae9bd1a4004a775a77e24ec35bbf483fe7c0567b2772616f6fa4ce8b573f4c1ab15cebb77f52db9f8b47f89e7aead56618030edc7e65a0b2fa9f21cb238efcbfd199fc3a7a68829ef98d6f926f45ad98b08e10c270ceced86bf10590ff6cf71753ea7c17b2b7e98a16efda3d4ee3f76d97fbbd4b961ca6feb772bfed5d0356965d8027d1d910d7beb8c4e177dd3fb02b88a3063ed6dee616fe0b7887c25d47d4abe7080ba7a458d849c3f033fdc818a0115bbad9da086893cb4d39a5b3312b9328d7cffc4edc4465a08e46c61ddc7c2679875131a6ab6d1c1649b4045d93c7e48786503dcb28a019206ee8d6cfc0cc9516abcff70ea69a3c9255d7c9021264ebdd67fbb77738f44b7704759ca3ee714cb210324cdb75152dacde0df15e80ad08c59fb74fee2ddc8b5de612f64a6dc526bb355cc3e6f3bd737725c46c3b6d98d40e1e5083c8a866c0dc9afb82abac80c5e122c74c686827205d8831716a4ddc1297d827268dae894da7b35dd62a7515ed1accc10f2cb1300e3dd0932495451cc51720bc59963affbad040702d27337f890a8f6b327617ee02c4a4510a1ce4ee7d5f46770a2cbb68fe665c706c6c535d2ae3001de7222841189e2aa4717e37a7a7e51e813d496c593f667e0310f7a31bc707cbe238048eb915348f0ff205616c6df6ae18d69b8145d73cd6b8144ca2b88090b478ff5512b4e4dd7135597e15d0f95df5270925e283745e566c1e725f0167f3bf594c9496ef9831853ea09f1382df50dfd4d0e47cdd3b3b48e33a94eaad6971d8ed6c58804b53133a0a25cc8f8b754b59de110f9aa4e4ec8e46fcd8df4a19242d6f275ca2d2ed85c14beb00ea8198da652d12c9f5802d20c8ffe6a60cf9a34221b92a973f7895d4a1d012d714e10d263f7eed13f2009330c73c6f38d6b92c09edaf7a7e7ac0af67b2760a6625a330828a76a62aa863463e838c957052095ada263737526702b8f9395bf5e047b4cf1755e06ff328355902033aba35c0de28de25e9c4a38d7d5610e35aac177e9037b794bd585325e453fb8f08ea447cd8439c722ed280188ca5eb3d9ba1226bc38ce963b9418fdfbad84062d1ac00368274900996ce03d8e83e1a13b3a7c07a7f61839e5e1ae8e0b5da16c52463ccf1652d18ab07b4d537b31165a69d62b7bfaffa2a827667e89f6e94023179a5ac0e9d946a1482932f14b73f05ff7dce8d5a1f00e448d96b3afbe4875b43c52397e76b3a863694f1b9ea74e4d1c3eb46b8ba1dab6595be47d5eb0e8cb00538e28e24f7b1c48fa63673c99ef89149091fbff94b2f95c3b04f7649995bfa919cd5107b73802b2ebd0788aaea51200ec5ce314fdd69760ee8c0d6aa7ad10116cc18e01e7904abe156a39ec1e910fa87c75075db4974f26a957b0569dde2e96d3d21bc15d1876870e17d69900edc9ba742a24a8676b27ec5e81102a37c1c9e94011771f9ab50e21ee135840dfbc7efdcb61645104fe955ed2a5a54bf640ce511958d5afc3ab3479afea9ba3e46b2159e724fbd85df7f3ad58de08f5f7c98ce11a6656ea1e6b9d3b77cd75c2f664182c04965f19de4f85bcd5d1cf243e4ee2b57124318dcd9985f2812534d1f7e9e7ac4b9959ec944d93cba41a2be48f962d1226d6a117e476f9e551293f763c2395df5f5e97eaaee1d6d09c245e475d5e7b70b317693b4bba7c4d9b3c0843b36f8168291d2466cac49dbe3c14a72d3f77fee85b6b6e3be112b4857a1b2165efde4e256fb0320b5c92b50e37b2893688cc82f9029d29c95a253cb265887cd092161fc026b0a1cdc87f3da2389b569e50537b822835e6d2446fd73d272dc05c1da1a96d74c02e06c670e3b253660f325ba71418e30c283b104beaddd6f81e436f92508aab9cf912a5eb08d264d543bcbf5ff0d724435c49abb052cd6635170632e25769b43472adf67d36bdca017fe3869648891cb82db36f32324710cd6e4001fc84c5e0480bc613990e4507a8bcdcc6f6b4f6504e25e05143f29034ced0fda648abd408b878914dc725c81d0c1dec9e269de35fc419628baefec06f2c3f7d961e272dd4523c3b896907e543e9f38f2b349d14d0f9c515dc41a6168522f39d5496b437d0c73b095ad6af26f9fb4dc528cb1c416cfd11cecfb50fbc90f98a22bcf9c6b7791c1988d8eedb6955d70e1f95bdf052b3ced33e1cd45caa5ad5f4a7809d4d388f97c0855956a47b4a4a31a704f34ed3c5c43a6b7a3d9eb502536963f6ed060ef1daebf647e60aa22715c41f1cd1845ad13142131fcfd1df101594b17bca6be3340e96c8348eca6da7ae617fc3de293e97c10db9d65294795c16c656cd808b81dec43a41ded7d774e66cc284cde7655d9b172a5d29ddcd60733e0bb62778cf0d7551b6c40f3958976119961f83cad49b75a2674462552cedce154b50334dd820ee9aebb0c0c08b4283b0548b7e9e111e3524d4e87c39a135726c7d4ea4ef11cad418fb0dede6547fdb5b5f752efd02808a77228618cfecab248cc568dc2f23d01a7a3ce005aecb1988c4a2121fe6fca70b7f0725431345ff16a73005224fc84dffccf5177ef1dd348b8bb3865f11a122d7170f64399a3482b54677207d213f1e89f162d5fa1494240f16ed3c7e9d3505970a15f978aed0bdc897c08d717bb3321886e99a70f79daf4640316fac5cf89f0306496460fb9b297c99d4b397dba93c5f8a5bda7bfc61438f7df7a0526553b8ea07069ed8db615b81625c4a78544f5ca09221879dfeea36ee3db72487f39fa466235f766eff37fe0e6d0a780de9fddbba88b942975b619541b90f2c898d9138674e606bbd01a31b2da603190fa544c078493b5db282149a70c1bf748e16bae996c4696678f5d9cd1b2dd8478895313eeb24619fb4c968b1e81119c349c42b222dfdaeb6659d32903ccb130e3ef81e6fa89d60ddc9847e5f28398a969a619e429a7dfce895e673bfb3e08f3f588ade65c380f93d31936469f1ec052630c0beaeefaf427b6519cd34ed32ff6d8cb9d4ec63eccdf4686175f66e821aa5e8a82e44ffc768d42473e46f4fab64fbff7afe1f6097b87f70337bda0f9bf4b5d94aec832fd79f84333205db243a8625a57a418e15961f0774f0b7e01776110a464d445cf4854da1fab197312f112b20fd04ffefedb521e96dd9b48ee174c88e73f9f29a4842e6f192b63df9507074daec69a9f302e4285074f75b2c223f5b17a55fed90a4dd5c698a5ed2374f0ab62369786cf2d2e80571ffe9439e446aa998db89677175164f339976205f0c961206288c18a6d037964736632654125e75de62acd8252ee6a1b03840f8befd1f91100f0becdc10c3b354c48b4b515c3c4176b083179e434c650090dc228ac4b0383d678c738f67dd31b061758a3a2def0876ecbe525a78bd9bc877046a942039039a6a73e9788136506c5634c3edb6f7617fbefa1b70920b013142075ad77494d69f348c918d25886ac792805ff1f45b63abffbe605d89e5a6bba2a9864e65382a5ceb0ca87625e12590c6af54824984bb9dab3a03a4e76d166877c7edbf0200b0f2fced333b8332d73c423a9ce91a447eb35e4e0fec7e2366c6c23a237cff66aa9d3d0a671ac8786154aa76276f52b2164ec8cfb816558929ddd055359f0e5cfc29e5fd7263e1bd82585dc8dce88378a142a098f6f860b8212fc1cbecffe5a12d1c385e6faca7a7cf3b5ddfff079a57c23b1f8861e2fa57ba9bbdf8c5088a53869ba32ff761cc02d39fd79257d8b94f3bd4158e433cd0e516383f60f63aa70678af635a26293f823f7a0a33f8ab3fcf97ef05a56101bd4b2014831eda091c9338f52dc1310f8a61a81b8489e137d481e882225daa6af7bee2e32ac369dde21921a9ffaa7065459124a272aa489e951fff265a805819c8304a87af4aca803497c50f90207a2d383678b95e3ef72b50842562d251480a17583aa75c0a88bae112c216d15e565d8cfc2d8779b88df098f4282b88bbf9066655e14ef78b8fc405c37939cd51671209b19ac14f047a7707ff2c55fc7fe4afb83b694d128bb57d904d3f2bf7b515b91d54e1e6451c2436351dd36061e115a81c66c3f089fab899cd728d9572ffb6c23b8e049799d3c6869548f17fd0bce4f670a2d1dbf7c1449173575e4f8acda177e6f7560b402faf510c839bcda8940ef32c0cf3fb55c59a878a79dc7d99695ff732bb9c98887e2e62989f8bd43ba53a7c82f4cef833ffff1aa6e0558b8164a86556fcc06df022af0df6d0c089140da73cc9b29e2dcc3f21f7486807dcfb491b7b5f972a187e5f5d99a5f195dcd32f406287e4b053c512a4e79e7a3b48b18c8505231ff8c37f2be72441d4c5839e8b84e21caeccf155e78500da06e19832642720068896f58b575d837ee641b0b53c00bd52b8afc1032a4537b3ac3c46347f524284402a0329dbc5c0af14e9e7d3e5be6b915ebecea0c500bab617c726771f77d83e7f09f81c4bfc066e4d0f2456c9e25aeaec5a5f74da949e65d490cc3ebb0edd1bee72e9f43b2018c60cb2c90582938997de249a31504f0772dfbe891c96d343af8fc55b2c7fe322157eba59d556d3e6668f73d4eef388195aeef3813866019db22751dfc059e2e07554b6e5f85eaacee74c73dcb5c68dbcbb578355b4be2fa469a3d6169d1dfd5569965ffc718dcef28437be29aba6907a847f4a11403355326bf2d2c48e94b68e916ff1cba7ab920ae3bb510c6a38fccd13213cec04a45fb4740283683a4e5bb1ecf16f2daa7f69ab63a179a98baf1a26b7228e5fcdb0977b1a5468d9d6fdf529a9e517e438f36c8f9ced7043a9f6c2d9f9be194208d9d7ce48b9681f7a86f81a806e11a5cf232fed48ffb565f30a0b50c244ee2ffa14c9bf417e72b527f5048bebb32afdad7aada51bf2cc7eab3307287212a56dfe41838611adcdb87ec6fbcfd61fa09ce3adefd7ad9ad926311b887aa4c27fa99b18e2de3f7f5df4575f34fa210cfb619076177f5da1f0ac8cbca4df213bb0dda1eb0e2991ad9a5f16c3f3556ea9366e96bd043bfeb170a504d7ddd9c70d9f6ee2cd36336315bd995ae38c8c1856bde437d299363ef410876629b8bc23abc612126f03bc12af186126093fc068b446a0b81b1bdfc3f4ab6f2f69f9ad4f629fdf4bba9d9597700f88629047042616fdb41af3491fdcf29590c17e5c05947f50a882f4ae3158d918f4ece08f56a9e50c02c0be2cea975189199000f3f6c39a0ffafa54b084126b015e65e040c32c9f0ad1a3f41b1c7d75dd9b1d2db080d5eb17003fd30c9a35cfb8fc5a8ffa9405908e507f0bcc0e8512b60f194f7dcb9abb47d7fe2c535ea1ebdd089ec9ad9f6c5449024659317c52aee3806a5dcc6338da070deae4adbb8462a9d61cd21b40a11155961aca1dce82e55a7f212eaab4204dfe818b1b6056393061cca9aaa8177d907eb5ee707aee1225965a12eb71a7f26d0c9b298fc8607e75868a307db1fbd1cb6914838dd126870fa67d840e1837baa8ddff9b7d397ab8c779cbdd33c35bed7e18e9e099b8f992192573d6820a1e3211b04a173a49cc2d08e1f96ab8d04aa2a8d8094b0763457e99af8abe735e457519ffc7f39f6557634f5d67efe926a04a7fc618e34fea233e91654342d6010052b764c77602a4e9b4c38ec000016da338cbdf805cdfa15fde4f05339fecd1c4536cf8a70b02dbe100c3744c5b5cd1c957848d17cc34f080c38c598ae23868a75e1e7a23de9f94eb965056f596e55609e6d861e754671be975e854db537076cfc3dce077c044199a9eae19df9b715fab479c9b5cd2571fecf7adb35bb5de570555b7921ae638737255ccaf4baf9a0231c7cabcc70efe4214a39380fcebc8aa28ee9c2b24436fb298e1982d3570af58441fdbfd96811b9ca35e688644ad0e9a99c3b91e883f45f09ce0509bfe97835bbcc48607e7ea22dac5448f225561ee978453e2d366810b049363c0e23ed584f08a127773487876b553733dca777f96791a7c37a97c7d18cd665bb0e62f5095da920813ed637a2d0846b94c881ec548982391d93168bdb732d7d8d213e58273a7cbe35df06acd1b2b1d381c29f95c7d170091d80bfd6956ec256b147b12cf5244bc4a4944c96607059f0d199aa1b9513788a444d0e12aeac58ebf855a19b1a5219dbb7b1e14f3ed19c4e2a56b9f4191ae1783f9a8b7b47f2549777e8bca3a4161d5bb2374504b6ef2156af232fd3dd418027598d61d755ce69864fcb93a6ce540b0b94e6ed4fc6e11ebfeac4406a11152e3809575548cd98a7ffdd78adbd465a067db8ca238aa42e8d1a20ef7df003051d3d2e2d680c44e6544ee537c87d1587a32f19daa736c5bfa0382a28dd3c4da839cf913f51ad6c722477b05a062b480b99944a263781f04aa81357f7641f3cfe0b96e68dc8801f11ae6ec2be52f02bca852c2f883a13d350cd80c7a5284cd5bec0711e858841b49ea231b0a320bde6f89808ff6dd2cb0c25abc97626713aeaca60a066b1e91c9f40e97b03d24de7d56da54b4fef631d2b1badd5a99be90c40d1209b068d0fb7804da16196b414e6fba76f2c76de697df8e4a68f6921fcc2247068287cbb53bcc9bbd6e1f8feaabc88f32534d98fac65a9f26bb5408858016e37a0f0d3d607c344e93b9efca80369a4ee7906f67621a2df359fce769b9e35582569a8ec42a9970a0624dd98db8fb893f3e33e307f3d7249be979ed4b53710262a161b6543048eea2d81fbce19c154e7867c16d154904d23f3f38b011ca59a67fb5d078eecd31ce9a57f3422788d7fa3435e9a043b92480a13cba92ef18cfa98bc190c88a135ef42daf1482b0679291740103f3c07832d87372c3db875fc7e39fc0da38967bd3f0667ea88c1c855af20b64e4fe20dc1092e7b196c4140ae2aa2f9497f7e61c9e7bb5ead264fa952a8a84761d24c8a9324e5c9fa089288aec23840fde93df3e324c2bf6d40ee6f261703c18bf1e8452d0daaf1f7c329e15f9ee1358acfb6ff674c823da825cacae5591eda13b472de83ec45991eaf596e58be56b5350743ef01aeecb3d28d93a24aae54333c0355bb12e23abb0263a09b66c9f0bc5c9c5cdfec67abfe80739ccf35f7d822fafaf0ae313483a7da1dd8024007e3edc77e20cceee7ad976906d43b3c25022c1579db79fcdee6616b909cceb3437005446edda5175ec167bafe2da81f3c6b8f58fbd369417b8020d02332de948b752c1a6923f2e493a7502c41d72da2cacd2005f09cbdd2f5fc6cae438a20c5357dd43d50a08bda34a0aa40bab8264d863ddf2d1feef2bcbedeac680884c3544d05e10dd24be83dc5bca0a8fc4adb14b5cb86cdf9ea7e00db4693fb5ca874fc1a6f7b594ed25ae258c1955f5fdda8a7e01466328ca95d7698c621b48a0d5033c4b8807c1e4f1a68e43b897e93539d28501e14b521551e5e35f2367a13e181795388a431581752bb92ce919020691c5d4f006eb28c37e432faf9468ebc6e6e06b039e8373be6adf79988fe4ea8d7c1ac97bfae0a286dd119224441e1297ed08cc149301a20377484f3274dcb4a421e9dc97e1c11637b8c180c058dfda5019e7267b1602fc6a33c575eec627542da09ccb7f38f34335b0946040097dbb5fe2644a0542c04086eb0c69634188455c3f20e8bc97246186cdd19acde35816b05a967a9326d9ed761f0b91640a1ad3fe1a488fdd8956979460cc6c3fc59485b3465b57eaa8a501fb9be1639ed8c2cea77fc20e806c53506e2a78eddac138a7263cecb55123a0c252ed3a4874f21e8eb8943496edcf4c298ae5ba11d9613ae1473e1fd48024b991570d9580145be6f202def0ce38017ce4fce8325f7046037fc2a8dbf5e1c23e04302a5c7a95f90fdc7759ab36501484d85442ad3b42a6fcda82f6b5309ae5e8145ee29a54e06b1aa3accaf3b6bc794a88bfaaac772da6d93af363df6fd39dbebc2b5b459ca4ca79389b4b73f88b1270c539c7edffa65420967109612fba290cadef486ebe80d5e506e73a0bfe9b9636a71190e98d4ab14099ff0ef59a70904b3d66198161047ecf9a033b974819eca9ae270d803330f25698d5b56ca92b4a1ac7706f6f15514b06091ce32c0587529ee53d10382e395ab445726e3d46e7eb5bb3dbccd05e231119f0118b024609ba1c7cdad4f067047a4fe9b6e2f03cedd28dc499f0996c706b395e96493dd9e3a8cb88984480b9b5d4ee2ec8e5217f6e1be68073a49e3199b4c0a6b89842f67ebd0abbf6615a8541078567c1fb015cc667b3fef2c147f522eb4a7ad3a0ad02e9dbeb13f99248198bdf87c286f4c7a1b2aa126f8245514253711a2f4e766cbd78ec7b3cbdd0c31bcf21eb02467a101c2de04a7f0096df5e330964e560e9530be66f7b813fcf8938c5b877566b242f0d606f3a8405d23562f312bcdfd4ee4d3602d2a018d9b603e474c968a0189eb06bb23c5bcbc451f3cf817b16210fee29659d516b96256d6937f8e0d20a04af6f29096fa7ee5dc8f8fd2a7945f4f74aab5b77308bbf35916a2b903420072f36fd574930575135f2a53011350377c56f7633d3d39a9db8b87654f398463fc07eefeeb43c7eea374d9d19c94ff32039bd4c5f73f7c433659435890d5df8a27ff0c879ee997fb0f1b0f2c9c2e9ec03ddcf10fa45436f005391dac5037479fe63064c861aed9009a57bd26a88d70a775ba206da6745475863b80efb63e7f7b5b5339310eb835f8f59516b378548aa84b48881efe58f3a277c7175540462bb3bcce211f3a95a773d1e0864039aba876cc473f2cc55fd2c3abcc8102372727c9d44bf5ea21617bdb44f6dd7f1c0729a6b80af7f609b9b1e0cad5ee8822e7cf9feff5d493e66733e160934dc6a22bf92a488ab1d26278b92dc865c6ed5ead525e36489875557924cd32a1f052ed430458d1bb47472be66b45af0636c0d0518feacb77927a7f6b5a5b8a50e0012a5b9abc613ed8bf2b387fb83ce863c175205d86b74542da031773eed2e27cdae25b554237cc0d1b0e2e10b54949e6cc33dddcf11ba2be24ee623303860549154f6702e15b333b6edcfbc9c62c3e5df8aa20c1c0997742dcbff6aaf4e19107229c856b9ed7ec1c892e2505464bd8b927d6a25d049306f1df53223e7bdfc28d8f7444467f972e28e04416965d2a0df0312350928688d9ffcd04555fc662fec917f5b64b705966f7d9a62431a1389d059eed2f997d6575b52708b5c58d8dc6d8e104e41d2b2c1fc0db95bb5d767e254b93c6ac7730408d6b1bb03cb504e3244415b62b0f84dcede12d554b7cfaa37760252c81bfd95a1ac122bd582a16577d3440f8a6af0602795b79ab05956ccbe3b549efaf706d9479b7f281f4c7ba287a1f0e621c9bfb7704cef4a0e2584d22452dff3849ce86283b1e1b925121516cbbb2d6befb9018a3c3a857681a4ab897badfde33fdd71d949d40162b44609fda301634acfdfc6ffbff99cd551ba96a21660303006d37e835a91ccf9024c0cf571c30500ea616d3c763f94450fd868994bfa539b25709b54ceab5c3fcb577314f37a7d0f99aa3ba82c05219eeab16a227e717c7d37130cb43ff83f6475f08011df3f438b5b2970baf3258797faef618dbd6a847ef52f84a67c0347cf8293d9f1966ff48e0c60ca2ee5419f1aadb83b6e91110366c3ab047cea071bb50ba7deff6424cdfa80d83a1ec7056267ddb6a36d7482150a8d7c7dc4be8af4dfa6fc36ca65ee1b045b3efa7f2cc7048091dbe25d2ab1e31815f77b44684ee512964ab825a9d18b9843e92957b24195e6e1a999f5493f820b1688bedf296c95ac3c227c9cbdf88979429060d973bb7bff4cb89b389915aadee59826653cc778592c188183d24a4cddd0ec631b7be8cdd37fb116432ccffd1902268866e09caf24307cf2ef8f98ee2c911410f9f0ff8a1ebbf27be57580b9732358f21119a22d6a2e2d5a12446adb8e0f7efd12a7753472816bd64eb9c5701291e4f21c6e52f7df09cf2d438339adbb1822ab41d2203863ca633665137345a7d033b4b8b5a6a733fbb81c8f88699035371a27a64100dc807d1d722fa1e5b5a4023990c83f877dd7f588f5b6d8b7f97a028f3bc779a359e6250984c637501ba1283a2e492babcea4f370a4d42872b8f91ba963c8560cd147ff97cdac3116c097231558f1e27bfd3dcb3d699ef8ef08a5dc7db61fecb7da84563975fb580f759c2bbb03f47da95b52488cb71372b6765ef588908035782739b947e3e09fdbadab12030974eaaf013ca911186491698f9fdfa6cae3f94611cbdddac9cfa482389e2e6e8341e1271fec37d0cc6628722ca4da2d1cc94858cd4c70d3e605e329027bf189225b3210fe06cbb6002ab7c43fef648fbf60dd319afa8586eb93b719977351c9088903fb2651b6329a8981651fd8f3d54b349a4de2c49bb735c465903808a4320ef869e7c07ea9f8134f3563fcc6297eeb2633ee361a44220b06379bba86f6457f6257f49dd3fe2ea5155941def826740716397f1c0e01e40b05801e292e98e47cb40ce4d0170191465786654dc31f50c35895d37ea5c829b00512663b53912cca5da3299f7b7cde352a11e2c547bcc6453793947cd2ceeaf62ecc954088747bfbdba631c4aee1b321685f6c19905a226374fdf0ec40d75c32142c64686e81c9b0e0b0bfbf231e9358f7dc0c87ab7f4a22641f6530e693afec63d80cd2ef3cfd462d2b3b6ed38420daeda2143ca3542e674727f3aafb5b4262a81a91364bf8265b6e84b1e98e50e3cbfb6b1a69b8f312f3b6061bc17efe8cc6e4d8b5126cd4e14f5d66c5112a460d40fcd577026f53428563f41546abc1e6645bee9b7111de43c48e98872f42c835953e63ce4db139cec15ff95ec4dc2a062535288f908a575ab50c953ea6b87eebfaf0bb9e4edda899898e1ddf7d0ee5fcfc3121d947d85609ec5ffed497acdf4264ac2e858cc6d7e9f4b0f96a8ca55dbe07a8eb7ce409ffdbcd8e0c1a5fa85743352f3da1f8c655249ebc2d46e81e6b5edc2b3e10cee1a1f2396224adcde70a1ad9b1f727efb4519df19d447fa9f817b6cd36b37561f7fea4551d9d00e371bd025d29e442a935f02ba1abfca49aec0132a9d3ddd7289683abf557583f11fdcaf021392e8eceeddca00e7d174e35ce29181d7e86b03fc8c0f02bd4bf5ca906366b698ac77d50ec3fd441318affa1a945550b5d44a48d534a6a718b4f6038606e9940e5c712ca5ef16b773c3fa8715067817add6eeefd7f01a65666d46b9235eb2185fd45e764518ca1e55e89daa3464fe2aedc206470e60a695fb3a0b24a62ab32344987b2f9ea875f37d3a599114a11f8c4b5380119c7de43fd9cd787cbcf2db3c044788d8f4ae10b6e3ad263610988d89347cd4a189bfc437f9c6ab591d47741283b56806b8f9794613b160bcdf1d4caa65e13f9d3b8d91a51f2b4405af87da8beaa65584cbc8d6363bae9721f984bb1a9522cb3c9712c66cea7ec6774447fd13668ac56b0c559da679309995415a7f3237342f7f69e88adada1100732592a58449c36dea3f6297ac37693aaf0b798e7665fab806d8515d62170e93a9c69b81cd6649016b4aa37b658e783261dd46cbd85bfd326d634490a7f34491a82874c46858a667dc2d188c2a51e7da616ac1dc783b5375d9c5cf40539fc5aa90f77f0057b2ebccad8662ca70de058c34072913655483cd75739250bcb0bdfc3ed5a24ef0ace7d714b620954678e23dfeb0f09c58904aec36229a5a1697f7daa6e3a903219cc321d57c054c493f52521270f9828f8ee0734f1d23f597e2998c1659034c07ea7ec9d8202f03d17d5543ceffc18a12f0fe76610b39d04683abf628e4be619f5a363df4b14a09d7efcf92f1d17622ab6c2d7d60fd362e23e1dd1a481b65bc3dce3d98110f4564c60f79e298b90cd2b2e4c099dccbc306b4b109808cc1e402b09b75717dfe6d54845bce8a622a7619bbbcc50334a7017e91fe33cd27a925b856a121f578b30fd6e81cf5288aa5c498090a8dedd730804842f33a29f2a357c469393b66e07bf35b716dc2fa698f36914a9f26f1d096af1ce648d9efd59299690dc0e8e2889babf829b43147e2fd77ed0d62bda5a4a0fd838ecfde7e60235986ec1d06c5a41344f1d7dc9a4223d7b2224cba0034ebbf23210c7e01dcd3316f3db4c4d9359f541daecad3252f75d7746ac0cdea575d0ade3bbad111df231197c8750142aca1265960e207172c2aee7089c4821fca3145acc65240f6892783b147476f3810b86788f278af238bf634a640d716143769b7f834ea9e56406464c8d9de7bd9d36385a0e62d7f4adfb874b627bb92468f2004ff619beb99c1e9ef70def586b8c3870c259feaf6fd7d798cfda91216cca5d7baf86ce052ae8f639f3020207f65432e44d21109983cfe59e587cbbdc59c2af007dd7cb4b5e10f7821dbe5137f6ec0c54c1062b8c5c7499592c9668abb01bcf68032f5b4fe680690dad0a5019ee6ab651b3f92957e0d8a08920c8541f06dbae4116bc58cde70fd39cc4aa83a8624ce8be4a2f25e4f1323d9497104367b48f824066f4532912c164a819ee941c75c3885a21f521ca207b379891e6bc6dac4d852c4590b02c350ebb8a760b2c403df99c94712b6a5c95cd9c2b8f453a83260c6a7099b4e5b12b7661fc88f8daac29282af6109ec7fe4549c563abef6a9bae8d80fb2150f00d081dbe3a8c3076da95b4c2ae841efd7bede934f7dafb9771176b8e445bdbb81b028848b0c567c36e158646724e3a12ede735f9d9c3f91f97ddb3a7f930ed12a5d73fe8eb8d71aacab479acb0a4e7d24ed82023bc047f56f9e8942c3ea2ce82c0c0a21f286011abc199c3eae7d89329eb70cf044bb5c19c312ca00fdb188dc0b323991c3a11a57ab464386fd334ea30eb3155c113b7eedbb23dd790bdce4870522de7b44d4a1dfd5e763bc95e485aec64490eca6642841659ef8c181b828f7c736a341e1f5bed2d49575bb29faed15fe71ab8b34a5ab8ade98074a8da013e297bd3619ad2a6acf68b09bbc04f62c685a1c86c6e6f5f21cbb6a3f87fa19ea92d0df1dfa05625cc1db5360620e7bce53e46b56e53d3808443a1bc937bf474b33fdc352901291bd5f95e4f820a4f5bf9b4c415b2aa808d16bbe9c1ba9ce4f4f00ee3d3aa2d9cc440a2fa31a6bc1c1e88021a23aeec06027ee49ff3609a4bf6a72ad6d2a62f29aa18c8e99f113494bbb8cf5f9544dd161f7b4e70999436c9c783711079af736e20dbc9539cc940223ee882a16782a1260d649168cad51c9bf89e291a02d093102e2107de6c6bf1c987003c0b827a96502da9f1b7da11dfd3ecd376a909ec776a4efe01eed5cb8043bf7be896f013d34e021ee4bc6e285d6ee3cc87222ba6a379ed14ecffb712525fa331e29a5577b905411b4ad7e31e79c1061de45d034147308795c264319aafdd5bd7de8e04d799b5f7ccb8d8765dc24b713ed010ddfba4cd98ebe434512cd9595a707dc6954a9d4a452decd4f220c07b3074d6237598d83806b066ea1e905b98124cf49fe5a29e1ff3b8dc19add2662632b0f8ba057e7403fcad3c77bbd69fd433edab41c04cc83fe06979dd158f845ba8855bf0dec25849ffbf85b7888cab392a1393c6c4129677c71276b613fe233ddba1753a48f8bb49a349c0fbb0acd7bd5054ecc2a1c14ce2ee3f0f2a1d27e0828c3c3b6b51d24dfb97643a62343f3c55a5d174e55d5b7366cb4fff23b355eb15e6edac85b4aff8e8995e649696fce8ac9acc85ce74f00b27bd95211219c6234987ca2f33402234d71038df80db81b2d3a7a0abe6fa87c3d0b29b21483c3ce7b1a792a0c25c7707d84c13c8b1ee1375f4b80ed1faefce55fdfce144cc5013752dc4eb53ac45bace6b4c9e49665c267135b7a482ebabe14dcaceeab5e0ad865b0fe946096c028b700183eef9386c269b1d0ae50689c935a0b911d34dfdc2afba8b33f0c0fd78d055fd61161dd50b1a8b289803257f74e4a1262c1204ef846e1c8d4254a882207b174eaad702c1223e9d0e92ec6752c2d9e0fe7c7179418bd4ba193b671e0a77db055fb145275c516ca2cf22fd2d355cce0e5942bee379d2547260abdf7abf2c0b407ffd83d441045056d3130ac01903c67b01beb7ce2785e29940ef06709c8e83304ecf2135efbbf867cd61adacd818fc1a771676d313317b44a0b75f8428ea7e5770bab8220755a8eaebfe6002379ce44812f1a2d9e09969bd3dcf80d202b45f8e41248642013e0179bea425d77e4488016dfee611a7df4c1f474ed472902ed1209645f61d550ddcbeda96ad4e22c0dcc1a1c9900eaa9fe7246cd7bf533899bc42ca90d7953e3849792bf3bec231f25618bd8c0e2b663a2f8a6b83ee5572dc9b6d12824630834a07603b1a27bbdd87aeb647bd496813910ad3bba6184b35f56abd7839c75face03656832d5da7e0022c6a51b0c66e253ae9c8db2acd5333fbbf8a3c53a61e21f677eeea3693fb7dd30860768e296da484ad94b5734e0f0c126e955658715cd36939f00b2a9d4f2f44ea5b609a76516abbd758859f5961a04ac53ad63ebe949729349517c86892eb2457c2f24be7e431c4e0706ce3af1b0890cd98ce963ae226a88911422e2b81fc886815059d4c4100ca9094831bbf910da814b61e93462f59b9d318d3c23ba8525b8af839bc444c2a48a7784e4e9d0bce10a80f5251d10605ca60e9f22f797b6b06191c0f07b4f805093b9683095be3774c87c01c2666afdd1acb056b11e024dce5273e64b5f6dd5d7b10c8a56ccceaed0fc58dae70269842331afdb980713f39d422a3ee937983ec760bbc1653156f7a2b7174a4f62084a20aa9753bb2449372ccf9533722fdd0bd5e9682a241372094aa63183d46fe68e0947a96134575ca05cdf68d1f09080d65013e6e70856e869a5209f677337976c6279af2f1cdaff97b50e85cf2e568ded59247419c24db98cfc2831e66cc098bc2f57d14161bcd85ac66e2d2afe820a75463fbabc51c528670f3679e766485d193637f2f2f6f7a532bf9c73987a960cc31df8bf6cea2fb331e0ad72e3b9c8c633a3f3cc42e5681164412d7f3fc2b32c7915c3c41fcf760da47af76b0c0c4eadc5b10f190ef2724cb6fc90700c4208f9adbebbe00e922b41b74760a7526925583e929e63ce50f77f36db2bc278b3ed1b43d050950be8010d861e7dfc7f437bb1593ab35558c7da60891c8e81ce2b529192febc6433ea3bd083e6650615a4b96d57867234e2011f3c27d9d2c3ed418c04c2f8eb68e6fd8c1882b6b80541a196409740189fad965b352660cd309f00c33f2bc1e0c4dae9994e93e628cfa9c01aa785ee0343733bc6b8532a834e9478b5e8aa13c7f10fa85de3b2807fc4c308c757234076121b420a8a782f557afe258f82f3d7fde8c88d8979acf492e38ec3ec9e4ff507c63b7884a40fbf634213e109d6cf73331e0b6a74631fb3f68553a42b4abb7044928c820f656205ed5a5ea857faf6058991449d1b6d1b59ee2dbc1a489a02d850ad97b20ef175f394313d82bbe181d1ce4770076436a11962292cf1de060dca8b77ba1b847fdf8658cbea595b0c66870352128544e7e6cb44b04c0cd88b9ae3bd2d46ffa3c5d2d8cbeede10551487954ba6feb37f45c2e74bae24fb81c6032bbcec37761045b414f65a8f1e64c61b1e592d9e3a3d7fc08d610824a03edfd6aa985c3eec92cfdd6f6030ed3913405463397a9bc27550dbb59857c1f5c15248e165121a1a8e9c72b30e02464ea3f5738848a4343f02c744384fa290ee375aaed5b28c98df3720b100b308244a285408db64ad5295e40fcfb910aec62dd2dfbd1725193dcb5bbd5b897125eedc189a00ebedc03d0e22f26473e4f75b3c9c830e626a3062bef8f233dccec0f119e16836f0345f41d62bb968eeac1ccbebcd24764f6a71d78f096cd5e87ce225d4105e7a718517c84262db13e9b8fc6cf1f5a6c48f4741534814b53a3a868bc33678fbd69c321f3686d0b6168cf4d4ba3dc8afd0a7fa1f0698353c1d7729d5bb85ac2218efea5bc823d5d5cf1093b865250bbed726bb574547b5f73a345746dafcdd526f86e0396ae6f10d165746a79eedbcc86b5bff8cfc1f38c0bb74a2a6737af129fca1ed583e744ff6dc35b02b66f6663bbc98826d62ece9cc3c8f521226943e87adf90ed84b1e904cee46431e9366276f9703bc07ad71f7b75d363f7621d1d44a13bc86757b676219d2088afce8f161bbfa599bdaf48669ca97f375d53b60a3a6f892c2d30d92e31bb070816795357eac447cf77f8adc3d4848150beb8636e910bfd8266ce0a49fafe1ddb2ec0e495737900b8bec73a5ffe4dc90c2336ced39fe18d42d45b1609d96a502babd2d04548d2bf8649a324618b7db7960588c96d9217b1b22a7b8d9e516a9a97a47adf32054947482aef93ac3035d9852ec178f2e059b534111b43cd3a1c306a66c6777edc39bde30cd7904debfd636cb09e3463fe1bb465f7c7f683c1761d8b369716439cdfb56d68121894c9a8ee75a2b0690b51192e6eafc8ef8a1d4663eb4c30fab888fb35ee581026496c3fa24b171c8d60e72dd9f19b7b189e2f8166f250eb31ae74a8495f66c8c0ee3272b8955cb4cee5844cb5002061de1879c933ed9b359862b93d72f216692e928c3d22c07758f7e55c2b3befb710f947ea818cc115b220f0ea1b0fdc1cf1c14713e28f65337ef1540994723058cf66bd16753d7e9c99a01dae6e34ec3f30fc4d745ab4fce2d9699ef833cba51eddb9e50dfe0c08ceacb17d07f65e7ff45a5dce17a46179bc39239c7410dc1582d20040a6d336c4d5076edec2bb33ddc24212ff475a958911271f51867e8453aaa15bdc21ef8df92ca4eebd2c2e0cd64209501d213ead165397e3908d731b3c213426b2d21dcd71b82f2d1ef8707b03478c9eaf65ea3730787aa23d43e879c90ab860b494bd2b4156e8c03bd2822a4ba30a2366c55b999ac6efe7bf02b725ac9bbbfb5d7af9e967caa300b53461c3c60289f8d88ab4c3c3eaeef92aa1e4ed02186603687d8f112c3401146768ffc367110ea35cbb5f4e44985c3f88068e90fe95a72fa1ce9b0123403409294946159e94f2b2ed24bac086e0b699ec092aba99d4b3ecda9420c92cf65d427383e3208b10f0df2bd18e3213137059b2df0153d0498a5fb2697dce5a0bb285aff996957b17c99e6923ee0f3ca60120100de7c7ce5de1511d8b6610599825d09bb59c90ef462d32e4ce5a7d695f798740ec5105e2cb39719d823202786e25a417da9cd35e56500fd5e2fe2ca54514015e25142030c9276fa759562154351e1c0ab562616a5ea51b19b733e42677c2b487600cb77568cd983d22517e5ec903c9bc5050d1d32f96321a5d1da8d6a31ef4b1051ba721f3282d8b08cb099016cf4ed18dea3cea66d9463b70234612b20ddb4b9f123b6f623db7a3c741fe56884f110011872dcf8dff0e3f5949f1694aa5e10e9ed48c1a259f52b8725e17884886d2b31c973512f02363328cb0cfb387935c8f564c63b57da2d87775140013d8ef29b90946caf5e025dd6a782e042cf8ac1ac9705d3726ffb2c38b0fb82b69364bba2b0ce3495e83ef017ac2fce1fcc6e75492fa0545e2da68cf2d451df2d1c89eefc7c7703ec2219682d637f7011c28bda2eee601d0b68d23e7f2204426382bdc12eb9413dcbab730935bc4e71cff66681f2ebf02533c5fd97d5a5cca209f4cc2a3f1e75388620cab32a6aaadaf3ad61df8adfec2a40c35bd15bd2750301f5f90651e2a479696ed5826d1d083f1946958c3ef6caa3eacd565dca34328592344715e04072252501536ed776988a21afc89e213e511f49d16cf808d5d01a3a3692e5f3ce207c438c570d347693ca6237e34836dc139c0ebd2940331fec033dc32b503d7ed373fd1124a049f0db857c6d1d46625aee36193af07a19ac4daa4932e1ff2c7c58fb8c4bf5d3f41d2faf94172a25a77fad1ef0acae6031fa7e183f76aafc6734aa760da34c2777057ca259887478ed7422adbced19a21f22849669acde2cbfdc3339d39f84afe61f65caa5831c8715f9b089bfa10cecdb7729c38389e966ceeb03f95f8759906e78d8fbd6b4d5db6ce2c31ddb8f4c2b3e7d077c247ebb06cc2143090eb95b5dabaf6dc7dfb42e64ed7076c890d59517eff3b2fd06b9b4657acc2965e5cbc68f78e4555dbbb6087f23ae2c76664d0fa8c94ad9f832e3ae3875df7fac96e61f0e4c3a7df295c63ae642c92805e97ea35f78dd26a2d127df8aa6fbf3a9f69b62ebdbdba39e1653ee2433ad0f56f5fb7c4833b32919eb7965765716b5cf4e5413e28426f0f4c938cdaabcd5f18c51e65f00170b62787e4acf58efe8bb5a1c42eda53a6007c5bd525565122097c097789f45a5407592fdd17d7e690dd27d8601db887946c30b7308dc1ece9442af2de43e905be8fc0b4ca78f1898ec9444f7141ee8899fc058785ead79c7dd5789480512d76877771df5f8ab6a974dfe499d352b26ec2b1fec36f1abe0805b677bedc68500c34a0cffef7d8ac58127959c45ed4b120fc07dfda817666258550b445fa885a032311fc4e8f0cc140038c31b682e385b84e303302715491cbdcc11dc1d44f40b9dbed0e57721054067ed44dda7f0f9a80c767a6f62c3c18bf521dd07a0b258732a80aecde1f9cd5d51aebbd62741c29503c62c0ae8cc21b422bf71243f4771fe9edb57e8bf12bc5e9819247d0ac24ddd013abefa4d745d55bc59555e6c01013b83862afc21d7d42049fe110dac227031f29c8bbff02b35cb79970ea382dce795cec1f68988c291313a0a411ed72de245080a29fa3afb36143f1274c470cc57e8ff18925d09c7484721962b28d054c36da42951d7fb8f8bd3dfc90c07cb3b4cf4c697f9a8072097601f4c61e74bb6864fd9c31c36965c315b141cba64c188c63f20239dbf5340b0a57be5f7a4c446be94fb3e150d9f412ad37afdb62a1d50daa70e52f8c43c596b059203e6a2d478f91a368ad55334311b951ba1259029a1d468ba5f6ed3819984f9b64c39c646bbd702346b58aa08eee400f18a50b12d8e1787dbacba84f68e627fa027c41d40f2622597c0ee3b7c4b03223f4772cad3716cb20cae738ee8ba993bfb28305628a5052e2e0701c62dc9e01a1ddf551f53e22ab4c4f129f103e98efc5e5a0415dd7fca309752a44a5ca278bdd4460c542bc0a687cb2d236a78ea3e9e8b9a33da01ca52aaedc04272add7a3abda0326346d5522422da58bde0050fec325656a19908a542f4342aabdc6fbc180b97dc16c9a40915e8361215b54f002eb532fe855954ba10341187d3abd6f5b80b9abd5f901d258780ed85bf41215957685e2bfc1f2e4f74a734a43053631687ab6886d2b8da119638e6d46fd0e9b5dac915128a848940b917d9659d67f1b78a13a9ea70c3dc8eccce6c8621d1a72bcdeed0a6492c68994aadf364620b45f9146844861ef19c0e56a13e531a258af984b1028e4672e23de054d4e4be15621bbe06edcacf83a9a1c886f2050371f89f406b054a317739d1b7a01cb1b263bafb43fd8a03cd1053d50d2f27166332bdfff863b0c1376d3401100b6034f7e68b8ca4c67f929f99f4c1bad8194cce2c911e6fe70f78f632b5a5b177411dc6806d8e051751ebc0e6c9a9bbbbb87ff1d2ed84ef66ad1103b8dc8710aba1001ae6c01856f37bf0855c6d56995c9b20bdad126652c965f323cb763f0346846ffd855563b3123e60f1d1a3bb6c7aed3a627b824f59a89c07a4311544bcbc214854c2930c20bada1a9c6e3ce404f9dcc5ba7bcee3307e53a4473321206b15fe9eee701948f123bd9f44a28905f890fc4b3670cebae960a7796f4dcae97e3a3180665033222d409d5425f9b955b92ed12b0e8ab82c510fb2cb71fdd219686f3b33ebea0f250c2e624f532614310322c3facfb978151c8fcdb3e611b73e947de28f3dc3673ba92ee4bbc82a7af9443603ea09594ad99b0a020864665e4fb1c43b03694eeeadb9410b77534053ab60af458f316a9bfe662a989bb84877b8563567f0f7cdcfde43aa3a1f11ab051dd52723f1971e1cf1b4ddccab9927cc1c828cdd559c2bec439bb8c177d85168fbc4b88e6d1e92f7ca2033e09cfba204d5b829144247a676568240c8ae0b3caeb6dbc17012d920fe20e446378faa872dcd8d74721e292729dd4feac984aa160ed409a4635bea7ed0a4ba3476db0b65b232a2fa696606c0dddc641613908b60c19b331645f85828152e9769eb681fefe25072b390aaecda63f99d12a486d58ab759ef6a68eaaf1ac11a48cca3df2c9a2fa3f0eabe40b08943bfaab8f24b5a54758c729a4c21ed1c9b3fa4114dcdd661a8b1bd7453b55b6b89f1ee72008aed4eb177132ba7e9b2c061271f734d9cb76b36fc7f65b37760a20e228d9b1bc3ac5508aa6aa74cef222e960bc1679707a7473a2abfcf37a5288abf87de73e4605a9cf98b3f78b7d30b2d50de3f860eb9138ab9afddc08d9e1d399abc25edb67b0ccbaaddfaf16d1128409ace03e45402c380a078eeaddd1ce2d647ab7aa11f08d1595d7a6be54ba9805aeb7034a24ec68115a5036b938bec5621f7af1ed2d979a0446269d479d802a509f89940cb41214e9fcf65dba321a5fded6f52a5e40cc2cf80b3b396280d4f5ae960105717c02b1e6d15fa28c3d0570e19c2cd9c756e2d61de79b40b055532402b9b3b152f4628d7b033341f29cc29271382abcc0ecbc84815de0aa67f8ed33fd56b6ca00065e78d447105468677fac5e7861f0ca87b09a190107a0346a1d3ccd104af29061cc1ee03cb2034408a3158add4ab0972021b534ac9016e4f0924359ca147e5479fc07116419bbdb84869ef8f6ac5edaa4158278b8868073b97bd432e3f3851b4a2aacf47525dac924aab17be7cf9945dcd26ebd800f50d05bb9f1ee08462dee0ac7466618b3e76d5e36968da023d11f67584c69f10ba84c8180c6c8f9fd9e61fa47ce2a145ccaef52d79b6d4daa9f53aff656bee58e994b28adf1f6c71d60e4f2f8822d9128eff8a96b090a12e6f183378f2d0834df60f1f62525f83003de6c0840a5f103dc36e7e724341dd161294ca6affde91c9cb1198808e59a4d87e386a901b0efa7f62749cb98d71e17f5a7f65205e20682f53b45c6ffe42b0d211ab0dc5b8236a6ff9ddbe4abde82177d4b0c7440138e6d2cadc1d69102650f61d576d69cfc301c5de63542890dd01cc3d64ab70fba7ddc705d5bbb051cf403c063d41b86e6a89f01cbbd3bb9e04fdb7fd425b795d96dc34075cbc758324ad5cee2186235d00b4d8d492397b16430d8953087685982c54c416d77b75d9a941f11fdf1156fb76afe81ccf8d7d96fddbafd0048c2fed7b6727a04907de0c2d9b839cbbaf09c1c70908ec6ae76c839a94b7de913276221943111f85dc74924e136b6b79749b04dd6601e0a3ef0b986ba2f6ab05e789a2152d4016e3d1aabaf26b050f022e09319aa9049510f197130de6021b78dc653b63592a833ddb0b7c06034e7accc88fde121a7c2910802fc66341a87f71ae0726a24fe7d909c827d7509603dd5ae91544856477baaacf75cb66c8581428dac70378b371d23412b269cf9ab18e2fe688fedc989d91e4c7e532a194e63737319e40b98c6c965f194b35e116396ad19d05d263ede837cc03c3e7678dce53bbc4a5e3bff7a43c56de014a893933faa8e082634eccfc9e08f655ce9420798a1be422ecf17e6a37a5715e0800dada22223c64e5cc96fe9ad2f5d282c2d6e278cbb0220cbea0ad2bc2a0adaae8319765e5fa1f3b9956275d83a7fa1f0f87470d68c01de0b856f95b8fb0607c165869d62a8744e17da230f44d859381f09a3a9bbd1c0fb72b8d2e699b3bd1e913f58d147ffacf6b2b5bf6bfd93c50b1a8ba381df69fae9ca44e6f43e6676e057daafa6750fe85736df7f3034f77f605b9b285fd812631eeda6bdc6a9c40169e9d5740adb9c02879afc8dcc327a6556399711225e5382b32a022798dba68cfdc8cea4131555d7f052253e6c88965555994478417602a099a2542edbb9b3d851a8dec0074c5cb7bceee10a2fcb962c7380b23c88f2c750bbae9a9302c6555a907a24a426118c26d56a50e5179e344fab8337dbf26fdb84feb0b895695e718ffeb4af9882abac80bc9753306529df7c56a4dbf371ffedf655be01ea8460eec00f0b307537e76cea4ad4accea02f8af69651cb9c2fd71ac0db15b52a01fdae6e28086e63374d7ede019ef332ca062cc8d51fa0a010953a52b52a60ef882156765badd01afcc0606835994d266e7e9927d42f64876056549153df83a1de742920085a1a7981f221056332368233efd9963d9624a5fcf212c524d3746719ee30e5f1b609dd8a8ecf31de732ecb4ce5b9076e813b7c275dc80c330e79932fb36549465630f7c4c40606dc83692d78a960f211e335984e7e6ebc8653b1e0d1af5f7dfd36808f545cd1588f6d6b7cd1898f6001eaa503640c7f330adc74afba618b7e0086d91c2f6d1eeaa2f3d023a2163bc344bf79ef8dc9add8c74dc27b1c96719805b7197c6a46a10fadbbedfb35f01b2f54a02628a6bb1cf9e2b288062d0b1862e9abf2a1ae774a1194b69424d6967edbdfe98aeefdf8e30dfa88ef47c56590e01147f1a5de47e08a6b2cdc7c041ec0806e9f400148b75adfcbd1a25393f895e7ec3c920f77509918118abd687851c21752a3c97c96bb457e2f2a71b95f886786aad6b31c0fc1b443d586bbaf32175425413d23cda72e2fd54488c4cadb04e8b729341905b1ef03c7cd7766d162b730965f1c5a0e64c3a6359c3f923c1e333ad22c8ede7cc04f300d4a75890007fce67b42b158e096be62c3a75e887a08babb411356645631206933202aca2eeca2abafd1962547ad9c26951ac2205e9565f0980dfbeaecddb24886126fcf8422d79e09bbbad617578496dddfddf6caf82d3caf8ef0a4f4ca910c82abcea29c1dd81569e898065522a7c13a1dd60fa61cf67043377d61dff87b48f6f47d1db12108b19fc257fd21ef763701724c88b37c82df6c366da7ee33213a5e2c6e9d40dfcdc657e3cf66ad7a2f24b2bc0a7576e1f5b15f330c20e795ec5b65b1e5ca726412630cd02805e6f98ef9af8f15a944e313419d64bbaeaf9f689cef754f6d04fece055ffcab85c2e6b943294e7ae83bf18e2a376edfbec809a758a883939b04d8f00901eb8345cbac2676754baee0bdc1caa5eb2bfcbc4cc35296dc2b86315cb0f7b3fb32d0edbd34d97fe28f296fc377a8074710547750b9484782a9a5be1f27083667441f6f840011cd3112456364816b0c8607e917fa687a11165bd3193651c8526af9a608205ada39ab59e1abd8fb4dd3c6fca3e40a76576f7fad946a7a6df54cd5c16fa229db2787087a8690156807bc8443b7b49f34661f25a8ff34f71c773eaa01f4e4421153f4585b903b3c71bef4f89204eaf00afcb9145e25e8837467c11a8f2984fe32d8c61d32422be3793f5ddd551a2ba2ec600ec010b4794ad32e5f25d6794e3c618db78662b62c886959e2af8eefb582119ddfad6335900f201a2d5bc051451617dca5ee7ad929042eacd013cba463fe9913f2f521ef5085eb777ddad4be830c53017b1a3b6ca5ef815a6af5c2fe4547f8a347ccb8208753e16d087bd6d6b1709e82da4d94ab7b4441f26fe6928e5ef5e3b8448be359dd1263ed7dd8ccfe9fc72fd7b0d52f8bfddbf62cc9000d5357d147609f2f83471a24c8808d06ef3ea095931612e2b358cd74b2e4e986728d37b097c199fa4f345f73259e9ac231b00aa0610b9942f607e83d987d615c62b557a8436cb3995c84632b8c166a5f4607b7b46062981ef53a6116dddacdc3a123c45b6f4fc84274fba551e0df2d60268b3c4f96bde93a39ac2c7a5fbab7bd6b9651a77cf9e23118c2da3f91411033beb5911f836d7527cb6a6bb250df8b8e6c198a5f4df9343e99c5ce9ad1a905bf0cbee1e8f8dca425a811cea06c812d24cb4f7a22ea37f244c787135653e9206465d9de2e021250a196082870d9b9b991946c3a5a1b390cb4d7eb0f6d00f72a24bd18e6932a90114d126361c8ba4c8c3aecc21451b639703190d7aef13065cc3e55c74a037ca3267c8e1d9a4a282a96af31a7425ec7dbb8ecbc5229fff9419fdf03d6ebe08bb2ad765c72c4d4cea0321ad83019404e7fe2a91018486d1ba91fe50c70fa6a75e64af4000acc702d70c27c0687b7b3f5c59dba20b948e8ecb4bba4437cdec13e312a661836b4a08ad1a2b193430f41101d973e935a700f194fcf127defccf671540634102f6e48ba733f1a0adb86fcb4a792f10bd101bd9dd8c55dc4571695242e7bca4701168da3f83845a36b5e142fc536f93e41217c498074d4ba8ef52002224ffb9e9479e9aef07c9df9bbb56984ac07ecabdcfc049d85271505ac83ec6744fc754079480099676a3be6b3f1c5cb145edc3dd26b3f514ad79a8652db638ef4c10c6896236be2835fbf87c94ffb4907d8b3eb94af87df20eb35d019a0cbe0b1dde0f154d99577d26096e28344f4f9ee3bfc407d192c998ac7f262bd299a524bac33bb902ea9efd15d7951914deb385d1178001c573e3a8ecc0667cd145b8a134f26db553300588a65fa0a1e0075a7130f11a9a64ec359f7e885fe50d7141bf84acf7c4335aa8c107bedee14395df6de272a89731e0669771d8135317311609400f42d20e821ebab4ed7438b6078e15fefeba41c5ee0c334778d05c750a0ccac868ae2796930ab60f323be0dde8a04f6bc0d27eaa00c24da0fe339678a661fa6007689206cdb16b855f65689af38da8e86549d650b6c691673ec99c3f902dc9649c9842af7627b68eeb12619fd861905b68055babb96f54f1f6888e66ee40d77bd275c11d3a30457520dd28fb1abf6e14cad026eed40e086e3dc2e35e406d8219317ab2604a87a2e20acc9449a019646280ceef735dd3d07a2a833790dd36a8139fced3c0841b5b251e9764c3d39e973eb2048d8f31459603a0b0403a89a5111367d40c254e38a65c6154e270b415b9ad7ab9c17c8b866a82b4fed1f9485783201961fd0c1efd20852a44f77a2cdbe7720ed311fa1318684dcd573c9a4c90d2b85628b82ff49a64f7044d7a57180976b7e15b7067fefa48e3448811cc1559543ce8643d1fb12c8188772fd6990ceb143bbe5c020262e9759fba5564450d843c2c6da9201eed86cd00da4a25c22a30ecd82abc893b756c5111c2b601c9f016e14d8747801b53beec4449cafbe40b403ec7e64685eb75b6509814b098181218d32ccc95844a24529f372b1b9f825ea0762457a3e5eb92e38ae8fcfcf49ed2f1bf84d12b0a5acb1fd3b6d877003a540064f616d003fd011acf6eaa73d23e4749e7a43f251a0e3b9674921718ba7aacea9e52105c372a5f1c81c1c9cc103b59591fda7a9d52c5b8022070918380c15ac04a47df4048d28d45cce5be723d4cd36d4cda554c618913b2a5ac1efd079cff26a513c6d847fabf8d466bba11d73ea1213f7e607aa053d1331cfafa7c6c58cdd5ce8be3ca746b2d947823109da6c99780dab672207ae0d1f46921ff4d71de3b6df0a075f611126f107adc90261d46770d5d77b6031dec5b498cfb271790ed8200fa9660699d067ed6eab2519f86c2df6abb8675059e13ca37e707651e6d0acf0aa8e5e6ca24578ff4f5e64ebba3d17ca305ed51c9e7290335eb6b91dc36ab6654e850c4bd16d5134ca3f3947743cec4aadfcb0980d335de3b7e658ecdc7c3475e005a4eef33c044533de02d1945ea5008cbb7da5387e74ba267c97785344ae1e6a7a81e378016ae9c7144bcdd8f80f961d9fe1adf3389ea57f8902d8d1d54996d52ffa238f186ef5ae7e6c32d60bf21e4cb8f38250eeabcb19a873205706c74b4fc56adec061f31f4dc81f2535ba0e7347da7bb33ff1734dcca1341a7379fd62ac119a4cc6e2679a857a0f94a1ca62f350007016b3c03b92806f7e8cb7fd1eaa2e3d790344ca8374ed2640727253ce8386261a8cb9b0cb1b6bce3735ba75fbea0566f619b00f6329081fa0ffeee437267fecd84e47090c56baa8ccc5540257aa7b2600a96e04241982d0b2f3e0c2eab22da211a9e64a8732240462f747e3c4c5f3b7b668f92524e3ed8ccf2a83a81d899dbb4fc65b775524c375671ffe16713fb4c8f68f96be156be1016ddc6c1a32a0f49e134670fd6bb7e2bc5dfa7193e0423d4f8f112e29cd75ec7e418875f6a21ac18554d551169975d20f19e1fe0812055c92159b7d7b84eea347c23f39612b5983cb15792af0e81eb038cfeb07b1c5b491a2417c0695d858968efd518dc4a7dfa63883c244ce9790fdfc7f0be948f11a7b2c4b166bb4b6dc2b3ef4662828abb447e7a0f7aa2f448bbb0900c29904b5d8924cd90bf5867d616227e405352c4e8604f330e405c70668734feff0fe39ef02ff5c2333427dcf27a04158ceddb844030faa0ae04e1622d2f871f9f08731b0e9de53022dbdf2732e3a9dc44f387ce19b5acd0b05532e67d715ad37e9432b0d6116ef166c9ec259b167b876cf468b8d37916285d21742104cdeb7d1a1e2842d9af9b87080a789494bcdf32300aee1b318be79e94dd15b11bd08cc98d57a123f73da8217d0a5ca8a82995be6699f9405d36493d37d9e32d33829e02f294452b752edead6792dd618d69ded550687be290d3e7b15d8662772d501135185709d85820dcd30980866cfe8638a297a7304318bf2d996e1c002a8fa62e778d9ac3b498f1702b87ffd893f17a0a816e8bdeaa1218d70ff66fde5edc594e1ce347996ace9947d100dc93536a32a6116f1c96bda50549949e09910f6ab5febe6a27b499f38250fae5ef382dab2693677428fdecb918803b563ba68e90f7414282ea51252f3283fa3f82321ed5dae5e3ea99f4d21e864a35d5fd87821ff9f9d370215a3a713810560638cd059d02c87c273d3eb1f22b00905f6caf55cd9cff3c48d33eee3175caf9b880bed4bf0ed40f9f597a2f2698cacb7bc428c3aa67cb4105c02f4d7f1b5dfe97c8c7d8e8292ed340b0c298d862fdbaf2fef5b992aa64e609b94a2dfc06266a109b47b0a57ce039258b1441f2cc4f87e3e57e81627ec5c565df440515dd8f5eaa05be2f73b5ee28da01abc3065f459e4283399a6a5f4364abedbdf212815ba0dc39b77589f30526f724f447264fa01371bba69ab896c7675f0f425cf2a8ee40bff99306492190e00ab179a55d53a04b299419974f09aade24914813e8fc57f21b69ba478e502d7088b795657559d1938db63f0297aa7791a4c719ef9c2ef925213f59b43ea88389667605c197e6cd74a684692fb850ebbdb943960e588f231292ad4e400d79c7420bf6309913fbad5c48d353915942e6b4320429185db2888bdeb0d883d9375f3856f690073b9abdaee54a0f6f0ecda2471f908356426d058fee85dbbf11e3acb8bd71a54bf4342b09908612694cb9756980e2de505efa33b72063e95f9c14bff86c9ae04fd2c2e874b3fbdede0e4460dec378125c9d0de59d92d123feda44910db26c6fc96c09df13949206a9f47c1d00bc0b2f2480d2d5d8a0b2c5b4da444759d61194900d44cd418fd50dd57d31855f5805c1ad66157c299f29e7ef71ace95a5cb129de924185859a2473a9dc3d922c122713fb3cc57488144a13f6395c93b176897c544610ed1f2ced2cb0a898b0e5f102dbedd165720d975099f9cba9a39f7300b49f1095aa181bf29eceb2fe0fd9f88f7c65e4db9be3a8a6a7b1c96da73bf794ef944de441ff5fb016c03d94872ba529e342500d3ecca25dcce57145d5023addebbfb02921cf73df217acdf3157e288bd09909a3827b7797fdae4e5cb5407e74871d105567b545c83438b386b542c85364fa6e47cfd2e6e7471e7434161ee473f4cd18cdaf337993c43e421aad57c4f100feebc019ce88a0d5667af6a7ad584ced21e4c606881a2071bb8e64fff2d0e3e5a4808bc47daa593d49f2b58a96a2d436becb5b34ec5ec864ef3988a8b22eab5c368af122f6d0efeb1ca2cca0a108702fa225940d0007e32cf1fae9149f671eba7930f50376d82429c18986512782c3118246ad6ce1b78e93a87cea5702b360e10bd8db03f19389860fb17e47a9c366baa15f0751ecdc5d921964debdc8b4048c9e5e9927d6632b8f096822e561df5884d15dc99e095d8edab1a9722ac22c4f8a59ce2cb4b47745743ed5d0c25fb8a99596317b435d3f45f1d1aa52fbd408e914d34b66be0a5924b68a148c4c214fe48716c6abb525f740c3599bf09340036370af61b460268476e09018b5c16528409bbf9e4ad1f6d4c80eb576d306684a34f7ce57479a1b722cbac6e8590c299e9544d8216e0e098b9ada376db3cbb63a3b0d94a514f5bcc7c49530971534167ea87185b35e7184f3ddc0d52dac71c216eef2bc6fae776966ba3ebaf8351735c58845f7dd9eb1d83e00b089f12c8e0c41f3d6991dc71317d1ade0a51bccb9ba860c71cd3849609680b07af4a1f41a8b6a33b37665c9702b79979072a69d93fa785e37de756109303837131e1e537d6481decb500d4dea70f46f70f525b4fc551211b3ac0173beef9187f481caf24a53a98c4416f43237d61b4311ec9ff97ca12d6918ccce742b3a0da4dd6dddb766620bf4690a939fcdaf2bb01dc5f28bbb3698506c96ac5f6ffdd9be04f3d2334027404ae47084f60a8a19cf7c033de09377f80d4cd88bae110e9ac4716e5f152d905226212a7acbc2ceae27c9c2d6fb854a9023206f4954b991863af9de268f4d8926bf0d892180aaeb231ccf73adad92342745c3a7639ef555e94a75e2562c7fe3e6eafe3ccceefa52691b3b1c19cb7ad89722d9d51c9ec34c2d64e1b24b9e51765392b56f74d85334a620f4e150091c28e2bd5c499b8cc1f7c4e4012de322ad5d6e2074761ddc7c2f924f4e8cade47c92b2355b4860dcc0212928aef909e27647bea92d6f194adfb7b765a15c3eed4fd433a4ec0ccb7cf8bb6bc5059997721e87bf8a05f4afbcf86fd484975e86ad247c5b797f9a1e8d52fd9a7f7232ae74a6dd7bc2e978ec25fe59149c4c13a606fc87ac304bfde276c4c170a8c0d2e77bf26065e716891c23b2e9308696f161a662e89e0b59b55f0f735b4743cc809344a82fc77f7a8f53db670fa51810e88773003f1caf64c4d8e2fbffa793de3eb36ed8c06e7bbe3ee00701b45bd50293973868fa679d5cbb6c01b50c119697152bc674ef70e3e8f1274e8bf0045a1b844247864ab24b7ec44fee3b8179551d03d99b7ccad3280be240e3b98b72e150b99de4f93c0d5eb2f49b30656523f48c72743211a86e822f865382782f115f74f68cffaf093aa2861dfd32a7caf7ab94ea2698911cca573e765c4b4dfb8120a80ee5865132f13b968c07c0c37bcb83f036ed36a95d3c67feaf0c86e6fb8b67bd0ffb1cf795fcf7cfd60ea293ed323112815d956e75c9fcae864185ba4f9f4b31b1d4bff5736447d044460a3350c0d41d8006b40e88b5c8ac814a19e0fc69bd4c5f90fe559ea513b7a1101b8b7535abfbba0ae2e7a58fdd19c16319f1d0651096203e25b1d855a3aaf983d587fed0e802e2f106675c8a1bab3c9b6e080db59baf211e1b0eebb904b8aa0bdbeda35e39a6ced24bb0a58fcf137b548d6f2af815ab63bd10324fab6f03fdb28185eddd746381a86924d3d3e8890afe1def2e3ec621b11f2ea6f1d7600d7445694689ec4818d4b04430a8d9bbc96f45abaf140da980df51cdae9bd3f96264cbf9bf8aeee121b5d1571695f1790eeea1f9256f327316b9a3b6bdd6ef509e4fc6d32196200299e9c56ebb63248d8eec3766e2f646b3549d0262774a72b2bfc8369b537c7a719940dc23747891e3b430304c9a80b3d3a042353008ea4f39e8e202d5b80539415cfbdfaff03aa719c76c467dc0e0edec2d31c33ddf6928c9ceb5e0b4fa6a8564493dd4c68b32923a8af1634aad2e750a1f2fcfd7db43c49d37ede282695260f800b931c595ac1779bc224378fe38acd9452b7fb9932d5dfbe5f7ef6870e4bc50ce7a0ce0c88c8ab2d2931ae3eaccc3526e4b6460c2c5ba12a309e1432acfa885d78f112ffd9f9cdfb1a704e456ebaf8b7ca27b1262bae49f316dc12557b0ebb6bba157f2730bd6df3dd773c9a6833dcf45612bf85e70138d7179d85516746c062f41adf3d67d7c74a0eb1337d1c70d14c628325093ba6c872ae05439a5a4e9e3e587f5c6ac4b7e51d198266ffa9548218ffb1c717ef0e66568b7e312682268c422e6f2aa684923fb734cdaa243fa95f997c6297f4012debf74c850cf56d4547cbf3ef499ebd7b3c3c7daecf3cdb48ee5c9ef347261d8aecb06afd8d4054a1b52b59cfec6cc87bafea83d1754729692a2301ab1c10acd912d30769d3e4c8682d25fa4da1c222019bfb058095c81f2d08075fd0e3c9721cc1638fa181f1e052c05e02c703314f3334fc55119ea3faa983017c1e0bff60e9d7cd4667cba5684a8e6df6f7b78e6c135b444e2284dd9114f4032d47b113460f1fb68427e72e2fd037e707c2d568b3d197ef5616a3c0f851913a2110bf9ddaca8991c44133501515c28231c91acfaaabcd461106cb406db7449a13f53afae119f6fb32d1794fdd509e2bc6f4ed7fb1a0a478da1b049ff1fac8de2ab34cd5b290136964a5d36df3def345e706f0bdc9c0d419c5bc77db4df9ee0297484239894c6540ece875ffebe67f3e727fb76da37384e66db536e2ff48e94be82cba929eedc0a44bb022a98548b8b114e43e79550d297242482aed81d539fc2b650591b9a237283861da11321bea0af5a02fff6456edbdcea1428dbf90160ba67f76c1a209fc3c0a3feda1e2f648779a2ed063f6b1df68143f09f1feec835d5cbaeba836c4aa9ac6338728e60ee8c27b0636b3b9768a953ad00150721e9138b411b8e9f943de71b2f32c0bc8ab713506b7a9534d3e0b8f167eabc08b6a4645713a9a6c890111ecc77ed62db4fab76caab0df983706f9cfbf564f32719408c29ac923560c05050818c8adee8a857ce26f370df623f21d548e2067c12dd568bd89c4c4b700dd80eaa85f417c248f016a8deacf6720433d89a9eba99fd2d77738a2b5ee6afe1f68c187e753b5b01fce7f73c9d81f7b9b300231d9f7564ce5c64978a9ec1d13bbfdcdb0c3516d3845efb48755f6e4bae7a082ef2b5fe454e16fe2f9d309f637e4b052e22f22df2ea06856a47b1ede3153492b8fb96680774c2c67bd8166d89f3ae7df15b8db70bebc4da4df464cfc7dd0503f000133cd7bbc5ca2bc01418a584ee780a6c6d9838d5cec95830be33b894da86503e71548d4a02aedcd9b49f94a8484a65c63641302513173d9413eee051de7f468dd8eaa32d847bf41582213b564874240e6d688febc5fc2efed8465542c56b048f8f6601d68065fd6400fad8c67d165c6a644e1ca937b3bcac81951bcf4dfda55e760d3a981abe47907adb45b481f89b2ff1bd07302f6eadff627361584af3c1da1a6d50d1a2af7ce859668774abcbd74a0485f3590867124d7baafe3c454f113277bfe320589bacce6987f2cd186dfa588fdf3b9a67f7acf89d6a72a8e1adef01ba674c168d97cf0135ab85d3710ecdbbbcf616d66221dbba1607db06ffe8c4b3ff7c2f8d3a72396823e3e7793e375d453866946b490b27037b8c621be077e0640a4889fa75990e8747393384bfb69d0234c78973839c2593dd22db4bb785beaec4bbf84c4ebc348ac73eb9cf14998e1b46d0d91f5b53a8a718400969ad726b9368b91a99341e583329d365a73b737b42b9d0dbe442372ea2c7f82281d1c57600bf3fca7d3ff99655bcb1bd0f6f03f104ac7d768f7ffb749df85a1ca49b7ddce21ba7c748044b5e81d70de9a4b82e7ac83fd43b6e9a229e8bc18e5487203e5736aec45c4579c28783d024f136600280279944611aa22624e069e79d42a03bb95601e055684bbe57f109a282ba75c306df6b3155352719844af3678e844d64a1c6035d843c89efcb23c84f7a6f39f94ab70fb99a5a0944ee6d34fb0f8986a2247d6de179a490f1f8d9aa72378d5022f2b69bf8720705892a36f390ea64a7399c20e93a9e84a2ca706575992595688a624e07cd9c69b33795516156a5f13d97d4595fbdb1f786a672a1b2a25fbbdf10724eed6eaf43caead6a2d14221575402e5ffb3393320920a332dd54efa3ec333fc680d74052487281e49a8d630657a6cfa6602efbb40dc1f98053c6db3caa66ba5c8925f3d5df212bd5757b2437c46b24df5087a8fb346df5a84c8ed9b804d4c77f51ef90f303fd8bf0f8c2a00fe83f8e1a1d97b9d276ba6d13d514f2a7f7bd317ba905314753aad859307e9cfb16f5a11fdb4caa8d0331951b8783a739bda391a09d72153de9ec5269e676e355c0f1cd7d5336962843beff55c378ae5a58c38072686b470d693b23b72f3069068dba848faba92e4f1a3d579c0caed8e388cfcd9592690302db6b37a4ff76445c9233534e0c6469f56e90311c3dc5fa80d8abaafc53fc43123726f21cbf77f05ae9efcfbea795668fa35e4a711e101442b9ff1560f3d2240df02e54c1c86259695b649e50abf24399e9fdf58bf7dc4773af5225f2182fcdc506581c3e7aaa1801f15cc41ef3f6b8b215379072d6ed3cb922dd3ead045bb4073eba60fb54711db3b9709b56e2c6862bb01320c3f865c6b2977a26846bab9068dc1cbe34b22ceb834366432bce0e64578c77e13482454196a37b754142fcff4343ead86b390b953f2a2d52f66df094a670d2f1ed4e81a24e7a87fc000a1fa881bf5dd2600ffa4d674fa1130be1b25d1cc2993ed666695d7b7f37f1902246273b6f1425f6150aa7306297ac748066f3d0d08ec457769933e596360f85e0f30b71a2ac3bc095b60decf7a279aa13702d3f1bacb9961a13a2205bf1cbc443410dedc3cf0be532db361b38daaf19593477e80265051aa239e8c2b33d6b2959aec366225d4628c703334e48ef2c990affa267794189ce10d33be585d6645d905badbe4800e3622036fb5e298354b5d457eaec85f35071f61e97ffb3db941e2958337c584a778d9ee487bb5e2fba4ae5fee96b76ae08036bc72c06a18da36ae36fa561ca0bb76298d465055689cc2832ccfe791819936cd047a912230b99885ef3f5ded2d232813e0860e0efc364f2172a443ec86ef6317e61b910946960e8435a9fa8c55b2c3cb28837592eb77ed132339c324c93fce2d26d0dee177557854f9b3c3ee0d38d814a872f6746c64020525b49ebdbf313b61d6ee7a9e031cc8d4b1f47029edc8bebf47a2c7b08e52d896a05cc00ef8e747fd8655b5756442cbf322ee6e04c4d02c865fe3f10f6f2d21beb22dc3710a9eb209c1e7e541970be6c4dc32a244f69162703e920cf581ba6319a6968d25934e50a09781a54b0647f3a7e2ddd79918d11f07031042b21952df084c23336cb8df5d1c6c352b36ac0c205eeecc24629fce2e1ec3e7ed7a8b80dee71645829d2c79e7275eb511c243ebcd033ef268cd565119fe8cbcac9311a1a387c7d7e3e427dafe8fc979e1d95082f216e0af3cea2fe34129d174760885a2a27d54bba70c13dbb3f79860420ac62d32563715174d23505d1dbbfa65450985c03d7e4f6cac5d7f1c15ad488d301ae0217423a2fe286ca3ad41cedc00da3df455262c50ec9f645fe8abd07ac95fd8fd8687ced2eedfff3855f15ba434aaf781d5304df430c16054cddf3d2e58a004db2a185278cf10e393ec3aa38b966489c4a09664a6e00996fecbdd27be45d12198d67f13408d8b7133f5bedeba3ee99f3ae00ce84aa61cfc72da77d588ed2516962ab8f7b8d34dd26cbff8038042058755784a2d28d87df1f64389e364df7375caed071ec74790b3c9111e5ede9cfa5c8b8426a6630c08930489c7f038652854e220dcbc6df80b02f5280aa7017b944195e7505a6546375db9ad28d45cea269a5ae0dd84a299345a21e86066ef265380727210d69d67e05fd6fda36cbe6a09ecb765e6400408e849206a48e5af4f4a039dc0971c5d639ba5ec9efde15c538f2fb4057bdd3ba48c0a72cd1128c6b3868491a8031c107816941784bb166b8eb6f7d6dd15e73bec53fec7dd1be225d71b3d6bf77bc55397406d977e7af452c7b0a3858fe94fcde62e8221a3c00214f024e728c696de1a9813d90aa1b6bcf5e875b6ffc1364dacecc39fb7ac89c99828c33d6b7af10df7eda6056a546982b085df949ab77b73c3c7327cc6ca5f444ca308830ba98f98eb0965eac1832bb6ce16491a4cc9c5a3874ee66898fdf7851187b3bf0f5e3b7d1cbc0e4987d59f4ec172ebb8078815588fc184b7c3ea8a15a1ce51fc5452f615f6336c86c31ae2f78e909a0e8b35018704b7942cafe967723a069a824b6344c3df958556b34dd52b35df0443ab9d14089de2a314d69ed410f536b9ed52c81cc95a076d1a5661aa8d2b26b8b680c59de772242d6cda65cfccbc268fb9c369d3e80bc49cd4b71490b2d88b70a2b658150ac47dca060c7056baba87576868017874360a9925c446807c51291191c691173916fa5e69006e3e87bb95b4d63f0c4a74cb9160ce2fe23657e5c2d58bfa77b4d3c9e0e5f11e028ac36fbaff70d7b4472ca42af5a47c43f325845faca9937dac7b74ff84af805a6e72fa008995e3a583b2d4bea7b6643496ec5614358aa68db9cc6765be999ad53f160264e041d9bd84ac2303dae438588feb4376ca8c70b50f7f46e36e6d5984b5848206e80b9beac87132dff655df3b68a9f96539991712dfe5c9dd81ec15ae9ae15da87dd4730c9c67a6030b6bd31e0e404987b24d0acb3e2848e08a05a6b80f696c588f01caad0b22e54ca328575e6f8f17e072c306f612dfe11094caf364c59baed6d0b82c0b6ed477e5122403a06b4694db716352e9f80cea6553ae114a1cc5b8d2c89bf79ffe3bfc2e1e247c63a9d8ba2f099373d458ec596b19d25b82fd9dd46f4317cc006f4688990162ae1d081841aee2ebe6f1a1fe8319707dfeaab9c93adf5e6dc64b00888b8d40246fbddd2091e5953584ccbc331033cdf803dd9d33d2eb89c10112077fa17951cc92540b571a597dceed0d7026a5bbfb00e4cf2a9a1497927f9e3509450231232aff540d2cfba5ba3f37c0ffc58adc4af12bbae08b3e249a60918de0fa43118e139a5f1eb34b49cbe0a052e1a91e7a1c6d9edfd48bcf15264dfc226c0b2cd3630b8371f438d7c015ed98b613f9246a3d2a663c15978eee8c16ad5a9b9bd60ffd6c72b8ecd666d573391b902d720655294582dd0c062e266c73271378d4fcf0c7ae9c8fd58097ffc5925968b69bf2e54850102ab60b63215834e744c71d8cfffe8fe1a361a02612b474a5740791097534b15275d7fd6b5b6299ae70175f34ea55ab158edae9d47a0e04aea47fa78f5b2190af5f573f4b955d5c700b6920f92b622a99dae6b1d69fe4313dbad1875cb19a14711815c61e13c39591ad34800b38a41a9cb1bafdd390e0a7e22463b26efe926b6f91f8feccdf69478ba1f5d41cfb6119652bb345465846e140ee3d5db245165fa5411cae008a98fb4e90bb67eb7102f913a2b1b35896dca9c51cc0523013953b7f8d5daac2f2ce6c774f3d9ee6453384fdbc752d658dbc964ce42f3115aa839b946c505d4e73f2ae31ba541a994c2d3655a826bbac8310ac9389c42752f138bb99af26d164bc656bf784dfd225962bca3539878fc33827e7b8f1b3adde3b0cc0b443085349889c9bfc76af5d63589d2d294c435005b238e1b5d9dbf26865728b4f738394c246e02417b488995c6df7ffc3780a18a3519f4f10dc4a292919fc41d37c514070c9d56d75eaa10e1155d63d41bab8ab5342c18fcb8a9d955e2be2fdc9e5769df3350f999ce006b738db753f6f37363e134c637338c527a32c91792ce87ff87c714ad90bb443ec37172385e4dc0799c8d13210417c3b95e06cff7fbfd43995b964c25012105307db1c48ca8278d30f56218705d7546e7b6988e6bc78601f657f600dd501961d93781c73d108e31687714e3fc18455ee09bdbac10c98a190183ba0dbffc2e54ec581f6c320af09f6a84a492bba355f61619611fd7292f7bbf57d643d4a0816a61b666bd3f4026f15ca555e3ad25a748ff88daf9ca39e4ec0ed69f8c5cede20fb8f700e29a71970cbec547e36c7b9bb7a80a903308ab0de09794204d07a148e2f201831b3874d8082323304195bdb1969f8db5de0314e70314aba638263b35881110a2bb52ede3dc6e44b11e589b5f0c880cbdfa2a4c2320f9676c6fb955219a831b47919b7be806a1027236f668a5fd86bbb361c2c745a9d507dc859b83cb2f9c02156a5fcb8163bd15d68393c45791b713f8402783dcd6f79781da14b272d5c80ebbfce80a4da5dc27ec6a0b04d0e989fad2555911902d36a49b58d234dd6a4735067f8980cc044cfad437224e8f46c11f7c8334f5149a383b6e9c0a06a1266c9e7f9f21ad05bcad76cded743660bbed46e53e9e31bece470a4ffc678dfa21a5186072cf92dcf959fe86ec878a2aeaf5d1abdd42ba31da9d42a7fb07bc3b3e5619415ed53544913ea4a39c50a3d711485f0a53179c6773753adb8fd654ffc018984d990078b3c7036dd2094e1664bd3016fc60f3fc870d368181677575a208164eb99ee02dab2c90903d97d53097455e655d5b9e4ea606b4c0dba7963fe53fd4ec26b63e8a9450298d0f66b785dcecadd57c76913aefb0de70cc49ef77633aacf81e84277a592f7152162d8cb77a614f25cc29082dfa22f9750fd996b839e54318bc03d07dd1bb2cd327658e2f4e7e334d1cb346cbdf37cdf1bc6fb19c92f0ce1bedbc038bfc8653e4c73e8ff4565ff7f359da0751bc833a7f40def4878699b6c958904a315dedea29862e76b498d47c6538c0c4939d712269733b10e03e18fd9a96495e67c6ffa2731fc879ac4eafcf11d5fa948d79fcc3e792573ed40a789c8ace042b7d15a444febee1dc10b52bf30f558089a25adb1082daad11fd795fe7a91d1818e89047eff324cb0eb568d9573b277878196a180dc9415426aadb87cbf23c4d055def0ceb224df7e4b9f632079aa1058bdcf82f14b9e52863a9eaec93b5dafaaff37da069739c676cab53e26f5bcd3214d92bbd781fd9d96784b677368ff0870410551914699c29a291b9bfb2a593046ce4008d214343c46a8944d9b9bc3a0d423837132f789837d2e6a3f9f19734d848ce333d7de027a46c52397e004255c43a23b17e7e4774456ccb6be17fa5a925b909a4d1e350d096c78a62f67ee36f16b42d182e19ed4db35c9405741980418a6843a005ffc4cd26756fcb90546846541b392253ea2bbec3637c95c9eb207b6c5c4c63fa9f8135d74e3641c5985d7ee37b810bd044a6ac05604a18060dbffdc1f7869317d447c6ade0e06b0eb2c29c83697fb9e6d43710196539463058603f80be0eb4f31774558510abe56f42f2741cdff670cd96071956b1b1db75c686bd84be09b1312042687d70cb046e12257675494fc13b339b75a15a80c0a7f65aaaa7ec9a15a1a8a4b71736cd92f9b84a8d785e1fcf9a96ca77b58a6a5da086dfcff52f718b5b92d89a2dd3297269c2bfa287c415e1af947de136d1055b74412f2b0071089302655766f06c3e6cb17d8f67fe064ae56f3d25b01a1a4223d8a2f66ff5ed46e851eec09b385fdd5b986b2492059b2076194c0720c82b5572a81b9e30984f951406ccd41b99be64e264c3f73dce1371d59d9dc87f8c69e9529a72639e7a6ef5a34d690919b9a56d6e948611806b50414866413120aa846c02a23e7000a5ab9f42a91673513ff1b2363103d91535f3906a8d055a41f2b0ece2df014a77a3218ceb5aa5877cf54e87aa267f2da5d1d520218ca8952ff53c59039f1a81f37ccaccb74086955dd880d909f45ca1c4576160cc21165b1e7fb0a6e961e8d77b8ee45296df6f3129676dbbda3a18520f0fc28180b4e5762160da22b78cb435152864e17d672885171fb89c0d0e2eda527c6fe01910f07c1e1aeb56b8051817c9d74e6f2e44b8829c356cfc46469693fada5cccc05e9fb74864a126fea5c4df8297c0506c9d9a559890df4c8cf9dfb01160d21f3a1b397ad300a3a09ac01f21e72c72ff0e3994d68be13274f50657785449dd870e522e014438b0ba805b7ce17f238a493c3d58029678e40c5c1b5ccbee58ac1a60aad8e42d433ce2f283915e02955e073e1d7e3de89700b1bf57fc8db4452b6b629a3c9ac7657a2c073e395415bc4b7ebb24b241aa8cdb2009f6cbb38af2e9bcc9a38cd5441db4be78b06eb4dfe8b8f16a6fcff7aa26ef5dac4ab7318b0fd48e70e5d4fcbe3b23afc1ff6a4cb8ebc89b6f407325f39448e054af49c301cbc729ec86c7d9edaca789aee1e5f235b1fa9a8ad67188d8009150281599e35ac03de96b82ddeba3b1a19cb41b441d5458cb126e910a2c40b24c74834efb255cf0d5f53d6d3d49816e39905feb6a4de6625066365bb414b9e0187c63343f13ea7df4650019da579b01821f650d82a05534d32e5b74676c4c017ad5e1a74242ba9f73063789c14ce73696c800464968ecf8f01e882e5ff4ac6f44525fd4c095bd446e8eb7e95bdf858f7af11b0cf58721b0a368d09231e67bd43e8b948da00525830ba54e04ee23f6476e343e8cfded3672e5e757a1e421ccf964b5f5aa7fcbe503b4ef9218a2381d16ec2aacbfd2349b57670b58d057c06d99a8032f30a5af035f49316e7a344c5838933fee548e0ef964b62c194320a072c71582a982a69e48b902201dedbafed2710e8d27bf59e33d79e12b778660a2918cbab2fee58281de050d5276373f1ddb36bfd3be9b09bc0a4190d2e3f82fb96df9ccd4dc5a1e246e702dc5afe4984ab0332a76cd869e9fad7a4afc96190b971814771323ee4f058750dab5dff6d23ec57f3d2d703afe43bb714204fab5d0b95ffd02fc6b4f8aec7a637a7e98a6c706f12a4d8a17cb055c54510d87ce3b62d3385df6d9f7258c7aa224aa372eb5cad00dc939961df8704a39550030db0664bbfcba2333d49931e27a15bf30f92851355d828faeb7470b8d3db900650cdad49353455593a15ec560d3a3b6665cf93eacc8e1f9a0263403b22f53314018c7cfeaea6c4e8df19a58f0bae5bb2b9a6d42c52dbd16d966acc60e1a3876891e98b63d377b657f08de4def3ff0ad958f3e9e65bb64a28025738650ea48d6cf336e25c65cf1e596bbfbdf960c833bb92df2d563bab1d7084b8ce6067621b874e0566fa793fb8f398e8180bc9e6822c37c1045e56ebd6c805e859c1e42350df2496e46da88d80668f364e8891247dbb6c0d14c2cc26dda8ed51dedcc5d89311796fbf9426dbc96db610a23872934da52199c432723b0e06e6e15ff39d81654bb36256c96f0d60bb7a1956b1af36bd2307cc913afcebd6d31faea0c35787a07fc4e722e410b8c4a0c964c33c1a5b64068f496bfb77108f8bb78096b606c4fab2f622fa45b843c5cf0f5c29e4c057db78e0956a8b602d2367c3e4467488653456a7506961231e5026dc8b0f07319ff32caebd31569ac881fc09cdfddf0030e5b02bd5a7ebb7b63a76c8420a81aeccca225af342c3667e59de83b5c0b4225f946b2131ee181450fccc4b8129e258e5da7dc2ccfc2a637b6b63c55c305ab3de0808a1e7fd002ceceaa230a583ab5056b48e2fef81b18741792956098b545058ade7502f5b7435039ca9220a6d8c53a4dcbd7cd8e5dcd07d43abbf536883d000bddd0d26b37f103a66fb2a9bd45625c3c25235d1fd37a44a577d85f4c2cc3975a248e8573ad70df1215a60115028401919d9ce03aea24c8bf791c68708296787a8dd0a984773d7c7a0a22f2536976cacc607b8af5f80f0d1dcf3053975e2b496ff16dff6184e8afd2b2380b052ae402f15f770990a36aed1dc877272904ded0ae9c9c9ccbdc8b83ef8a7325a83009c389a1ebd47ce6f0984f80f297c053007ec3627e0ef75023725f4f630134eefed75d84acb9116ccb05ced182e59cd20888a1b08732af1eda043cf801e1d936899909ad92da585fb62cc35c03fdb47d8a61c9b6d9dbb48ff396b04e38c9e3842fc4a3f1b69b89ee91903a3f7f26d3a83a3422cf535ff9e10da72aa93b2d6f5469831f0871d8000db1e32bd95d5cc8b8b553eb784644c4ad70f19d991200b259d2920cd3fe1047bd52205c336c42176fd8a8e637a2ce016028e5879038b3b41a43770c2a4de941326c501c2b65f784efc7f7ca02dd021d3ef86c2a454337c32e0da0cb211253683f2b8e520dcc07b7018aa149cc70d30d46a5a6bfe608a2b59a4714a3649bc83e111885a205397b4176d43fd539284bc1260ff68ac80f4dd6474d3635df89dc8dd0c3168def3ec13d655bbda29817b8d3dbc0d8d425a1397e24e0aa2014171b1e34b2050d292d5ee0968a571432d0b36c983a8a2f3cc6ded4d0ae555b00eef8118ec2a62bfbf6b7afdb7c6058754268c808d4a9975898f12d119f7af6619779d55003cf46ca30f1b824971c73854db86b8e3ead5bb2f8fa337b35cb902fff2a76c6c01f6de6789f84a39765a9a781f85f1cd07a5938292c0b0a5bbeaecf6b35f89a89808dd6d3f83d33f317ad9602bfb97d2dcbfcc039328ae7becfac83094482af7b9eaa9e6a7331178ad3cd819925d1d64be6e43f2693853b97ad1960a9cb58144cdaf1484eab31f3774826b15f661c2d2ecd976b66a9e4662e9b35a30930a84097657063aa3d8ae167c2f84fda0670d11213249e7cf8dd9b0728381d296a0314bdbc6a18a1d7c2821667cc664e6e824d06252e1ba9bfd062fa6425e5d3cf6cfe31578e98942cfa0cd3294b43316e44c0397fcc657e9afd35284f6995f0a137aaef751eedcd5d6d4d1539a7a853c2bf0b98aee60c59934790765f29ae8c2392e89391c39fad8314d456a6221ce6bf298626b288ae5235233e1bc398231c8f8eb48d9fcd0e37b198f43d5930ca06845196d210d57bb3c894186da8d0f1c662c65f815e9285f1efcc85664420f86b532b30974b737b79921b08047f9e565969b70d99da3f2468a02902eaf91d98f6f229146f26d372f2c904b609575de72c55ca555f56bfe458e131b87e954e4e388185370fe20e25236f130bfafce8f4ead4b8dbd681b16d07000dd9800186e0b90f1c184163b1d0176694274fe181609592831e150dbfec8e04ecbed1169e23e65077064ccdbd81ba70f8d709a96792505883620d7d1dd728aa25e717d843e9359dabb65110f04c9ffe9f2ebe22759416439201c69407ec25a0704fb4081130c11b62088a1d8579ad6cfa7b78430055d52750977b930fec2f8c335c07172135cd85cca0769be80718952a41a0ad02e6cd9d8bc11bdd5da8f923fd4aa6ae0163d61d313fb8d6dcbf65034d16639ce27bf92011c968867533d9cdefef01b842009ec54133b90c30b1d7f9db805fe831cca9cabde83acd08c33c5e65ca851551ea70e4938cbe3ad7b2acc57aa250e8397c2d3ea447d74c4f91e03c63282cb65773375e30f30bade5ca26a2ffadbe9a9d2818ec72b805f60a56a705778f82e22370536398c4fe7a92f46da339229d7906cf05aafed0ca07a8523c5fe950feb8289a34d8c873443ae24d20f244cb451b0906a12038eb9bc7c54b63b2a27d3d82ec66fb56e2fb2385e282bce2f4a1d2a41debf1ff25260492d93cf8f0cd66d787be587cdc8de30c9ed11f0d623644b88a5a2def6428413520bd444d5dd1817c54c21e7f4d276b27b9515f44cd7b5367dca0e8a94db19519507b52d7369da85592adc799d947ffb2c29e85c557bb1a8353946e897ad7f8909827a9fb96b7736d6a41967ffb96f971a13332abdf9cc58a6326a4a6037f03aa789417876961de2556085fbe0ac39171cd718f06ce33e2966c147a492fb03163111b78747ad63ccff8a0597ae32230c2dc22e921f579a7facb31bf3c27dce6144581866e8f417c7818ffc197657cae8d39d89cd745557134b9b2f3c211b5230c9c1b156de0867053ae1be2234b2a987a3d4334b728fbad876147944bb3931424e9a9a0f9822b0e1b05212ec5d6d5229cfda8fd5c3c5b21434a7a05dccc48b21fe3ae03c1e3fac87ff525769efdb1567e6447d97826fe47bfa3b7de2c9896f7b5d18a6b3459dd636ad29fab2d500554a0c703d36d788d4ee2fa8350d38e96ac395770562ad0098a3b54dcc76b1a9b6c743cae89805eb0c56308a9384cdd7ce0709b84c6ef28bfce63ddb4446e78f2b1480a232ff77aa159fc40de80e04c988ac6dbfb543305f5c72bfd3c8269f261a1cfe62ca002234c299767a54fd437c0d3a3f54355554ea3936109486abf79b751560d3a4807da2be687fe66b062722f1055478220cf32e61374158b2704158972c0ea389e011aaa19df140e694ee2cf870c568e17ce2012d53b7dc45d64baeb102bc61b16dc427c67363d4f79b40518e41a753b2849f5b41eb6fc61bb5ebee78fbc745928b3f759f7ec84aedbc53c443dee943ac5d3e5effbdf4474912bff87bf4457ca6e7e5559911a623cbd001bc29cabad1fbc8d04c4b8273fdca26be3375df4f9dbac23895a5344130a325dc6d1224e9bae4b78277b4f94bb5b9cf5d57e91d62335add9b378272f1163f9210f328b6e3d02f3d9c02c6c2d4ce0c5b1832e459fd21d4697b52200edb2047ca8d6a83cfc2127122f6de4f5fb6a47f6f4682bc9282d0fb550f7515ec8e28e381475351b520545ebd1fe1bf8fc710fe6966c53c29a6a3b61370d44c0e1087bb4198df537b7206c5739347faf574f2bbb95c94b4e18d7ff681fdc357c5694fa9037d22a054df2ca7c2dd71669a92202c3f984a30a1048223e8fb8dc8c3b58a8020b0d436ac98b3199af926c164be354b1ef3a5805a7c4471b84a3f16ca70785172ffdb0ac19b2e9fe849a135dea6713069e90141f1925693bf74219d3d41886e80ab68c42ae6b8dbc49788277d4b48d94f6fc72ac1b756528277ab6c399a15983c1d28844e6c7f4eb7008f6f085bacb3606f1a1c042ef42a85454041a371ff6036b382b2e5d0fe7c80f7f1286b01a1b0e7b0b45157e97afe7780952c5d60afa149702ec3a9ab81d4268acfad4da55ff24a6c748a9855e88dfc34905791d5a7b80e75a733cbcc0ba3cb89b1842648919032e13901e821d9a04e2378feb26b407f58cd7a10365f569e582c86845ad59eedf9291a87d2229c96e9a8d36e6978e73aac37eb74609753d0cd33654c97e892eb6b93ed67a8ab03d2ecd8b794a97de18c3b7326fc62ae4395456e62af820fd8fae72c57535c00ad79339d87a5b0aee099cb4c8bdf638af1b2a155f7e0ea0716ac55f297fc085684a201ac821f1005d067a60f5ff9c8a9d7d29372ffbfa6f346079ae84e88c42265e87220d4fecd54c9583fc3037aa1e123a1515f81614aa988bf9cf06d5339f1fd2978c0eda300f2df1e63991c98dba75ade85974cf8af74992a419d0668e6005649d18db1a48e29841b9a73f3b340e988c6a05168bab92eea5f338040fe752101d5f259025c9e15cc8342260860ce22ff82b975fd13632cf43875f9c96d45045c69d8fdbdaaf43aaa7d622fd1d0ead96b306010ed96d90f182ad4c4f4fd6af2cee123dfa5f2f046f2dedfa98c6c2c07e789323ad79b2a0f870169b01154c3eb66f2c58dae853e6a7f38bfb08b837319677875dd0ac421321e958060962268db24ed9be207b504b1e6028b557a6c1fe356ba17790eead35655c470a01c84f352b498d82323ca8602d0c0aaf1849e81a316cc165ce8a1a41a309941631a5adbc339d1cd53978bd7379a22cb4ce3835bc200052e03f9bdc62b4428e7eaaceff1c1ab93b89b866a94a2bc43f175b2555c595b6cda8e273d07ef061e710dc376a2b3b5259897145338fc27d31a3daccd73add8177fd8ff6c6963178d29ccf261529a051de6eee5b2d1521b64589d40d65ac119aa3797906ff057d40169bf521d752a69430f64f196a3a189c3de8bfa901b2fb21f742239149692c7ab9348c038bfc56b4f0e4990cd9e63c1e2130f0f71ee088f274d2f48b2daaea0b11b821df4493c80a61fbfa8de74275f3c572227d4c0ca3b07bd6e1d89b7066a9e4819793f939159fb297d39c70679cf1ee12f20458d916dab255b8645a82617676a839467b1c29f2d3ed1a56e0c4590a9333a55509d509172760a00c866dac933cf953e86f1716050fec05f5f2226bb2cde96b807eb16468de8971b8dbfa670787d3b2cb4b63e64b9281e18d158b25fd7b4a8be8a09f8f376a7680177ab27d485ad0fb030fb13b490af8694c9e0251d2d29b0463bea940f250e8170ad6796778efb4462e1e4189de0776f05e7090468fdd26d72ab08c8a7775796b0d0d6150b426c2db000e5162b9d96c921193ae715b2037c1b323a95a4ea37a03df99726e426b0e788e71fb21bea543ac6d1d9a29fa0e18534c5d1ca91d9485552a59de2e56b83581ee8d776733f2d8428aac5f9414bea7f03a84f840e12f3c9306562c0638f31cc173c33b8281a2703fa8961c656b7f7766fe40cf822badec9891464023ed95f1a9c0d2eff4c5c77e328e37fe5309fb8a2dbbac3c4aefe39b58555ec2f914d339139fb8e52e53b28a96e844b75c240c20f1e770ac907738e9bc7db132f9e296fda4ee3bfa83e01618530865310630648ec5fb350d6a5d460777bbf980d68953e1008b6999c374f7bd9986f3fdb651ecc85f04f87f96e22b816baf36255f3146f5239df85e3eb54f5e01b278d25f37cfdba03fa1f6c7cff0fc33a89ded637097af0721a404565b18db3eef297e3845ee81ca2b73a7ea11797aaa5b94a89d7371d14caeb08f6076c6ba06332193e755450d34df4f328b7f03f31f7bc2f5e31b3d06a7b3b9e24e522ee2e424ff720c1cceec54adf6e9f0a6c3962cab3c250987a23c46ec9bf3c9d7bd4fd285de43064bfb30bc4cd0e3e5e171d386c1d15021e4059d36697c7cf30505ea730f484c26a89eaa4244f99b4cb9c1383c83f45e3a1e7fc46379a153b205b202629b5e578f73486ca3abdd6ba6fe7b0fec50a9ca4d10aff41cbae10ea80b237bc1e036faadb725f1ac8d929390507e67eb4a651cd89dffe5c24232cfe18b6a086a3dd16029024db27d2083579e2f23b422db54fd70b176abcb21a741408ea35eceb9f19674b86687eb4b2012feb3fa22382d2a273d2f673fbb22d283eaecda65797f2c1b078053e53360bfbbd5bf5f2db4def3107e4bd1d424e6a201cefdb747fee46855d93ea102280456f946ddc934b1361d6d8833c29a8346d55698216dedcbbb0a4d746e61c5e16b0ca2cd12b6ef299493a240aa6346351ebae77c8c6251d763393c88e6b554edc27d076215b0380fe42dabc423458fed4a64cf3457ca19302f0ff6ac44d0e6f61dce6b93d08410e0184569303837304b3c89ef554d2d29d3f029220b6b4f6f5f5bd7c1dd896eb6bd937d76134a3eba81556e25fe359c18e67449192e2419ecca983bbe456225acfd9fcc9455cbcebc40d48a7f4dcc608dae83a0ef2fcdc9c92c5a0e7a7dc6e1d69332009bf209f3f8352a776d4264f749c40b7b9e4a45f471717c9ec2b069e6692d9142566c1379824b8c95d68bb6882296948587fd1fddc07aa920bc63c59133de63114752f629794f7674a9d6d8caa785d40762dc49938def391d5821231dab58c50f02fe96720631c4ad07a3f45a7d084d64d7817511154ced2d57be551546ef8b876c1049867a1996de44c3b56d533549e0af5df49ef835a96fd3269bb51fb4ecaa80918d939ded8664c2550f5e3f1aae2f10613332259d522dfb68e03f49b0b6504ecde16a300d118e0dfd58111d535e855b67dc88f3503f0f1df6436e060a41904df9c088acc75c64e5e54e610936215d4980d0b4afa5aa0bd1de4f9fa577c4c124aecc3118ceab08f5cf102832d4ee0fb358a56d1ebff67bb501f6990ef03e7e4d2e4809787786a69ce898d4d491cd156a2647004b83c7d6db8885f3894b797775fac067375f68b38ff4690e2de0030a6b5de1ada706c715574248e4e840ee62718314f7514e0779e6b603f8b29a34b20b51c617d83b88192eb65e5700c80aa703bb2526bdebf07cb3da2472ae13f52422ed772fe8cf2879446c74dc6a4b8d6687fc0a9d77f269aaea9389c98aea5210e6a3106ebd7fc7bf84b51966745de5d69c916d32df76af6fbc5b30bff0903534953b071d25b564e0a9ec28b9d4fb6c391d53f33b386693430d66f677974ea55d6f46f6ca5a9ebb7eb16cc1c9770f55444db5af234c6227169e94007779112bd1b1a89bb5be69b6d59aa6f0b16fc542e21cb5a06cfc38e1bdc7c98007a44822deaff7d334c41490ef047d6954618f9ec616cbe307f511f39d4dc6838b553659120ea6c220294d1ace6409ddf62f91e36b14dfdbaf8c70680fc102fc8e5ef046a3744e91ac3365703f18d6bd452553f8d7ad22fb181577cc89c45f1909a59ea511c12afc26661235d6a9ca342c475f3eb56f585435e2c31382db54c778d89d2e1779b0df0fe853d4b88a051a6962482be9139bb717886a3d6a671bc3b162f33798716758de175398f0d6fdef9458fec07e56432dbd2529b8bd6348ea063dce5fa30d4493818ff478bd3e354292b604fa8be8c379607381d0219351d74da0b38b0486419a1d01a892a8b97ac687f5714945f3c403a754a78bbc081ea88d2fad5dff50e126c1cae0ea8266414256c1673fb67339b073878f1f4c16ff19343fb6100da7c6af4302d9dc96bd39545f2c39a4830172607adb68a05bd8477460c35378d1312ff19efcd76319e2a53b49da33d0caadd4f60be131cbb92c3ccf6c87b5aea54eb84792657c2cc42fefcd74252565bab7435bb4afd44b72c9c7750229c93a8f37a68f9c4c2ec1592440603095e4002a91568a55419d09d54a1f55817d6accdb9c88c2681b2abc0bdd8591fd03034fc62ab374ab73f73609b802d173e79538a7a8386c17a2a219e3256343ba72bca20d41c112b5e6057570a4870a9ece80391c891f572b14be989c7cdb13810c41e14e3097b174875fe6ddc1a5ab5e042f14e9a4c04c2ef255ca74512423f2101448c0c9f505fb83fc237d5121f4207e230e23172ba0fbe14cb81b83614f1506cd15f8bf94ca7f8ecf44144e992bf2563a9b3563056527a1432cdcb4a84d4014ffc01428cfdc7510b5a8f9273f127be3d36a6603904882c671a55315dae2b50850028ae45d12738c8a0a7322b228bba581ea2185a3dc9460970d908d4df6e082ff96dd317e632857ad41a1bd305b32163be44cd806494756bb4c6dd54a26a0d4825f2e2f3cba13b3cad960363744c0aa0e517044e537df82c1d74c5f753b8ef2f603ff91ec6a67da30ae1b506f0b7ffc93b25beaee807026f3b51dbee45e907a36bb9164373492d63e44cd3130419e17ca406a7e5618edf4cff7e00378e7dea297a061e5e799aa74c95a7d642a92a650e2c60a874d1a061cf9611a8f648980192f356a32d90bc808d8dfcfaa5c0751070188bb310e3e202a8f5464a666b882fe7a47a3e0c633113d4212f9a89aa96c1d534423fb866a2af775cb0bc05dcd3ba9c6050dc72650506602dcfe9d4127315c8ab0c1e120b6d37511c71d5b5981729644920f7cf8fc9fd12361648875a3142bf240e2369e15ce57d15a1aa195e6298a001eb9e1cf44161b152a9badfcdb5e84d971a4c92287bf1640741d9daef4e99c0512d3ec45d189d1866ac40168b261fe01737db7545173828d8e63af8acf9b088685c1387aa2d0d2d037e436a33b1c31cbfa688bf471ded9c0eb828bcea04a933deec10dff3aff3d54d5358315fde112f19e9bebd5c3b701cecb06900da944ac83cd03ca068ad3332210a06634986e6d0836bcb6544736396bc5d720012add72204c2557befbdab2a84a803d3c4cdb68f51f6f16cf9428538926c69ec1117b1c0a842ff28048d06e3d592fcd3c873a926144879fec7dd201676222ddd45f703d5b1d6f617fee70eb4cc8a4e923bb03a6cb066aa0097479c92229be4957c99259474269df5c9794135bb81ab5bf6afa00eef0c7f48f025beff17712580d6e07faa6dd1497bc76bf2cab59550dd6351033f0faf99078227048f0f23f5a8c9a00910843c5bfad4fc8bf107c46f96e8d704b6bcc2fa1021e2786270e35df0d9330ad703df1d8a428e740d0c6efdc8e04516c8b0a6e1ec7cd65f7d8f88155d2a13eaab6ecb801bc748065f7d1669e99a02ca5c453af18915206ccdbe6a053bf1c100e26e6f675e60241c9c06593f6f7befd23c50d6b96fc7ed6f582355279dd5711755d8dc208842ed44dbb9903dd61191c4291f2347f3c6199037fcea86892ca5d88bb50b76d5ababcd7e650c9758788ef0a81762ac4e66839e1fc10b559762f30fedb25ee544af8d442761892f5a4d53647055b6ad37936a5f9a5fbeef954bb5356cf461f97322d5744fcf30d971cb0461ac1da1eb81a02b077c117ae5664e2bd847df0c41d1772d309351f6331039cb139c8155663e483055abed3222cc5466245a557c695fefa17800a698b1fd3e7320a1d03c395a470f6018b32aa1fb4f088da2d233166fe2fb6cd40ea5b27c13e65b51a9b7be86f582400ac75ece3adda73c178ca4b0fcd0208eedb7b20ae9e02d0e87bde2d0fa019ca21dd276bb39d12e65f2aa253ab4df209a6de328c5a1e15d8ca47742521267fd3834f0c17c82ecd0ce353d0b6e7d923df5978b400f69642ebbffd18daa2b137283bb1ea4645734b27f7331475e50442dbc3ef4af1a552b9ace4e1a9e676e934c9c224722c0a62e754b56509a0f69a561035c5afa0ac33280aa8e0cf6f6cba092e0820fab322d86f2f78758ca0a2cc7a8ddd8489cdcdb095e046f7e6c45f3aacf10d9fe663da3897475e2e2c8ea2c8f58a52896791f4a985318c0186ce8aee61cdbd198bcacb5560af75ca3c5411521d644788879b2cce0083216f6a0c783eb7c6a3494dffe0c8e5e49865951b676dd07697aab2c6487c14f9e9137696f3a17b82711fc0e2e34e54c29cf85edfb4106fbb5a819e5a588f342ce108634e8f9baad0f46d9c679c9194c63b397b28da336d1603c9bfdbf8f36d008b405e3079d2d422226e34e48447c620d73d4913977abe96435dea56852c43f38bbe7b8f7407af6a4f7a2677628387c68cc8b0782d671d83b53b5de2f29cbd240a7f50c26fc320a582087cbc4a5ebd84200845e2b9ba78be4afcc8550adc283c3dcad9f68f0a6b8a8fd8bb22330872c03dcb605f660e7c891dc43868f8bb5e5ed0b7dc6926def6e65d008b71ea3466e952d7e5f91765042b0fd7dccc3f1e1577215fcb9d201a2c0c13e39e2967f46969bb4bb6f4c54f07995c4c5f85a6fe4d07350fa59f4a68a3c147e616eb0b0bed04ce1ca010c5c115529d2cb8ace75bf6c470568fb3be84f62812e1b2d6d7299d704227de41afa7343e01367b6a02933a9f7f3a50bf916a59dc81f39a78645e93c8f119c45cd40e624a33ee9ff5a0849c1948bf0d50f7f1b68630f7107760a69dc31ed142f3a3b6e86f26fc78f3b31b3170274c46184d816cf41d205b819a545a554d029616551bd9b42ff72607d2bdc729fc18389fff86ce54b94103c4b8570d46b3fdad848188993386250119c57cdf184d0c5f2dc2a4dd7c329811e6cf766b0806ed124cc3f2a06a1ab54791d54b0286cb85964112ba1342aa122cb4690e7ad0a14dc51c477a7166b9ced5c6ad79c73019bc297bd1a3a31c2b485fe463dd286613df9a99c6f0e3935ffe7079d14843850fd3492a94b99a053e656d4c575ea4bc9af78698a69ba8b5677f9da9419af468436d05602f9337ff387e0bb690649cb18e3407159813fcc43f61c354ee84c2997e9095cce2f3eb20a1e5282f15632bb490f86e2cec5e9f0f21b7d3542c962012715769ede53f56d2862d673be3edc84b12fd4ea294910c5bc06c352851ccdc6acaa0ddb839e28e5534b7c45ceff105144bae14c0b18bcede85c318c86edbf08534ab649eee688db81af76de2951f2928fb88e1783801b8f07b74cf3703c7bb6d2d185512ca3957ded88fd385f5a470959b044c6b27ebf23fc7edfe61f6ec23ffa16757d8b98542e883457a5662d80ceeb7dfeadf626cab06a7f713bfaf6b40a67c3042d2d58cbd2ba0b90f39dc87a72d58838b5ba207c3dabf8ed497a6e0180491cbf9738e41a716b697b6b24a3e7c8a4fc0367989a9071b11166c4d5fba6764be9828cf490388eec0cfb39bc6528310052a59c2e562e4b17bafcb38cad44768d1b96d653836ecd0855c063a34a1e1cd5cf06e8b139aea4d9797a880ce8542ce73c7a145a4f585e8332d2930eb16e9e4a7b50db859627271614184a8940a94ffb0253184268959cb734d4623a6d92941062ff99c830b998cc27cb53112d099cba9b20b47e6dfa8c8d1fca0a50b7b142d72946d05948e9903bd98506f0ebfaae5e00ef08cc839fde6217ba2a6b3cf5c2097e5c13273794767984699002697274f397312ea9bd0a1c3fa590a978807a3482a586fa8a5681952c4ff40e96a866646168a4dece9e3b885bf730f06ba5857aeeec3884bf1af41181b5c0380a3e9c550447f97ada3fc1dbcceb405c2431b251256e1610d4cf14df4d88c5c51ab6229da83a75e6b6476f517c95054df3622bba916da1a6b33e85c53d458682b88f221abc12d30f1176ab76004130bcb7163c1277dfaaa245cb37656efcd4e11e535db4c2bbb2a51f66813e4ee883b006612ff98006d34c220b81e943df120f14e61c766728a2ff12378e00ac1e93b529346c199b3538f926d6d3b7bf1c5a7d5db1498891f160c6c4978ff39fee14848727a0c61645a5851d0adcdf522ae2bc89e07d05984ef9af961666ca86dffea1e392d6646a75d5d1461ffc54d289ebb46df75d079485cb556f5e3a7bf7e83441000c66c089a2f432aa07b8d449f9bce0904c254968f7e4e916704bdd072b28aee93289c5c0f65b421a6a01b1f77151ffee3dc2142dd2145dfd60d669c572d0d6a837c754837cf6ccfa9ca035a3eb1a702a168b6d78695ac0d280b30e45f326ab4c77d3e8353fa23a8d4b20d5171aa593cea4fa58537c74f13d05ee1b3a1ddbc738f14b77824695aa67dd043ca81b90214f7f4260693d15d18323c67e66f4876c1370ea479606bb5271ec947888afe401f0486d4ee0b2f661eb94deb12123c3809c63152021e38e0948e6d1b8cba926cd47e8554df4f9ebcd4fd29f2661efd5c60000e4dae360d8a76e3304e2a8cc5571448f91fefd361a0acb7cb70e6e028219e49dc389026efe08315c52d530b707a63a57ca20d33143c2a7050cdeec47e767aad498c30eef383638427dcf8830554ebeff5344511ebdf18f13b89c08bcfdab707e2b8da76901b8222a2a0052ded6e84a19352bde1d46cf523dca00ac5ea0298d5b7b4dc8cbd62d92a55c5db162db2f86f4f3dff9c7688634dc549db6d8b02c976cb3448ef3709b27222874891c771fa8d63a5bd570111e7837fbae2c253666af1dccf1dd9d78d38c835af66e8a694dd109ca428c931fb2d047b006f2ce8ab8e6258cbeaab8132d61f065b0e263f6268f7ed12c6aac2287f139bb9977298e2c5c2e24aace6559feb59d5cb36cd0c4208d7884d0294bf7fc3896475792b098f2f5b500a3c474a593a9c4495414856edba4e6e50bea878f1c89135167b67cbdc021d36ce4453989348bfdcd64aae21959f57bc35c44841cf854e61956b063ad2bb52dce3b0b05d9450deaf7ad067caf40eb19536adba7cf096b34d3b8add5b6f7fbeb7fd8c1f83d63fc231c2b912ba68f27953bfa0883d84ae5b4fc7d25a02a5129cce31d173dace8c918430bd2896d6a7a6be9d0a6fe874f639979c00a78b631b1d68e334cd09229db1c37536656bce195a400d50133dc6ec6dac1a98132457ecff156adf1100398c75044a62ff67fe0834ed4d22b6f75ef9e66fe8d99564a29109f4dd76b41a172e3fa9e3b18de4fc046192eb2bd6dabc67f88421a892bd77d7c7b5bafb029c2a6e4a1693272f679fb21d6e210ef4b7b384f3eda8b0d2e4cf5e2af40d690f6a39140583049bb354e77118d685ebbc516039254ed1b41b75918585fdeeea5665be3aaaa9e0c0b67bdafb6c03535c36d3373a6f153131b21d4bb318ca609d158321b9eaa242df7a45fc4a77136b7902728e8841fde1d6325788f99321808f6f627cd7aa37f0b7f1607e2a78f7a7c8539686adcd413207400f708db41b1665cfb66ff2eae1f1199dfb9795b73eebced3074cde4a52d87b72353980cf2415735d1095f876bfe0d0c21f30d50030f868635d1e1a0bd1d054d39a61071ba44018dbfef63429dbc9f2eff9d9ad713334e98b17b09a4a34b16f95fb8005a1bf984c896807c36f249a55c95862b4e48bf6255e2acf93d044513c9d571d661c227ddc49291d797591aa5d840a25899b8d498251e7a22f7ddfd5277d7c376a6177ac2f3d80e4ce78a906293720f680208eee8d30d21852715092c382d3635b5ebe8f78439f31407ed740b915806a7e61e1bf41b8b8f8027a9139f2155c3f860a2965371801e5353c41bb10b309ba31611ed3aff1ab31ef12fea5349f083b8a1b476fe1d6c627774070c9d07c4ae73490da0222a4e5428043722672b5319d920f53cc38e0daac2903d4caf890e09565276dfb9b2588bded6d68c4387804c3adaf49b9cf050c037aff5ef4d915182c9bcd609431a703443bc93a21c6476e8beb5ecf0c6e59679bcb998bc158869e9951860fa3e79dbe74b3ebaba3a34cb65494c973e0dbb336728fb7a6631ecb5e963e8c68f5db9c5d20e6c326992c90e2f73513f36ec649483f0640723a7e5366ba01cdbbea67709c49b3624c50dc5bba4e72e18e0505b4cc2ca466f6e3fd87289223805854e7fc8bbc1bb49f43fdbe846be1e952d5048c19d2930c3b4357a69342c630877604ac0b6f2a3b7531bd6533b82d6df774829558144c21014a4ad10fac06d1adb407fcb910cef1fd8207137a19213f8718fbcd22846e120b240d20715a0cd8d235f31cb2a38b6478693605d641130062ccf6b95713dd523b0b53374f5bb886595c7d5b8b87518cc82d57f83d20b433eff5bfd50195646c6fa4d108e3bf4cce03422b4ebcca5a9328f498f2acbd0d8b21b89b29ad5fa34e984b900efca9ada2b4d4d7e230a74dd136bfa31a3ae85d96b8f771f7a1a8a763a67892ad4e28082423a882fb8cb08afa67443b77c2f56ba5b781b8626a726d0f95819df1c5772064216fcdd3a2c21460dcd0853196bc217c1475131bdb3d6532b9f099dabc0b475117acab5e0c6468337570d95cb5a251951eaa21e3a604308cc362860f35849d6c1bf6a32d9fc6b34ec2f2581ddab99f03bc48333d91309770cda0f58a11188942378b1d6922328306b45e757ff8cc4a742be3f3efb9bf1d7951bcd2e4f03a8125665031c3728c8327c84e48c5c5b4aef0a8e7ec9c13d4f2fa21a400e20da71d3de04053c23b1de12f6c430ee4e57bea1754615ce6d0dc14cad0f49dc766dac4e605169af8d2f3049c1834dbd34da568a685829732d519859f47a77dc2c44be88cd835e25a5effc415ce17f380c8e54c6e54538c21ce25c6df018b428d20e727f9cef11cc403709097814f5f592e632b349b9da5b8c6a167e92872564e419519850b2461739b00745e2a9c9e90da9b1a3cfb92e7b1d99200caaa96657f90f6c2c1a97abf0caab870ad8281e25cafb7fbf7663b51b26212fb6aaae3a574d8f2bf5258d28608c1129f797605154a16b3ca4162336c13ab94095f82c5e73b648c351a6123557c3f6f57c2b4d4e8852de75b68bed748bcba85f0faeacd3e0fc47e7c73258d5567ed16b2a22673989542b7a74628a9e4055e2229f26a2f94a620da973c5e7c6ff0fbd1be794d34ce88edeaed0586e5df3e30379fb90ec2fb96560965cd7832179e0968a2619519fc5a313e659d57beb82a6871884c257942d4e73a96bdadd18457d02f50254fd6b42289e19543d7829b8e2d6bd4a4106ecf2cf233660dcaeaa059a9a3a79a8c58a54f8f708b62e14e8791b4433e54ffea4e26240c5e9716770a55cc373a219ff8c841705427406dd4ebcad1503d681541d2fdd58a3191c7e379ece902d6c7546b7c771e77d8c5d67fcdb391b47bb26a4e7d52fe1bcddf63d8055f7dc96b827fa78b84fac39e9e100078001c0c9fa26dab13a89c86a4d402d4946d8c363077b3b70e83de10f26ec38927ff711d5d634ab4d5cad8b0ff4cefe05906ff29af363eec71d2896e81fe74cf52c99553a10261766d5e5ad3d1420c6673dba474d3ab1d15a63c028c6dc9cddccc26eaf9f4d8dd3522828bf0725f57cffcf9efa6466de34921d7c4f16db9be4bdc508f98d558b8879ffc0158ad1414b36ff6530e8b31ab0352a1b4c7a8beaf8ccdac29564559eed19e39778f9241664bac7d4795fee67ceb8b9ac7209ed11a6c273f2f34ef94c6c62fefd65de497bed0c1d7e0f185a52285ecbf7837ceda6afa3e0e771214c6066f4d047df997f10c860d73645a872222e910016ffc5a5606355e49d4f7aff31bd14904330fa329a09c395c36ead60d1d5d375878608e2f562ccabc096b37f72f378df262115a8878e2b6f70a89c6e9fcc3fa00688bf84e4902e2a1a13f77aa83d7a41ac2c20439a80f0d77b0d5062c9335d135ae450dfcef832a9cdc8637f1af13cbef5c29b6f93b793e4f3d034132476c70031276c64040aab186f3d41b9dd9a7d724b57c8c50117dc8413de69f60cd5859417b608720d2fef52206e11ebc847fbf44618a70fc30a6cb27e60b34562b3e3512e5896e053b96921822cc3ce2797c70f1635e4987f0b632ccb9a9c5e63777b23b31e725dcfe6eca38fc87c08456a72f72db6fe0a56a0c7617ec21215e7643e4b05388c552fe991380e317e67a5195e4891980123b4208e83d9148f22583295069dc704cbe1f70eb1836e4b374648d183c75e6d5ceccd743ff00f857ee46b5dfeed0a06627e8652718f6ac526340c112d4de36a122cf0cf74b4e9ac288eacd6e055d2a15a7c3b909a26676a121dbc38ba59a5588105d538ddd6c53b8876e6f5c06f32b6a5824859ccd930138c72543195a49edcc6d31a4d72f448ef480159094660b5f4bf1de3d04a444f19664486eee35a7d14002d9f543f683136f6d25c1fff89fcd9650a0e4846bab70b54ff7e2f61da9e47b749c16826edd5929c4770a2161259bd927691a8d9144467de04666ce982d4cb065689bc34898144c1067640f8aca76f752e2002abc3281e8bccca992f495a9cea89d47fe0edff0f3b0d62709dc32403320b0478dcef1e12aee76284b66c61fbeba019e8ecf40fbaf7f233a9be08d93eff5450a8597431764919bb5fd2ce396475d66cefe699d8caff285d0254bfd2c7e132ed2a0ee7d7cf25702f5f4c547dda2dfbbbcd1dc358dd7d35d850117077878625d88adbcbc94394d82929f4d4c0b8d301a5e56beae51311e625505ea38ca0c622a08551620742aac25790b79a62d41ae469902bb337a94deffe59e89188bee0e8de7a574c22dac346048ea23f08682786788739e0b3f10574c8f19f88b0dfa54a6301fcf7b6aff9dd2f4b4a32914a1ca93a6096c08776457c55db1d31b685d85f7fee2ba0f0f2ba1c585fbf6bbf515c9845f6c7388eff246fa6d83f70e7a04a5411597b2f87c1df268a4f58b4a17cd5bc87a8c97e60496dd90ee1eecf05ab8683830436e928d597d4f8182d0026cba68719784321c283bae08e301af97606f79bec6a45ee0ab8a4a53b5dbb775f118e0389b2152eee757cfb872b90a84e23febff72740f70c9ce066ce0e50c306f4390913834138f73cf08afe299a11ddb1bd56c412de2f760a718d13a99a5849cd07d301ac98e7bc3c2dcaa1f552a87d674cd397b40932432c20d723cf4dd8d275357f0cb57da9c34e78dadf6dd85748b55bd5b368d3c9df58a6204796b5f1facc64241f3ee4cc90f83aad1792cdc6f665fd0e10984cc5cf61df525c2d34247708d1bfc28fc46381fdeef3082164aab7a8c544a884105726f3969ad7e188b965dfb13c491ed8ea96bfce7110578a26cd6ea0d3dfb1bbabf21154cc0a4130ec6f24653883aa4cd9ff1683c7ecac750e3828a133095cbff92ddefdd67a4cd5a5746c708f9dd4d22352b263b8a191e7338a689f9da8e7ba8032a97d9cfb55693e6a646050e971e38ac231aa003e440d6f824750982c94555dedc30cc271417f3348754522f560caa7d71a6da5aabe7954350f00fc66e9ce266e9ca07fd66951a55b35b978336341b7a0f256a8e80daf0225bbbb72973b3de077c0fcf9e854c5b84eb6eebf80f4cdd9e663fe39f49a8a2347ad058d532d3468af78b5599450987d593277deeccb9d31f9f7268ca455d0e5d6460f4ed69732789afa0c699004bab380e7c3ce83553ec7eeed94246f85805cdd91b076aca0733c4a737dda2f977e03131690a1d5b635d79fbf70104d2e55d1c477e8610d0bf04623c237c8ff2d9e391edab1eee9caa511a88768e0f2a49e6dd5b7e5461f3d6e66f6f1b65f6d01c17043ed83a9e214218bdb96dd34de51e18bfa32de403e7a70e9b1b544c6604e977543e1f48c971cc53edd35926a8a218a0037aaa94bf98ad3c9bf24e5b74c44b1314ad1875015a14260fe8d68ecc8c5d8e00121751173d43680bb3337f32733e552b0b21d1323d2ef3dd48951802d5d0e6d6a7442ff5e1433218ee1b39bc5211da65c5b4c8175ee735df9d9695a7760862df52d81a6ae43374610ac54d46f6937496b463be0cc5eca9396b8d8d9cf5cabbdb596d960c5930f1c373acd59322295c331e71dbde4a7d27d1288fe489b84bcfc90735040f7d1730c13561ad4d2e3b324ba11bd035bc877185500360a35c93e16358a79bc75ea81015842599911cb90081b201204f50cea966b968bbb3be3ad767fd9eb3ee844797a1dddf53f9a9ffc7a0148097538267086066649739e9df1f87de1b39dfadc129e028d8f758043177740f88198e8c73bce2a2a444a4fe0aac4ccc5c6884ee5579b97af0b38ced2209b40b4e845a746e8426f77b0102572b67f4f2bf95409b8fd2404f5ec4c205bf536a35b32a89ee2efb404cf015e66e57fdedbb931814cbe61b32d688892bc491d8f9690c181fcdd5b3aa15068ba3037b44d01c0e60fa61bc27f57aafe3dd0ee4de41f8694934c01b1cd87429340deb13820b21c4010c26a081791e79c4bcca234aa27b22eb4778f4bac06cd8f517932e980f2925956d7f38be9e4683f1e7a129809bb90ea2a576c52ccebd70593b7720f0983a21e8c2e983ecbfbdf32fec6b44c2a90e837f3b40fe1f83d00903e24b66171e0732775c473dc3f142a78c98d320d88192984bff3431f0650597e30a599d0a27015dd63d6ce11bfb529a0c628c9cb40e799b78e072e8b8852cd54f7496c7fd5e459c067b63c8dab8c8bd2ebb67c339b09b8e41ecea1df4c7ea61f805d47da246b70571fa777d1262bf4f31fc4612cca1eded4d77b6c4679ea77c99b57be9007c86ca49c7cf23625278ebe8af3b39d2729dcc96f69618ad815231644a72d7527ccc86e211360566772f5a4d8c61b412227bf44b34ef8e2e41d285a3b2dfc7cb03fe54e226ce631fc101ebc2b27e69e07cb9faf8abf1fdc3a2b02460a12187867f9771cc91d9e3e6049981383d21c190fbebdddaa23a0c397409a60655ffe3d232e152df8096e23da050f72868fffe2c00071449ea86274977d4a0a977830e4a4649b830a688fe352184f08e045de674ff0600606c0f705065bee6ed0a9befbd7cef38127eed2154618aca89852998b7f8e344c863c540e5b3d1d62dc2308f74ce34e063c87e81cc2650d6836f226b09ab133b6dda7160032c0743740d470b14b3da7102b735701a667e9f512f4eab10677e67ddd30e8bee1b3253efab3144ba85e4bd0f5e866570a68082ac048ff9c3be0740ea8598622e67f31daedebe66289b36801c375368dfdb8824f70e25abd5df0eb06e8890f4cd2ffb45ab447e9f793156a187076ab2bd32e1c4a14937c5a3052afe1855d0cf77956bcbbc822cd920510dd32dd73ae6570e00a675018eecbd9b4d603455eab9f3ff90f7fa186675abdfad73fa3bb984718397d25e4ac503b5735ac5eef4e6ac0f9d8283b86de73041fe958348abfd3f7d4047e95801b060815cc38368a6e961ee96fa22bd6d819538eaad4737ef4a105d6fe2a1a7e85d637d339cd6fc02a439d334b092238ce6a554ee0b8536b7a464980a153b16f01925309c356f86a593e4d14cbf1a31a20f482ae72765c77c4bc0310bf0af9f87c0bda7aa5c7b7e8ac31a16ff76073504d4637fca3e55f76d925c914ef3bcb6d0f3579ead2f8fc96164a44be910743af0234f145b4ffe8d36b8a284a36dd4293dcf3fd371fe6f4b52d98ca42c26492058e80100576ffe7d3e1502d02d61cf31615e8a0255164ffe19c2012ce45a431736da9f2e4800f50a6a293650902d84bfc82d4f450bcdd99b71c82943c08b2168e620e59fc9f06e56111216d8d4966b175521c30cb28a8a60ba2d85518b05a8fa1def8d72011ce0db297346b7f4d8b647689c9da086a5d0440c3299c698c164d3183f2c35139c2011589e7b3862e57f185dcc34dbbb9d601cd61c838fa433ac724633c7bc1ca16b9744734a59380e07076e3b82532cf1a878a800b8222d465af94d089c2618afc496048811fddc9a79eb1e4e7981e3a99fe00cd73636a7b0f2f404c376e336cbcc4634190e8799f55e6bd3fd236b75dd9cdbdfc50c815cc66b53b897d7bd337e15843c79aea51f22ecf0c4005492ebe1be321cb1fcac70912b955387aa3d20b6ed91706caaf35b9485af9ed92d2afcfe47ec9864456e6000f991efdd6e4a6a2c93d40293e747ed13d4521b5fac5fab7db7a1231b87414ac2a92e500a101fe7b36e6ab7ae6a4a0a74337a19a1e531f86e62a05c7eac94c9b74ecc2828edd12880e2319ec5c84df98fcc48317310d3a1b809f437787f83eae4c94bee021c458bc50857e27bd8c6b1fb46268134e119717a07561dfd6eb000805665e82893f91afb69636c5065103c84f8a9dc9b3757ca74fe2dc53a3703ad5d134dd335ec99aa83314df1cbd8e6c3d455378b1c31f414c50df5154866b8129637bfc40844747bdd970bfbe93476312b77f64cb5cf2e5a932f880c97419dd8fa72b308733a1dd82c1abcfe907743c48067fc03dffaef865ff1958fcec05e987324fcca39dfc644e714d016996060dcf6c9bca296be85b452c6d169aff86f79dbae2e45111eee07fffc7cec3fc75b120ffa2fc23b3492e04ef9faad2dd0ef1aa556cc3376aa6c4bf676f9b3074c85a6ee444d90514cf9cb811a7626a0f023a95d89aa3dacd84f3e5e2fcd8867a4da2b25e335fc1ab0bc95adce2c25b67654132cc603eb1aa635eac4dac9203d775f4d2cc8d196dce58a4e67b3378e0e5794bf21da4cab08848beabe6fedb4ff4c2fbc52bd8460be2f4bbda647f4b0eb9f27026fbcbb0a62cada3c55705d84f5f8cb610ab696f6dda51458d474a720bc72b9e42a89bfc31ea5b107ec31d980233ab48650b0688ef8963ae5c038b09e31b8e8f35c75a862fa5a87a5e3da0fe231615255c8f92174258cae7b25c04d2d94331a8dbfa913625f10180cc76e0b242729864ac86bef89af365e364452e154dd5cf2093148a21b5beee6c96cc40c34251a0fe7aeed91e292468251786fd7b3c496a73eb7f0761be868d9cb6d1822a847932f52f759588fc6ab68d3888f23ced56a9c0d2561d58439f457c1c9f7df6544fffd07666a4ba52f01ea34436381edb9422dc90371687f211f78a41f80d1c27c53ed842f03e26067b8e3a2950a72016a44a24f63e8dcc0c3a9f560ad5ab4d2699258fc1d580a48806e58f84a6c7cac3085236a111c620d1b63f8409d33bbd768edd158a1853025f83362cd33aa48ad692742a0bd231c5e6cd1fcf05e36d24f57548f0eec16beb6d65a84cbe98d9ee7937c1f2735dc8e9b48afaad788b4c1e79dc49cf7ebf9da1d77bbb0948b4e542301559bbf273e1c39ed797c734604a34ab7996aa5ae025227b50472c7b131517f2e42e13ebb4bbfcf82cb65c5cd6aefc2ea910a19839ccb583133d30540570d823cfc6b91232c1e00784ddfe0c223c84f2b3aca8c7988a031402efcaed182152e24069f5c347fac47c099d877b08cd4edba402416b5acc7af4653aceee80cddc153876d7429783861e1626dfc62c3f2ec8f74349a833f0f00a484ec545d35262f1d3861e42c02188ccd90dc4b21e3e8105a50ed4080fea989608360f3f267cee4883659773f5b36ba96301b15c83231297561ee3f71f6600eb9087ce9756cc780570742bb2f1e19ccd97dfe2ff149b3123721d9f77c7a9dce494d9aef213b0cedd0b373f86f64ca5701510b0971c5792bf3ea96a869ef369a53a49d1fcbf5d549dfd045a6f697d5a8927dd589eabe72650d50129125f9f5a0b30a9bb16ccd8993f8c53380ca59abe598fb12a740fbcbe4945766dd09d6fdf526b7c9a845d39fd453f74d9879014edf025c47c992c38051b80605b3a8013167227d889d147eb5cbb748493ebd69f1c4f108b9312e65b12bbf935be52fef1347a922175fcb5cd6755b9b970f90653194f3719b32b96fe71614a0280ae7ab4f5d7046897a58633828fbf234a56cc2e26c6532ea282a6de65d581ef81ca167fa0606ad86a4e8b9ce917892193c3685835c2932d908eb951387a1a93f75c7d4fd6e174bd768979472148fc4e52b50b8ff02b2fe2efa8d416d692efbadf569628bc827c6832a2f74a489e933fe46bd30c59eb6c759b8742dfaaa3787b2d123131ddee03fcacec2ce0ae602f5bc2c7bc69add9a9d6a7d7b48329e6c739dd319624e869e444767040d7e665627690b6302b65bed24e17264449138de01c50ce4e4fa81a29e438b225faefa9e2f3de9af682974ebc3be673e7f428cdb7fe66ac456b23036fc86363a739ad677aa68cfb4dfae2e5f5dde6a934d17cddaa9e01e80e52bde40e02a27020e050456a21a668bdb6508d763e0b3158169b8318d0011b20cf5539ce6998394612ca11ed3ec7d44302798745fdaeda9e086e16b6a0873fcbd65c4d43fa7cb37ab01fc78498683cea7b0ff0baeb60ad1d05ea0fb33b4b60f705e33b296e735f1ade7187a95fb40b2f7a3def9a9cdc9307729810efc59202fc959e7d875ebf2868864390cbca4a9b50dbd264b7fa4009440289bcbba7b7bc503102467f5ebc95203c702e844a89df452b43a284eb7a885440958bed4a2890a2703f34f05326fa8e6abaa8720d0b09cafbb94766ad42bea7fc9c6ab8dec24c6e9c8a4851377b9a59738f2e85e4db3e89e993f95591fdf1dc9bfc7dee238f3e7fa96fff97ade2ae742259813a8b890ce77a23d6a971bbfe0e6ac49fdcaf9870c8b792864d7563c1e36a8e5b45237705af1e455cbd385bb1fa38f0549258270832be83f397138cc331e6484082b85204b3b4f1dbbe716c09cb2fc2708cfc5b689890e51ff0fae4a56be63fcd515e8de028c086a37a4eed2d12e4a1a25f9f409d77e51ac4068c77f27d6f95210d71dfdc75b7dc5c43aca04cb8a674959aa0e0603fb8d69a009d6e31fdfa8800019d5b97e929a1cbf5018c5d60b1a6b58f77b5640a63d938c5cd6c951de8743033b02712970bd049d208d6a5517bcc477e73c8712f9a1899909128bdf6e8789834fa3a3faee8764deed7a38c9598a8effd741a9902ff116ca03474aa2d0725705d3451013b508755ce72af770ec79c705b409d08cd6e5456ee7633f46871be8215b64b05f99dfaf1e471ac9b0e487ba9d9751376e8cb82026398637a828d4998b95f087260a07aae182d5a5d30fd75756ff1dd0e8cde18be827bb2478b77125e629d1392281da9e510ec9496b50e1103ad2bf9ce3b1d8d637ea3607d4c1cb166b561616afaaf7ef211eb56e4a85c21899dde98a857d128856d3382da7ce366204ffb29bd1cf1ea12fdad41b8cb0da02b6864854b4831fd02d06ea88be5b78609675e46b01ab646fb8ca4f702e9876353829aa610d63cb94a2b4c4cb9b42fdf932de3ff2e605aad11e6de45dbf883122513920b23af6ba7a15529781d0884bb3b7ced6b5a3a0272af7d58e0f2f7074b242387579fa5f0cc1e6875b7bd2e56c6014af7c9133a976dcce9379de9e2727f1b639737c1d1189c0be3e1ad2a0969c3d25d4d64b8788284ea8d1972ec0da8412f7407ba64b67ddd8c8898e89b8bbac66f43a06a5f1ac27d49020a5466edef4f6e8e1c8b7a781c4b9404902274a5e8d915dc13decee5405adea97182f68ff568afc40f77df7843559c54224ab5a89136548217abb44a79ebcfeaabf3dd05f09558ebe0de087faccce2ae811222e38c4b9f80ca03c3c039a54dea7402cb09f22bf0e28ef097c3a2cd4d427e955bbbca2b5d71f3db3a453586ed105c061a8eba24a66d61f0c06efa6576a1fcb42be973f1a614749f488ca4babbd2c52691a26b5e3a5ee272865c49b4edba139bfc08bbbe024a42ada05ce28ea4a46c7c0dd6d38c0bcb183dba4f691ba915b697dfed08f0147574b6959a1acc6eed46f7f0e7bcc844d96713fe2b442927e58a773b2142fcab049c58549713be882bf70da09079bba56c7685d5528d79269d31e1ec3834254e37712942b2976643d5e910c72881e7d7c1103f15f884e81aefb9fce7b48e6ce5babec266e4f1dfbfd75f8f332754ee5d95cf2ffdf972e4226b38185b7b757a5ef23bfe0fb3832406ebed602adde36fc7f83d5011a0c13ba8ef3b71a85a5336648a97147121be189bf906fc6e9f0752c3abfca39b907454ddf8a3b661bf872668914d3e47f2abe7a66593496c0ac06d186b76c1e1c76d044aa7d7157c2369eead59819818972219050dc2559450fb88c7785dfb15e99fbfa55161d297b5f86d63e49d4bc25138281e172044cd784d04a3b7e3cd4fdd8be3138248f31ff38ed22423b54b5885f8512db39081582353d53ea18e74300cae9706c82f62801000576bee8b708b1f29f6129d300f96cf4623e41c4fba9a114ddc9c92d4b9c40bbf655f3aa986894a3eb3d770b012078fabb8f1d3539101a2ee9966bc549cf0499a841361a3e78c8407a5c3873a2a77586ec9832039e8812b4fd29f24e3620d22898ea0d7bd284f9515b39c35e97b24acecd05d86eef19935bf87e2970f608c56ef7ce2970896a2e0586f264308492507658c7a33c6685e98d0009e88c5300f0d40504a0e105487b09736eeddd49363a4172f38e1ce2382cf11917b4925eef55f1bd4eb9b16b13d2a85c7d138e22f0f7adacb47fa2b4394eae8870a63f44bf613a32f5481bdc11c9f760c9bf7b6d41961d0af42498a52d387886f865f6820ea24b2b7f7a7a2833b721865c436a31130020aa938e6dcbf11b914710043b3d331b40d25a43e212e75868dbb49cc1bb777019c9c8b258e1bffd32a1f90eb71fcc122f4e0a52097ad67504eba0e884561e72e62484667555747c4d8b949ba57b7320ff0253afc70af61e1ec76f31e66b3edcf561569d09fb882afd997aa67ffb600d55fa201b9eb9ed66adecb2bc63362d8765a0fa9cb8fc4badec3c4d3e3b09b1f929b11409f17612f5f5151d7af9e17ce5c5d3568614e69da4ac9ba7fe5343661ad8e6fd6eb49ea84e6146b7e15f8f070ea77aa013b4b9b21a3459fc5179dc3f4ae01645d54ab82353370660820c91bdaf40c9883e19b9145f62b7087074ed10a3f0757783b1326749dac416cbab929fcc56204b35a0fdf9f2acbc1a874c70d95e15d7ec390ce55e346504a6917adc8e6f66d9acba055fc7b544a26e69e942ae4d6f9a400b540509e50b29d7fdd5fa572b5b1a53920ef24777c387f07b6d7b419cbf15af36220a84c3a0d2ccf0f0aa66159e9049d2fe0026fe530735e8fe57cdc2fab0776f375ab506cdce4366ed19d6c5ed8a32bda5b1624cb943996623a0dfcf353ea31ad7e7901e9c7879b93d614deaae9310b4d37da178733c8e2efe1aa4e9dcc244cc0dcf0e22e40b7761cb99f0cb49fe4229203cf60230531c1c705672812443170f2bf8bef1c376f1dff9237a54cee23d10ecedcb4928d5f7122c9baeaacc24b200c67fdfe1e82f459169e98c95b9df8591d6a276bad0e9ca4365979a35c38a588342966e6f1a6780daceb69c6f8583558797a5d987d2619a82496e7a618978fcb47f9a70acaffa0d478d2561195ffdf60eb2bc70bcc571c85fb2a47cd4f11d51d47a89565814d4d009f7b0cdf04c71fcc632dbb6cfc01ea1132658845820322a6140d5987f1a99d88c63d41e9962305bc6c84f54b8f8d071765f716b151ce48f9a3d264da8cf06302147ba8ba4817779f312bc56804cd12eae621d452ebf3505b0dda48624958126d047f28b2b9c557690689fabcd1bb27c6526e8d5ac6321ceddfa9314bd4515cf7468a1b26c997237b2b1fee439a3c61d7eda009fb54180d4d5874565462f73929a23917fdeea502df5808c507c60f275c8c30324fbfb398437edb181c26f0ff54fc68d760771f92989598eac4f2f11d8f533806eac205e21eccccce83ca9f155b228b069d95f43d42e334adc6e3cf18dc039fe028fdbe1a032484fab00a3dbf948797e24bf2dba083690234423707e7282c70bc163508c5dac7fb478713b24508327670f223de0376a89bea3dd923b2fdabd7c6a09e3f61b3ada6018ca21a415c208c9ea44d0ae6905d45c1f6ef0068612a9566f85e63ad2fa330940b02c8b10a0e78156739e36f0f448bf10a75d60e270d60c4ec0b8ec9b53abd25686a3cce37b2fb653d329440b26db0b20a04c14f6abfa8a0c55c24d2737ba098fcd7289afed1815d1eacae0315bd3b3cb197828d39ea302b4d695712b0aadbdb8082d1b287b08e7502585378d60ea5035890ac942e8afe1d82e8569250bf222efb4d4a824eee43b5b2f50045d9d51e68a98eb4b300807ce7ea8be7dcc55f5aa0a1c65718d295512680410598abde85d1df2af745178c5e8b13b8b823cdc0095dfd4097fa4517fd7fe405eb0cd90d0a353e713143457c774470f49077c817736e9637d84027a1abd5480f3e41178c29586bc41bcbfeedfb544df160bb2022dbcabfc23cb0ccbe5dcd4a05d3b1e7667ab397279ba090c0884d521f6fa5cded5b8942bd25dc63061cb2f1ba7d2f462b3499569fe6947fb0313c8db7f6016210c63b74f76c85c78cc56c400f5e37cf2dc98cf11a252ddc5b1714b7c85d0ac88c2c0e74d68297e06893e24c585da5725b25026daf609518c61e77ba909660070e4f92078eb073f1e591a884cf1d90336c539f5e1b35cf48c882aa2e73edc050672feb44dd1754be0a0c2240438939f0d060b1de057eca9a45b3a9f72bdd9b364391d920e5ffd47eb4bd4c5209614c8c09227722c8e5d6850b9cd3125d9abd0c62c5dc3f135def8b64165de075ae122f0d355ae1b8733508b9b64025373334a312c88491dbb5380a983df1d317cb6a78411f7ba845af71fa7ca48ee05e946e74e67f39aef95367e4f476f1140c61f35c81f0fbb913453d2c48e838334a4a61d548f03275816951c845baa64d6e75e47efc6b4079989178a970f22a5ed9d29834782aba6acb565f6d8f20c81a131cf777e381655bcd0f5810be1c69887aae15e8834dca9b55b502961d0276a580cff21922b5f32a6dc8da368da161a08928c5b47f0bb4f3a4534631d476e43499ee7e81c2265e2cf7fd306c76df98f6c369a363ef449349bb0daa500d5be9d42c994da0affb729c8e0a6c2f95a5afcdeaacefe2bbfdbe3ffaa6ec280e3541472a47b7d9ed52180e03a81bc0cb031770b43649a59265462a8f933f0b215977ce09cd2532e610399dcc5d5deb06b47eae2695738e16923b2d4b7e6a11e00d39995e5f76366bc4f27c6e5cab8069acd653a25da8b3be07a917af0b4192d5e047e6d47630e367d20fefce7ac0ad2f7db1e30f0ac9192fbef6c072cd9be8ae16336d907b6b34dc2ec7c98b848213f8eaaf821af8a5d27c06dfce06b30b5a9d37027ad21a76493072c542470be3361f492b049f67e711cc7340c83a5664ec8bbc968a49e9853931c3bb83dae3442333f9f9c7a5717b4948ab3b3af9797dca938f0a7e25bc6ead2ea296f09efb28f45d2aa169fcf1fe07b728df043db0af90a36c3b37740d3491ce8d4db647cc7854b4bd5059498ee2f2901a37c14560275244364ef50b263d69dc94ee9db7d8649b14ab5bd46d717e2905d7a3be679d33a5ce1d296d468cca6d1c959f21f098ac63c750245b6d148cf6140084ccb4776e047f192eb4c497cd4765c64fa8f0e667fa5172c1fbfad9014f9d00bb75e18b720b6114e4f9b45ef555d62ac2df1270a81b21832f1d9b4f0e3bfac6573c956c0622741b10f9ae059415b78f46ded9b5371e7de05a041bf80071ae39a0ac07d235514bf4172c4af08fbd31c0cfb126e471ceb143fbdf38438c9d3cbe849f35cf206027ddbe4e3eb52afec0a2cb8086866ee752c27eee15b3f8cd3fa10ee5912c0a36691a5495f4aa789f898ff16f409d0577f70fae4f12141c9c5054c3f6626d6b3319c5410d85adfce516197f653691b0b464abcf445a1240fa312f262016fd220b0e49ee2995367530dc551f6f5d39a97df1a2c8149476d74ba0b39fbd917e085998b8438466d6bcfd420254fe9372871fbf2a51c7257dc7273c4e4730924204dd209391879ee5f241ef15160949ddc03ee7d456e5149cc90af502a211346f251d62f39eba54d9bbace14c7d396dca2770f4baed44d51f5779b82d8c08ce65bbc936bd3d5c0789f21767d4e56c8c53999963af1e11162dc4da7258152cf73cc0aff52e084f1dba87171dc354cedd96c12df21919fdeb9da0d334317e90b52de1597a9f9ff2e7331c72585f5bddd726c693c03f52fca65a6dc3513009515609fb540269e39ef1d6c1b36b52ba31e40ef065986ee1a39c7afded3df7e618332a8b5c21c4484210143deb6262e68907d8b24106db8a1d295b36471a5769814ee1690081c18d3d6666bd61c2bbd3ff0f624c58b845c523d16cca37fcdcd3877d861de1a787e71adb09acc15703d4eea8d7d2ccea8dfa462da76ffe83c3bd7fdb3a4bfcfb33dd0823b25f7c2eca3ce7cc27dec83b8c7274dc7bb29aab921a2db8728725db7b0769effdb5f5b72eda809387e838fd51c635ee89db91d83b675bca9052186e076631300d394537f9d9ddfe6bb9d16d67c265f6dfeb295ebdfdd1c4507037de337fe9715f61a5a327692c2b37a867ecd44471c046c1848fe111c0564da92412a48a8157709f84023736179952fcd864527c2cc3917602d58ea23d123c067e4bae12bd5aadec970b59907cc7404dd547cea347825156266a5373111f677081f3728589e34dae57577b7593118b16f2b73d972ac4d3317e3ba83b951d68ee30a4c24046cffd32281715af98e7bfb8e1d5afd3ba6a010f04e0c811bcc8117cff5f855b96accc31eebb261955a21569d8980616e97a58c05261c87f7b42de5f7572411d4a15749216b502fae53e6b9fbfee1aaa0d5e52efe851bde46aa0b494c9afcdfe001b241f6c3032efb10cb52c3f2fb44b1a44cdaf292befb6a4bc5551502bd2274a7e54cfbe5cb556ab568102d90a3bcca794a53740e4fecdab188fff09a7732fbd11db1bca15c356c1b7c74f69a7bdbb594909b97f83fb256f26867d2ae08bc9afbc8febd0f3076a4dca0806f8b109f762bf9bdac65305474629e97d2b57f6bef90b4188b9f1c692a7186840589fc68f8fbca010fdb08e9641687354f9fe865ca846d5ee2493e140f77a5dca010779bd34f20b1d36ee1b569e954f34082d37f72deda8598f939b2a6c07c665665c5713f5255c97aae5d40f1fa46a1424679fe5a942c65df15d6ff41091409abfcb85f73ebd740a101be5b18c346d06aa755b48f3e59e767b1a3cde29c5419cc139b3106af39ba5052f9b11171e9d9c2e86674a0c18e91c5836b424a3a9e2bb748264052a452bf651f4df375bf02d7fa36afe78deb06eaa010da8dcb5b1903629109c6215086ac2cccf932c34062d513db0328c57a72d64ebe9b9fe1c7680f6924cb4d8c084864a78215e0cc0c847c2341aad2374de47961b5f2f694b0f50cd69451c1fc9235252efe42aaece64bc8cd4165b4a64689ae674d63ceb5f172be95a3ff3a8a75333ea148ec431a077cb292114367b3dd22a20191764b89fca3349b8dff126dfcb254a1ad72b67e23984cff32cc1f66dbebf8f30e2dc25881716c38ffb51b1dcab99558d53a907714b638dac8c924a667f3158efca1b9e5868fda922488e3eb1bfbaa161a3be57847b121d70de9379515d1b7d003398726f0b453c1767253029aa0e3e738ade1bcea822f6b747e1355e0e0b6dd6a4bf41f8a0fab73fdda47be50d8a43b4873736126fbf5340af8779005945673337a97470848e66d0f870eff92567134d72d64dc56450c8de56f61bfec58023ad7ff01dea134169df70582798861be06d2c323f756b2a862354bd195e15f27e965d94a4b0fc46f258526fbbc783a20f458d5a6e3e14898e801a83a5d1f13d981017985ed5b1daee3728750887143a1cac5f11234e91c8c9f0adaad5a5876084a7404177c7f4fbe5248dae30a38f0605e8e7e3a8111654b07255cd059fe8c3415fd824d986e82f83c8a1b897705d4a185752213638f418c9f7b905e2c8c7f8e98a36c96410ed846269119ef49796e461f781fb102e12273b7bd74657b5e46024737a3cd6cf7f45eaf9742850c0a0507dd90acbdac098f8a83e5485deb0eec27f1f96e7e454c48b767b872015b99b8ba5ed5b74e5a786be6992a334d7d31882148707876267b31feb28e4c08d15d55859962d864e1864a103fb02fe55103a40df309d53c523810fdeecc25ef2fe4fa8d05e0ffbc371779b9a9d0260e6b87f59e414399d5ea8a18960d9ab1f2da61e963b64f271e331a921e664a0ad32036ac00621e1f58ace6198363f30dc60ec4802da686c90591c62060b9a0a47d4b70e9d1fa45adf4175961f279691a918fe4046607f1c3d680c25a5476615d35717c3966f14749a29e972f380814090c83e25f43ebb625bb92be9c0e447b9b5f1e65ab779bc22f340ebc2c3e52aeb5ba303831b69f94e238a222b7619e7fbb39ecd6829280a15da96fedd2dfa468b1747177bdec3c60d61f5640e9dbcda9f90fb12c0c940fa4dee7913788afa1d6bc61e5b17881e05de23b11b0c6d7b917eef533908f36ce68ee68736dd97eb44791c2f7a4dbff72e90ccefe7d8822b6e13de81d7b57c93f68c1b8e4b6e9bea8705f909a9d52a834da936ffc079d9a628cef2e8468453d13078bd5c75fc159be3971d137282a6fb75a397197af7559fbd396eaa7c06fde0bfc55c3db87a1838b15a7539909e93ab7b6f1404cb557472bd0aff259374f9f83fc2325748b2a18ebb579dcf314e7fd8ab85f367c624c8e8e793c81f2e50e748c768e78626c8aad607bc01737484a7be0176a49a6ed4ac79365144ab3d65f586b05a49236221ad301f0c4169c6043b8b5e85bcead5992cf187a15b1bc5db877d99044b8d4613c6ee966e9bc5c4e793f6c2b5792ae26b2824c32c1af32609fe04510ee23c73ea4a10e867faa9f19685c6b52e243ea9b067b1bb1f559ebfd6dd44b29bba8d10d4b3747c69679b90dcc373d997429d086025301151069706920ede704448550909290e7c89317c7966eb236805d7319826f49e62d61987fc25639b33b9021f8509515180b29327b87fb79aefc2dc853f8b2e3b3b9eec0f70b0bb4118ed5468ed8b57f67c64d5611228244da3d7697058644e8b216332e4dbff9f26c4d95da3a51ee1ba0b495e7a3006c0e9d417040ef4311628659ab9fae2c9917d8206e7cc6ac4bee73e965844f7d6c8723b5a1a870ce1bac93c6f0d4bd41d068efee4092fa6416ed3cf17e87c6a484cb368c36a18a6766b0779982370edd751ebe94f584f8a718873b4633fa618fd242bff0ecd64fc363d84faeb2957ee4a5e7e1910f372315a26a335e55d4171679a2a8bf69e8d510963ee227235d8547c96375bdf8e00329048ffcef967df7ab21dd33631a9c5a95524183605708607f7ca41919be81f27b142dc66f32802409518043582bb8b9b3fe039a0a59f88741a386e030878b43d69bac4c27ecadd8ad448830397bb4dd2dd469ada15ee6d4877eec635bd34622491926d118ebfde3d69626201e2b39b291e8799a27cc94ddd36d5e8aabb592bd13df9ac95682230f5e000365ab1a52fbd81ef72e83cb57664cb692c9326f951e21d2c960b1e1781e10677e74de798ce028b7bfb141dc117bfe7cd1af36308600d062d6cf8c31fd1477061377db6734241b3013ee4f932fcdc63fdac06db65f28bc23b636552d679c805e03c9804a8d82fbe42f30253b08f64c26fa9a3068ad4c789b5cb846b73759787683358fdc69de79620de54eeaa7842485cafc1c2f8e1ba400ef93c92e3cd2f7cfc9b429da9381c76fd5dfdfc77b255e882eed45bebaac156e9b5d557fdb555328f08a8fc5d055153fc4d8e11ae543cec4e1e617af9c4ac3ba1240532bdea09d86ac93c3c711b80f0a7d7f37dd583f0e5afddc6a97602ad953c1f6b2cf7d30454b401faa764f9c1694fe7fe7dfb36f83f5f7400db8b9975b29686803e31991961fc0de748aff630b418b14a0d031362a42f9fc0fb4d044ec1f267e8497be4e49fe9abd0366dbb158ba103017ae3554e31b07e2d1de45539980fda548bac89a0f97e3967aa1be085787ed0bf12be6ef2b20cb5c943b1a790eb36f55aff3e85fe6639493950fbaf0465b9ce207d7b4f8f545f83490c7dcda32b3053cfc58005ebea8344c9b039019c1397d9ea8d5b55d9ebee358d59d4a4d01efcdbb09621ab3ae58fc3e8c426d63abef94fca5b06fbfbb1b6c66fcbae8e19291aeac6af16498c65eff38da42da2648ea06a825739bd3efbe42ea22cc4e1f440ee86eeb12ea23142e982eddaa72c766aab54b5034f061be5d0f3d615261faeb260ca922bdcde472e118bf0f5d59fc8cfae55247df4e4611f6c4a1892980ae9e429167f33d88ca978f0370d85d5fbb4272a52008de259b1890a392ad43b6ab56c0f92ef1832957c142f8384878b23413d2f9bb3497420c15959cce48bb08435dae9153c5364123b832ef0ac47ed3ec605e7c88a38d4723b479610daffce5fa32b0af65c88ee352aa94d82a873efa58baefc0e022bc121188039ead570d7a975b88d0ec917b9594daf166dc2c16c7a838103c087781b5f4b7afb0f477780509694a5c767fdb39a00d933429e1ef8431d98cdb0f734cbd2e129ea269909f088afbb706873a961e58555c9aaaaf29a7180c638bc0ce929224666b96984cb0baff3e46e5873fe8f2335765f74a955ca95d77d85642e4afdece5f3c08370febff9c3c48a553b39a86f2eb99855884ac9ed77e13e9bb710dd53af2c70c2a020ff0c930d9c550f217c6acf54897bc5d59615adb3f03fd1b50d8539d0976851645344d44d686cf46c59aea7b4655fd7aca38b1cffbe96c453bd879e417cfda4ef329aa96182ea2047219eed59550359ce93fbc1fc4d502418d5bba7a6b4c3a5dc6fa4de508237b427fd12fb666b67405b0ffc774e97725322d27d2d4949410eec5b46dcb4ffa2ebaa6879cbf3bb4f9ad1cb342885e103c42676725644b7b945a5c83fcbfd16c2fccba2dfd8274beac55bc8a88a2ab695600f6d503070f49ae030a8fb8c6bb9983c6576d5107acb6f62bbaede4d7403245c9ba995cb08aa784fce27a8a3ed736d90b7d906f8959545ed21c330306b4e94bab8390263be62720f2fa81618283eb2ec980ff7316a8dddf06e401310036689ece503a231b14cf81afb0818ea52183b5cdbfe2ee319ee0d8956f93881e4f0f829e615395877e4f3bb86c9d9e72c38c751af0cb53dfdc967c53ff45ebc042f4e3defdd3f1bc2c77f2399a572905ddcfe78a90d0f756e6b2bacf4bcf32349f436976e292896d719f58ab8404cd214666733a07ef07e6dc86d3230d21ee3857997af8522478100facd798ab85f7f0866b332dd8ff33f9125a708c962e169172d24ba3384b9afd8880ad6ed469b49072e08d90324ada8a0dbee4d13d759d96e528709218f07bbb14d074cd910fe153e7adadd6aba5cfdd7a0c1a3a376344d06f1e48eabcccc861acdd32e2d838fa43a4a0a26aac5fdd922d170659a7d17df22bff470721fe534a73171f3e7110a40e0ae6817f494531570f420f205527c299e4aa09ef33c3dcf545f42b48c93efcbb287fd7a57702b310be51878f39ef830a0d6f01207d4ad47a25e4b45107eaa88e8aa5021c01b937f4fdaa0cf9687cb93081480866306bd92688c9a6187b7ac606e172c786bd089dc196199bac3779feeac8d243475a9df85ce1553acc5e6584b198ee902d7b9286e7c49542fe8e47751e10c3c77b4ca1953e0ae9846dfd6289a1dd6cc9003bc42e7c0f9991576e0bebe29b89fc4c65bf688a33d524715ad802e5238eb57316ed99a26d270f26f100dcae6cb8d7187ad54e24880b4b7a8fcbb0a535122d65e372cb79e190102844e6375cac149324f3c33249713a22ff81f9fa3a713678fdc2ee761c49ea59dec0c9bb107d997ed0f4d1d87a29b2e6955842134c48dfb70a27fe7bda7afc26b59f2dfa42235b8e74e1a6f66403eaabe22a79247f494e3bd7ddd8dcb4c12b4e13ea0fb83258458497b53be045343a679569a5fb910a649688c25c194c28687d87f76315ee3813ded0562933f2f87b079c7247618b4d89b4f62b52b795e2c9e5e2c6872da70a9d76ea4ad0c2929aacba600b0161049f11488bfe0ca52a5ce619ec967e04637a6c2928f069bbd2a7a4c25ef7e946b368f9934d7a19255e79f45d16ef6fca152e102b00e814c9586b14fe505a48a89808529e90c83a6fcfbd3448a476af3a08156feb93c5f9268f379085b573962e52270dfa1116e505005d0f03f3513519565f4e7045979db1361d4d88b98196d2f8b84cf60e0d3539bf02402415871ddc33b8f9e0dd1c8d89f710ce3c0737aaffcc83eaab8c93e891c56edd8ee38d378810c2e6bc228afd4f8fd928ee37b2d5b4564bcdce89ae0bc9a5ad01645ae84bff6b1d94c9b987fda8167b72b0a52e40f536db974d9e9b5bc879b470b7ca86df02b9f4820a291512e0ccb2af1577bb9fb91385ff14bf83aff402d40ff4c785e790cba811166a432a5297c0931c491abf43f88c6b844449b88c44ea0599538386c7fe7b4bf89fcb5ea9ff20cfd56e22e05afde8aab1f0a5604b151bff1a8a97ba5417198a97408553c4db7ed133be4b47adf4a7f213c020da3f548bbd3c6c51a6bbfe3d4edc030f4c1d6fcec180c21cc5f55942dc3949ae66ea8f6597872c8d931f066344a3ea403b6a96980e45a1ed48c3079179a955189dbb7103c7e43e708ae2ee04f54b9710440bac2bf0cfa1964a95f3455d1c3b04c2fec9f9e702e9125261988c3f1a8596aeafb8210c52e7b16775135cf93e7866346bf615ad780aa663be67914e3d58b1ed9d16efb7b20a941148e8292cc7202e8a5e29ec92e19cffd79d41e90ae8e3ec82bb6765194d99007a5475361a37ead80f69d0ee165dcbcf90e01571544e4fb80b48ce3f1739af93abe0bd0213a086c1d19f35d22f27c210c03d8265b12eb15de434fd7b989aa850e92a5d68c9791064f5d241488dfa263f068d9762f5f7c02b72d045c3f898f0f827f1b1be0c2fbf2cba2488833409bdbc4588c6b7906269bda11f876342ed31be7e24adc23c57de3b1449a5acdf4ec3a0641319a5053c3a361297b4e4e77f31a5c334fccdd22841f5601cbd83ab3e70e8c1906a31a52f0f18e6993a479c3cc9db77891f02155e6afaa7465be8305885595f2efa5c000dd5844131157836d46ad1d63eca32dfa59a7ed5662c104e8ffc2ecb5f25eb97a075a4cdb39924fa4aee71abfe72ce0cd527a5333311355601c4e396e5bdaf74dfd088fb650aed32891c3c45022a78f938c25e1744458c4ed95c2b237bc2054ad3945f9d39d5bfb0d08e9eab7dbe9baf03cb63ac0cbe0a6a7d775780fce7bde4482be44789171ba3ab470382caae235a0762308182fb47bf80a9eff7378705335fbd4373b4fc4413ea223b47dd29bbf50c870a015b931372cff4cfa133e3b3610167a133ed61a49b80bfa457968dd0ba35efb42b2c3af03f93e5e5a3e2da5997e28dee058789c020eee06145dd0a41dfaf65b421eafdf1c8f644fb8ebf74b53e2c5f71a5f61684e7f63698b146849487ad8a988485f9addb512cb5b89fb0711e6d28197828929de103e842635e68f9ded5321bc9f608e1582618a9a3d32e326db6e7134af62fccaa6cf16e37b97b398841d26e78f25e5717f210dcd5eb3ca028235b6cce73efc14bcd3e141bfad3129d858c098ad18f4ee1835d97f6a5db74597fdf0a8d8ca2f72f08d1e97211df142b95c00c18991ee621aa4f5d4b6c7fc1ca5fa7b653821d0f59209f4d5d9896a184fea228b4fe3b9678c8a2b5dd16b084a74849b6e87084c777c58aa4a5dab1453663801008bf74be60ce8119bed7268d6d1e4b22495acae8a6683ee24d795270d5254bcb4d10b89c8db570d80584f795588fd618b950b6b4d00f7d1cb7b7672b95ec41d961e649055cf2bbce2560837c5acb588a541067dc76d759254e29244d2103f7cd04c38b1bc0183f09252f95cd00a84913ee0562d3438f397f1cdc76d85e0997ea4d928dcd01bb1c22ae9308484fc496cf8631974c7e5f95c15dc788469c5ac1384c6e50c62ab11a03d62f189c0bf42a3c915ac109ce45e6b5f2ba701d740b05379c0dca2c3d3a23bc09b39fa6a412bbc4563282531e38b62d5fefd7d66f95b2d863ea351b969bb40a2f349ec188360abca1ce2c9d2fc44ecd26f76dae94cd3b6aa037309b2e85702f0261be91d7306f2576b8a37c4088cf8341bf3e414c2fc9bea9fd4ea3c91f5a377a271d7afd420a84bf7abda922f5d750dcac526d808da2c3261be3ab3c22a9e25912fbc6761b2541f56dcc4c1358a2bbc4b20be3f7303b6bd61c05f2c66e15dc16612f7e21448d9b6c0b41f710a82431a78d64563a915870767005869f9b52747ef446c32777192c00070d1cf71a54a5894ff96cf8b3e7cef239ec779d43ada7b3b8fce348bcfadc0ab6dd82beb45ec12796517ce69cf85d339a7e42525029768aa5ebfd9984e34cc67bcb1cc8f9337f1769f14dfe57d31db91322cc4ac4770ca2ce02594ed1353698e8af3e8652eb54e54f8eaf9d93620ad082a98ffb45f83bef75fda1ab65a6f5c36a385deb99d83760326d398c93b80e2dd212cbf14fc870122f4810dc8ffc21419e4e1d91dcbd9d7cdbdbabaf373a122fd442e34b2e5a8a0b424485874b6f5f6e5df84b9861f84799be6dc3f5d1c3af75151c15761fc8da7327accafc9791a76de289f1ccbe486eb61bf95a3ab5a120fe446e47069dd0ed13fb834d71b1b56c3ac0095bbd35a7e5ff4f3a0086129a9c371bc65c4c2baaa498f54236f6f087472b8aa620c1d910f7999535864ddb14d466912798dbcc1f3954fe9200f80f667bfb335de86c6c0d329fc67003ed31c72e701c66bea0231d8e6e1f17d1b93c8faaff99cc6b05775e18055e8307f43d96bd517596a94128d2b254efe9dc79ff85dd00377a831975c0af6b3de4e09f29f69d33aa0818e9a67e77dd23b75d27041896567887563e82b4936fbedd348ab7b58747b9c5a8c068f879c71853208499de076d6015df775c9e3fb49a81f7c5ea594acabac64ceda2ad96d843dd9ed9fc3a4c54c011503bfb5f5018f0c11f3dbcedfb27b47fc5a0d0d8c532df83dbb37d384fde9033cf07bd68ba9f037e0a01b4951f6eba7bb8afbf468470e764d7d5fc8cc0ee5a1b573fda60ad81fca15489cea5746d1a09e974cff94110c1d92bb5d6923892ecb94087af5d0292c53e02b710000a4fbd97837b3d288cc07c6e4f57bf2bc96e7e196a886c3ab82bb97bb1945db91851c4256f1232f3a1b88623cf3ffb4f7517678500e4ca5d01587fffc9c86c5bfec2680d94d71ef136e890f7cadb853161f0f401b45ae00731ac6af9dcdc37b19906f18e50088c782d9ce77f6e963fe083213e699629d431949736ee5eb380b03adf71b9f05a05c8a9654060c006a1e49c528a61c9bcc2999842b5eed5a64f03817540652f5cecf61e7b36ef33fb536d1ae7b3fd5bc9ed6338acb08760ac11480c81e86be05e155488f10801bbe0e232a67020abe883939f0be5c277a59e14d7234d7391812aaf2c88bf5907c77f609e4f76800377149fdecf68b12a4bf1a31fe4be952ee5449f5bf6cfed688c9c48649e8172dfec1d290c7297f78403bd13c180750cd642b4e5ec70257e15b68066c607f135714d32c47733d0c7ec61418a0729b2a2fbe61f07a2f2fbcad37efd5eecf428abdfe2c7f8bb59670963f325e4a02c42138718b020c89484ea2b5e5b355ea0085b4e1159f3dd3a512c5e7c89b839855a7798034fcbac7609d84a746815e60e8c6e1b898b3b1120dcb532334a5ff300cf30715cef511bd2b75964c3edb2213c8142a866fdb3d3431829b0a698301a27c634dec9a2b0cfa62fc2b2125e82ee4512e2756d4e958902703dcfa5a4968578d948e4653d78e1ceb48527821e49e4a050f291a6f0346dd5d630fb9d486438c81acefaf3f0ec9a18ba62b671ade5fdb327924cb43689d4cea6c313ea551f16626dd764fff73f911eed81d256b7ebc6fbb0b9859311779bc0c5465d44c862ea3288923ad530b1348179d4a44c31653c5dbfc77ee50992d2b94177c03e817b4eaf1d6a4645279fbd7d51ef5c8f25d196a433ee41ffc0fd71e76c91d43fa077c8c683ae86b66c77a883fc60ace4a255377622e961c95a1f35c224b71b1eb93a8c0faff2bc6ceb81617e4f3648404af24f732f23220f82cec92d144c428caac51ca48e2ef39c9b04ff32e86cb86b2908e6cb0c99210b645a44288e4aea4fb360e50daa3929f83b8f4e5c80403fcce6471b665d5890814df416bd4a75a1a780f33e788abd3ef0c7119751d483ae41d10165f4cd1243347febdb29c80101432c423a5bed5592338ab8380714c3a62801af295fce80596bf9ef1dc53b3cb34035973d5264a0cfedae53eedbbf767bb82ccbd56f38338d1610b8bd2620bcf04701803a6bd5238b497d401080dfa12c6dae3e8a722459f5fddb95ebf028051c09b64683a938085da2b89e687e6a8c5213ab2669af185ecad718684e6aab63ccb6d95020789c7da2ba4382cea55d27ebcaeffb0896d6067e24bc56fcf34d77e8e8e3fddff06bb74fffff7f10846b67de74d7534f5f368f0d6aef8cb82aa4075f9997152cdf922dd0e05585ae6cfbcdce31b1f0608666ea59053a9570aea65240e4ddf75b8b24ae29a345d4014d40f5eb14d6def517191bbd6149d84d99333009494eb96a3a68844ebafa7a0ff107c5d448bd8a817fba0af09a443337a16f23c84eab26e499f5c837b7092b14528effcf90f160af65ead244c2b98d0159a79683b54ad71aaee6d78f646018ff468b74c5335b53266f675b162e6c1cf129b57827b1fae5eacae18a1048b63b6c3aae2b98c34b24772ae7d07c62eea11eeebac83ab9ee4d8abb36bab4ca09a905a72e8f3109725b7655392d13887cfea7c6ad688c21379aab1fee2f1dcd8d3dd9757b6ac11748dcc4705aa2b7c91141796e1df0aa4604bfd4cc4458930c1ceaa87a002407938938cec529c1202d85d9644305c325404bb6d91b6f25f1667440562ab42faa7527806c296bf01752a7ee5d63a0ff7cc50e8e12c4e3e21d8893640c76971d0dd6872e461cd0b9e22a15b4b5d753d799a631a6dfdbf25ad08f44762829ea24fb755d34b7bead56d909f0d731f168eb909a23469d6a6ced2a33bb88e379c8f40d1c9f149715e5023fa137f0c4002e9241c43c073450c471b81cbeb537fcd56588467714958b662393edb298a13c69ae256c5cb70598bd9a3c8047d67fc8f4e8e290af9d82016aed0879ec9d5eeb6cc70c6cc2b86e478d291122ab0a0f7ca2b829c32e8277d665f08524449712deb5f330c1fcc182e97af345478efbbf31d061a195267a989590529e33bf2ab4de0581fdb8e81b2a8a92fe01503dd0f8cc034386b463109a0040402ce1a6cc477721831e0ff21fd553cd10f13aacb171f22f05c608442700bb5bb346ce0df8e8aedaf5a437317b5782455596f0e6f4c62f54e5bc55da2ac444bb50fbc152e2bb26820ea22ece713d267b9fa070a2a230c89f7a9a1d564d958f2f3c0f3f628cf74512d7ab9ff568614514b9b6ba92adc3e2f3297fdf0e8cd0313707c23b627757e88f1620b7e61877c9c86b7be82b941688404874358a96629466d77eeb143299cd8368d0706c43164e64ec3dbe6a8803eb140570ff7a24432a71786da422ebee8b297e78c04916571a1d9c5de7f99c000ccad95de97c6a84530fb79c1cd4528a0b8f317bc2d414b7b8892373571fc9c75606b3d861511ebed80f2af526b40f1ac8d688f762af835689451e694a95754a2e5d0f3d96179052e362696e74aeda8db9b263e0f659b9b6312bff8cf2aa158353cde3f645d03f1abefc707ebba641de451e6a2acbb0c97d955739c7cba8ff685f903560b9b812da22b4e1c2da61e42d2377ba525c83dbd83ef359b7f9fd7fadcc833080e893925dd251c35f6956ce577e0ad098f80bac791e1fc72b451ff1dcd33214246db3d26dce9b27413f055b57adefe4e5ccf3f332eac4c071182979275922d36c9c4a40d3fca499655eca2bacd53f622d4f549fba7b16c4b7baeb5b06f888dd988abf57a0c6793320c54b6afd7071aaee277f3e650b2c7cfabbb115da5cf72dbc099780bb9343aca2d216af3c2905e34119e56dfddbf8565d3ecc3c5749f2de93c9ef9b0331d2642a70ad5df58f39a051b60e86bb7290bd6a8644d60ec421017ee96aee39cc8283117732a2be702e9a4ff653df7b93fabc7b270f0871d7c25935c8dc84ddf354a623a0500529f38a606263f986a92ccc3c7102b84e7ace70de387be62b5e14e713fc19c607d8c9557e152da73c1cdc48bc26ad118a2ab2afeae09bca3d1f3f8b0fc3f5c9b65d0e7d84662539741131415993cc06d0b50fb5c34b3a20f1863ccdc18195795073cd8a45bbf32efa387538848b72a377350cd473c3b7ab5a381c9db1b5ca72dd7a7afa1fb77a35ef25e9f846cb1dec32c4e43d5d791feeabc67e6e549213aa5ca7cae9892700e9823be7551eab76f84e7ea652351b10126d9c90c0ab670d9ed891fddbf64f472a1ea61813f439fcc492fee764b281f141e2f20aa8a4b56cca58898234dc73f1e008c6c63591cbeb7b8e061317f75aa5260b3d61e03b72a3841d5ef5eede338a1426fcc73dbffbfbd021fa14e1fd93ff52372f4b63cd963dd2db0a83160909fc41dff0b9c753df6ee75ed6a7a2d30484c716ecb2ff05609d5db12954657209611266d2c0cc49543354f3bd31404f11f69a8e181ceb1ac15ae34a77dbe13976cb6d053d332afad02d0fe4ef319dd62d29b78cc776a15acca148fc4a92538fb95a311274576da5000ae62f26022ff8d7fef656d41a5ad7ecb820f5a1d8997253d05a937d6c5f17020bb5509d8c00cf97046dcf8cef9e1ab458f8195a2cbad4420a0716cbde22647321a4e1f907d326617fc57aa233a4d6327c4aae020339adcdc10b62c05eb64d889de80d3d451c56ec99b6dd75551bc217790420d3e68faf5e86c2b96780419c062e19874b6176f39a5175e7b8ffc1ebe6e036d89082cd9ca498c0c11d30ede0184c6e394bfc653fdf89eac7bc5d440cde9cb4df43f7681b4a039e7b8efc6ec7bc7307f7b2e897becd5b4eed3a1b7b4982dc95e0bae2916a09dd9f9402e50173d334b597ee2f0c15e3c09d1b7e179de26c16e9bf5975f3c54da11d9ac25f5c83ece4f8395aba7f3c20f87e078fc599d36890c8db31052044a0d8d317832d0aedc73ec50acb7e58cee70eab70e6a764579e7aa9a3f85da8839505d956bc0683bdaff3fbd03d76ecce97b27756f58ffedcc1e1982f34101c359cff9b726f1732d00b114169e475b27fbd8d4312110651e9884099a5935cf73b5a2d98bf9ab796c997e96ca0dafcb033e642e81e1352d151c52e954a8a82416b343289646ddc62710d02e76934fd6f1091217f66bd59d72c3bde1cbb15f8f2ae72e823eb63baf5737698ef6cc9fe7775a21668cecfc3b100d092ee95810a9184c972d6006e4d24d86466756cb24cf45901bd13e139593c1f9625261684805a3fe0e6eea6236222a627a0b3d3250a53dc14023bb86685a18e26bbf83149a81b9293935db2714457e356effe273cc6293f4d9d52e7cbbc38aa99bf1881c6a00fa219d7120320f280e340699f21a514a42fc51e197a516f536fa2a6d453e3750f8aa9b9dcd9a9757b3c5972e2061b045f6316c1275edc59adebaddc3fda63e3b9ff79350b1cf5344820aa2394d7fb8e135cb8abcaa6d5a93e76a37b3fed83e0123b16aa993a67f62650c4fa8f2e63533ada7b0db557db8251f4ee251726cb05aef1eb33bde02e4e82defe63dece3340153679cc40b92c496bb9dac638f8e59cdce2ba99f74e913f70d5c2b0a52f59dc15500416cb92ff3e65fc36308c0ea72bff0a6b8f28fc27d48c9e3ba17a13980acb1eea54937f178e53b7138760c4fe9e6bc415dc24a7596f500278ee780c160c9a50981a346b857f0f4c2f0c473e7cbdb2ff9a2e1b964dd833ff7f533c2e14d4d24aa8182a63876dde53ceaaa1232af84afb64083e61f2a9e2b6956f8576505b3564f9282e8ff575e005e528c3d7ec64010a910eec91296bd177376a89bafede34400ea7111bd21ac852fdd98d43bf81730b2d1500c7110279eedb8ec01b586dec2510886a165199ba321d26e57ad4f9d872a0f0108cdd04adc02daeae7a1af04e06cc6a6ef8047bfa1836edfcd21e2c68004b6fd3ff3831808fa91f680fe287de10f80c3c21c40f218e085fa963ac7df4053d459c1630f48f15abdb9b0ee855c80802e168f814b943a185319e3e1f01736774fd91e32a5250866de25ba3809758d20053b9e244813454c937044de931bb17f0738d82d5b1a43a68be25a93fa08ac504eafa1460508ac9b6baf6cd30f65612cfa47aeaa9d9b4d496b294bb0ffe96ef34cb30b8ce9e1bbf8bca4fa19c6e966287b6e80f9a16f017e0231d0a87ff441e62bc46d6ab7b99c5c33e01bc0b143ff78ceb9b4385ff68cdf5bdf534cb654d622348a070108a18e1531bb003b97543fae19a9d8725023b52a6f79a81d6d2ef644b7acb0eb7aea672f63f007b011ff251f386cb2f9a748243aa45c646fc2f6f43dbd0290081f56e70957a158429d3a106917d45b2399792e680015bcdde62d4a8c590f72ec7b93cf25846869b00d2611b30584fcba92c9d00dc0e930aebf2a85d50b871dcd82b1e31af1d5e8f9b72387582db214ead61da7b5c0d5acddeb5f6a4f0fed131e60af3c70cdae90f935d4f43ca4b7d854684a12de638bb7714367746e4d6589584e283764657cdba7227107ea4a7174f7c306dafa88a5432d3b0648a5dba876e000df25ad413dda59cb223422a0f959d9b70949bfc0ee601e65a09d3a9b6ecef9ab7a03ffaa14b6d77461371a8db6db1160b6ace4b428d7c5fa3b20a433eb78093d221f5c34670c01ddb20d0ec97a8814729aa012295dade701b19e806274979542336407aad37673a3557a95b4848c343d418ab68d9f677af2b465106f5e28edf5c0a4abc8273f931a6ef8a086deabcd019c6d2b62e85eec6b2a5395955c3d387375929f0a49871bed16d0f0a4f2f412ef63d1872b9f718a3d11ae7a76bfa885cf58f62fa0018a6ea3332ad590e3e41d4d2403632e003997812a9853dfa501a3a0567f656b69dd48e90a0aed0e39ca78d19b354284c6eebdd466b58ae8573ae11811bf48ce3a0015571d7a1a5a846162916c929ec2fe441880c3c1f606a326e03b0067b4344ecc53984fa3d3dc6ecbce81c87319ce10231e012c961a398b8b603e3498172d0cf42497a948ba2a735c8014afaa7e85b0fe7c1ea2b44f1fb9ff1c2cf453162169630ff22990e5a975357e137577d115ae74904129c28b8d83a103f501ad15c10c8b22df01c143171e8fe80f713f540e3208a342aa70f5966a1dbbd3df086d537aa19665f41aed819373075ac8ec6fbe1f27dcdf567139893e4ebc78aa8c943cd671a80590ee303e7fae579f54dbe6255ed29744275db3efc04037a31cee2cf38887face4da1089b14d2a670f3d8b4cc3078e598ac5d18c9c457df5d3c68cdbe2ee91cb9522ed44ee8119918d1c7179507f07d59d62d9317c2444dc762cacb786c59f5ee8d6f857bd889840f02d6c696e995974b73bf7902f27601ac1f5502455ce318334cf3aab62caacefa4957ff6389a77e4dd7d6033f65bced839f1b978d180acd8889a5e005f9685eed02d3a5820fdabda18e44b0e97379e88e9510c0335f1b28d08aa6153e356914b8460453bc83860658f57aacf73d397e982f85ddc031c98510929f0b622f54293d86c73c70ff6c9a62e3bd4c7e2cf0cddd9165f0783fbc6a6107fa224a1eeb8878167f05b4a966a826b9614707690801841e0199eb83e3bd9b1bce76174fc2c409bb4f64d79808c71ed893f9914e2452f3a7ed253c745bdf1520fb4c998c2ac2f65bb5eb943039935bd2e7f9b5a9ae2a5340ca8dc8bc0bd79420f7cc408f5455b76ae00031975cf5dec75fd1bcb166bda353496e36e20b4ddff1068331131c01a68c7806bd40ca54b93d9e2183ad2e993084bd06779fdc38f7f8d271cc011c99f6b3dc7ae8053f511b2ed7a7056b1d964497f0ed10bfc06bc982307eccfbcba8e00cd2057f22f01ceac6e262936dfc7dccc06895465c25245a61d6c07eaeb048da7bfd81fd499c8e8491ac1c762699b38d948aab18c49d5e4310fdb6a733472513d66bcde77eb8e5e6611f9ce99bbbd040a011126463e4fbb5fd7ab29075673af0870a96889d161d5eca053db16cfb2012122d69be9ed9cbf5295a09bfd7130fb7785720c792b98316a16eae4290b92ff9716133c1227267f763de49ffbdfc93e26f15f27a755196c58f47001698bcd0bc93f5fb933018e6eae153e2763df25d9f07f6defc243492787742114f6b59b1cced299cf4ce5fb43bdb4e565a2f724e7e9570a3ae579d9dbabbd5dfe712fdc4be4f41b69936b040390f7ed16ebbbf6c0f60e8fd5a3e89086d2d1c3bba4d666964227a3aa25a368576497abffff8c32f94e900c20ebc29f7b54ebf3ebd4a9e78a66c2e10b0cecf28437e413ebdedd1fd9d6cffefc1a1b6aaef62e0cc406c1455d3d21f69ef63d88d41088877a7a14cec784473a39711b380017a90b74c99929493221511adbe6a79064523b830360be0f71983b0aa044148e2ed7c61783656c273081a06641ef30d16c3e4ee5fafbf409a6be446dac6efa65df9e814f858180a881da2d0b5c135911232fac0d2b2ff0237a43a538c5f1d0ae40ea973f2eaf6cb75b048131e170c6a37bf0a4b1a155d70fef064dcab77d9f3f2004ddbf74fc91ec68ee407b247feb68f8d575b2e78f1ea4437e2feaaa4d46883c03822f60e61113c199f28a9678220fb3d97b617701fad7cdb01602750c6eac6e7c52796acdcb1a2a900ba2ada69bb1a9c850d137d12394b68a603afe7142f88eca1d5cd6cec260dd1ab25f9ffad55633c66556ef57abc380153045f3513b1311ab0984650c9a49f7e360663f18ab760bf69ccbef77298e0dd3983d496024a7bb09417e239f83e7310a07794985ea999ee09514c84129b0036205feee6fb0c7dcf26049ad1f0bb78a28d88bf1f57257d8d0526e5d18bb62ea3cb83a826e08293d6190b778ea298d2c4449f90638772e27f6a35ec3c44823ca21781e9d81b5b60e757ae70579d9340b74971ab35bc2483536444b2475d0129080edadb7a5f792e99061bec02ac0153baa2ddcbac7686adf2306913d30014cc8f22e8824f05330c1c51dce2821cfd9a8943cff6a42c866d9b0add3ad257b258145ce91ab63ae4703e892cdd71e5831fb475c568fc4f58c355621806c3bcbff68a7c725ab763fbb711b57adafdd99c3b9f678a1152c22757772521ebd402df8134754facb168a8f4f1e7523bca394fd14ced5c493b96ca9a74efc05bef8be89b1c6722899daf274bdf6a2ae794e162507d7946cf7be021f4c46915a8b76442a8cff7dffbb92653bb8edce11af915502a8b56a9212076c18c5764f80ccdccddd12ac053cebc5a9d992fe2be095659b02ac350b5a676afc6ad6824cddd1c48a63306aa9b578c2ce6f2387c2d1f333780832b73682645bba975287c3447a7d4d028fdb73ace03f27905e5be7edee2307632e64e6aeedc9f3f3a580574bbce6114086367202be8e538514220cddba227aad2632ac2aadbe9af4ee1fbea22b48ab683a6126becc0f72f8a3c55c81a5c1cf1fff8f027d6f8b07ef66fa325ea4cac96b7d97017b90479094bc87d6b7eceb62fe3c40b6a8a2a8d133b9b51cc9b44657e903a3daa31197fa5fb2437076258f596093dd9e40c84b2184fa5d7b90d9e078010c00c907fa6b071a2b2f154c00bf632720da843b58e9f210bbd2ed78b96339b9700afcdb7affc98b38521306b810fb90e78acf6514573d04339ae6febc11e08c320e155b0d7487dd076c5dff190e0cefcf3a5995663c8bbb9432d537f10e86f04f8138c01cd5a9c355852adf8699f0c49e35cef834248e85108a36a4dbb99a4ef0ff1cc16c8dc3f2ca65a1f3a233faaeef8841fb12144c7a8cdb2de8bcc476bb8bc8b11bf9056f023612c4270955994cec63f0886949943df7e204ee9926f5832d4e7145b9a27d64f634914fa30bf7a916370f68a8e73ab0f9e9b4a0f6c6f0aa8b0b793436ac9a59a2815858a4fe889836ef036b6183d4b6d42136cd6c5b08b64821e15f6097fca7544dbfbf6de36e52b7d5c3a2a8b2a55a027a328feab9cc06e46fcfa84ec9b4bd328a6a1afdcea6bf057750fbe2f96df91310196c2aa1fd7a5f52e9fcd21688181d0575823e062792d8478cc8d4e1fc15a225d233061c7e7044c0c242f349ea11c49468ccd1a991da832b4397bce6cd1aaafd7cac91a47128f78528725de23c098cd5bd1e66853de57f1e56aa0df63a1b74ffd7b2d160aa866e4d76036dcc36684a8364a996d5cecf47458b60c0212b49fa177127a0796373ce66368d71aa92f58d7978e2f99d5433ec8e1057d7c39c99c7f0083240d0def3e92c5bc731b7b81b4b84b43e53a8176cdec150e07dda7fa14e7088f45db0d23740f388621947e4c8b7c270d0d513852ddbc21d8676c2fd15f03aca95ed5e94a5e66213e145fe71392349e226e1f839d113fd00b6ec2e00ae1a6a68d0364c12145dabe517599f9e0826840873311aadcf87d1f30fe9bf35580113823b0f2c99c182b4920ec4ba5ba6a3c305862a1539b4926002af47fcfe3dcbb6412c95e6a4ae0921bd3746ff517e959745808de85aabd1b7f8da644177bbca38a7e41768855bbf8997abd6d1057bcbb4ae1c25501f9313fbe829e08c55a51012045d2893939f6f4fe841f3f34ae7f38df03bd36274dd42bf5194bd20a7332771dcf1eeba1a8a087488793475c7273258be2c501b7775276911b02d2cc32bc9e7fee34b3caf0dd20cb4c0dd30aacab641397670b69f9c60e9510e2267021dfc35070da2e49a7c2d93a271f2103d2a46866ec69da0e755d3b01bfad2a51fbdb4d0decbdf99a75bb606ab98b789f0899d2946eb22b207d716d47da0a5320ce6ec46b8bee797473430003892c71ae4944ce9b13509bbc30b0cd2c62e9a20905d49bd6607e653aa842d79f3d3e33c4c3cad94717774f61c7e9774fbb2e1c186a5fad06ba9a403eea70aef5ece7df4134b1c629ae15feae7b283a386d632b9b37d5b49b7eae0b48c728bd16282eab611424a2e3632194fbbdd0c3cb608c55658339d12fb2855d8d5b17617e88ff3f56ba487af59b3d2e799a7c5c2394330000e71ef5a5b555340a1dfca26313752caefb4e6775038b3cceb138e6e2d251641c0e1d61da7d2f463e54ad7c35cda9e5e78676de8101efdb97aaa72f84d8ea2b4d9b53091fcc4b4ccffc4d061eaf4aa23d41db0f971aa598fee4d807b85329e85b669b0fef6ccdc252711b62769436b551a588c11972debfa8ac04ea20a4366f1da6f5e6a723094ecc47a4dc355ab685daaa33226adbcd25e26c232693e2f6009e26ef11f162588cbdd6ba6848ba5b955cb5ed2acc35f5a35f440adc9b210e173fd0c58e8b112ac128077ea649bf8a4d89363c2b7c1b7934828968a277e4549ddf1e58018b37295bd1df5acf705008fe2d5f9355ace5b2fc464dbef932da49666add78948dffca8c44e981e1f40fdc7d4f31d0a4dbb727072c2ab276e29fc89ffd408e6b33f8de14df12eaab14b8bf1629e58d12f594ac7b5fe43bd9b479dfaece394c3c277c1c2f8beadbed3896183a076403c336adb1024f2e418b338776c85ddc93756d4c3d23ec754f7b8510f36438b14206f82136c42a2a15814837318f043ea3c7918e09a554c67ac6fc7c95b95b8ad78085479a882f03ef97b073e2307c2651c79631d2968c611e0d952cd3c3845d333d2d24975dde94b4c0e5c68ec3ebc7d489a3b0eab5ea59907efe46779e468c8ecf8aadb7e92a3b146bf4acffa0034dfa41e70ff89a35d3fe14205a169270228ca4bba1c4b09c572bfe6965a3261ed34b5ec0e46a8062e4a8f0e236afc74175548ad3528a8ec1c09269fa55a94fe00dfc68073a637d2b2463f2261d479ec87d2fac09702730bb66db908a2a4f93e383deb3af5ff95a446884bb36aeddee548b6c41f19665fe2027bd0c351781ffdd5b3c7fe0c15143638b0ad73aecd9dd573bef5d844d5a7ac325a13466a270094949851e215f773927bacd7cf8a9fd625ef276bd19af334c95c5ffd19799bb3210163c08f1da6f8aa7e16731c61c4f241373b33b71d17fce548a5356859f42991881053b776ff9091a3bbfc88e9a3bcdb9e2d613212f3bacca8bdb910c26b33b8626f317bfa255af2f837eaa25bcfbe6dbe4585a6ce3da8ca19b4c3e17973adfe777691505a9f233f30de90bcc6a40d33304979bc3dd928ae3b7d6f25d4e970a273001fde33565b5182b143ef57c59e40026bed083413570e15b9898a1947126536ffb63897ffb9d5fd320bf422b639effe079f6cb861b87e52fb2d1ca01ee5120f3703b6a86a0dc11f92ad8896bc224d7e0e28249a587b24894fc8392f52dce3552a69d839aa810422dc83ed1d94eda39c52f75504b55af0867e11303081332e54a2295e5ce614066dccb7c6cf40a8d975145e31437d885026f759551d15fb1156d464971e5787a58d85696503c90af28f3c03c66de62ee84dd700c8d669997dafc41d17bd3dd28965ed83f8d258441d1845fd608628bdf9036948bc723399e6ba516783cf0adbbb21fcfcc19951bd5a7f44bd53a2a09308da01eaeb067b12c620c9df34588f0e28ff9016020e3320bc4ea6926f1df4b1b47cf4d9ee05e1189ac151c51a35b7122290e69f91fd60a84ef1ea76a4cbd71da2896182d26af5e54a8065018f3cb7b5bb87b4da3bc4bab92689de792d5e0f1ef899810883dd711f16479546c9b3c13b1050b5e1d0bc9c277502f45a26c5458c9510aa58eeb6116d24f055d7dfab55894c8ff5cb24b1427c729708599a3b6ffa85d1baee94799ebdf72dc92bbbbc4ce65654301b47a691eed80e6ff8336c4f56053c2b91153fc0554802a7465f1934a154a4722835d11103ca06111e4c17ea5cd82b6d3d4162d569261d03de1867e3d2da2e7ffaa921469dd1a43a47810e77413cb7e33a6a56ecc7c62678be23d0cb9ca9d61c75978151a555a167ffa55f5de784ae11b5f9123a262532ad13e8d068e491a2f31ccf4a48ed0610e2051f0b853a058a9a1c0d2abbd25850039c832a48ebb494c84dfac19bd696ac101f3e9bdf254723bd91385b4f5d5d37d88c83cef40fbbd4bbe606ee42f1d135a7ba63095793fd4241f8b5252f6352c04afe0c5ad6cb08e37898ada5865fc9af51c694e46e4c82a52a2cbba6d9e5d4001ccb3aea52685502b1bb5e0c2700399147b202f0b1c0e5cd70beb010fd7b32273e6a065ddf48bf8ed8827bce87016e479a73aa39f8c2b9ca39c34167dbb4d01785e319457d9aaa52cbb8a4e0e34b30d682e47609f723803eec106078525445285ce189f70f00981790e0ae238be6f8c0f23d52d018abc81255bbd9c51bb9a461f2c7af6d6d6fa135d0772a28c15fd8c64dd699ac3cf4dc5d204b16cc03192a5ce8e5d5fcee844167a62d7b2373179db371336f832f710c0640195ff2c74bb900a718f84116da63ed0b2f62992b1f1757769efca00fd3513f65a678a865abed4b4332714d73cf537b4c55bb96a0af0f9936a5b1a568d91a405e91985833b8c7416d5c2753c28919e9db5b5655497b62921e87f43e177705bd7b8af528d41ab4624a6af075a9c65ef1bdcd13e5be2cad56604bfbbe2961ebf85acd2b707b3ed6f68319ba4de85609625823b5010e6c8d6bea1b1dbf59223d325ee53da3696b259423e1e733df8675b92ef13e5d1ca56432204eec646fedcdbe84f3f5686b94a4aaf980da13acde718acdf56d62ad6347f51011d4691c30702d44ebdbf936d42888d9ebdc46394a108f3e32395f11544bb80baf1e4a70de57de015df20d81f6f7b7cc2001155f31c7a9937e979baa9667226c02a1ee96a933c7a49f0bd41c57037f79444329fc1175cede37ff82a6b4a90e35e8d77260a9f68aaa230fecc2da72ed222c7b4096a9cd5e1801639d9d2c2329962b904c5832640f9f15d1f1637df7c0b241682418ed1dc8812306a2573762b140b272b94d9572ac027faec80acd1c907ce6a82181669d49ef3653433b65940599d96c411313a0972688c3f1c1727af3d1565a540ca2c541f827db77a45270b09b503d74d9d2580ec3704605f3549a8f7feeedab1d47fb21020078cd0f8ec7335549595b041fb68dfa293ee7e221c3d80be583916980a684c0a3362f3df50db5fcdab107c32c42c55652aa9c915eed12cbf7eb8be20374c7845ece63cc85857d99c0f534de0be29ef516e45992f2015f921809050a9c5dc1b04b1b4ececa9750ea6061955c841c8e7702cee71ba56ef2aa4fbf5dafc3b5b0bcf1ea2f8d3284edbf6d6334fec3ad56798f7dd4ba12d0fad961617d01f706e2aae6bb3fa11e1528933729bf90d763dbf56fa98c7a0b5f568a00308fb264bb425314a346b1c5066039736d266dc0c399cf806d4eec54fa61f38e1a503d77ce55c5f331abfad8b9426dbcf050479901f4ddc67cb93b354adc77684af09ba9403dc1bb39ad63f34f923eff154969bb0e09235692c2181299fcad7da17639b6ef54db5133fc438830a731e3d83c47f42f529e3439e8f8e993f4540617ecda2be0f231582370ca3dc9f9e07842c3f5352df8c2a6c97b0383a8fc3c833bc7ac503fdfb8122e0862b0102494b368d9787990c2e15f2a774b5b6e99a1334e0d4be51334f2a75cfaa4e42d8f739cfe08dc6eb6de331c893f9cca4a746c021e3327c0bc31d269ff3d7331602fc519056f1c593352d676f2ba9633719dca2ab2adbf44a5fd2b671f2c7fbbb158bcaf8bc8724dbea2d6e34e1b938c3e750b54669b5878f80ecf2f017dc087515d5a05fa6e821b4ffc075aeacbc8d2b593b44747de290198bb39b925fb704cf289b9fe938e2ecfa10bbd5b33ace109d83a396320d6aafdf6b0782e72afe21d1237233dccc4ff59f8461a2e144bbfddf8a152711bf871ccb8c5d2d518795af3d47363a04ccdd73d0615756f37bc4bfbc49b33c24f109fc488e40d6e144530e631af4906441836b2ebce499cc5b0e2802ab47596e949b1cdca9ad2041f5f7eb339c9ba70313336f700701b83048b5033c36abfe64c481a7aa77112ff80106f7fc5a1312e0d867609ecb1cd4250e7c38288da43794b2d3084a1764be7a57cb8ed21376437c1a558c96232668ec41abe1d219dd304afcb63757d4cf253a6e40999e719cc4f80dd997bc22cf33927b284631d0ab53dc9f7c3461ded5f86f48cd3977115eb74f6d173691bb0803740d264ff535a9a0903e77c28d8ff0a241bbcaa4513a53132687cef7195bd0de92b5cf59bfec55e02fab3c348e5454df1cc9f39f795735e17a650ce49adec13331c358a79a6c071c9671e99ae2bb4f6910c3deb3ef2016846baa05caaf423a629a2717f3df280e3de090331d5454ffee323a6bbcd530c34b5657539b0ccf862a0e61b5a273f62dba61a0379ba2fac64cefb183766527eceff3bf13bc4ba34cdc160af8e8db15cd67be13673c8dfc1598fcdb994bdfa641e1078c761ed988a12e5df8c066dc53be82a864f1eaf19fa2b0d0e8c4ef3123fd6a1470910bfae819d4770b14e7008a81c8d1a1414ac1f5a68d0cc71fa64057347ca8d83b1fecddeaa5ec6331eb526aad065750f6364102248b50a2754cfa21a95052b284cd419ef379252b463b49dbe04e12669cb6bec8dce82bd12dbebb031864c93dc73fc938c7eaf1533ea3dc8a6bd014e501aa543ff0087c8d105355ce2d45b1f606a50bef836da201b5643acec5ce52ad5013fddfce95201a3ccb5bfc94e26ec7a56c25e1fdfad43e63f64b0df0c25f7743bfdd53728d2e18fbcde967c0d98af731086244f0a02db0ae6fe8e2d4fd5f674ac785d8f9d727ff579061f7cd204bd3175d3ac4ea53b707dfd5d6c028c54e13afb6ce0441ff4927429281ede2728845fd13a220f6d270450bd2f98b901554211fdfd78383f4533cf08bc271ec5d026836d89ed9921b27379a406f6b58ea316090b5170df7757ab2259e42b25c56ad29cc0a22eba78ff8207c11eda96e77234a57cef70d62264356f60ff3bbd82a1218231b023ec2ad5560eff5c6a48ea3ffa8971b08a161962d8cb08c6e5b5209ce6cc70a3ce69ac1b3eb379c1204aeb3fc4da3e12670233b13028e48bda4e0afa572b97a3548b4114cd4327f11b45c0aeb4b8c623ee331fa5b6b9cf668d38ff6c11a7223b65c10090d24634c1db2270bf2c83610508fea746836dea24cbb6d12af38f7521ccd87d4ca37820069ef874ca337afa0c5ce1a66f239b8be8108ccd1a7f693a2e8b0d2d0a826ee3102d4f8a54644e08877048226f453f3c5674b0bf222d11c33a94880c625b5c257f1c9df2a877497832c3e43b86ccb688f41900f68afd72123a8487117f3fac838c9ba650b8fb0d299b774250b815338ee91997d01ea9202271f4ce3f1ca418365d8378960623b0ad9f398f3977cf20d627d14bb08a0908ae82ef758a767aa4cf7988a548c9bdbbeee14fe53491d8296a14982f92607733d8d4ce39bd23d89262002f800917711ec771d3eacdcba2805a96e1665e55f81c1141df090ca7c400b6626d1e7f834642d23fa8c58d67a9bb601f5fb59705973b7b68779261d60cf613fe8f83b101e12d189bef6d77ce749a6573bc0303a6b4d999d23732c3adc2b5c148a044b90f59139f1f691d36ecda8b0c45ab6ebc41373a3ce65b5bdd749bfd8c6de4c28ea7f81087c06ced935ec22f872bf0f58b7fda98ed4c85cb6b8f465170ad6c51954b3d2f5ecd4ce6f9bd06749aadcf3059bc5a2aa720abcc3a91ee6b0607d2d452a91ba2ac916a2957184d6cd814c837a3b2a2ac5cd584d66e8a9eb9dda1ac07022244e22d2c69f11114a3bfed0b0888c4c08e1f39f912194e7a43b4501a0501b5d994b8b0321e452e8561aa52ae761abd43b45844e8f1639b1aceb34275190cdf18cff32841bb7cf61878ea0343e5ba78f3f63f2fe618dd64a2929f308e249ff348987bbf340d0513c2e4355a57b5dab1f7f7ba66f7aaf461e63f6a872ecac562de02faebb12a27f2bdb4f7de29f5729529adbe008c05a71ec7cf99b0ddda954423eee484c9c13a1bfd6a774073eeaeadb2557b176b60b7c10a8c9ae479b04038be2dd48bfe44f81bc6eeecf204f4825e10f0b54fe9752454eb07d05f81ff95f622578193a6af8a0bbe53b8469cead43a665b5b717d3290ea7efc9db8473461be2ae5edab496888738a64ff140241191b7907bd51f9b16184730a2fcd83e0077b67e37d7828b1213c32463641bb766daaec0bd0754690597e898ac0fdfdbe3813e558e23e67e00aae02a5749cae5008a694ead0cd48d45dcbdb54c6ff89c57519e3dbc45069726c995fd934cbcd10f52d3fc371ca48133844f067e1348786e73eb629dd5344b44999bf87fb0d4946ecd062eca7f03c46c004326a41946cd90a5fe04bd9989bdcb7aed61ef2c252e56140a273b3275e2bf360e2f2e0cda7badb247e520c582b2ef8854a8b5758a45d38b177435be5a0c32e326cabe52b49a5d3b42a88aa4d2ab04417aaa83a00bba2f905d48d5e3114ebd45f7820b5a049e52ea7ede1f300ac88bb9a61f314d7f42a082739ad9f070782cb58f92bb22391f79eef3a7f3fe4bf7e2c20a45f83d0222da2efec5c70188f2fcefe1a26c8860c53e983462dd528e239135ee53046f02ae730ed3fc2c478a1dfb54e89b29f7321326f19390da8a8dd0658b6eb4842e662b49801bb87bfc473f6ef9bc747bb3bb41a900580015c7cd81386973d71e86a7568f98d590a8c598c5b2af8de3efd8c7593972d208e2a933ae4d76ac4e0aa4879b479c534468b13671dbfdad5826fcbd3518c0155b5934c29c4542f96e2ecaca6c19ebdf82665600dd9b3f34033ab053b7e9878a272dcebf8b9ac597c09cc5edf926eb9a6e3774747349e43a7da28cd211d2315927d9567855b124d4f8107f46f1589ed44dec0675527f244bb2fe1414f8565ff847d87a144eca0727309e81e0e6703d01cd22ace29e484f7704678a1b6c7110fab61804d9c5d5a4dfc8511e334adec957b8c7f1e7bf6a2f4cd3b66858233558c6d5a7e1646d80165d2d7ec5db138a85f4e7bcc47471760151b37f42d19d277645dd868eb633c2221b0f3da85ee09286557a4423f92d7ad1c39fd531466312cef76f78e19068e61ea40ee59251781e5f2bb609ddd5351db23b1cad8b790808a1bce8641b361f745f190ec89011694f4abd8230aa8aef2665a19ac06ccc8ea49d8bde19b6473699f20058574ae936e2393da98b99d2e3a7c13f24a8068c83fef99c2d20f8a90dacdf7a3950f2ef54d36d0275dbf29483f507feab4c49921784f96b007c4b982ea91995e65c0a68863bdddb3a69cc8bd5981925473b85cc987793a72ae5ed62c86536ee75cb37c7e8dbebce897825616931ae814fc738b5fc1fd409343763d063eb3fba8cc7fbf2a80cf53e8daba69c1c5458fe67793f67a724a8a8623eb8218ba99390ded6186d7f61c01d73e85688162070f11a192f28f589f5f31a03b2f1a168ecc03ad024ea58f46c0e64e5675acb647f556a439432af025f835227f2b14950bb51350e658011c8be270d9f78cbffa718e1eb03c947b5e1d32a0f07292946f0eddaf31899bae73ae6f6214fc26013dbb25191427f26cd09d42962eeef462b0d59c2ae40678c93808381acf8770fb0ae130a33484e4df228777a239905f34148222ae85865d5d6bac2af9349a870ac41f9db1b3c9733406295fb388d76d8536b000f4fd5326effbd992b6264245d10fbe5ec7743164c9661c7ede5a5df1892ef94e112b3e6c14854fdfd06135e03922ffd620cfe1b22ce6bc4653d1eb493a60be00cb1b3b79dd2e5d2972f479fd92f527af11e8259f5b9db76ee3727cb00b94b7269b02c5086be4bb0adedb94bfb5d68c5ae2ca8d3b852c89ccff22cd001ee2e496aa96698d8fb6f997f0deb111aeb3ac041ede69fd217efd62c0eebf40cc695103ca7c9db98d6d39e1c35675e3a474e8013c4ca08a01fb4e1d134dc673a6a4e39528821a874d3f9fb0606cb29b33959345dc40d488d60260ef5befdd04054775a5bbe5a35ede45ff4568ec3a6171e3ee433a1ef091063ece71c3c0b4e03533484c1556822ac16c82780b112c958ba5b91ac1e8b59befc479d42c7ceeb65b5755d2c91453756bd739f3f9dbbb410561a41e71666ceac59b3c8de6c63b966f21e9144ade939b8e7a1d76cd595cd6aa67c9257950ac1cb57c64c0748eaf6efa0e0f9ec2f5f0318787613c568ec8541954f32cd7ec0875d134a6646794469aabce1725354e25dbe2f7900641eaff4b81ab5912d8bafb1a5ac3a157bd96e66740409d2b200cb04d9b3488d319385c298503e1cdf547f6d2ab36e623ca75b08cf5ea8296894221b93347651ff8a5568d799a556421c993506db98eef238631976190a0a14e51158c164b040b0c6a6b4ab0daead69232b0e531377e7e06325404a1bf63fecd7dacd94f39336ee44c5ef4b4986a20962910018cf3d88810e7dddc8fbf9c124024c65d1b031f096a2f53a394ec0e97354cb6da6e5a9c78301c1145134934111f62eb15bcef8e62bd86ce15cf014bd9e44049038eb5ce72f7ad1e1f5632754ae2766ca2940109186ac71f2418532c90496f873214a82b2dd5766f8a3e14ca4c6549dea8c9d388189f4e155575eabe90ebd47c83a027fa8c592c475a2aa7d22a3a78025a258f6ca2496738000fe9ee32b6ea62bb1a95180d912a37a4e4b2528007a90bca7e476c339efeb9d91a95ad06aa5de64e35558ed3228b8b6b60cdd0e46921ea967d1ca9b1f8af2656e8751f68094b838f02a803d1bac89d11029c034cd9a6af6154c3a1be0d6a0ef073894d3f5c1bc484a34b950e20af768b47a5d79953fc610fcb0fdd6326f20a67383e1efe8f5f90e0f1787f9f277cc4f8be99ae656f9fc25c22bc44567ef30e004e6f87f597fa1932200588f47738a68a51b338950802518a1cd76afbd7bde33c034121e1dea3290a2a4817fa4e17c3fbc5af8460eff7801ba72d01f13958c2dd0be8067d7d69e08e2e07d1a0469328d5348eac33a136bd1019a9bd08e247344d46d6453a91c149f2fbd4d82ee6691398cc7427c20abf601f42b09f6fcbf7ec360429a83d27ac8780e92bd9740071595a76955cc78a59b44b063aed4bf210a489fe7daf964870ce29565f795e0eb9e0276f8e6251505278ae968d04f6105aa2235e38daa365fdf0222918083d2d7804d4b65b959d7cd2943565715b612ebf36e6fd2f7dfa986f0922ae27eada8963778a42dde0c9e5d273ec235d9b9f1cf13f43efecf6b6df2854c64912e3b62ef091c2b924a154c90da601a8e7e7fd2bedc14aa6eabe6405eefa669bd9a308e7564448e5601324bb3f7adcb69d1807ca6111ad46ade70730a9d4e0b5a0c4ec981e2ae7f5897c1b4a61eaa02071447d0385790baecb50c76b68a8a1d3dc4b565e33bfcbedaf6b33e2d695e7133c29dd43566bdfd6c8c763cc9f4a393498490616dd609c13916159b54724e6b79236d2f60d662dc933f38dfca705d0c9a2bbf7a7652f64473ef4c1835d299f7eaf2494d75a5e084b09d3fa31fe765a7f78665b9674c9dab8a17b1d016ec33faa4c49fb47e3d7cccce8bb8e46b5eed52d813c9d23106c691fa6c400396592e40241e1695f7b4d1ebdd6530b97c466fde768a1f02beed19e55e2db720c19953bf1c6c9936f982cb09cc43690a04cfbbc2212114731cf7cea54bda132f4cc9d5daf2315063dfd93474896bd050e319628024dede47c5d3ec8c9aac3a27e7db188b070c8eb800dc65fefa28f32b06efe67372147c00713b2cbf03b63e1290661f4afddb9e7dc9dfa5c565f2406ee7c99e8d0cc55b9ea7509bb6627caee026ea70bc91c00d82986ea66f9dbfb6dd8648c224b9956968b016606f0cca8fbd6a6a737ee51f92713092f648af340865159fcda00fc32ae92d58ac1b22fa09e6e1d8672dc18e79bc82b96ac718c1f1578f0fcd1582279f472787e6ed2d97c22cc8e1f4f5fcc18ce6ba2563dfe133052d4dc0fcf8370f1acc94459a7f1f83e82407d56dcae36097bf673748ebfccda1b28a83dd048bc36856493f465939367fdabf15c9e1c42dd2ff9368ac462739a0861faa26ace5dbb1f9c97d0ba4d8f0f661e131925c46339957311a2d41e93318c4e278c5e61cd02eb576010367e045a3222058ce8aa67867c452379629af9b11e3d48b3c132488947c7897a2ac4ab40a12eed7005adacec5682b8ef5fc22924230447f63a8ce144c5bffa30043385f877d1e180e7ffc38ce5b4a7544d31a2a45c01d3b844d8f4f05953f2b094b2a00061f0f225bb12d00a9f9afb049625a6f91feb88f3a355d526fe261e79ca9cf63db882cfb199bbabe8b5a747f365209f47606813c50c2fd46f5071c92f58febfd1499d0b8541ce73bf62f1d94583a2f45e7a0bb8c75dc5a5e0f512ed8a35fcc30f221629ec8a198ecdb4de3b733049d0d51d4bffafa259e592bda2011bdd6b7d295125a9ee4b77411702d6594bd0dfcaa995bdfbebafd9324c235168e7aecae87917af2d4d7a9901c66417a345a2ac18f8705ab71106016ac96eefd09fc9ec1b1d7a3bc8889c56e9d0dd8e6ffaea5a65d57e1b44e94efbd912d42fe70dffdafd22fbdd648326558361cf17c827d562df5e8f18234e63a020c64087a05fd154a4e152368c6e98eb58fae676de7802f196fffa0db51c724e40870af87fe2e7f6b581e02c7daf0e4a4498ceac6aa720c9353da137dbf405fb280f9cb61c97d2fc508a91f19460059687a34352e768b44c9bcdd1734d195df44e8cfb7d344e31d586d3201594c8c80fce9b463b83a2adc532f091f9610c384ae2dba369faaaf6b679ac0a5dfd3f40f8efaf677ab85abd5430cdff3642a85644331382cb981ef71a5e3adc97a8335cad030e8837046fb766cb23b451c3ff85390424f826eeb87da1785a6f757aa800d0e1c524a3dd2689b39c2e1c53b0f767401b63b08df8397629f97de481d3c0e7002f5979b549fc776c2d8f0f4369777a7c9d214c56856c20823886bad247c308fbd29338767ff83fa85cf15010243bfde9c5e322da64d822ad0a0f97f8e658bb8bebc78deaaf3bc61376f96972d4407f5975e89a9a1b41643f9d56ed8207ebc3fad788ac469d881bb4e9fe79a5fc250887f23c11f61b4ee21241e250785ad6316aee368235fa8f400279f310276869588e5c8ac9f54d35d1596e4b27b773311b870dd137ae7f564fd6b25920973fbb81686945007d592756fe1c629fe045dca50454f6640ea26972c41d0b1153f74a91cd55fa4f69af3f6799ca9a97e789453da6c4c7a1982c0e165cc24532149585d50ea6001843b9233eebf9293c5049835a1eaa63e00c8ea5e5e472572780c27b377b67abe1dd8aeb95398c5679f3a4ef3450f8233b7b017688033d46cfcfe8d04c308cbab7a9a163160ed0f4f974ff8d427d84f67af7d1d6f68f045424209ff3d8c33a7f85bf12c3ee90a6ee9063c67191f2e4d0d840adbc6686ecdcef8d978465150d7aeb4181c327f43781ad07201c05ed2c0d437dac9808a01dad1f6fbcb1a8c3c76ea5845e5bc85e9e4ee91b44f0ed24548c2c4941d1188158b44e4738a51463d826b9160f34711f6d3ad7dffb030578078225b6f9ac3e7a39cd5857b60b23e51550cf35bac5384d27bbf9e8efee391355611196750518a9154411a5619cf2d220d91cfdc05a21db813693ad956b37743229343766f1649bc81b5ddb53a32d47d59e6ae5124f698bc6562027ff86c7af5a4912da8d76c1345a4f07edb188f9bf1215abc0418e5bca47efd4514b3ce65ccf3302fd8101ff73c42aa6fcd4273458395a5b3cba9363a9c580a07987d2b1b3091e547f592c1b12ab299e0766bfa0aac55edcfbe0ef36ade4671a7b3b6364f7de176f0e02a61f42064680d1b1d92222aa31f0ce80e70067439d0f8d2040f6d9d03f4e85ad20529412764cf5c15ce5de6a6573ad148d1044cae682c655a51e7e549798dd9d3a7400704d775119e201efbb84911c22028454bad277eb10b73ece6d333b5abccfeb81908c47e56b3c0311ddf35ddff31f6208a5841e37366c38abfedfc2dae8a92d950cbb6e23df8d86cdec7d5d59fa190b3ccebfd33067b528d5128bb5a6720ee9fdea58f047425cafbe04f233e3854d7063284c3e54b038c9c3e07eb76aa2cca219f96ce9dd5c7e38b0013a634c5fd8f8942eb898670844b827900ebcf286e3b3ca014a028c1c00f681a65eb8e1236bf12621bc6db0d5ec269c8a6860b31a789f2462cc2b4cefc2ec1e0377902c8cad0391119d74d64e9209527fb002441bdc68132b4255f70517e30297787fad006fb5a62db2be6b13baf21612d72f4807aaacf00bca93b37f923b65a178b8959f20bef2423de9cd81e48caf3fd85bd03836fd131dc4cb526adad67eee35689d175720350df2fc3cbd9fb0afdfed85ffce224e5d87b51c6013c41a3d540807c633b21694e01b1124d97f05435d39c9d8743f306a18ccd73459446e60fae93106aea5de7868b5fab23585d8286a0d2b509dee44e963a29037008496e06d652891472a06a614303eb277b3d30d507d010eeada896a4870eb4bbed10ced6ae567a6c6937af4aeae9dbfdeddaa32d70dac1984b828d7d038df5e295591226a3f3197416941c58cf7cc0810e1caf2927937d09adbd44ab2e998b4dd26ee1754aacb8c48cc070649b26e7a42a7beb27f96bb0d888aceb25dcdf784381828363ea9ef3c72bf2127ec1945260030bfedc1eb8464c6b9ead1bdd15dcc4f5d0567c7ea33083e1379ad9e6d3856ee3f1bfaf6cc40a246bc5a87a4de68655932a9679dee8f0b19d1267ef24ace3277c9ed3c71f29bee4e4730ba60115a6cf578eb5cb974ffa0f7ed85ae23564d7fa4755f1c787bca7a434e7ee967433db6053c84c3d261a983b70ed8fa3e6ad8ed1f05eba1abd47550b8f752de6a9ee5314f5acd943381b453b4a7fb897886d3c6b47164161e384eba5ffda7ef35b9e5fbfe13525d801bdadc3c8598a5bfff3c3c5008200f96631466d0a06512abe4afa3b9a3727aa3baa4fe3c40ba22095ff2987acd7254dbe1740d9218eb18b189c2a135dd0cbc9b7c4272a3c1dd1f95cebae8bb72868b78f0ee2ac2c12ff1648a9c4bf17e2bc5b31b479e1a72ff02d27dbcc0e47440ac23f85fbbc970f597f5fcc71275e37feb8648c4c5fb865237169142f69403f54a0ff211ba7bdb00479b2c6f1138a46b96786d9bc887ed5b3b20cccbfd6d676cc2dca9501e7058946a765587dfad70189d0c1d8fce8ffa16ac24f6c36225286c8a5bdef1da355491681f78de40024fd338262147d47ceb45e02d8be4760703566f511a9e19921d64cebf6c7a44e4d4cfd7add052fff35272a539837c89d361f44944fc1767839e6b875b6908875ae062bed85e4b00d68d4dc5187971bf896636743fd30ff2ea10d391aa125dae34f3329af97d4a41492ddbe4a27723475167dd9298c6618b2e2d3540254ef22a20b3b6a96db80178b8d80fb2bd70ed9f9b31e0290e06ef591c987f552cc87863b3817ad3bcc19be0a8016f65d87edb200de0d3a9c34f9a6754902e6a9edf2a8fc1dc7d0e3abce4026535e11479d14693b1b5a3aa7af59074d72e7a3a94b353f9efbe1bb073f854ee2be92276a4ea15434ac811b303acfd0753987510c01c738f9d06ebc371ba6064263bb7e7f649dba2dfdb49b6ae4e7152a1100d11389c8dee6c49f7355076ff9eea45404fb7bd19502f5cba88eede1461134eb1b7c295919186e9c30181514c42386c857239213f644940cdaeb4989d9fad130d7062d3e7b4ec5ac4fe8d7805653db0e173cf676a1630589410530a3e5dd094410cef76e5c776405828fcda77f358c7bb87d9ec2549fbbcf7f632a7efc85da38f637f1cf5b65e85b83c39cb1fe02affcd800ee5b69dc0d3b929eee533f616abecb956259852a23fe25d1eaa03deeca08ace60633df238f1c436538a55cf1b8497be754396e4c1a8a468a9c1c719c885018498d86b288638e04fb37dd48295d0a547dc06759e0665be7bf1e1119173b3af0e6377d3be64911fa901533eb3fdfb1a7438ccf24eab98baf20fe47dbbdd8f363ae5d1605a05d666cf4639d744e231cf0588ed27b24eaa4f4a072350ae748e44bd96f8a9a09396181aec61ec92c02a474beb2a703499b30f49373eb9b178879742ba6290a3cb4b03e5b2eb758d3ba1827ca1b2737e762f1fe0fdced037461d1dac54047eb99a9b06bc54d3781dfcc4b0c66718030e685f64fb290f22b9c15befb172a854fcdf02ad40bb12b4e537e118e90da23a38fabe779cb151790677bee37bb68872675d434d0101b89927aa78003347bd01f308a3cfc3bfefdf5683af2eaea43730c0e9d93d7549fcfc53d66738a808f389912fdd7c6416b448709ef47f74b8ef8e7f91082d2a7d353edd66d14ec16f2ff39dad930c98db583ab5ee2699fe89cb764e1363273a4b1c0fd848fe60ef291845c86cb8791923ee953c5bb89ed713d667c386853b57e88d624950c596b9a4a6a9ec87b9145584b4692560592efa0114ee96833baf364c67de9c7096fdeb4dd48d1192e5818bef60040b465d8915a4d005284b27bf7ebd8219bb30e44a8e4ad121d53af632244d05bd93564395ce2bf43329f2ad639d42079b0b84bf80b4076745725453419285df2f5dfbf4baec7abba53926881d5b88d487d22f5abcc8c986fc86b3377ec3cbbdc1e28dfdd127420d5a84bae717a644db192595847fe0f4a84c41e6c9b94854888e421176ec5b8df4029d4c13e289fd394b2e07ba71e79f8fe400592cf925e98b57657b5d89d8bc011fb0f9fac1bec9680374cc3692a8d2fa43e9b16d52e483fd5ba9dd1474d6c902863b56e7fc9044f3a7defce5fd9c2e58e2d41889bc4c042d49bffd5c9d728a3be879ec2c8b596b996732c35222385b3b63291e8b23a0cd328f2b9b6450fb9bdbc4f1030481d7ef80ac9dda95ce62f28b37392d3c487af916e97170ff40f372e62c96b26e0ed8f124ba31071582982daf6921f3c9402369c68c8e13da91cc6e74afa072d712beb95f4c878c7d8050b66fca0c3d7b57c5fcd96a1e8578caae8246fcd534da686ac8d856825d074f2a0dace14b6a21826f27fc5a498da883003a8a4a9fe003430bd736b7e06e26efdbe81ba48b5df4cb6646e13c42cab2d1b6d1d371cc3a12908dfe28bcf6aae65f590fc7c62cbedd145a236086b467865cab668aa5760333be4b0e40c02f7922da521f33cec28f43d0cfdd7b9858c1c471687e5a53c28d55fefb5fc65c77affb82679c40d1d8b6564caab5974b2204f7fab128c0adebf0f0393e7d66e15179f0af3ef307</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> school </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025.12.06 connblk 题解</title>
      <link href="/posts/248795be/"/>
      <url>/posts/248795be/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="dcdbc4163332f20741aa535033a46c10451a81078f58380b7cf48d8cbaf909c6">93024cf999deb8d8b2919f7e109263d4ddb9caa614396872dee668a898699de815f023cafc6993871cc8db2ae80ea01c3b842526e518bac84d27a89e5e5663baa054709519ced70de89e346321f3c2130f35a84c64b20e2d5d679c67592ce21731daebe37957222796a606cc4ab6f8d46deeac3f63ffaa3978cea303dee227b1fc45995f1858161b3a0f2cd6629e32e13ba59c29c4023f5ca973cbe30f0b9f93f0e8a0e0868e4e34ac4630fefec7208f20e4f234a87fb018df7464be66c19dd3030bef523e67f7203fa54c45edf9874f74e27e8258ac4ff5ffbc2f29d85563521ab1aaa0251d6190d656b90f48b409d10c8168cba988742cb8e2925118b58acfccdbdafe33c6e7cd06ea548c8750fcc5114a34f6c67db243618f1347c4f92327f3f7bf4431780a5bdb00561bfefcc1716f700f9d5ed1ea42849fbbf058f1dd2ab313f8a45c296d14b344ae28a88fdd71a3522f494dd0cb9025d573749a747826cf8c72079fe17767ebd2760478dfa98b6abfcbe790c9870f9a0a8a8a7897a9e7654b9f6b502c0e113192480110e9471a3cc378f019294d94b048b2241244b0c817348ddc5167d0b949e331c6b020b06eaa05cec4590de032aa5d85f54e268b87c89ad211a14985887127e8e122140ced117b68e60aade658d0e405a7ca918d81c561f1171391daaae3a088f8357950d180606ecb3958740ff5de0038319a96daab70404899c0a8441ba8e8a203843bb4e6c269b913bb9eca44bf070c4da934c354013ee12defd90642a6a958a8439d1059be48d156143ac996ec7f42148be5ddf3bca6208709144ae52d048249b001dde52bb43f7fdb2836a415755ace400afc4d9a83d10643ead3374a50d860e973ac3decc4b02e535a9796eaf4d169b012d21d75df6de4de622b9d57d31b51d0765bf78325cc7d98598f924d59fffae429725c8f06637bf18eb7b3280d84ec939b16a65dea5dd7d3e979551316429cb3cf987001da4d33d33f19e750bc1d9085b776ce79fde9b79951f3788be6c36c17ff7ce5db9bc708291e1168c93f6a1b83103402d754c48762e062cd0a6580409e90f99f9ef96f91552e6265b2292a7e6364dd3a89d7c909043b7a1b9d36c1a5182f1200835a2f7c37e8f84593456f6c275876bb66cc99c3cb1ab096cb55dd6a6e863754a6250b644a6a7581a27a230e0810a7ffdfa8971d26296d567815b9962bbcbf77fbb026de7e1425b5a450070aa7c9450b3edf59aa4873ae7b98a68b490ad0a254f07ad7805352ee5fa2bab337254592fda58b5ddf5543a3199b856acb97d0aa0bc280be57882bf429665fe4cfe0c45010bc7ded6a21c8516cd672dba1ea477a993eb3003ae443e5df388e9a7f7b5eeeec4c83994bacf2798de59caeb9b26196aaf063f82756631b692ca9a8bb08017465d698dd82198c25eca8043cd34b08dac7b8a37e39edc7703f35865f075bacada3b19385d35b736f767929f9b4c24894f313192b3d58f0a0d986560fedbb5068cc2ab448ce0748b00c2c92fd67e957d4faafa1063e75222e474133666ee2a8f402b5973b59ea098d715aa19e222a6433671fbe7670c9f2204bcf12ec9e48a546a32af40411ce573c345fb93dca0ad0a5987907678bf93e0fdc7f1ad44edce4a73db22dc2d512389efeb55919cc35733c78ffbdb7b5fafc45bedf3cb5707c8df65c1db00d1e982834cbbb2c3b89dd1cbe61e7ecb72266cf5acbf5e73a1ef3697afccb1f73431e10174650661c0d19d55a8a7c9e84d55d683a54388f81ba52ce2dba6398656fa108e620b0febbb82590cb6590fd7420bfec87ebeed229b2282b17e3270f2bab1b08d95f8511c5c6dec466780d0867c0a6f17fc09ccec3f9bd957c676b26b71241109937ab65a3e2b9ee4680df1fcd8c2a7696fec29568562dcbaea7b38032f5e832309140f637f7edeac311338c2357ef17c93e0a58e0ca34f53717ca265959323c331888224d9f5f6be2297ba94c56a04c78a8898ff0d469bc521c1c15cebb02d713700956dfe8d31bcc51714e6829b143d80dbae16b7d6b0fac973b97a31d3b0e527a0c32488d6aecd08395946709dd8a8afaf4a9a4a0a37324e0b9a018ca9bc522d705d2c3fee2e699a4a59bf0dae0be2848f88e48898eb462ec807731cae103b22d5b88b885e6e33e0d4987b80f7ce083c54dda9b70a94b13968fad089dea949cf4d0824035d0b87edf18d53c302450af896f166ab1899b562a34fe49979a6f5737b57fdcf6d095dda28ee5626aedf7d61d50f554589f2a50df2783ac43da10f8fc24936cfa1870c715da56df0928233a4ab4ba14f5d4d62d0d222459d948e3f9e656c2e9069d4354b6c04812bc566e0377976aec849430a12403660ce3f6388b041a36efd15b3cd5a2621acf8b40d7819c1b6110c5dd4bfe6b40bbb0a08130e6b61e97260074b2033daabea4ebe243e3208100606f1ce0d75f4fb1078b5ea06d6a7c1cdab5cd1c81aea450a4a6c7643cdd2758d143b4127ff83192ad2242a51752fe522e7dbc1467f625578148a1326031ff2dcbd6ee583b4646cf34cf60eadf4dcfe987afd13fe4446cf13b6bbbd89f0262b518c9c8619778b67e2d82198b1628ce7f9b709bb62b7f05560ea9be6881710c16feda7ccd4539fffdb84603e04490a1283aacb64bab90e0dade29adcd350e64fb2ff31e96ae6102fca8f825d77977393b841d3fa88c2de9ac62aa2925f8bf8e038acb3f81be9bc5be2a4762758031f3aa259142e2bd96870d52177321c66ef4c65dd61379d2e773a07e3b23ea602c1fbc832d6e25cc2704be70037e46f35673ae7da6f54c7b69bd0c00f91327e9ff8a3084e6506b3c4f4fad71d6df6f2f57fad53b37be93b553f30e2ef285145f6bdb317b134a695b77464502cd247fd975684cc5da48a550c7d02e71661b3729dce40f2fb89f8e66431db4eafb11600672e55bfc2e178cb8ecb6aaba874dc3d9e691fe8486247711bbce8a935100ec5f076a3474a1e15b508d57b3f56dc0381884324f2d10bee4be20f2c80ec29a4ca56b286cc7da45cd2ffe57662cbbef9788519aafc03800bab4803bf9d9f5252c2b4d148280b58511345ba669e3f93174f3e2577f4165512a03bf51f00f802ae298950b9c5a15807ee5d642756fc150a5c2d899e7a44fc5687fdd10f6d2f75ffbe06ce58f56d461e5712c5f8122b291df1e01b708cf97c3b7308a43faa70ca7fe555cb4a4242634f97aa0607c512b09fccaf45e93ed9ca5f32cbcbfc908a90e59df49ea3c3948cb8b88765080adc191e0dfe7c7e95de960ec186da9027b9812b09798d9bcd8d7d661237319141a2df33c95091eb00d3aeae8a034b892765fae1b7e5314e39f71ea8655e5e99109f517c386e712c15eee6e87695e866794e8e3d3a168fa14e9a6f4633e69d2b58d3e64d4e64bccb3e2b215d25ca53a4ce33ba9841e9a8fb8f40c2923f3e24a93a23a0a6cae854c2a838bf34f4c516c0316a38e6f33d2bbc79e2b239656231eb36a663c88ea79011643dbfe680a6e6c62842e6e5510f45392b1ece8d26614924ef0c6fc18648c4b335d1b5cfbcfd589a177edd1c989f78433734c43f58658f41a9235620d4107324b70d307dc8b304e68e9f3952656df02a019a2cfe006ad8f2573ebfb4e4d218fe4f182b7f8e1213d22cf98aa001654d5ce18d541f4c5bda8f89d0d73d660eece6109031303a6b756ee919105fb2071830b91da0dc01ec8e832eb90404c95f028e4e38b753746c17b6c5b7f877f0d1e32f84b66cf5f1b6e827d37b63fa27be5e400b840cf22e6a2239792bdd8f48d06592f17dfebc271c95021b546b517236d65b8c7b6f7d7c238b66e6109c94aa8bca7acbbfe874f55d2a85d0926078c273693fb3d4483a45a244b7f3ccf56128dd192e13da69eac552ab6fb32c5b0142b9e53f4f857692871664be481c0412db811ff70b5c11fef29915f562f63711cda8011e8d819188bdf14816e2bc85d79ebc4e2073ad95a175b89e7473aaa0fa992aab086a2971f05af60fc7edc0453a32a84bf16f023084a7255ed8d6fc517c70ff7e77fdeeae85ea9d1c3d04b5f7c31cc5034fc00a8388aecb0c4cf047001ea0d9bc97941638759090dde0b43502c0e1829d8052b227a2b185d3e5d2c8bd0117e0a062e9b54881486af1c7b663f90c5a332cb66ed9bbfbc7d4cda6b2f52ca01fdf5b6a756c4c761f26e8db754044558d53cabc287b33f52d3b1702b288150c098623365e2903e5939094e0e1cacfa1b30e650ba94a707b4168a2c472c4b4d73c91f0f58937337659f0f3379348439ba7d8228abe706053f5e727bf6aaa4fc64a870db800968ac303a7f3df348f938071d78be1ba9f44ff9664f1d2de2edeb8458062b6c08bea06e473f6c617f81b54171a59238f3836c12af53f7d84b2900820748c4f387051e01af5a0f0ad18af76278704ad461c0b181ca40e5340cabd9e74731f39a281f42d56406c22d25d7644c57b84955533499d1937fe507115be787f38b51cb49f00020425779a1868c5c059faa3a22f36a0dee92781f653138953466cb2c25329c7287b8743f0727e75f1d100cb0ce80b1fe08067ce9f5d22da4792cb683370ac27ab3a201644bb7dadf17b30d750923f4ca35ed722c60697becdebcd7868e25849edeee2ebdf417e57cffee29fef96758231e189f065c9027e71ac97f9b708aa5a3378ad8d7c78a2593fc330d870918c58bcc8c5fd32ee97f058df6dfca864533660c32faf8a64c0e422efe5aef856c79a29c0c230bc4e6074f346c11a609c356746262053063849c18f6b791458a1221bddfd5ea3666ebfd54f9117c1c1d5e048141c779ab3d2dcbd8d4e549f5df4235fa2a545b2b6fc8eef01620fc6bc65cef26e75c5e3c0b2600f0a3b24655d41b9ff4dbd9db275bb94f2a4efaf45ba2669dbb2c7faa5c0fef4248b11e12a0dcbd879c40fef671ab4546ebcd95620f910e24a2b4b4ac4e2c20f563107fb6c081cd244de1b0823f2f8ad5b1fd32407808957c242203e47607a755fe7ece72fa4325607f764d38bf740195d196902bd2a4a60126db8d26ca16b96fa066582159f510eeda65b7ab02c282833e32e7aaf2f25ea327014fe380a2d5abe5296297ea2913a0ce60c7f6a9c435397ce484104878d86bf8ee7f350c36b7e8fdde2b5ebf41e2e92cb43a5ccf3069f58536553b1ec621afac920b95547f78bd6a1afeb8231b2a71c0fa6a4edd007793580b19c3821f51269314227733d26cb32cc73d34e180fc0fc86a06fd588d3b5f8239bb949745a43c8bf3d26272d466222bd630d9ada136cc1cc0bfb38115a0051ef7435801ac7be3360b0766e2141441ae73551f65c33cfc7b75213899edc16d8e0fa26557fd353bd7b6a3cfd03bb1af6df21a26071c39866230d26255cfe3c9ee04f59777cddc9e159f1100c91c655bed7d5315ae562caf650aad66023359fbb21560f0c086a8cea7ece967f874e5771ef4999abf8202cd77fd1402e8b2a7127160b04a610dcae043f908ff688a22a61121bf311bd131bed7181365a5bfe8b3a07dbc159854988385ad8f63747293fd5a97efc54e3e9fcd65b7bf100b587c63352edeb90c1a6930202d025dc2f5e78a3003efe2595b989bf290c6b13e615af14a5b6114084f32008d8849c21ed6c449a17369c8df51bb11ed23f0cf58063fb67ed323b8941813a8345cbb72ade055ea235c491ccf1a5f24bc4c92cc957375afa6601bc36dc185d04ef1e66f08d7d3ee7ccb502a6dccfe65faf35da8230051e8c438aacbd3997686ce9548173db02da721ac2837a613b2912b934dcf6fedccb98e639539e1bf1e5c5a9a030508602009ff5c4140c46eef264be5aff364923043186286fa9820027f6527c20050e763fe40501b5458902407591d0a9decedd83000942b563331f9010cdb95ecc8f471bf76a6c2bf50d6a3943fc71fbec843715f19809c6f970dd8c50b120587f9c25f6eaa3652d1cab9b68fedb5304109f6f538d74fa3fdf9fd83ca2da361c24b1a54b31afb97bda55ab696f68256590136130dd19b495f401cdcbd2455e0b647130d49cae7c7a12b43e0cc10a9af8c799b24c9cb0d0afeab3627597d84505c3c5e85dca61108b718a3274d60bc8bd55d49e0ead327e9059e4224a0336547f54160d42804a50a34000d1eed3683519618e98a3dc71ff1c57010aa87be9326aaab17ed78aa9a7286eb979da1159c26da66925dabc5aa460db7b350e3f30e64e810c70b326ea7182ea13584ddb01498509871e08b74e4f583b84956d756ca53b0f0bac4f39f7875174f0044509f89b6cf9834ae27555f9780a5945e4afe4eae65ace2bfc505abd165651e037e766e519c0e5adc3ac4efbc788a00c1388e5f9857563a60dabd53db37569bef0c6312e644222967c613301dfda6125e2e27dae812ec11c1fc53d4bdb041c3a49ef4b60b5c65f6f15ff1449951f156f2f27b8e8620a051d0fef60dfd1018ec4f39dcc5f144239e0a1f6e12a580da4291262ae93e28e67b4b4d8c83d0782785f70a99c8e76b3fab73669c6511671e2b557eca5ca413fdece1413be151d221a581d8291b4ae0ee5cb00e1f743e5e5bafabf73690ca60ca068433156f32eec2f6e202cbc951f921eec038507f8266ea3095b4d993da09a3ce3689375edc712dae2102796764ae3b4bc1e2bc2e1359721a7e99076b285fb2a28ce51eec95d74666e4a9742b2fdd5f0b7862d6a751909b4a1515a4a3a41406afd888fe19fe4ef7083b14aba7cd748a140815d3a71f6609d6c8a12f1a1280fccb7e9ea37e4124b396b442bfeb06328145d022b2937dd71f449c8829ad092cb6f229a5bf1e1b52324de74c65e3e9ef47448d59b10d767ad83ef2234d0bd7646025e3536e746fb660ac1be32ab750323bc55baf7dfdf5a67def91018197a9ee4a17d268775063fef97a7122ece34d91ad9178eb3a40f537a479d57d7fd1758262dea83dd8a8ec02659b8d5fcb92f61c272827332696faebd619eb6f3875ac9fd49b1b48aadfc32155c7f8dc90705bbda6a13a37e5183353cb449f4734a6d5ddb569a7a2922ff27a97963d0338376493b327d620fd989e9d0dabf7c9e203915433a23b14e9199ea961408b4b480d7511875a47063e7b5b5e062f637e4c17733c573d8e0a672146fd0ed3ded956e995f3c1eef35edfa635b2cd90d436861686d8152eda5645935ae9984cfe40779283738b972d5d138a65516e9b2814d9d7d9c8a8b2e75c4ef772ff73003f39e0633de00dacf6cb0f47cb3f817923034eeec3e5fbb1e35f939406e5779a4001357ae0cbff01643587de9ab97d119924e2264f3a196f92af11a29c66b13b7c45a7e946ee6841fad3615e8d9205fd90720252f07552d21d1510f9a45daa36d70ffcd65e4d4a0e70b9d479a926e7bea78315b28b6b57a5e6932ee6cbeca096cadb4ff8e3965b2d81aab7253d7fb1693327e4f867f006710b2f4576c67e99725286c3b4821e14b2d412a4526a3f9694f35c57fb9e8783255c5d1d932ace01c967a7edf65f16a2cb1fe283f40f9dd25f8ae49040607080af25e3a1bd8a094d9532f5f4f3db5880beaa974c5ac954477e2c9278df2ef8467b685ba7aadecf52270a62485a4f600a9e8062dfb797436d1876b07b4201230bb2f53ed16dea5ce327648c38e316c0b30079ea645ee1a1ff80bb653dbfbef081c53631bf35006e96b889042b5393ab81f95ee9f1bb8e2cf6b60377403a8ecb6e6b69c875a9570c16fcc7fd22d323c36989d46d636387a934f674e6c7222e4922129c4cacfcf3eeafd2b1aeea646905497bb4433ad895c6645eb46b22292919074603a31e53a08be75a0fad16e3ad1b5341dbc0fbdc43b0a8e2c25041e72372a164cec7f14da0cbc10587dd9f5dce4a3b1737febf7bb4c3be52da6d5417026fb865f54303a122d19a2ab147674e9a6dfbb55c404d8786137b852197563fce816536e7b801f24297c32a5dc8f15cc89dc26def366b7581448571e0bfdabf9f5893b82151ab84114a73e9de4b863b42e90afc80c4043e24cb74f566316e4457206dec4f8fcadf69cc3fa0e376415a87448151d8f81c216518223c264433cdbfae5804da3fd64cc4f476a97c683451a7d98ad16c30ff189e44d9017e04c4b57eb5a40c4aa8b5ab4df170d7f7dc2051a41b21f29f598a9643902add28d916517090c1b37cca901a81926e88e0ede006b4b3045fa133f40a512990b6e0b5d286a7eedabd6efe9fef1365250613e5dc344a54f3dbd227108bce8a061b91307c6b1814fe476087a92f4beb1ec4ca9349700a3e3cf9447f7d238236058ec88007ef7ee7a7c0daa79e1a8d9f4e3007dbc49c6ad5e253f4fd03d9e85006a55030a20669f853cf7043d71c17357106d57d396a964c15999e78684242fa187161f02f315f7f64e61a9a5c37ac0281317937d692a7e71b072c1226fd2b9d96fabdbbc66c6a2aa46afe4c8df0727b69e51c664c7060186a6d471f2d3d67593ff4eaba3b5bd9ff965b3da7a884e6c7b3834c417ee9eea762513c7c07553d89403416b358e3d0ba1208f30425012b5ed179b654c9524500ab3991b150afd8f8e58485e3c0268772f24c7e9e25cbfad836570272a75fc156f907c19d8e95d21f03e98678d7653be15a8547a1b961590fdcb0cb640368a46efd51fc5aa60b6654ccac51d1c40a76668913d8ee67448ce236d7c50f45085f2b0ede6ce2fa84539c4c7c978f75535b0041fe856ef91845384c9b4f390e72ba6d1f0dfcbb058b84b4ca7bed8f6c18c7699574793650bf9027f7607102c21cde6e8eb869581044158600c02e8c97837254971392c8d4484afc3161ba8ec3016334d23aac22f02f8807796b9166e951e8bf40a9952e56c5f6c37bfd2f4665cf94e6731bed118e5c096319dd3e51dd0dc3b9c94d09f189e87cdb8aadd636c78d88196f0c5ba1579cf8b5eacd1f02ffd75857578639cd6d560ec8c53e1caf6573c920a3c1733a2c5f3e45a40da19156afb5dad3e4bc40d4ca9e8c152dfd6f697b41e1dd3cbd7ab92ce60431471a0d059ea5a77b901fc6c52e5aa7445e352a5a0c38c142c2ec335ee2b8c990a9f0deae94ada690e6aadc02c98559128dda69708be4d9a932825569c5ff4d2030ec673f3a5153164b06a12e630c369021d2d3d6dba0c00c2c22f8ae5448a133a7f515c426c2e213b2029eab714550730cee4a065a245e96719506e36006425cf7a9685cf0d01242a8a2634a3edcfd25e4ea6acdfa934a922409e328a58b16c9d2d5edc572092eb7ac6267962969ed491773ff1ae481c5ad419235c57f3510055da7f310ff7adbeee40b39d1a88ae97a0368505eb933717fe330fb2880118b579c41f57936d229955b3f6a71e087b4eb82f19e97740d2ea918a5a6c2d86a4919100ea43cbe0fce97b3594f8d6cacaea2554b5dad7e4898aa58b4c96c191e3469ea012c46138510717c1dae86d178983e1331e4c7d7a4cdda4095805b5038cfaa1c131f3b800c5077980d88e2e17878ae52963754d914366c70da36c3764ccf9abcd494c687f8c08974841545af1cd86e4340efdf3e0ad5bfea9d8bbd38998e5b14307a5c5e4e8cbcbd7da4cbbed5ca3a4c7cbd0d8ad76197c5bec56381f6c424e3c9e8a9160ba59a4e2521041a3a55c2558b23fe65366dc8f9843863e5faa851a00b6e5a7e0d4fa601fc13cc6564cf9212cc05666df215d4521904f33fe2fd9dda241059c7aa2f55916b07aa684151815b0f8c844d37b351617871a13fe6a853b7c4de59331443bf6ced1c969d59a3a76fdaf5a5a86bf17dff0147365984f18581056d50c33d7e40e3182ed0a54e05126aaf6c35ee76877cc5f941db3373bdb86cbbef596bd2f915e3f0237171b60f991b681d809c3260ca49639cd593247b1be91c2d7b5602c68fcff1f5c86e9d6ea8d3152b5a8e0926661704f6ebe620e5fcdf48b0149c53a6b3878f4e48327c337dc9b737fbb3562b520fb126d080ff5e730d97104936ad8990f435c3dc82ea3c96cca3442899b1175aa19b860ad8fb1c82b13227a4327fb82a374a05879b90142fe23ee5c397fce7289d11519960d679ebe0b4e9ba52ef83a671a414436a2c90a208a388c266637ef1cc2ac778da00d9a8c75890094e84f3f5cf129b57df0bb90ee3acc459c9e5b94519b9d66d1f7ffb9a969ddb43d1649970dd5a8769a5f52b93e5a9a6c36c9024ac5ea35988e1334aab855184620100b468a8b2cf64c2cc7209a5dd17cb7b0db403bae507b686b4bc7b98febe9b8a2ce65e314e5257ffb03de140bab50bb48dde5f0a490c157ca4c65953c3227d93c1be9a9585a8f7bd1eac3354b572b60b9d7c8bc98256e62d6d3150f0e07cb6b85cb64df3809311a81caeb998180cb17ac2f2e625a68cff3647fe0c9aac28da1bd66df7e530eb5e4320bb3a039d4d32d8490fe8780922601f2df81a054e01f54d0b96107c1162816e12813f773e2894064142b8263dafc255ef1c5c673b9bd6571528eaf0ed56a49c916c1e50ae356db8cc7580c0e35a386193f73ea0a680eba69deee60f1a0fc904c19afd618e0458342e49099b14e1fe0da6dac0017c70e76d4c77609c713e6771601ebf7f59562b19afbc424b71956b71d5e1cda4c9f8dfad45d336aeff79eeeb5b93f4d53ef1ccb1f1cd31b5ccd6e784eb230f1c87fc494eba097679dcf3719ec2cebb94c44241d987fb3ceeb64c232580f1da3830ff5fc1b6245ab45e3bde954767187de24bd29e34a734659bf95ca75cd7f41f2c6d9c0b3636d8e5beba64770a3cc3e596c526c7d47fdc2de385e22cde77adcb7d30f26d7d777b4ce797615bc28a98f38165baeec36804657afb2cc63b3c5b277dc5ca4fb91196cd3e4f4e4c9854f3c341290a02c2c92def3a33cb0cfb8aa03c53d29b4acd68f2e482468ebb12d2d28bb27d898faeaf02adad80032f9ce428fbffb6ba9656fe08417c0fba5cb414f16b2ab33cca11559b8249f32576e47772ce847fd7237a09227bbe8f63c1b0b95d61a20bdeddb48564dc0b89074c85147705c56d2072c54722f2395a7a198be9adfe4293bef889457f3b7f5715105c10f03b81f0d14687bdfc0692660135374d8687acf165f7c2357867fca48d4ebb01ed092b1fcccdb02f09770d231237d8ecaf8157d083d454d525e89b3def415e373bb519210d5a44ca3d30f4639349685856eeed432406c4e6c8809a35763f68dfe319b6c486e1edf588896b99b72670ce2282964a432102274b7b20968962aa7c8ef2d3d1bd8b24f1e403b078aafd19e92ebfb206dba4af885e86568daba3ff5d5aeb76d95fe8b468cc1403b6512beffc299be46b35d3316d1c6d988929c11a85c2faeb20c6bde1d393b5942944738b7704b1125a4f4cdd0a0d902c0cd75e50337d78cc0e5221cb31d495a48f383e6dfdf74f085c5baa19b3dd4c390d544054c3c70add35b2e70693ede72fbbdcaaaeaf6176ee84e3202954e92580b2f8a6bcbde476e87fde0ccd28931526d0c322bb99d4f04f8108b964691f5d2efdee5ad4329547b3d425b94497a07aa97cca65e2eba83c2befaa79204dd459bb8095bf834e5e0a238e63960130864c8764814b44d27633181fd5e69764309a87f53f6cb5553c08f8f45b7f0ccfcfe5681eb51f998e8e9e492cc656670f6addae4ec1b0b31764f5cc4dba3b9eebb427df7f3ca029cc22411dec2a43fb516bc1cf66c528de0d7ffd935ffef8340624a90173e1cf51172a21627e27d8edfea715da0fae96c87cf91ad5a5241afa44acb4f3c3b24002bc8867a5bc24c35c990aa621d0f87da0d5b2d2d3c5a5dd8b6541c724a3c66faad292db9c526903a74284f710fa0ff8e40002b63950a843a1e092a7dcd839166075bafa12c58f84338e233942532f1ee0baa87452741d8abf33c7eb2798bd2ec4da7bc7387de382a3821355ffa54d1307a251790c466e5881da9eebe04a29e8cf19c135a09277ba74689a47008b9b4cc6e20cc5309488670110aab568795487ae27b3ef10416d0c426610702fb215c982def09748b14f9aa546a1b637c3d09cff323bc1f197d476603fc753eb6adfff9fdd2fec88790812f7da7e4a61fa8863a45b1db1983fd8cc7c422203e9131ca9e8875d5dc6b2ec1df453c83291ed8fb53a71e5dc69c89f9792276750b907c03cc3b5252968362a96e046b10e5ff5596c5b5010fd6c763a8e79de1588bf1dba25cabe3ef7a4966bd0de25d5252e878cdac5f8ab1223de412ef2b70c0f8f8e752e00ed3598cb1fb10ec1cdefa35405a2fb0bfd6025879fb50704b2818c6cb8e5bbe46b4b99f9f765114dd63d4dc3fa835f4cba5488b144bfab2efdb16358dc602bbb843baa555f6f8b3c47cea3443db8847b10a34a26cfb737f2ba67facc8c88288ef26c2934f9ae7c5f098c4510bce9254e371c3b6c61a99e806cdb2f2d6df6371635978f932a69a517ed8a8184c8ce2098dedb6a3b1822b7607a8456fffaf5f9f250043321c8434208c3c91f6fc915b0436ff8e1d19a10b1678b5deadc2a7713a1c2bd2c668a29a887a1ddf750bb9b40ce95b48de13f0b83dd58e0e3e3890430bd08a49eccfe8845534a6e11c46b8b1ac5e751340cde6eb7f28cadcf0f8c35c091a47bcbc4ab501dd87efae4bb13e6a9a889f651819f9bf188cb686310775be716304c44a53456ebdd4ea941753c87bf4356a7f4d776857f79c749885528daf4f95d2e0eea68fe7d8e89eea081da652603b256a4a819014f5c0ba7290f69914751396fd26de5474feb021a3007bcce74af0591ab3e851dccd49657ebce361c0109f98402feb5d0189feccbe595f64c5d5b9f409d027e9969c91b0ba3434a22fbe5005599372d1063219ca7d03412e307477418e692d43bfa39e72725c53e194ed94afdbf356902942dcb955400c38226617a26d1a056bad3008593d8b2e9f1d36850e09932097130deed7a78453f6881f89650f2d80a853bcc82849a961cfa20fa0fca1aaf2f6f4f3f2381644aa140de8db4962fda742016a9bd3f4b879dd26f8e7fd75fc623a6ad815b43573e1022d6ebc09a9547c7b0b78ddd14eb690bcb2468a9dcdcbbfdb175d696fd27eccb186754c747bcd783eee538d5d26093284b90361b0e5c3b9925fc7bf99d2ccb442fabc885cfe1797a8a4caa33ea82e55427db0d9ba79940928794a195c1e40f2850af189f2d6565c4b94558bc6aa73c932c496e8918f666d418d2137dac9a4f0a070232b3c65510713a9a3f53cc0b836421bca5e77dbd7e1e77c7c13a59f322588858198846e3378ae06090d5765169b78958fe8962302dfa936baaaf8cfad9a3668a56af88cccb7713d084e99bf88f386d2facbae9bc970524cd0e39e8c491951bc4e77b00ce571180486c618c25a967fd6930764f1d05da760d34f160a9fd508c7fe8d6e9422507e3a55940919c03d460898f57dbf97654e8092e9a207a4431b32ee2cd68c2116412354ebeeedf7173232e247dc07b71b3bd9ea42ee0350b2866373ea7a411d8bdfef1c61b461cc4d95b99fe87cb8b2a63e0d29fee45de3c0d9551e355ca866f396b1b59c6aea85ff760b65ae35b0e214e72d72adc65048ae9b535a9a8c71ed715e7715b605f49048d8657ac640150cdcc449a5198d972e9cfefb9fb3b39ec237bd692682f190a53bb3020a0477531f00c2e12cd4d1b544e158c13e1d14bab559ed8cb2cacfbb80b728ee0fb579256af30bdefefb90e437c9cb074bc9e47e18c7d82005d0f97f936d8b4d73d59831dee6df2dc9ea45b2b6a530a163a5d23f1ee6733218fdda586afbe8f97160a80cbce61f59d3dc0b31dc685db2b2eb7d7b6751c8d2f592d952aec4e292a407f7a3682983cf7500a69909da8bdac0b36569bf8f94682f31497fdefbb4ef13e49f91b489fedd620198eac6627d9d1121b1bb38cb67e5445d60f5d1ddc5b5e1f64279e089cfb9a116405ffc7d0f5f68cbb5f429bf2b9bca2a4bd2980e070a5586a95438d25261aa0accc91882438ca62bcafa4877b1fb3cfaefb8d47137e23219b68108e58a5d8d136a42a0aaf096b956121c2dd497834b286f190235f982db6fac46e5157fbd19d19088aa7437c515a08b7e8fea487d340a1c9b37cdc85f612b9810e233b445bee95927083fc239f8459c23a926f8bc3dd879ffccaa9487fa8006ebbbde01d27a94550088f80988c904d51c07e02f8db5828b88504d5bae679617fe04336a52958c91ee772f83daf8422f98012a586ea871990162ce4a87f1cf22d68e62e538dd4fb2abfcb9e42adee2d0dd55ad3f84c34c852780f1565ce6628e9f99de87ea0d339b7b2b1f5d9307b2d188c7724f9b21a818fb3c0090ee5c07240dbbdd98ce24e8847f349e7fe8db942c37aae652d7ebc22d0ca4934b0ecdf2a44917445d8584df6c32629310c41d49575125e1ff8ba814f583cc731b3c04d843000bb3220820fbc162bbbc5ea5fa99b579d671b8aed6ef577fd6680c36819192c249ee4fde087cb41a2fe9b48e347e8f165a0fe65da4154bfd66f007587759fed4de50d3b62d1c4a59f64b572ffa5d155e543f134d02c89eaf9a18727490c4edc0036201d06dfc21335e0fe328da8b4f545a660fc9b1a8e26c34b53188dd49f7ddb3a0112d6b53859c64cb68a227d5ebcfe2c23fcc7c9bd42b70f70c3c0c9f22836739d75c4c371e90cfaf6e94886c49d4296f2745eeb9c2c0fd74d19739772b164244329c9912b83d959ba32f7f983ad972319428baf1a08291300d7d8d8ca676c367cd62054958cbd4f16adb3c58a5fba1c5b76594a18a735932117ea1660ad999c5d06a0dcc536d9a18a9743545e7b65ab2ee68eed84e7586c233365af15e8a6825bb177dfce229a9f44c561f8b03fec2c7a329a6f9e6f245dafc9ec699cec1c4b0e8148dfdcb95429cec8fd1e7a43c743716210ae6cb08bd0fbfaf7e37440c00839508b4073ee6277b7bab8b1486d3bb0744f687f27c2ab9ac9bfc9cca48cd608e234d31596f88787d43a0497fd20b661999230f5ddac99ca0f7822f2914c6e6b2ced25d53771a1a776cbc350bfe9eaa28a5a5ed57208901aa9e5c9916ac79ee23142cf97a803b3d25f968a72e3c96810aa3fc1dd6e987712f87b7f0c7250faee0e5cb47f3a1fa8ae6cfbecc5bd9f6c5c97607664e64cf7bf34c2ef10d946ce589cfa0094bf9148d51070b18d26092f1b6cdcffa05556053732b4b4c1d0a18ab397064a2c7895266d6a611fc1291fef66a5f18bfb1a09472e4aec80c23c20c9136b5b8d442bfc4eb1045c9c1f3c2839e268b2c7a825111d9ab469cfb7b7abfce3265f0f0791a369c3fcdd262677c566c4973b8cd329054223c0e150bf56db50db9a605928fdf18de638ee06429a5000cabdf20e8e7a3fbf8cc72a5bed949953ee1c7962b7e66c70349d97704c2120aef8c244f8d905ee3075620e40746db9c6a5f6b27d654952a2933e9b0fcadb1773dbc14e3311e1a4a50191853786a3d6252755ae9d0e1a8feba3e910b8a0a969b97a68e8de1991a2736e489d2f1cf14720776edff43a91a0f3da9dc7ca0e81a0faf59e95a2e47025f95936a7eecf6e406c4493cefaa5c976acb3cf87d459bd021c02764bd9a784c15a0fdc4f46944f7cb2bd67be8983637be1e1c9662ecb8fdb346b0232421920416397804d8a6e46bae4acff404c6aaa07a80824b8af2afbb9da9c8efe59237819ea149a292c34233d2307f83c70c6734a1c3971cbdd7b0631229cddcc9ac879a25e945623180b36deefc4708c91462fb8a3b176ce9e10ee3da6b632414b1c746d32665dcc0a8def15a04681b9fc0645db8836eb5a563ae40f27fa79d81aadb2cb5eb3bbf21cb69262db0ab7b289c6de27ac31429ad8ff8c8bd472514656ac87f1d91b5844788a2478e5d91170200cedec57e49ddb1dfcf8531f5937490583</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> school </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP-S 2025 复赛总结</title>
      <link href="/posts/50c3b0b/"/>
      <url>/posts/50c3b0b/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="24654ae23a4b1b0a2fdc690ad83d516a99cdd5ff84c95e10f655945b3338cc80">93024cf999deb8d8b2919f7e109263d43bde7813366d92974e8201c5729688b53b6d364e3ec4c0b2febbe00e48da865e5aec57325c13c1e62cbf4f5d3c4cb3cb03877896f72e623a071793170fe1c4b0688e5b13616ed628e4d98ad0b595cef79dda2303f07c06e7275130492de16115ff2a8ac740a3491fda648304269fb030810eeb76ca7eda44c78fd04ff57bf753d60fed8b0c7697cc9d08b0a8d6459a0ad6652f6294d325b8c6be7bdfc124174c77b94a49055ccb67eb1a3b9c54ba458b14a1bc6d8b329f100d88caea9c076ffac061779b088d01cbf451e8d5391a91d594278e576eeb0ca76c5c03cd77d9bfee77b737ba8254870d991ecb24f33821483c3b27597f0762cbfe175a8fb0ffb7108770614f1f716da2d62b647a18fe435be354de05127f4988ea9ebc12c86e57cddbd6be3349ec2be34c37fd8faa61451877fc17af9bfd3794c731007ee92c9dcfa7f3979bcee18b90c7d8f75a38c64b958b6017f21157e3b10ba69d6e4d960fb4517097b180c52249ae76773d8e6a2e650ddeed36bc254d19caf0e6843590100bf707e0693a6567c607734b3f08cae729d1974a335976e792f411b0fe010a3ce9bf7e6e0a7e3d372eba16d7c8a89887e0d94cc5cd9ba502d28a75d436807f0c9699b05f47bc274778e43b725830e37da1d6effdd29df869b7d889cba59692025a36253bc2eecca17a552cdcaa382579ba59715796f5dcc4804e3cef497dba3c4828979efaac28ddac25516acdc3c4589cf89ae57d551234704b3db47bc54b82d4133b46fc880b3eca45ac5d7de120099343795599d67d3d7f812d5bbce7dce70cf0ca14a1e22907847b16751190826343aef1f22f084c656e3a7663e7947dfea0aa444f7c9e08a137bad5d85be334b0013a5329f825bb6247d739d00de3edc5e4b1dc2e0f18dc7e02986e9392423c85ced3696dd4e815cd307c765149ad1146cc09f833e18d6b289a3af4ff90590d4c07cbf03ae2a0deab4092a430b0a36cc4c744965f4dd2d107b3a48b541b8c72126468593be4e230dd74050ca26ce5e69c85e709a7322952aad98b70f3edb3a2baf37b1dda5785ead459ab6700e710cf61cfdbed8adefb75019f57ee7cf7e213c86da91f2bc749c5691c95cd1e418d37f60053cd4b6128b06fb7e7cd2754a0f287ce71b8a3c46736d814248155e6be0b66f7b4111eedbb091b2ec06e5ab93385ff80fb482e6db7582b4ed553c9b1688ecb20b3b3fbf5488f576f22d472ead8a5cce92a0054001ae713e8d1554e46a9df7bf877b11451cd43d407fc1c2e4fc402e7b6deffdb11f7b9bf9ca9b5dbd9ba65cb824d0740624627aaa1ebcfe30381adee488a4142be6b844f9db3afbf88364b263d592843987a690b6992f1ce148844af3407fb3ca16cdfd7ae677202f95bcf6a34ed9f7e4d4c9f43b55857aa8d72ef8338f6c541b91820c09dad4807526b6e786982f6f42ecae6d636ee8525b8093ded9b001a6872b38af7e59b4301cbee4183202b22e344d7533c0af5231c9a5d6c8e691bec16e08b19265b9bc3b9b3278afd36ffe8e1017fb8e169d53d6d2d9f9b2e068e944502752cd4dcc58f4c3cdd18b3a8e145f11dd8fa8df4fba449055a2c5c72af605be4f6ea7fb2217cab8ba7e7770a1da6e74ddca87e3d51f4de85325b9b7b15d97c234e9bfa0e917da9fa4be6e5fc032b031405808c8bc4c12e2ca87f04f68779a631aeb03830144a50034eea327b96cfcbb65b239878bd04a46c2abbbc60b8b9a321229251ec2cbe7c6142728ef8673d4daaea17710590ac8a94e4fa6094f9e798162d942dd83db72ca37299c7c9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> school </tag>
            
            <tag> csp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP-S 2025 模拟</title>
      <link href="/posts/4431276/"/>
      <url>/posts/4431276/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="0969d13065601f286051cd4dad569d41be655d27763ee062ecc6d886a9d7fa79">93024cf999deb8d8b2919f7e109263d4e315564c46bffa64389ef39ca39d4b835992ca3dec13767850919931ac5d9419bdec04d7c0560cf39c8789fe1c6e1380f89c3b3a40b71f14e88c5903b917db32cb34f3e818817cb58fea8a7e9b50f9f8902a5bc36cbad24930efb88af296ebaedae181e88380ece308f7fe8f9a19dc5a2a1be4b5a124eb3ed661e8938dad290072974ef40bac15fabc5f073d9afecbd6a471d11b1e7a509ab2b295c1b9650503a45309186c9900b404b533314084318844bab9dc85b7edfdb7df6e98d0bedf6562e6284d27b5320aba5d11bb27d847cafa3a2d8d599fa529d036a5d46fda3111a9506a7c7a4b2f1ab199394d60b4cec7549daa360f6cb20e00abc7889c6d9dbad088c02574e2e27d438348fa4eadac80e19ded699767548c4aa15a6e9ab5c6312604c7363905b15f146307dd51a8c2103bf14e7b34e25b54caafc08a4fa8149228c0fa576649c9be8117eefd01d8f081f4cf54a48e3ba284b5a02d965f66ed641639c55d57b46d94dfd5f71d03fe0d1d0b866a279fd889bbd8d29f02e577b00946cf81a12f9102698bab7ef0bb219332e146d311de3fd663c3d36ea5cf48e7f36b7816acc3a546e9fc691e45963ef32547150306b443c61950421ada02bb4fbfc589c9b8ff5142b5f4e5a029a705e369875b74fcbbf8cc98ff08ebee8b5187a72814f4bfb0ef50b2b4a7ea1f975aacc1510743fd96cb2f27383749c4da22fffa209709046a5e36fbf49a6c896b9e6de1b6c5e91d2cbf86376e6d5887e99c5bb7767126e493cf6ea48ad31dca2245362d6927c6aa68ffaedaed8443677a89805e6b56e8541971e2880098f211be6a284f90f0e4b3e8295b1712b9f7ee2e04727449365bcc7b24b649ed06d6ed1115f83007b36fd31df59187b29479278c4486658a32fa49bd596fb8ef91f4b8548c13c1b3c1e3e3a1cdfd0dd79a3399b26fc140c786c685f0a8021b1a8a46920d96a564c0e4717e68429465d0cb61b5f492aa2712c47cbd766f3809c77e3b432fca90d20a093eb5b2cb67729b6509f33ccadd319722530d59a701412b0f5bd3fdc94536bbde79b0b856d58fadb2255312c92d3180b20a967d8f713b47a691a40e694973918f611f462b19deb0478ba2db65f21b5b309f46bd545d70f630b9d33e185785071efa3af4123d79f7dbe39ffe1b45fcc40c4ad669dbd04a9ef2dc410dd15004b2abb858ff996d725b7a6af90d688947352272b4e4d2f103704920a6c64e1725bf91f641eb5d7be6675735a5e2bd395e45f8172dd71b8b161f24af88b1803b79f1daf07b3f8cb66af35eed48eba8b254327bf9b15852cd90fcb5c5997b44db5bfb4410a80543e15ef875ba8915f3c93fdd590f5b75f1006d0802ea37f8de53889975f69489bc585a5a6d695eaaa2c214afd82b048379683eea763fdd29bdb35eb1acc65b17f9cd0a7a72d8c1913e6bc47d8cd0a4a64383933af8559b4b1439dda073df959a55dde06a414d8bc47255eab122ceeda0d49f425ccb2b5a9111a0c708deac2f4e5193635b7d91df0539b855f76b6a61c9bfc8ad7aa19c8a082fc1ccf6e162024ec191c1924f50b265b279cd00449cf9b52e4929f2a7e2782360ee3a0b10bcadaaffa337f291cc2ec5b9891e5a9ddd7e5c74aea22dcbafe718bcdb4a8637b83e4959f1495f57a962ca27a096c0a24830062c9ee3e93d6a7a6297440cb9ccc54ff3bc7355aa4710c3d2cd4a03599b78f22d0a2c2142e0843e98beb2598729a78846b6188ed1b8b23468dd7d7d84853d7386e7777ee4c7491df1f29bfff5f722b6be50fd298810dd1646fde0fe6b1d411baf7c4c568a1cf1550a6458ac599c328f3384941a3db9101414b1adb0d1adc2f615a6d2b621d1003768842c9d1718850a6542b005c1f7acd2f63311a47e9b826fdc976b81bfc6670c14fab17cdcbc1d100c7a52b45e0e607fd5862ecc71994a159f6e825ead1a37de4d3833ece9eb35b82d3d36b349e4fc04af530d9630bfc1437e10880a32c80052fd37a99168eb529636b0736e2414ed4d3fdbb2d9ff2286eb8347fa5dab2e9204f2b51f7c4fb6f24515708379f100e76831b7cb298d0971a4323f7ac390a489d598ffd4e3512290a8bc0bab812c0f8117ba5a187ee14135942bcb08efd4a3fa90c6c13251e20e0612a040e6595cb8efd3b4a0252ed4151bee14e3fc4c5b782702bf8b5f1da48f03fd6a9c82a55bd7b55f5285a62478f5bde179b62dbc99c78e6b669d4b086b86fe6c7415fb18e6da606d74b0b07deb6ee42d18af710657c7f64fcc9b8489fee55440cecf89f3e132c7a836f62f79b8a8c0247a0a8902caf34d0753242f4135b7b02ea887b1331d54db08d7371d544f2b4363d7d78bb972eac984cd9b90da6c4e9fbd6f1688db8750288fccb3ec2f548466dfeb059912c9bb501d24303c5cfc5206beeafee192b7aecc96e9656801740efa11ba7a2d182c58df90d890b5e033e3502502c45b4af19e9ead4c7c99d44b8269fd9a72ed39af93d69b35da1dda0d9fec9bbf356badf068125342080e0b3acfa6b8fc27e5896e0a52dcafb1a0d4c56e3ae699f31370ad4ebe2f987950e132663011fac3b0286017d9282122df78143acfeed5c0993061afdf999b5af52c9927efbcadecf65bcc4008684b4bacfa5a6a5d1c708ea41f633eb369d19ac2cafe15b1932d723037790a589bf66dd986899f72353e48d064f2ff4e8407f1e0371f57771d0b301d75d2f8a265889b8aeb621f259edb86b867dfc9d64f1b9d43e24017764262a2a6942759fb6eaf15b07280d08edd7d7eca3b6f4e5161a7f9fd86cfc1adb5ec2524104a210b0bf2bfdaee1fd469c08cae1cf437db223f1e8f2e7281c8f151a8d482ede585a672f23b1adbf7c4fad450938c11fb306ea4040bc218a61cd509eca9f665a41566ea4a4fc0e058e68196782c05cb2aeb476ebfd3fabd98866269f64ae07746c692a7ff3d06c87faf2dce1eaf9f0dd9c9339a92cdef1b2f509ad25cd77647d8c5b85a32c3da86cc5eb436d7a5024c32b8473863ed9cbf80806407be8ce7d2e8bf1e675360a15f7764a1fdb944fc3f6bb8cec1115a4709ad3b745e7c7f01bdd962e5eab4713d0b58790604a6e0952493dc9748dde3fb46f7f608b399f99c3ff015b98eea6ab5cf00aa17986c73815ad666444ee308550eee24608a5b2256080e4003a244ad62ca29294a189981b8264934c74c680b1276681274663067aedde168319961debe7bdbe98a37bb938bb2b59ec0136f634a96d797dfd79ce74a0096fe561e11749e8616f678b859e5efaf4f18449853440921a23d6c755af1f08d5a555a21004d563cf31d4945bb2cd21c644db2924970cbbb0b8dfa4079fac22d8c2304607037d4161d043f2e9de84a65ffa6d303936b8473ddb36304b3876f81b8826aa8c987e706a0b7ea20dd91dbd7134ed6c6def0fc6b9c25417d9efcafd504b2184b4d5e3dc116ba060e6512b439c5e021176f41727a88625fa54c7d2dad44e2f4daae9f7dd5cf1644f1fec3803a462d8d6167d95757011baf38e92a3f94c0873f4e7f1c7e6a340de499532e498384bce0e0a8ea5853bcee2aeb04b2170e1c867aebc082934d59c13041d2a58693b0ff4c0610eb6519b24689d891d7a0d1a136b1d4b6887a2d6c9f505340907d46ba1825e789ba828c4058499cc5889852036e4676aae5cbd73110d70bdb8357a2f9a0bd0cc5edff2cbd51f60ecbb0e20c1fba8fd63124e0d8e46992330f0a06eff8d5f3772216ec142720e79d946dc3f423ec090d40a351b00c92dcc171f6fc977a9f6de430aaf889982e7ad82b3b8b81e9749ac1affa8de91727ba8c38986400f3dce7f81b586479d4b266dc89290ad56bfe4ab2d83b10afd1d68113bd71e4480b559b9fec5b170f04260b69dddccf984848f42ff0b18ca5e0778a045a015c254f617af8619751a874e1331a3dbb881e56a0b11ab78b9df7f6434d8dc4e953ca7a612b4b1257c1cedbfee6fb694ebbd72329420a4c644233b24dd0b88ca90728ba8c4b78eb9870b22f317e29b0729f0e4e5f36ad2546f0e7014fa576ec50c135ec82bd6aea4204f2a389b009955570cdbed7a25728eeae9154e595d2d23faee6e9c6f9ed21e31c59ed73bd1e2e17796046bf0f4781b418422ba0e6eee44614f8f520fbad8a68c5258d8b37abe51ee6b6831c51751e426aa9d86f0a9f58bb8aefb0846c3c8958596103a2cdcda03ee5f1d59659615c973dd25b136cfe15af187ff3c3cfbb288145b5c382410ae3a3939edd8f09863b7cbf8e0a56e0d96e3b5dbf453e328792a32ddb1c0e81915c3d06ae7d08540b93bc613581dcbfca2fbe2ad2549614e9fdfca6aca2da3b5f283c9fc514890f4e4556614b90e1d1f5fecba16c565c9258a0be586725ada110a5bfbea3a018a7d719aa9b50e6e1539769f8a88c84cc2387e84971a95f9265949a0018f547936bfb4315ef2af7f2844558912b61a1eec2883d2c9d124e4fd6ac0ba332ac486110c7eee71d5e58f5b81dcd9efa7fb0b0cf8e931d3513abfb49586c5e3a8bc88cc4413424eac89b409923ee047eaa7ddd2a21bab2789abba6a740e13b9efb72522c6d9a2b2308a5371080873b22a6437fb29a8bc5dc28458edafa835044bb57b07b03ec76f5a80e767676d4667a94891da3cf164677369d2185c74f2e12852e0f1385c3efe52c00cdb8fa58026fc79be51ec179ef4f59f292a83069aa3c7cece0b1a4d55614743d27bcb55208a9022370ad1478707a20422f1ba99f1d1c702051e5bc64b8ffa5d885e24c5d1097a848cc102bd0d6623576fab30ef7f86bed43ec9c84a0c10b6e46238c501be860f8245ef0f68c4f9c43835248ec42f274d900199ce6ab6da389d86f74c9a22a2dcaef455ba1411fdbb94c97704334343bb44ec975637f5bde8036c22eebb5959cac5595ec180a0d1006ec5573037e4a8794b111d9c0f836eb3477943ab724af50f25eeeab2176b9c5f999b90709fcfa440791da367dccc48e73497e93411969832168f3a077e909e6901fad5348aef68cc29b5be2e4bee7a1f4fbbe79a68ae667af96ac0369d60bb8fb83282acc266eead27419c5927a386048858ef3e3039732c91b7da15cc221242c891d7311412c1c567fb55d29eb47252899ac14c026d14fbcd005dcee193b4861</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> school </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces 训练总结</title>
      <link href="/posts/5da51cf3/"/>
      <url>/posts/5da51cf3/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="65195d48eb0de7e1cc1e06684c9d84920cab5f072b550996d7b59d9526681197">93024cf999deb8d8b2919f7e109263d4b9ff59e0556410c2db97fd68e70f496c522939b7acc745c5a773cf6f39a167e151c9f758e2fb1fa21e1733a8cf021a925ab259528ea6cb83a3845841150cb281b6bc47ff23ac6c6ee4726c2e6a317ba17c202960a436e1a24d66e69eb75abbdc9953eaa4e9f62038a3c2a3250e0c8d72147c6de13dd2706d3b2cad282a66ad4149516009763af4e935c408cbb04c8110a83a2befc80c5c495962ac662bb77a7a21f1520c2e41c3960499e11e777bd5fc6e4b735ca433876165a21fc94b0cb1201dec492cf5e0cf81cf02ff4877668afb27cad1951974c969ffa23f1176d77029762c8b7e20d88ad4a11806d5abc28726cb86acbe9656088919fcb744601b9ec91023dceff06d05b5015f591d966c4e02907e9c288c4c0ef91a47e3bb9ce2c0f4ae4dcd958f670f02a88646a7588c94921b1d7226508bb4ff230c22f994418abc454b72e764482723f19b1521499c272ccf62df2e690747e39b992721ee888fff92ae01326869d30244575c77b7ba99d750f8f7789225e8ff5cd393010cd50a3e477f77d8e6799f3935f882b34a0b0f42c01241591261e03bc20daad7b03318c36512497a57c58039557595dbf1c1735215ee341c168e9fd6f5d4f3bf354a9a9d680b7b8ab73f000996d991465b5ef3df2e9100c61370d7448ce64a1f31ed060b78e8d8ed8fa9301117043fd2274d7f82ddfec87127c21f6b0725b338f1ac2912f6fcf3d9f1bbeff15393b7baa4f391185dff399f6c9fe84662edaae109888ba7e5a6b1a263c777e04664429175d14c75719d5bfc16beaee1bb649cd7c4802efcbb4bbf8d8585ac82d6dac857dcf5d6d60fa2b6ca721b7aa034fbe1a96c669d60ee2bb18aa1209147918d36a7c85718db24ed3ceda169c688f2895c764340ac0e4ecabe27bf0cfc1b4a852f0d7cb94b4f6f63be6fe3a04218746fac2c78dc71b5f970176d83debff04c5596f9f0aa849b39a93c1f8e632d04217581fea61b15ba69b51750eb108dd39988804247ad459fdfb9bd5c113888644d08c5650d24ebc60549c9c1bd3c4ac0b39b2c6fc4ccd7cbef502500398349c4594e2f42c4562b4996d4f32f865b6a0093bde02504a84a0dbc26c2b47a4f3b27a43eb7a5b884d08188016f32403ebbc048bf731d62190dacc5b8f81ccfc4f9667458f022b53f9ee3b02c1c9a02080e6c9be571fa077177bfaecd2490d8b363694facf7aaf21c74a4c87fd5fd8bdd196dd266c64e712425b0e8c43a7649c3f406f7e25325bbc5848bf47ae81800f18aee4603447de9c2c5482aa49df592818a3ae16bbd787b3df1b976d11edfd322d07a27b12f0add02ce42a36246865bcd3899b5ea25a688576a80c67c7b7378190d11a3f00e5d255b63a91c408b781b277749bffa44998c8d173f864cb5ab3ac534ebdb0d4afd71e4be3afd29f74c1744ad7185e47d48d10f8b9150045d90301b73edef30fd863a30b611bd774efd4b46f4e4db06d687ec23305f819f6edb28d81c8accc27afbeeef8eae2f2bba7eaeff3799b52db2e9f0e49e81a7179a27de773a98564e0d19530979bbc7c6ffa5aa96859fb8454bf90ed491db1a04786dde6fd0b41d607d6af66393924607a7c4039bd81d2704464e2a1b8d03fd62a3ee1f74f6ff7f6cb63cb9f0c5de78553ce8ce5c6b64e7459d1a34281ca02a8b6c5b13484f07c874eb48b87f890263e373a63ca941a0b57bb70c0c63706749ca13db0cafdde6bbfc6fd24b401e23348df836ed7d6c4330ad172a5e2ec15b13638e4b75ff9a8544bf8ba7c5cee87c76d6965f4f2d70b09ee24ef74fb89213777da612583207f4611419f8cb78e1da7e83b9ae699591da1756985e39706ba2f963e9b04223cc6e0a28adb13f36b405184db0aded8c4f1182c7f7913e13d15779164801a746c9b33d8ac616a6ba897951eb959d8b1f4148d667b389dadcc11cfed1f856870575242b63d268b9534a9b0f24f601f8cd29cffb92b4fd98348f1589b1016b596c45bbab78f33ffa7520ec160c97768615f0f20065ddb2270d614ce96be7633c6bb6980f3b5735737b3596d3195d60edbd2f63e9ac4ee54ca7e2e2ce8e8802db1652b1430b62c42cf597b8d719948b53aba0c2d957610c2914022a4e068f489b20d5ba29826fd374de4ed7eb7dc6af1727dab4ba45b4ba5870065c47bf72d7af2a0c31b194005d393444eaa86a2ae009cfaf1c5d5596deb354ea7c0b1d10281bc2db53c3f184d9d52b4ded0c51ea95e4bc3f1372c1e08e798465b5265953cb759b7d6e02913fd83919893883043e8371e9cb743e7b40940f97af1ed111cf53aaaab33c8e3e0bbc167ba0f648f3db2a3f3d3c37b4edd7a782636d0f92654c8f8b7b41111fbcdcbcba747bd7db6abbec5c00f3fa0f8b09a422eb1cc6edb90639a77514e17651ae659985ab423591d5306f49202a9c9c4e0a48d6f136e12de7ec389a3f5232e999f2752a1d3966310cd79bc0e0da8a18abcb28adb8213a92a17ed528aedcc4f605f517b717c136b38147ad0de289c53505395cbff129eceea6f1794668717b0188cc11499a90500d342859cf7a2e823fc026718ccc76ddae5b4dfb0164348515a71de729e305bb513e22f52709fe5057e2decc0a4994ae0b41603408c7dac088675e20b8a783d396b68f1a2e70edf4d3e2832d68a4e2fafc689043627f9d18aa6e0e02f7d27326c54e766841fec0e5aa8fadce8898b54071e90d9585135bc4f0a3f5aff3656fbc57797c80265f431f2cd1e2f948e007e5330cbc1806e75b9e247b980a3abee90f6272316efacec64629a129965e54df02e805a6b7a233cb9433601a1667de57c0b256d78ec67e03732890e5203e06528356fd343c5f1441f0a2c2bb51b84fc854dc45fa3eff5006b21887c1f9df5c4ef8686608b407abc0e502cf1a01dd9ade7f0c09724a86a9756af605f9b2658a6ca766d529188eb25437dd2b561c1387b5ca67ec799eca1cc88ae6c4b6c6e9833e7aa65189630b523255ab421fb020880cdf2006f7d573863ddc657f1479e6390405808ef50a1dc023ec79f182962510ca531952346ebac6605eb007b3ba34da9a324c82792779bc81f6843a5abcb15f62f60ce5ff6275662f1698006020d345e6b771d326e49dfc847b61951b19b690ef7c7fd8255853bbd45620ef884d8483ead76d22ff59fc6631de75da3d67a3bc7377f88851721a6d738412b17326be5144f9ec59d94f03523c4d31a8d8bc20801624e0b8a44076f02db8c618326c10ba0e0381a00ade06711925a201ba493a7a7110d5c26a38432037c8a5b8c526e33387f9d99cbf8064917e0a8ab152acef5e344d94bb82345acceebf262ace0eb78292fd1e163e11c74cd9e04b130e2fcc0ea8a4996e0ed311d51c1376f6dc0f2195a9ea2351bb6e223b8ef277e3f18742a395a7ed4b3406919e3b9415b54bf9f103dd90922b7adb5b76d7851c0a1247212e026a0958f4d52c57ca5a03c6b2d88bddfef1c68028bc37b5a9ba7d4042b65fdc1998a2c5853350e45748e492ca38b7ea4b0b8577dcd5b684a6e0d54c5146c6410dfa4ac56af4dff69213aaa3efce55d71e19454926af0d7fde133f4898d96a2b7a0d7c65ba95594671b99a79e1a199b784c972874ef46cdfd293acb3d78b1882365bc39663fa2cc082ece46bfdc24ec62f3abf9e1efdfbe32f66df19e2ec9a327252ff56a66a5a8e22f6288c48cc1ab64480198bb50fbea7785455e75defa5ede24e644e9d38651646fd0232d492289a429b8773d1b9f79e5feef25790ff34d0bfc095f3511c34cc669a7e06bc7ba59440802971a113a6dab584eafb0c958d335eaae356bac3dd232df0a935a35669003c7be4c0add559515c870cc8d478926fbf9367aff961f7cef7b68332441b35828fb7a951ef256435f45309b2f8010df9619f07149f017b2d9f2415112e0a4d84b1b1634f26b47c93bd57f71b8520e1300f10616a42b4a757774fc5b1132a1e0ce0e351e91d2563769ef121d975c994d863325e50e6a751c2659f77c1c0178396dd8beb4308999f67d802b3f46bab57cd1d6f1ac9447bcaf0b5c2bf8fee1c88ea44e7e8db9d39cb2746260eb7ac1d31e9ee5a3117934988ff08278cac99b5476966f3b381654955f5f33fb2ccc7333d9978ca067843add599f901c40a9a0162f705f68c2d01e85d028bae99b23e24be77bad9155c04a14edcad662904383055928ef6ad25a9b8ebb8fcdc24622d794de7f24a1316bd908b417b306353dc5fb165ecb6da974fe143c93a7eb93b2fc6c84b3a2a598a398ba73cc91c4bf7739e56055137158c914eae44ba7e82b9a36d8f1764435386016abacf09ec83c8704a81f6d615f07b7ca668d3829f3972d218ce3e5601ad756e84b8693559f37f3884ecc55a85391521cd78a34545532eab1fa141b1ed23cced02e5c8ea36e8357dbb9a569db062658a8bad62254df675411d11a854049fa5812280ce0d92df22298151d6b18727ad9c3a7b1755f83877ce108ed154697817435085173b74f0c064bb8dd3e0a5590c98338c0d97b1feafbac899f616721a3b4ab0cc55c80da1b351eb3f8758f247fd3c11bfebc7ffe76cc946a9954ffdfb5f671db7c1e0fd69ed00b232d618d36069f81e14c6163f6db2f29141780a78cbbd87b161532ad58a476759845f0a884a50d1a37c1438d064da8d7565ad481bd0401e01110ec2df98bff166ae3019b7c14ca31090e28e2012e02ac5ef9af399cff9dae2cc78efd29ba093249e062516ecfbed387ca4e0bf59ff6a0014749c6a7c9a9b3a68785bbc3a3339c6695b43af4342d074c1ce69519b7709db785c034ba25fff61283cb3f19ca4786a26a652ff026572d8f1196cf7e80a1c6095b309910c45946d150ed57efd75b1fdfa561c988cc26bdc41d8595893cc474576b7943e3ea5926fd8b95339293c00ee77f34d62ce23dba670f74614b00d63e50ede8b575fd325d694b73281d425ac2c290c1cb4fa0ed3aba8cfa6b8af28601088d2ccee4470b16c6da2aa584717ace30af75212a81fc608485cff525f84c022b421324b119ebddd784be74b64c2b04725cd6f04b381333e947b6dfd194478c8d1d101191fe52b8c4f5bb2790edd17434c216876a77dbf9e26aeb0008ddd73493f0be6d94797e2764fca1846b7a63c592e2bde84663bb2f99c2179c5ac7d673293ba7268aa8e400450cc05bfcda9c8c27c9a94913bda6623022fd81b956aeb3beb249785ef2c6022901d48166640ba796c2b10d9eb79c0928c91a54a59cc82767f838ec3d2450b260db8ff52df21191a3af1f14941214d55d295dca4e644d11b258f57a9b2b738b998f9ec7cc9e67a3416bcd263db72e2ccd79a508c5d5fb972dfb7f305e3522b81f1cfe9f45323fb38b15a28f386c705a5cc33cc2b028c8fc6aa258e69f0f5738b0dce37fbfbcb9e58da726fdedc16749bce88ac3e01ed8432757a9565e07d8851d45a0228ef26c33a5bb99f29b79b06194e336773ff35ba066dd069633a78919677862649f0a057c480020578955c30fe9e1b906256acc9d5882d035d4ec761268ac4c05cb5726b713de9d17c0bec8daaf5b32dc026acb3bbae20b64241784e6ba414eb2eec06463c0ae98ed6517c9a4ead41b9cdd42291fae10eaa02395f9eb7ca597a63f94dd7e752204cfd7e82ec61f89c7578a24d26d34ea93f758e09870de27836befab7f4dcce589d2c9665f8e5819f180837fe144cec8ea6e57e036529ac759177a0707f7252417a3c226b9ab35d4f25a9ce7fe2827c3ae2f00af7d2a8e7e227b49c4d3998159b40015a331c4d57fd27ceab441e60d492db9968c98a83d4a1293c994c5cca6f7b155d8842f01e170b4fb0ea330bfa9d3c9370c5e4c40ae6a8072d524b6d8b38b468b70f8fdb2d3ef856eaabb9ce6f3bb7b209d1cbeed13b73644f925934840204f286a0ed738038ffda829f43cbf3858f9ee6f7ba01de1e50c9056407d8a36288df46f69cbb1262bc002c4b0de259c8ebca16aa1083b82d64cffb417e20c116a2bbc312e9f27d48209115cf3efb9097271f8a35d44dff133f1aca56b7e2d1567714ed358426a4efb13f3061163cf78198bb7a97f693461008b44718bec237b3d37d51ec538948bf0c3ccc7f589d8ecc8a1198ff8f19e7ded2e9a9be985fd231d5e56ca931857d80944b93d4dbf10dfccb59fea939d3ff0631fd4afe39a6060146430695c1534e453fa533a343c009219e23971662c93131eb9383fc815b313a69ed99c602e436df4fe4564e6fd73ec6b7bd6b106e85ba1b73c23ed56ddedc820dd772369744eebaa5a1a9ab98164cd5d2d09df304a52e03b3c07829e6b1246eeaf366730eb12573010b0efe5dda79cb8e69391590ea657d4397ea8d6c77ebd2472de09a14be607a43848c8a896f181790e11a20d32d99b6380508b9edb2ba7bcfd8f5789a6a442b7e3860c88596fe23ce210da20c82d7ed302c494f4a8efa7bad208e10ab77ca9d1979c3d34aa4a2c6085576f2f3b6eda7694ae29b0767f0d9c3d1e37702f8c4a019df1ca067b83c081b0346ecdd1ec2f265fe8e27456c1e6cbb47dec57aee4cc5c08891fa9eda933c1fe72d304eca2d958e9f492d02bcb676078e3c165b0f464edaed67abe11133696543ad952fb8dee0fc66869448045846985fa7a679725c6f469de5ee8b8afbe42ad524e7386e003ee7bf93bca62a8c018488ee458d76af7903c7f69d6d4a1985f9dfbe5bca67db2e52780924e9c66af239b46af05132a8e73a2c7d38b7de178c228abbdaa6247c1dcc260ccb0242f53ec8665aee2913d6b15b9fb2bfae17bb40794d4178f2407430f5c6df56f26b1807865a4dfaf1da8eb9161f16ca7315fed04741fa5a8fea91117aef3d253478406694b023cf2dc9540ec8c5beae6906ef9ac8ec7160f9f5d0c6c2e91d37ccee8dc0147f7ce4b5e3b055104dc77186e36b89610f6f01bad42d8a31e910c95655f601d5017fc539c4df30bbea6e0f3b226c9d28408519084b0a9ef63cf467db1bf4d2c817e3a5868876ffc1e751635508d2b8ac3f917e7e9beacbf687554f5bf20c43c6467b3860d1417da1cbc3c7b2f7adb0707685b993df78a2781a432418c8f9784b2c3c93f3bc62dabaa73de87adb8c4843589019f4a8e71796c683beede41ea9e0d4f913067814d1189336ef4d595633b105207438f4034b4aee99642b6babf69752211d069a07695a33b16cae79178f55cd13d5856eaa2dcd14427dd7ce06f24b8acd8efac4a7dc5d9aaff6772da2adc636900052fe223bbd9c77c6cdff4004701859a9ec4a0a15613032df2278c864391a49baafe2ec26a03b02baaf175c557fbf9f625de5c6e3762c348af9a24106d1688dea3eaa9bd219dc2e9d681b86656b3bc72c3e6156278a47184e3b3f97e095a790311219ad62271a7f522c0e12f8b3fc84d5216fcbcc70636a2bf43371592913d5b850e12b2593d147d085068edf2f11836705601b6e4edfec69672861e354e71a40a61e90256d387a3529b1db0a4d94344e86f426924c63fadc04b8f2dcea6aa2bba4af583725639e4e15bb330c016b5b0196fea2d34763f9a2b910deca7577bccdec71ebb69dd1e2bd195f16acc97f8dfb1de5dcf3af3931812d5ea9a3af29ea89d4d34297d7ca2f6b9b09c9a548599a9f59dc0fecde639ff9e56f025f1a5417d32a32a33ccda07583d0ffe97ba9c93f32a3b140323427fc58da023647410f3c55e56594df97cea086d0d09e075bf05f501fb0293f9eca8c128c06ed99c3cbf1deee3b31af1f5f49791c90ed492a8d5a7471496044e9609fbf4476d9b5c99d385b7dc3b2eedde38fe80f208918f0b73c20fb613a478da0c1a943fd2ba52490ead014ca6525e5e5848762a114b6d7de37e89ab796695c41b1018bc76fef2fd4ed6e138a093c34c253e6256689d82e6b656c565d03d64a206540c6be34018b669a6cc6fd5bbe0136269bb776cfbcde6753f6f6cbe6105823179811d6cc96baf3e26e6db2a943692fd733a08e602c1a01d9483642de400c90e5f0c0c2d40c3ed537f7f464ddca17d72f8891ebb05562617b70a742deae5b4fd8492e88081f274077913a5a49f32ba738c18b59dddf82d28b43ea1f9bcb89a4401bb55e31d39f57d3ec33bbb3403f6d6201f225ffad90dfe365a10422c1374010bc930497800ebb50d59683e683cdfa0d8f368448ef86b023e736f5f002691b1faa097239dece3fb40d3491cd4a036632780a5a1e0d3c9f440a165e40b77b5ddf99ba6069171c9cdfeae47b350b36895772eaabe0843cd50a77d537f53b18affa8a917a59ee20984d8f0716047fd4a1f90f5426471a705f70d9b5bf1b976d48d00c8b905d2108ada3313f33ae8c297da71504b943bf7c811896c4bad1dec43d56f50307d2aa97d8092e45583aa0bc80158928b943b128f2325ea84889035c3497f3a056d54f84f9ff9b8e8e586bb7587d5d69cf9c9b610b3b9073caaa4508e6264edcb3d35b0da3d4709059ac08a8b4a7610f5a233eed59ed873a916242b21f33c3068694b67cfc21371edd9383f08c9719261c74924ae38e318fc807a2c3f581facbd91d5db12973302be08dc8e4203a5bad6de867e94314d05507a696bc354918eee5de9351ba450665cf603bc61027909b17d21881bcab379e3ef9fd2f768490cc73eec39dbd358e6ed26f2a998209afa7cfe1d1f78760e095e3c9e16d2436fdc62442bcb516ef7d1794dfbcf3fb52ddfae364aaf791f326c71b05aca67c3b2208b6178769a5b3031e739dde8966eeee277a59b11bbcf13ad0c125bfd473ba9ba0566e4ef44369ab659407ba86f062b4ebe77f95435c3ae83dbffc29bdecb852d71bd30f825cd215afc8be842b5767be3830d48134640d9cf570540f4385811771192d99ce7d3ad8580e8dd5a98efcc14af6d5d6362a09bc8cba7f234d60f6a8cc6c571a4c75eaf8c31cdbeb0c576482e4da58f535eadf2bba87b1ed203efac9302113df8afe22c3fa9ca12bb0aa5786727dedb805ac90b3f58c9190df715e3d893174f284ac95f3f56d3fd8e9eca533d424d2f8ddb2f5ce56e857a4888e5c1bc8d5b580dd090bb68977a3c65b003a15c84e1ad2d0740e70a3322dd0b1aa6924bb8708f590ba7a2d9331b21e375205b06e6c1b533b23acfd7afb6cbb759d46eb51240cfa2eb4e09ccb3485984d11436da3a5b688466f3c2b1fc66880770aceabf18fed933ce8fd553075b4a02371cd4664f97f139ea301543fdeef0eea65e93b22eea982afa1d4a545d893b25ca6fd32d4313c7782fceb915e0147e28b82abf8a05813a183ee2c9c294dbb67998bc337e1aedfdacdba4671e3eb9125e59ab6fdd3594c655047eeb0d77e202fe5d773e9310dd857a4fc3a5c990537f08f874677996868cbed27ee1c516417f5b5408c8ac9174d776885b820979d1908dcf9b80bd90e400c515aac3ee1e2f513d28f727ad242344b5e9381469f9a64c07fc506cca4c79f7711cc7c4ebe1140b73774b1edf6e82f76e35b87cec865721fb6416b8b6c2ade6ce3d4d5dfe7e43aefa2068bdf1b89c93652e7d699c449853c408e50b25e3d6256b427deab43afd1ae0c49b633ddb634c575e6c9e771e8ee1bb6105c170d16f72eb2b2beacf43e24ed7ac6ce1fb7800e44a3ecd4d29d5b8873b1f32156454120e3d9465fd74b0afbeaa98a8c754f85590843b8e28b30a448d0716fc1be19d1037c0e5b4a2cad4a70fd3dc87bddbdc890712870452bc579fcfcfb92d01d725412ec3e857b4055017a87d4ea26dc3b8e38486b051163e6f800a27bf264486e4652711ffe72a7edb557688bd326135a63c4c63a2c223a990474106c3c0d5b2d1bf5dd0fd7c67a2fe8e0baef91dec820394809dc35a60307be8b43a6011e7b830aeb77849643571787ae2033488b6acacaca9d95adebddad9b25d103b28a827d30598f1493b6d139e5f12729dd3792c38a1dbda6afb4f55a19c742109f65e093262ce9bc9ee4eac0e7902cd91ac72a722e4370f2bfa1fad747d45069e13e9cb48b6a18a928cd3d9b10c0582efbcb1497ee5f328d849ef74ab09d47383f79dd86bb14532cc291c5591fac9e876612f3c84755b2760c6aa497bf5620ad882c47060baeab66c82150d359fea6ff166223fbd1450dd7e3c27d61066d62e5a9e40aa16344fcdc5201a8b9e95a9991093c76318b4a34f487a512756f13d9170f8fcb6b4ffcc8681f1793dccfbdb14479d719ed1fd973ffedab6d429e1fde70b8832d4ca120c52db70d85caef028a6ab7a2e7f6f74d3374495032aaaef2496232da85a135cb88a87f0c23456242eafd6ffb244222a9ee4a320ea5b174499a67fb8850c585f8b28d9076c2cbfb178ba45a0f9a52e5332dc86fdcf505e6e0a4874769b6cb318617979978becbe09e128116f50eb4ee3f6f573dff6e812ffa3cae9ee303214495b527c19ee71cdf03b1ca7c28132f0c9b5414981e47a08cea43a9b8fa9da16c11637e54c430244caa950c09a533b5600d3367da74663d6eb28b27b61d4acf10769f98b225dce9e28c57bb4ea21282c4c27510dd0dab6fb06ef791c3e4b618a843ca2f5474dbc87c818066b91a11ff6d8c167cba222e5785f0fd9f9f1e63b42400cc9f8cd86cd062390f75239f9d249720fe641358ab226b5a1c59481af37d8e87cc42f030845c04a32809bb285d9bd1addea817c8d398afd413f6e2c7a1ed1cfbd2ae35fe80ad3b7f7ba2dec3bcf4cba41df2a032ccef9545c6bd6935f8cb9e6ebd4737be3d393aa75e124fefa540069b5fbf69792d38b2178c3533e468a83bdee37d50588498a240f374fcdc04cd6d0e4795b7e82e4dc382e279de7d7bfaabb75863124fa80495f3b7858779362bc7e617d81facc4410cfdf171d1d73962592fd5f144741b8007bafa4cabe43ae6b6f2f7c0a37ec7ae3dc26d72174fc7fa49e8ce119d42a900bfd27b38c3aafcbce4d665fed3c2e2c62e03c36581c91aba609cd10d5901a4bc3cac3dee0da814aa09e72195a2a6b175f9aa6add397f4916294189595b5dd82dfff3ec706f4e41938dd9e5031c946b376be90d7eb62dc0c5ea54611cc3096fd59ea3e67b24529f008177bd3cabcba54ebc938074e14aa63569d2dfcfd154ba7dc880c498536cb342c01d6236838798ff395aef7cae5b34e73d49210a3b088ec0850ef862a561cbdd61d4de0595210f73234de2e1bb4e5c7a13ab3b1793d010e398c831f3d35a63976348f743f61b81503853e1d6cebe5184c7c28953758f3b16ce4c0922d3e514a12f97a6579d167c9337d07fb18e2cef8994702a42fcec06c2477a3729abee6eea53686fb2239dc945416ca11f7e613fe2a9d690f2dd19c7153e348ae667fadf8d27f25e337ac1084b851b6adb8e2d79acbc63ec7a96a795256010cf45568aad9ad6e2ba1ab584e59c4aa4e1dcc7cfa4fdb289793af072c00a54329e4162539bf9f94011a4a0c8d639f9fb0e7166d3fe1a59690319f0df3fa878ef485ea45ad2b3e8c74a55fc3c61f7bf87ec16eee54a94b496c26abf45f4663e12089282a922d6bbc54a6b6a901073095180a92a75c63394dd021233f59a89c4946fa349c015c3c4bb7d66ca49de95e9465b9dd0c9f382ba6a21c6271cf2a520174076f281018a68a14516bbcb32d5581b0f6769091245644622e856850b1345ff630ac27929aad35956875d3f21c2f4584406bd2a2dba4b11bbf1a10096bb1897e85f5cee73ae1d48309fe3254b3961d3ddf2cbb96fda1e251c02deda7363ecd6f61edbd2adc03db396dad7ade4feac4ad643ae7022e019a88dd180a16b1e3a8088f723e646c69655ae826cc0ef9d61d1f90813487662193bac58f77bd12b93b6c7e708b6f2ec6e7292c90154bfe983bf7b5240f5f7f70895e33c018fbea447f057969f7655fc651649fa845629ffd55034b6a75311e22ea4aaaec9196989e1c0a3ef99df37d047bee6acb527a3204691054747adc864d9f547dfcaefbeb8b8bf448d06c2a82fe741967bb1db4caff0af96c00460e4a0c8325576559af0d1df146046f9ec5228606de9bb116fb540859cf06ad64bf73ce42488cba9f14be71f37fc79a40f0e8d2ec8b751e2e86a957a0f3cf9ee1d6e63ffb3dc2eec7d94bb1af9b787d626bf8da3577ef3c59f819accfbf32b8b3e9dec0aab05e5be5651f577fc7031a5317aaa38ddd4c9841c967ef292179e128bd4812f00b1da78f69b46a4adcc6a58da2a871c1a0fdbd30ffaf17ab73e19a37b6a35ef5e77f9af8a764cc7fe192e2b6c27c715d5f7afc345efcc3d188940cf041991e1b99c610237998ce5fb0ca52145c0527e580de2534508b0a58a6febb48b4cec3a3e09f2801402600e73f940f41f47aa135e0869b83106729c883bbef920ffa454cf293837dbfe0b25b2d1f059882c4161af1419ec58a0792b4d00470c6376edaac0d36df56dccc81f92882b75befe39743718ff87cd28fa12f28bc2b4dc3c2f36bbf6094d472c6feae495388307c7fff89d0d73b6db5ca51e368bf4793a5975eef74f4ebbcd351959ba31f3cd8f253234f71e8bb2424b4affc7b51a1bbb5ca53c8166d0c190b8fabfe347663552888a83fdd86f62c84e1499b05ed7469960b4ad9ae72c9cfdbc5e5ba4a8d8c5cc5f165169cbcd55b6306a2b76f33c6a7b3f085f91e9302cc05729961135bb4087ddc552a89dbf9ce47f4a625f876a7a6ee509bee6c0f6a110213d8153f27658cd850cb38d307fd4ad6c1d8a1852b42676a2a2fe61904e09e31bd932095f5b3dfbf192ad93d735b72aaae481558f2a2bab78dd1af02c88aa4e8f60be199d6addcfbfa39f72467ea43c6879050acf69a73a8fe9d3c11d55f74f40059e41202c38d4fde34d5a05825de4a20e70b996d6a59e1eb515976de5d2be1e16313da9bd973183445f04c281798595a2efeef8b1dd0d1ed8f11f85fc046d35a81f13dca82778e0be21d17daa6206f75ca3479c6b433cb10432ca1d4c363b9b3e3dd59308562ba3ddec76000dd4e2efd64f24ed02f79ff4aaedcf34cdc50a6f721baf0a3cf2ed6e22b5ab25e90529bf1fbf7231bb9b3a57ee92cacdd27168779dcab55df868bc0a8f586888ff4d072511d300ffafb050183b3c774027662c114a287c8f820936d16cca2ca782b5442ae6b07f4ee22a977838e8eba98e656c5d160201c07dd7d37f593c73c3f933d5d5701e4f5250d3cdcab5940ab7359a5a3e4267186631b88f3805a17f95b17b074e1273a2286e22ae4d6aadda9f4b701de2ed10db1529a894c092427ce54d3f22ee01741697a1637bb9edefd68ea6b73ba9ab71804a49362901f89aa8f5e1ee0023d34f6b4911929f5e0691ff9e7f9aa88155a31ea44c1562da7ef4c93a94e28bb13ac7f9dee7f41cf87dae46e638ae7a32510dfcd5f4f197acf95563777a449b3dd207b6fb597691f3e83be0be473d1fba0d61adae510ce5b0477a5176594baf0c5e68f061aebf5a3c7ba194abd7612fe7815ebd59282ea019a0a03d9b123abfa6f0c3e33229d4c5bf7740ec21dd7a773eb9d21db03d6d26f3f52405efcfeb1bda0c9fdabc7de54b20dd21da8676fc430db8b9c49ed4e0bfcfa272bd072d9ca0b747db4e4924982e9b944458ce3ee215857ec3c8472366e89e9e2b4ae27795e7303daa08e4a9be1a9e2a22e59650b54d3ad68011fe147998edb0e1fec45ada35cbd2556bbef677b4256fb4546dc049c6e408fd4df92387a8ca18150139636860c2679fe6629c5b67f0c284601d289bcf0c512ed5e375d2f2113ebab5507ab4a635a959a9c373d3197839571ae68f9210973650f459d2d12b7c8537323f8c7acf96126d3079f313f90dfc76d3e169ffee9c8a558775f1de0ae601b10df5e8e7ab635fa0293ea3f65de72036cdc004503b0ab1cf3a4b481914b1fbd5b85598e6d7ecd7045190454cddf9cecde3290b8b081c8cf14ce1efefe62b8044e32fcaf52c6da2b3c8b30daa473960309c3d3570cdc4009dca9aad8403d3bf1ad4f7e03d6860ad1bf8baa6a63faddb381ee329089e1c7c3705aad690444adc14de74424a2436140000c84c74a9df20de6fa3bb5ac2546b1ce1954ac25305f20d7ddacbf6a74510cfc070e6f168250d21bf7334e92b759cfb0532d2cff15daa56e6cf737192e195a2bb9d385e27944d4f93882ee78e7a6f41eefe959d4d5409b5596fef26</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> school </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自然数的 k 次幂求和</title>
      <link href="/posts/31a2dedc/"/>
      <url>/posts/31a2dedc/</url>
      
        <content type="html"><![CDATA[<h2>简介</h2><p>自然数的 <span class="math inline">\(k\)</span> 次幂求和，顾名思义，即求：</p><p><span class="math display">\[S_k(n) = \sum_{i=1}^{n} i^k\]</span></p><h2>待定系数法</h2><p>我们观察几组式子：</p><p><span class="math display">\[\begin{align*}S_1(n) &amp;= \frac{n(n+1)}{2} \\ S_2(n) &amp;= \frac{n(n+1)(2n+1)}{6}\\ S_3(n) &amp;= \frac{n^2(n+1)^2}{4} \\ S_4(n) &amp;= \frac{n(n+1)(2n+1)(3n^2+3n-1)}{30} \\ \end{align*}\]</span></p><p>总结规律，我们可以大胆猜想，<span class="math inline">\(S_k(n)\)</span> 的求和公式应该是一个 <span class="math inline">\(k+1\)</span> 次多项式。</p><p>所以可以直接列出 <span class="math inline">\(k+1\)</span> 个方程，解线性方程组。</p><p>证明在下一节给出。</p><h2>差分法</h2><p>可以得到： <span class="math display">\[S_k(n) = \frac{1}{k+1} \left[ (n+1)^{k+1} - 1 - \sum_{j=0}^{k-1} \binom{k+1}{j} S_j(n) \right]\]</span></p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>考虑相邻整数的 <span class="math inline">\(k+1\)</span> 次幂差：</p><p><span class="math display">\[(m+1)^{k+1} - m^{k+1} = \sum_{j=0}^k \binom{k+1}{j} m^j\]</span></p><p>对 <span class="math inline">\(m\)</span> 进行求和：</p><p><span class="math display">\[\sum_{m=1}^n[(m+1)^{k+1} - m^{k+1}] = \sum_{m=1}^n \sum_{j=0}^k \binom{k+1}{j} m^j\]</span></p><p>左边易得：</p><p><span class="math display">\[(n+1)^{k+1} - 1\]</span></p><p>右边变换：</p><p><span class="math display">\[\begin{align*}&amp;\sum_{m=1}^n \sum_{j=0}^k \binom{k+1}{j} m^j \\=&amp;\sum_{j=0}^k\binom{k+1}{j}\sum_{m=1}^nm^j\\=&amp; \sum_{j=0}^{k} \binom{k+1}{j} S_j(n)\end{align*}\]</span></p><p>因此得到恒等式：</p><p><span class="math display">\[\sum_{j=0}^{k} \binom{k+1}{j} S_j(n) = (n+1)^{k+1} - 1\]</span></p><p>分离 <span class="math inline">\(S_k\)</span>：</p><p><span class="math display">\[\begin{align*}\binom{k+1}{k} S_k(n) + \sum_{j=0}^{k-1} \binom{k+1}{j} S_j(n) &amp;= (n+1)^{k+1} - 1\\(k+1) S_k(n) &amp;= (n+1)^{k+1} - 1 - \sum_{j=0}^{k-1} \binom{k+1}{j} S_j(n)\end{align*}\]</span></p><p>因此：</p><p><span class="math display">\[S_k(n) = \frac{1}{k+1} \left[ (n+1)^{k+1} - 1 - \sum_{j=0}^{k-1} \binom{k+1}{j} S_j(n) \right]\]</span></p></div></details><p>这样我们不仅得到了一条递推式，还证明了 <span class="math inline">\(S_k(n)\)</span> 的求和式是一个 <span class="math inline">\(k+1\)</span> 次多项式。</p><p>直接递推，复杂度 <span class="math inline">\(k^2\)</span>。</p><p>还可以用分治 FFT，复杂度 <span class="math inline">\(O(k\log^2 k)\)</span></p><h2>拉格朗日插值</h2><p>我们知道 <span class="math inline">\(S_k(n)\)</span> 的求和式是一个 <span class="math inline">\(k+1\)</span> 次多项式，当然可以用 <span class="math inline">\(k+2\)</span> 个点进行插值。</p><p>取 <span class="math inline">\((0,S_k(0)), (1,S_k(1)), \cdots, (n,S_k(k+1))\)</span> 作为 <span class="math inline">\(k+2\)</span> 个点，得：</p><p><span class="math display">\[S_k(n) = \sum_{i=0}^{k+1}S_k(i)\prod_{i\neq j}\frac{n-j}{i-j}\]</span></p><p>暴力是 <span class="math inline">\(k^2\)</span> 的，考虑优化。</p><p>分别考虑积的分子与分母。</p><p>对于分母，考虑 <span class="math inline">\(i\)</span> 已确定：</p><p><span class="math display">\[\begin{align*}&amp;\frac{1}{\prod_{i\neq j}(i-j)} \\=&amp;\frac{1}{i(i-1)(i-2)\cdots1\times(-1)\cdots(k+2-i-1)(k+2-i)} \\=&amp;(-1)^{k+2-i}\frac{1}{i!(k+2-i)!}\end{align*}\]</span></p><p>预处理阶乘与逆元即可。</p><p>对于分子:</p><p><span class="math display">\[\begin{align*}&amp;\prod_{i\neq j}(n-j)\\=&amp;n(n-1)\cdots\{n-(i-1)\}\{n-(i+1)\}\cdots\{n-(k+2)\}\\=&amp;\left\{\prod_{j=1}^{i-1}(n-j)\right\}\left\{\prod_{j=i+1}^{k+2}(n-j)\right\}\end{align*}\]</span></p><p>维护 <span class="math inline">\(n-j\)</span> 的前缀积和后缀积即可。</p><p>复杂度 <span class="math inline">\(O(k\log V)\)</span>，<span class="math inline">\(\log V\)</span> 是逆元复杂度，也可以 <span class="math inline">\(O(n)\)</span> 预处理优化。</p><h2>伯努利数</h2><p>有公式：</p><p><span class="math display">\[S_k(n) = \frac{1}{k+1}\sum_{i=0}^k\binom{k+1}{i}B_in^{k+1-i}\]</span></p><p>其中 <span class="math inline">\(B_i\)</span> 是伯努利数，定义为：</p><p><span class="math display">\[B_n = \begin{cases}1 &amp; n=0 \\-\frac{1}{2} &amp; n=1\\-\sum_{k=0}^{n-1}\binom{n}{k}B_k\frac{1}{n-k} &amp; n\equiv 0 \pmod 2\  \text{且}\ n&gt;1\\0 &amp; \text{otherwise}\end{cases}\]</span></p><blockquote><p>作者太菜了不会证明，可以参考 <a href="https://oi-wiki.org/math/combinatorics/bernoulli/">OI-Wiki</a></p></blockquote><h2>第一类 Stirling 数</h2><p>这次我们对 <span class="math inline">\(S_k(n)\)</span> 多加一个 <span class="math inline">\(0\)</span>，即：</p><p><span class="math display">\[S_k(n) = \sum_{i=0}^k i^k\]</span></p><p>根据第一类 Stirling 数定义：</p><p><span class="math display">\[\binom{n}{k} = \frac{\prod_{i=n-k+1}^n i}{k!} = \frac{1}{k!}\left[\sum_{i=0}^k(-1)^{i+k}{k\brack i} n^i\right]\]</span></p><p>变形得：</p><p><span class="math display">\[n^k ={\sum_{i=0}^{k-1}(-1)^{i+k}{k\brack i}n^i}-k! \binom{n}{k}\]</span></p><p>累加求和：</p><p><span class="math display">\[\begin{align*}S_k(n) &amp;= \sum_{j=0}^n\left[k!\binom{j}{k} - \sum_{i=0}^{k-1}(-1)^{i+k}{k\brack i} j^i\right]\\&amp;=k!\sum_{j=0}^n\binom{j}{k} - \sum_{i=0}^{k-1}(-1)^{i+k}{k\brack i}\sum_{j=0}^n j^i\end{align*}\]</span></p><p>上指标求和：</p><p><span class="math display">\[S_n(k) = \frac{\prod_{i=n-k+1}^{n+1} i}{k+1}-\sum_{i=0}^{k-1}(-1)^{i+k}{k\brack i}S_i(n)\]</span></p><p>预处理 <span class="math inline">\(O(k^2)\)</span>，询问 <span class="math inline">\(O(k^2)\)</span>。</p><p>但是不用除法。</p><h2>第二类 Stirling 数</h2><p>考虑这样一个式子：</p><p><span class="math display">\[ i^k = \sum\limits_{j=0}^k \begin{Bmatrix}k\\j\end{Bmatrix}\dbinom{i}{j}j!\]</span></p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p><span class="math inline">\(i^k\)</span> 可以看成将 <span class="math inline">\(k\)</span> 个互不相同的球放进 <span class="math inline">\(i\)</span> 个互不相同的盒子里。</p><p>那么枚举现在有 <span class="math inline">\(j\)</span> 个非空的盒子，自然乘上 <span class="math inline">\(\begin{Bmatrix}k\\j\end{Bmatrix}\dbinom{i}{j}\)</span>，因为这样是无序的，所以乘上 <span class="math inline">\(j!\)</span> 才是有序的。</p></div></details><p>考虑求 <span class="math inline">\(S_k(n)=\sum_{i=1}^n i^k\)</span>，即为：</p><p><span class="math display">\[\begin{align*}&amp;\sum_{i=1}^n \sum\limits_{j=0}^k \begin{Bmatrix}k\\j\end{Bmatrix}\dbinom{i}{j}j!\\=&amp;\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\sum\limits_{i=1}^n\dbinom{i}{j} \\=&amp;\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\binom{n+1}{j+1}\\=&amp;\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}\dfrac{(n+1)!}{(j+1)(n-j)!}\\=&amp;\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}\dfrac{\prod_{i=n-j+1}^{n+1}i}{(j+1)}\end{align*}\]</span></p><p>预处理斯特林数，还要注意 <span class="math inline">\(j+1\)</span> 在 <span class="math inline">\(P\)</span> 下不一定存在逆元，但分子的某个数一定可以整除它。</p><p>预处理 <span class="math inline">\(O(k^2)\)</span>，询问 <span class="math inline">\(O(k)\)</span>。</p><p>也不用除法。</p>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++11 的多线程</title>
      <link href="/posts/151b1912/"/>
      <url>/posts/151b1912/</url>
      
        <content type="html"><![CDATA[<h2>多线程编程</h2><p>多线程编程，并发编程的一种，即在同一个进程中执行多个线程，每个线程都有独立的栈、指令计数器，但共享同一个内存空间（堆、全局变量等），可以让程序在多核 CPU 上并行执行，从而更快更高效喵！。</p><p>但是由于缺少系统的保护机制，多线程编程容易出现数据竞争和死锁等问题。</p><h2>C++11 中的多线程</h2><div class="note info flat"><p>编译器版本：Clang 21.1.1</p></div><div class="note info flat"><p>C++ 标准：C++11</p></div><p>多线程在 C++11 被引入，其工具集在 C++11 已经比较完善，主要分为五个板块：</p><ol type="1"><li>线程管理：<code>thread</code></li><li>互斥锁：<code>mutex</code></li><li>线程同步：<code>condition_variable</code></li><li>原子操作：<code>atomic</code></li><li>异步操作：<code>future</code> 和 <code>async</code></li></ol><h2>thread 线程类</h2><p><code>std::thread</code> 单个执行线程的类，用于创建和管理线程。</p><p><strong>构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::thread t1; <span class="comment">//  默认构造函数，默认不执行</span></span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(func, arg1, arg2)</span></span>; <span class="comment">//  构造函数，传入函数和参数，执行线程</span></span><br></pre></td></tr></table></figure><p><strong>成员函数</strong></p><ul><li><code>join()</code>：等待线程执行结束，阻塞当前线程，直到线程执行结束。</li><li><code>detach()</code>：将线程与 <code>thread</code> 对象分离，允许线程独立执行（守护线程）。</li><li><code>joinable</code>：检查线程是否可被 <code>join()</code>，即在运行且未被分离。</li><li><code>get_id()</code> ：获取线程的唯一标识符。</li><li><code>hardware_concurrency()</code>：静态函数，返回系统硬件支持的并发线程数。</li></ul><h2>mutex 互斥锁类</h2><p><code>std::mutex</code> 保护共享数据，防止多个线程同时访问导致数据竞争。</p><h3>std::mutex</h3><p>最基本的互斥锁，不可递归锁定。</p><p><strong>成员函数</strong></p><ul><li><code>lock()</code>：获取互斥锁，如果互斥锁已经被其他线程锁定，则阻塞当前线程，直到互斥锁被释放。</li><li><code>try_lock()</code>：尝试获取互斥锁，如果互斥锁已经被其他线程锁定，则立即返回 <code>false</code>，否则获取锁并返回 <code>true</code>。</li><li><code>unlock()</code>：释放互斥锁。</li></ul><h3>std::recursive_mutex</h3><p>允许同一线程多次锁定同一个互斥锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::recursive_mutex rec_mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursive_function</span><span class="params">(<span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lock</span><span class="params">(rec_mtx)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (depth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">recursive_function</span>(depth - <span class="number">1</span>); <span class="comment">// 可以递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>std::timed_mutex</h3><p>带超时功能的互斥锁。</p><p><strong>成员函数</strong></p><ul><li><code>try_lock_for(const chrono::duration&lt;Rep, Period&gt;&amp; timeout_duration)</code>：尝试获取互斥锁，如果互斥锁已经被其他线程锁定，则在指定时间内阻塞当前线程，直到互斥锁被释放或超时，成功获取锁返回 <code>true</code>，超时返回 <code>false</code>。</li><li><code>try_lock_until(const chrono::time_point&lt;chrono::system_clock, chrono::duration&lt;Rep, Period&gt;&gt;&amp; timeout_time)</code>：尝试获取互斥锁，如果互斥锁已经被其他线程锁定，则在时间点之前阻塞当前线程，直到互斥锁被释放或超时，成功获取锁返回 <code>true</code>，超时返回 <code>false</code>。</li></ul><h3>std::lock_guard</h3><p>RAII 风格的锁管理器，构造时锁定，析构时自动解锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 代码块 </span></span><br><span class="line">&#125;<span class="comment">// 自动解锁</span></span><br></pre></td></tr></table></figure><h3>std::unique_lock</h3><p>更灵活的锁管理器，可以选择手动锁定和解锁，也可以选择超时时间。</p><p><strong>成员函数</strong></p><ul><li><code>lock()</code>：手动锁定互斥锁。</li><li><code>try_lock()</code>：尝试手动锁定互斥锁，如果互斥锁已经被其他线程锁定，则立即返回 <code>false</code>，否则获取锁并返回 <code>true</code>。</li><li><code>unlock()</code>：手动解锁互斥锁。</li><li><code>release()</code>：释放所有权，不解锁。</li><li><code>defer_lock</code>：创建但不锁定互斥锁。</li><li><code>adopt_lock</code>：接管已加锁的互斥量，避免重复加锁。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx1, mtx2;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1, std::defer_lock)</span></span>; <span class="comment">// 创建，但不锁定</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2, std::defer_lock)</span></span>; <span class="comment">// 创建，但不锁定</span></span><br><span class="line">    lock<span class="number">1.l</span>ock(); <span class="comment">// 手动锁定 mtx1</span></span><br><span class="line">    lock<span class="number">2.l</span>ock(); <span class="comment">// 手动锁定 mtx2</span></span><br><span class="line">    <span class="comment">// 也可使用 std::lock(lock1, lock2) 一次性锁定</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">    lock<span class="number">1.</span><span class="built_in">unlock</span>(); <span class="comment">// 手动解锁 mtx1</span></span><br><span class="line">&#125; <span class="comment">// 自动解锁 mtx2</span></span><br></pre></td></tr></table></figure><h2>condition_variable 条件变量类</h2><ul><li>允许一个或多个线程等待某个条件成立。</li><li>其他线程可以通过 <code>notify_one()</code> 或 <code>notify_all()</code> 来唤醒等待的线程。</li><li>等待线程会自动释放锁，进入阻塞状态，直到被唤醒并重新获得锁。</li></ul><p><strong>成员函数</strong></p><ul><li><code>wait(lock)</code>：使当前线程阻塞，直到被通知。</li><li><code>wait(lock,pred)</code>：使当前线程阻塞，直到被通知且 <code>pred()</code> 返回 <code>true</code>。</li><li><code>notify_one()</code>：通知一个等待线程。</li><li><code>notify_all()</code>：通知所有等待线程。</li><li><code>wait_for()</code>：等待指定时间，直到被通知且条件满足或者超时，条件满足返回 <code>true</code>，超时返回 <code>false</code>。</li><li><code>wait_until()</code>：等待到指定时间点，直到被通知且条件满足或者超时，条件满足返回 <code>true</code>，超时返回 <code>false</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知消费者</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> !q.<span class="built_in">empty</span>(); &#125;); <span class="comment">// 等待队列非空</span></span><br><span class="line">        <span class="type">int</span> val = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>atomic 原子操作类</h2><p>用于在多线程环境中执行无锁的原子操作，从而避免数据竞争并提升性能。</p><p><strong>构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">void</span>*&gt; <span class="title">ptr</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>成员函数</strong></p><ul><li><code>load()</code>：获取原子变量的值。</li><li><code>store()</code>：设置原子变量的值。</li><li><code>fetch_add()</code>：将原子变量的值加上指定值，并返回原值。</li><li><code>fetch_sub()</code>：将原子变量的值减去指定值，并返回原值。</li><li><code>exchange()</code>：交换值并返回原值。</li><li><code>compare_exchange_strong(expected, desired)</code>：如果当前值等于 <code>expected</code>，则将原子变量的值设置为 <code>desired</code>，并返回 <code>true</code>；否则，返回 <code>false</code>。</li><li><code>compare_exchange_weak(expected, desired)</code>：基本同 <code>compare_exchange_strong</code>。</li></ul><details class="toggle" ><summary class="toggle-button" style="">`strong` 和 `weak` 的区别</summary><div class="toggle-content"><div class="note warning flat"><p>某些平台的硬件指令（如 ARM）在实现 CAS 时可能会偶尔失败，即使值匹配。</p></div><p><code>compare_exchange_strong</code> 不允许虚假失败；但 <code>compare_exchange_weak</code> 允许，即值相同也可能失败，但同时性能更高。</p><p>所以 <code>compare_exchange_strong</code> 比较适合用于确保原子操作的成功，而 <code>compare_exchange_weak</code> 适合用于提升性能（在循环中使用）。</p></div></details><p><strong>内存序</strong></p><p>在多线程程序中，编译器和 CPU 为了优化性能，可能会对指令进行重排，这意味着你写在前面的代码，可能在执行时被放到后面，或者被其他线程看到的顺序不同。</p><p>内存序（memoryorder）就是用来控制这种重排行为的机制，确保线程之间的操作顺序符合预期。</p><table><thead><tr class="header"><th style="text-align: center;">内存序</th><th style="text-align: center;">同步相关</th><th style="text-align: center;">重拍相关</th><th style="text-align: center;">应用场景</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>memory_order_relaxed</code></td><td style="text-align: center;">不同步</td><td style="text-align: center;">允许重排</td><td style="text-align: center;">高性能计数器、无依赖场景</td></tr><tr class="even"><td style="text-align: center;"><code>memory_order_acquire</code></td><td style="text-align: center;">同步之前写入</td><td style="text-align: center;">禁止后面的重排到前面</td><td style="text-align: center;">读取标志位后读取数据</td></tr><tr class="odd"><td style="text-align: center;"><code>memory_order_release</code></td><td style="text-align: center;">同步之后读取</td><td style="text-align: center;">禁止前面的重排到后面</td><td style="text-align: center;">写入数据后设置标志位</td></tr><tr class="even"><td style="text-align: center;"><code>memory_order_acq_rel</code></td><td style="text-align: center;">同步前后</td><td style="text-align: center;">双向禁止重排</td><td style="text-align: center;">读写结合的同步点</td></tr><tr class="odd"><td style="text-align: center;"><code>memory_order_seq_cst</code></td><td style="text-align: center;">同步所有线程</td><td style="text-align: center;">全局顺序一致</td><td style="text-align: center;">默认，最安全但性能差</td></tr></tbody></table><h2>async 异步操作类</h2><p>标准库引入了一整套用于 <strong>异步操作</strong> 的类和机制，使得多线程编程更加现代化和易用。</p><h3>std::async</h3><p>异步执行函数，返回 <code>std::future</code>。</p><p><strong>构造函数</strong></p><ul><li><code>std::launch::async</code>：立即在新线程中执行。</li><li><code>std::launch::deferred</code>：延迟执行，直到 <code>std::future::get()</code> 被调用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;T&gt; f = std::<span class="built_in">async</span>(std::launch::deferred, func, arg1, arg2);</span><br><span class="line"></span><br><span class="line">f.<span class="built_in">get</span>(); <span class="comment">// 阻塞，直到结果可用</span></span><br></pre></td></tr></table></figure><h3>std::future</h3><p>提供对异步操作结果的访问，表示一个尚未完成的异步操作的结果。</p><p><strong>成员函数</strong></p><ul><li><code>get()</code>：等待异步操作完成，并返回结果。</li><li><code>wait()</code>：等待异步操作完成。</li><li><code>wait_for()</code>：等待指定时间，直到异步操作完成或超时。</li><li><code>valid()</code>：检查异步操作是否有效。</li><li><code>get_future()</code>：从 <code>promise</code> 或 <code>packaged_task</code> 获取 <code>std::future</code> 对象。</li></ul><h3>std::promise</h3><p>存储值或异常，供 <code>std::future</code> 读取。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt; prom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">perform_calculation</span>();</span><br><span class="line">        prom.<span class="built_in">set_value</span>(result); <span class="comment">// 设置结果</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        prom.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>()); <span class="comment">// 设置异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>(); <span class="comment">// 获取 future</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(producer, std::ref(prom))</span></span>;</span><br><span class="line"></span><br><span class="line">fut.<span class="built_in">get</span>(); <span class="comment">// 阻塞直到结果可用</span></span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><h3>std::packaged_task</h3><p>将可调用对象包装为异步任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(compute)</span></span>;</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; fut = task.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在单独线程中执行</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task), <span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> result = fut.<span class="built_in">get</span>();</span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><h2>实用函数</h2><ul><li><code>sleep_for()</code>：使当前线程睡眠指定时间。</li><li><code>sleep_until()</code>：使当前线程睡眠到指定时间点。</li><li><code>yield()</code>：让出当前线程的执行权。</li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL</title>
      <link href="/posts/3006dc10/"/>
      <url>/posts/3006dc10/</url>
      
        <content type="html"><![CDATA[<h2>简介</h2><p>C++ 标准模板库（Standard Template Library，STL）是一套功能强大的 C++ 模板类和函数的集合，它提供了一系列通用的、可复用的算法和数据结构。</p><p>STL 分为多个组件，包括容器（Containers）、迭代器（Iterators）、算法（Algorithms）、函数对象（Function Objects）和适配器（Adapters）等。</p><p>使用 STL 的好处:</p><ul><li>代码复用：STL 提供了大量的通用数据结构和算法，可以减少重复编写代码的工作。</li><li>性能优化：STL 中的算法和数据结构都经过了优化，以提供最佳的性能。</li><li>泛型编程：使用模板，STL 支持泛型编程，使得算法和数据结构可以适用于任何数据类型。</li><li>易于维护：STL 的设计使得代码更加模块化，易于阅读和维护。</li></ul><h2>容器</h2><h3>vector</h3><p>vector 是 STL 中的动态数组容器，定义在 <code>&lt;vector&gt;</code> 头文件中。</p><p>特性：</p><ul><li>随机访问：支持随机访问，可以快速访问任意位置的元素。</li><li>动态数组：可以动态扩容，可以根据需要增加或减少元素。</li><li>连续存储：支持连续内存存储，便于与 C 风格数组交互。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;        <span class="comment">// 空 vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;    <span class="comment">// 10 个默认值为 0 的 vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 10 个值为 1 的 vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(v2)</span></span>;   <span class="comment">// 拷贝 vector v2</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(v<span class="number">2.</span>begin(), v<span class="number">2.</span>end())</span></span>; <span class="comment">// 利用范围构造函数</span></span><br></pre></td></tr></table></figure><p>注：vector 的构造函数默认为空。</p><p><strong>成员函数</strong></p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">插入删除</button><button type="button" class="tab">访问元素</button><button type="button" class="tab">容量</button><button type="button" class="tab">迭代器</button></div><div class="tab-contents"><div class="tab-item-content active"><ul><li><code>push_back(const T&amp; x)</code>：在 vector 的末尾添加一个元素，<span class="math inline">\(O(1)\)</span>。</li><li><code>pop_back()</code>：删除 vector 的最后一个元素，<span class="math inline">\(O(1)\)</span>。</li><li><code>insert(iterator pos, const T&amp; x)</code>：在指定位置的前面插入元素，<span class="math inline">\(O(n)\)</span>。</li><li><code>insert(iterator pos, size_type n, const T&amp; x)</code>：在指定位置的前面插入 <span class="math inline">\(n\)</span> 个值为 <span class="math inline">\(x\)</span> 的元素，<span class="math inline">\(O(n)\)</span>。</li><li><code>erase(iterator pos)</code>：删除指定位置的元素，<span class="math inline">\(O(n)\)</span>。</li><li><code>clear()</code>：清空 vector，<span class="math inline">\(O(n)\)</span>。</li><li><code>swap(vector&amp; x)</code>：交换两个 vector 的内容，大小和容量均可，<span class="math inline">\(O(1)\)</span>。</li><li><code>assign(size_type n, const T&amp; x)</code>：将 vector 的所有元素赋值为 <span class="math inline">\(x\)</span>，<span class="math inline">\(O(n)\)</span>（会先清空 vector，但容量只增不减，其他 <code>assign</code> 同理）。</li><li><code>assign(iterator first, iterator last)</code>：用 <span class="math inline">\([first, last)\)</span> 填充 vector，<span class="math inline">\(O(n)\)</span>。</li><li><code>assign({initializer_list&lt;T&gt; il})</code>：将 initializer_list 的内容赋值给 vector，<span class="math inline">\(O(n)\)</span>。</li></ul></div><div class="tab-item-content"><ul><li><code>operator[]</code>：下标访问，不检查越界，<span class="math inline">\(O(1)\)</span>。</li><li><code>at(size_type n)</code>：访问指定位置的元素，检查越界，越界时会抛出异常，<span class="math inline">\(O(1)\)</span>。</li><li><code>front()</code>：访问 vector 的第一个元素，<span class="math inline">\(O(1)\)</span>。</li><li><code>back()</code>：访问 vector 的最后一个元素，<span class="math inline">\(O(1)\)</span>。</li></ul></div><div class="tab-item-content"><ul><li><code>size()</code>：返回 vector 的元素个数，<span class="math inline">\(O(1)\)</span>。</li><li><code>empty()</code>：判断 vector 是否为空，<span class="math inline">\(O(1)\)</span>。</li><li><code>capacity()</code>：返回 vector 的容量，<span class="math inline">\(O(1)\)</span>。</li><li><code>reserve(size_type n)</code>：<strong>增加</strong> vector 的容量至 <span class="math inline">\(n\)</span>。如果当前容量小于 <span class="math inline">\(n\)</span>，无操作，<span class="math inline">\(O(n)\)</span>。</li><li><code>resize(size_type n)</code>：调整 vector 的大小，若小于容量可能会删除元素，<span class="math inline">\(O(n)\)</span>。</li><li><code>shrink_to_fit()</code>：缩减 vector 的容量到当前大小，<span class="math inline">\(O(n)\)</span>。</li></ul></div><div class="tab-item-content"><ul><li><code>begin()</code>：返回指向 vector 第一个元素的迭代器，<span class="math inline">\(O(1)\)</span>。</li><li><code>end()</code>：返回指向 vector 最后一个元素之后的位置的迭代器，<span class="math inline">\(O(1)\)</span>。</li><li><code>rbegin()</code>：返回指向 vector 最后一个元素的逆向迭代器，<span class="math inline">\(O(1)\)</span>。</li><li><code>rend()</code>：返回指向 vector 第一个元素之前的位置的逆向迭代器，<span class="math inline">\(O(1)\)</span>。</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note warning flat"><p>请注意区分 <strong>容量</strong> 和 <strong>大小</strong> 的概念，vector 实际占用的内存空间相当于容量。</p></div><ul><li>容量：指的是 vector 预留的内存空间大小，可以动态增加或减少。</li><li>大小：指的是 vector 中实际存储的元素个数。</li></ul><p><strong>释放 vector 内存</strong></p><ol type="1"><li><code>vector&lt;T&gt;().swap(v)</code>。</li><li><code>v.clear(), v.shrink_to_fit()</code>。</li></ol><h3>deque</h3><p>deque 是 STL 中的双端队列容器，定义在 <code>&lt;deque&gt;</code> 头文件中。</p><p>特性：</p><ul><li>支持 <strong>两端</strong> 高效插入和删除。</li><li>随机访问常数较大。</li></ul><p><strong>成员函数</strong></p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">插入删除</button></div><div class="tab-contents"><div class="tab-item-content active"><ul><li><code>push_front(const T&amp; x)</code>：在 deque 的头部添加一个元素，<span class="math inline">\(O(1)\)</span>。</li><li><code>push_back(const T&amp; x)</code>：在 deque 的尾部添加一个元素，<span class="math inline">\(O(1)\)</span>。</li><li><code>pop_front()</code>：删除 deque 的第一个元素，<span class="math inline">\(O(1)\)</span>。</li><li><code>pop_back()</code>：删除 deque 的最后一个元素，<span class="math inline">\(O(1)\)</span>。</li><li><code>insert(iterator pos, const T&amp; x)</code>：在指定位置插入元素，<span class="math inline">\(O(n)\)</span>。</li><li><code>insert(iterator pos, size_type n, const T&amp; x)</code>：在指定位置插入 <span class="math inline">\(n\)</span> 个值为 <span class="math inline">\(x\)</span> 的元素，<span class="math inline">\(O(n)\)</span>。</li><li><code>erase(iterator pos)</code>：删除指定位置的元素，<span class="math inline">\(O(n)\)</span>。</li></ul></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2>迭代器</h2><h2>算法</h2><h2>函数对象（functional）</h2><h3>函数对象</h3><table><thead><tr class="header"><th style="text-align: center;">类名</th><th style="text-align: center;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>plus&lt;T&gt;</code></td><td style="text-align: center;">加法</td></tr><tr class="even"><td style="text-align: center;"><code>multiplies&lt;T&gt;</code></td><td style="text-align: center;">乘法</td></tr><tr class="odd"><td style="text-align: center;"><code>divides&lt;T&gt;</code></td><td style="text-align: center;">除法</td></tr><tr class="even"><td style="text-align: center;"><code>modulus&lt;T&gt;</code></td><td style="text-align: center;">模运算</td></tr><tr class="odd"><td style="text-align: center;"><code>negate&lt;T&gt;</code></td><td style="text-align: center;">取负</td></tr><tr class="even"><td style="text-align: center;"><code>equal_to&lt;T&gt;</code></td><td style="text-align: center;">等于</td></tr><tr class="odd"><td style="text-align: center;"><code>not_equal_to&lt;T&gt;</code></td><td style="text-align: center;">不等于</td></tr><tr class="even"><td style="text-align: center;"><code>greater&lt;T&gt;</code></td><td style="text-align: center;">大于</td></tr><tr class="odd"><td style="text-align: center;"><code>less&lt;T&gt;</code></td><td style="text-align: center;">小于</td></tr><tr class="even"><td style="text-align: center;"><code>greater_equal&lt;T&gt;</code></td><td style="text-align: center;">大于等于</td></tr><tr class="odd"><td style="text-align: center;"><code>less_equal&lt;T&gt;</code></td><td style="text-align: center;">小于等于</td></tr></tbody></table><p>还有一些，可以自行查阅头文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> c = std::<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;()(a, b); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 降序排序</span></span><br></pre></td></tr></table></figure><h3>function</h3><p>一个 <strong>通用函数包装器</strong>，可以保存函数指针、lambda、函数对象、成员函数指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f = add; <span class="comment">// 保存函数指针</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; endl;         <span class="comment">// 输出 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>bind</h3><p>一个 <strong>参数绑定器</strong>，可以将参数绑定到函数上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123; <span class="keyword">return</span> a+b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">bind</span>(add, <span class="number">10</span>, placeholders::_1); <span class="comment">// 固定 a=10, b 为参数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(<span class="number">5</span>) &lt;&lt; endl;                     <span class="comment">// 输出 15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>哈希函数</h3><p><code>std::hash&lt;T&gt;</code> 可以获取对象的哈希值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string,<span class="type">int</span>,hash&lt;string&gt;&gt; mp;</span><br></pre></td></tr></table></figure><h2>适配器</h2>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 库 chrono</title>
      <link href="/posts/7b504e68/"/>
      <url>/posts/7b504e68/</url>
      
        <content type="html"><![CDATA[<p>C++11 引入的 <code>chrono</code> 库，用于处理时间、计时和时间点，主要提供三类核心概念。</p><h3>duration（持续时间）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::chrono::duration&lt;Rep, Period&gt;</span><br></pre></td></tr></table></figure><p><code>Rep</code> 表示持续时间的类型，<code>Period</code> 表示时间单位。</p><p>常用别名:</p><ul><li><code>std::chrono::seconds</code> 秒</li><li><code>std::chrono::milliseconds</code> 毫秒</li><li><code>std::chrono::microseconds</code> 微秒</li><li><code>std::chrono::nanoseconds</code> 纳秒</li><li><code>std::chrono::minutes</code> 分钟</li><li><code>std::chrono::hours</code> 小时</li></ul><h3>time_point（时间点）</h3><p>表示某个具体时刻。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::chrono::time_point&lt;Clock, Duration&gt;</span><br></pre></td></tr></table></figure><p><code>Clock</code> 表示时钟类型，<code>Duration</code> 表示时间间隔类型。</p><h3>clock（时钟）</h3><p>提供获取当前时间的函数。</p><ul><li><code>steady_clock</code> 单调递增，不受系统时间调整影响，适合计时。</li><li><code>system_clock</code> 系统时间，可转换为日历时间。</li><li><code>high_resolution_clock</code> 高精度计时。</li></ul><h3>使用</h3><p><strong>获取当前时间点</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br></pre></td></tr></table></figure><p><strong>计时</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="comment">// 代码片段</span></span><br><span class="line"><span class="keyword">auto</span> end = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> duration = <span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Time used: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p><strong>返回 <code>epoch</code> 到当前时间点的偏移量，并把这个时间间隔以整数形式表示</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrono::steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>(); <span class="comment">// 常用于初始化随机数种子</span></span><br></pre></td></tr></table></figure><p>不同 <code>Clock</code> 类型的 <code>spoch</code> 不一样：</p><ul><li><code>steady_clock</code> 的 <code>spoch</code> 通常为 <strong>系统启动时间</strong>。</li><li><code>system_clock</code> 的 <code>spoch</code> 通常为 <strong>1970-01-01 00:00:00 UTC</strong> 。</li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 中的 Lambda</title>
      <link href="/posts/eeb037c6/"/>
      <url>/posts/eeb037c6/</url>
      
        <content type="html"><![CDATA[<h2>介绍</h2><p>Lambda 表达式（Lambda Expression），在 C++11 中被引入，是一种可以就地定义、没有名字、能捕获外部变量的匿名函数对象（闭包）。</p><h2>语法</h2><p>这是一个完整的 Lambda 表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture] (params) mutable exception attribute -&gt; ret  &#123; body &#125;</span><br></pre></td></tr></table></figure><ol type="1"><li>捕获列表 <code>[capture]</code>：定义 Lambda 可以访问外部作用域的哪些变量，以及如何访问（按值还是按引用）。</li><li>参数列表 <code>(params)</code>（可选）：与普通函数一致。</li><li>说明符 <code>mutable</code>（可选）：默认情况下，按值捕获的变量在内部是 <code>const</code> 的，加上 <code>mutable</code> 允许修改这些副本。</li><li>异常声明 <code>noexcept</code>（可选）：指定是否抛出异常。</li><li>返回类型 <code>-&gt; type</code>（可选）：通过尾置返回类型指定。</li><li>函数体 <code>&#123;&#125;</code>：函数具体的实现逻辑。</li></ol><p>Lambda 表达式是以类（Class）形式定义，我们以一个最复杂的形式介绍：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [x, &amp;y](<span class="type">int</span> a) <span class="keyword">mutable</span> <span class="keyword">noexcept</span> [[maybe_unused]] -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    x += a;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其 Class 展开：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">__lambda_unique_id</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span>&amp; y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    __lambda_unique_id(<span class="type">int</span> _x, <span class="type">int</span>&amp; _y) : <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">mutable</span> <span class="keyword">noexcept</span> [[maybe_unused]] -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">        x += a;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __lambda_unique_id(<span class="type">const</span> __lambda_unique_id&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    __lambda_unique_id&amp; <span class="keyword">operator</span>=(<span class="type">const</span> __lambda_unique_id&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3>捕获模式</h3><p>Lambda 中的捕获拥有多种模式。</p><table><thead><tr class="header"><th>捕获形式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>[]</code></td><td><strong>不捕获</strong>。Lambda 只能访问全局变量或静态变量。</td></tr><tr class="even"><td><code>[x]</code></td><td><strong>按值捕获 <code>x</code></strong>。内部拥有 <code>x</code> 的副本，修改副本不影响外部。</td></tr><tr class="odd"><td><code>[&amp;x]</code></td><td><strong>按引用捕获 <code>x</code></strong>。内部修改直接影响外部变量。</td></tr><tr class="even"><td><code>[=]</code></td><td><strong>隐式按值捕获</strong>。捕获函数体内用到的所有外部变量。</td></tr><tr class="odd"><td><code>[&amp;]</code></td><td><strong>隐式按引用捕获</strong>。捕获函数体内用到的所有外部变量。</td></tr><tr class="even"><td><code>[=, &amp;x]</code></td><td>默认按值捕获，但 <code>x</code> 必须按引用捕获。</td></tr><tr class="odd"><td><code>[this]</code></td><td>捕获当前类的指针，允许 Lambda 访问类的成员变量和成员函数。</td></tr></tbody></table><p><strong>generalized capture 带初始化的捕获</strong></p><p>从 C++14 起，捕获列表 <code>[capture]</code> 支持自定义变量，但必须拥有初值，加上 <code>mutable</code> 后可变，生命周期跟随 Lambda。</p><p>也可以通过引用的方式定义一个变量，用于给外部变量一个别名。</p><h3>参数列表</h3><p>从 C++14 起，支持用 <code>auto</code> 声明参数，会生成 [[#泛型 Lambda]] 表达式。</p><p>如果不将参数传递给 lambda，并且其声明不包含 <code>mutable</code>，且没有后置返回值类型，则可以省略空括号．</p><h3>返回类型</h3><p>通常编译器可以自动推导返回类型，注意当 Lambda 中多个返回类型不一样且未指定返回类型，会产生编译错误。</p><h2>泛型 Lambda</h2><p>使用 <code>auto</code> 声明参数类型是，会构造泛型 Lambda。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br></pre></td></tr></table></figure><p>其 Class 展开：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">__lambda_unique_id</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T1 a, T2 b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> __invoke(T1 a, T2 b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">fptr_t</span> = <span class="keyword">decltype</span>(<span class="built_in">add</span>(std::<span class="built_in">declval</span>&lt;T1&gt;(), std::<span class="built_in">declval</span>&lt;T2&gt;())) (*)(T1, T2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">    <span class="keyword">operator</span> <span class="built_in">fptr_t</span>&lt;T1, T2&gt;() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;__invoke;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __lambda_unique_id() = <span class="keyword">default</span>;</span><br><span class="line">    __lambda_unique_id(<span class="type">const</span> __lambda_unique_id&amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line">__lambda_unique_id add = __lambda_unique_id&#123;&#125;;</span><br></pre></td></tr></table></figure><p>额，看不懂没关系，只用注意到它是以 <code>template&lt;typename T1, typename T2&gt;</code> 模版形式定义就可以了。</p><h2>Lambda 的递归</h2><p>在 C++ 中，Lambda 的递归比普通函数要复杂一些。核心矛盾在于：<strong>Lambda 在定义完成之前，它的名字（变量名）在函数体内是不可见的。</strong></p><p>比如对于一个 <strong>错误实现</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fib = [](<span class="type">int</span> n) &#123; <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n; <span class="keyword">return</span> <span class="built_in">fib</span>(n<span class="number">-1</span>); &#125;</span><br></pre></td></tr></table></figure><p>因为推导 <code>fib</code> 的类型需要知道它的返回类型，而确定返回类型又需要调用 <code>fib</code>，陷入了死循环。</p><p>所以接下来介绍主要的三种实现方式。</p><h3><code>std::function</code></h3><div class="note warn flat"><p>注意会有额外性能开销</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fib = [&amp;](<span class="type">int</span> n) &#123; <span class="built_in">return</span> (n &lt;= <span class="number">1</span>) ? n : <span class="built_in">fib</span>(n - <span class="number">1</span>) + <span class="built_in">fib</span>(n - <span class="number">2</span>); &#125;;</span><br></pre></td></tr></table></figure><p>这是最常用的方法。通过显式指定 <code>std::function</code> 类型，提前确定了 Lambda 的签名，使得内部可以识别这个名称。</p><p>注意不建议使用该方式，存在类型擦除和动态内存分配的开销，且无法进行内联优化，性能略低。</p><h3>泛型 Lambda 自传递</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fib = [](<span class="keyword">auto</span> self, <span class="type">int</span> n) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">self</span>(self, n - <span class="number">1</span>) + <span class="built_in">self</span>(self, n - <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line"><span class="type">int</span> result = <span class="built_in">fib</span>(fib, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>其 Class 展开：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">__lambda_fib</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T self, <span class="type">int</span> n)</span> <span class="type">const</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">self</span>(self, n - <span class="number">1</span>) + <span class="built_in">self</span>(self, n - <span class="number">2</span>); </span><br><span class="line">        <span class="comment">// 这里的 self 实际上就是传入的 __lambda_fib 实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>零开销。编译器可以完全内联，性能等同于普通递归函数。</p><p>只是语法可能略显奇怪。</p><h3>使用辅助函数 <code>std::visit</code> 或自定义 <code>y_combinator</code></h3><p>为了解决上一个方法 <strong>多传一个参数</strong> 的尴尬，可以写一个辅助包装类（通常称为 <code>y_combinator</code>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">F</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">y_combinator</span> &#123;</span><br><span class="line">    F f;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Args&amp;&amp;... args)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>(*<span class="keyword">this</span>, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fib = y_combinator&#123;[](<span class="keyword">auto</span> self, <span class="type">int</span> n) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> (n &lt;= <span class="number">1</span>) ? n : <span class="built_in">self</span>(n - <span class="number">1</span>) + <span class="built_in">self</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = <span class="built_in">fib</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>优点在于调用语法非常亲切。</p><p>缺点在于比较麻烦。</p><h3>C++23</h3><p>C++23 引入了 <strong>“Deducing this”</strong> 语法，允许 Lambda 直接显式访问自身，彻底解决了递归问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fib = [](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> n) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> (n &lt;= <span class="number">1</span>) ? n : <span class="built_in">self</span>(n - <span class="number">1</span>) + <span class="built_in">self</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res = <span class="built_in">fib</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 中的随机化</title>
      <link href="/posts/ced3a8ad/"/>
      <url>/posts/ced3a8ad/</url>
      
        <content type="html"><![CDATA[<p>mt19937 是 C++11 引入的伪随机数生成器，使用 <strong>梅森旋转</strong>（Mersenne Twister）算法。</p><p>相较于 <code>rand</code> 它的周期更长（<span class="math inline">\(2^{19937} -1\)</span>），生成的随机数更加均匀，速度更快，<strong>但仍然是可预测的</strong>。</p><h3>定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::mt19937 <span class="title">rng</span><span class="params">(seed)</span></span>; <span class="comment">// 这里 seed 为任意整数</span></span><br><span class="line"><span class="function">std::mt19937 <span class="title">rng</span><span class="params">(std::chrono::steady_clock::now().time_since_epoch().count())</span></span>; <span class="comment">// 一般用当前时间作为种子</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::mt19937_64 <span class="title">rng</span><span class="params">(seed)</span></span>; <span class="comment">// 64 位版本</span></span><br></pre></td></tr></table></figure><p>调用 <code>rng()</code> 即可生成在 <span class="math inline">\([0, 2^{32} - 1]\)</span> 范围内的随机数，<span class="math inline">\(64\)</span> 位版本的 <code>rng()</code> 则在 <span class="math inline">\([0, 2^{64} - 1]\)</span> 范围内。</p><p>一些成员函数：</p><ul><li><code>.seed(unsigned)</code> 重新设置种子。</li><li><code>.discard(n)</code> 跳过 <span class="math inline">\(n\)</span> 个结果。</li><li><code>.min()</code> 和 <code>.max()</code> 返回随机数的最小值和最大值。</li></ul><h3>random_device</h3><p>如果不想使用伪随机，可以使用 <code>std::random_device</code> 来获取硬件随机数。</p><div class="note warning flat"><p>C++ 标准规定 <code>std::random_device</code> 可以退化为伪随机数</p></div><p>但一般来说，在 Windows，Linux，macOS 上，<code>std::random_device</code> 都是硬件随机数生成器。</p><p>可以通过其成员函数 <code>.entropy()</code> 来获取硬件随机数生成器的熵，如果大于 <span class="math inline">\(0\)</span>，一般都是真随机数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::random_device rd;</span><br><span class="line"><span class="function">std::mt19937 <span class="title">rng</span><span class="params">(rd())</span></span>; <span class="comment">// 用硬件随机数生成器初始化 mt19937</span></span><br></pre></td></tr></table></figure><p>请不要滥用 <code>std::random_device</code>：</p><ol type="1"><li>它的速度更慢。</li><li>有研究指出，在熵池耗尽后，<code>std::random_device</code> 可能退化为伪随机数，并且性能急剧下降。</li></ol><p>关于 <strong>熵</strong> 的更多内容，读者可以查阅更多资料。</p><h3>均匀分布</h3><p>mt19937 还提供了 <strong>分布类</strong>，用于生成一定范围内均匀分布的随机数。</p><p><strong>均匀分布整数</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(a, b)</span></span>; <span class="comment">// [a, b] 范围内均匀分布整数</span></span><br><span class="line"><span class="type">int</span> x = <span class="built_in">dist</span>(rng);</span><br></pre></td></tr></table></figure><p><strong>均匀分布浮点数</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">dist</span><span class="params">(a, b)</span></span>; <span class="comment">// [a, b] 范围内均匀分布浮点数</span></span><br><span class="line"><span class="type">double</span> x = <span class="built_in">dist</span>(rng);</span><br></pre></td></tr></table></figure><p><strong>正态分布</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::normal_distribution&lt;<span class="type">double</span>&gt; <span class="title">dist</span><span class="params">(mean, stddev)</span></span>; <span class="comment">// 正态分布，mean 为均值，stddev 为标准差</span></span><br><span class="line"><span class="type">double</span> x = <span class="built_in">dist</span>(rng);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 奇技淫巧</title>
      <link href="/posts/78aab76b/"/>
      <url>/posts/78aab76b/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>编译器版本： gcc 15.2.0</p></div><div class="note info flat"><p>C++ 标准： c++14</p></div><h2>前言</h2><p>本文介绍了 C++ 中一些有趣/神奇的函数，虽然不一定用的到就是了。</p><p>STL，lambda，随机化，chrono 均有另开文章。</p><h2>__builtin</h2><p>以 <code>__builtin</code> 开头的函数均为编译器内置函数，效率极高。</p><p><strong>位操作</strong></p><ul><li><code>__builtin_clz</code> 计算前导 <span class="math inline">\(0\)</span> 个数（<span class="math inline">\(32\)</span> 位），<span class="math inline">\(0\)</span> 是未定义行为。</li><li><code>__builtin_ctz</code> 计算尾随 <span class="math inline">\(0\)</span> 个数（<span class="math inline">\(32\)</span> 位），<span class="math inline">\(0\)</span> 是未定义行为。</li><li><code>__builtin_popcount</code> 计算 <span class="math inline">\(1\)</span> 的个数（<span class="math inline">\(32\)</span> 位）。</li><li><code>__builtin_parity</code> <span class="math inline">\(1\)</span> 的个数为奇数则返回 <span class="math inline">\(1\)</span>，偶数则返回 <span class="math inline">\(0\)</span>。</li></ul><p>上面函数结尾加 <code>ll</code> 即 <span class="math inline">\(64\)</span> 位版本，例如 <code>__builtin_clzll</code>。</p><p><strong>内存操作</strong></p><ul><li><code>__builtin_expect(expr, value)</code> 告诉编译器 <code>expr</code> 最可能为 <code>value</code>，用于分支预测。</li><li><code>__builtin_prefetch(addr, rw, locality)</code> 提前加载内存到缓存，<code>rw</code> 为 <span class="math inline">\(0\)</span> 表示读，为 <span class="math inline">\(1\)</span> 表示写；<code>locality</code> 为缓存层级。</li><li><code>__builtin_memcpy</code> 同 <code>memcpy</code> 函数。</li><li><code>__builtin_memset</code> 同 <code>memset</code> 函数。</li><li><code>__builtin_memmove</code> 同 <code>memmove</code> 函数。</li></ul><p><strong>数学</strong></p><ul><li><code>__builtin_abs</code> 绝对值。</li><li><code>__builtin_sqrt</code> 平方根。</li><li><code>__builtin_add_overflow</code>,<code>__builtin_mul_overflow</code> 等，检查溢出，返回 <code>bool</code>。</li></ul><h2>强制内联</h2><p><code>__attribute__((always_inline))</code> 不管优化级别，都尽量内联。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> __attribute__((always_inline)) <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>分支预测</h2><p>C++14 只有上文的 <code>__builtin_expect</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(x &gt; <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">  <span class="comment">// x &gt; 0 更可能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++20 新增了 <code>[[likely]]</code> 和 <code>[[unlikely]]</code>，用于分支预测。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>) [[likely]] &#123;</span><br><span class="line">    <span class="comment">// 这里分支更可能被执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> [[unlikely]] &#123;</span><br><span class="line">    <span class="comment">// 不常执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>constexpr</h2><p><code>constexpr</code> 在 C++11 引入，表示一个变量为常量表达式，<strong>必须</strong> 在编译期求值。</p><p>相较于 <code>const</code> 的仅保证只读，不保证编译期计算，它的速度会更快。</p><h2>algorithm</h2><p>这个库东西很多，这里只列举好用但大家不一定都知道的。</p><h3>排列</h3><ul><li><code>partial_sort(first,middle,last)</code> 只排序前几项，即保证 <span class="math inline">\([first,middle)\)</span> 是最小且有序的，复杂度 <span class="math inline">\(O(n\log k)\)</span>。</li><li><code>nth_element(first, nth, last)</code> 找到第 <span class="math inline">\(n\)</span> 小的元素，保证小于等于 <span class="math inline">\(nth\)</span> 的元素都在 <span class="math inline">\(nth\)</span> 的左边，大于等于 <span class="math inline">\(nth\)</span> 的元素都在 <span class="math inline">\(nth\)</span> 的右边，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>is_sorted(first,last)</code> 判断是否有序，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>next_permutation(first,last)</code> 产生下一个字典序排列，复杂度 <span class="math inline">\(O(n)\)</span>。（CSP-S 2025 初赛）</li><li><code>prev_permutation(first,last)</code> 产生上一个字典序排列，复杂度 <span class="math inline">\(O(n)\)</span>。（CSP-S 2025 初赛）</li></ul><h3>查找</h3><ul><li><code>find(first, last, value)</code> 返回指向第一个等于 <code>value</code> 的元素的迭代器，如果找不到，返回 <code>last</code>，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>find_if(first, last, pred)</code> 返回指向第一个满足 <code>pred</code> 的元素的迭代器，如果找不到，返回 <code>last</code>，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>count(first, last, value)</code> 返回 <code>value</code> 在区间 <span class="math inline">\([first, last)\)</span> 中出现的次数，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>count_if(first, last, pred)</code> 返回 <code>pred</code> 判定为真的元素在区间 <span class="math inline">\([first, last)\)</span> 中出现的次数，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>binary_search(first, last, value)</code> 判断 <code>value</code> 是否在区间 <span class="math inline">\([first, last)\)</span> 中，复杂度 <span class="math inline">\(O(log n)\)</span>（<mark class="hl-label red">必须有序</mark>）。</li><li><code>equal_range(first, last, value)</code> 返回一个 <code>pair</code> 表示一个区间 <span class="math inline">\([lower_bound, upper_bound)\)</span> 满足区间内的元素等于 <code>value</code>，复杂度 <span class="math inline">\(O(log n)\)</span>（<mark class="hl-label red">必须有序</mark>）。</li><li><code>minmax(a,b)</code> 返回一个 <code>pair</code> 表示 <code>a</code> 和 <code>b</code> 的最小值和最大值。</li><li><code>minmax_element(first, last)</code> 返回一个 <code>pair</code> 表示区间 <span class="math inline">\([first, last)\)</span> 中的最小值和最大值，复杂度 <span class="math inline">\(O(n)\)</span>。</li></ul><h3>修改</h3><ul><li><code>copy(first,last,out)</code> <strong>复制</strong> 元素到另一个容器，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>move(first,last,out)</code> <strong>移动</strong> 元素到另一个容器，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>fill(first,last,value)</code> 用指定值填充区间，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>rotate(first, middle, last)</code> 将区间 <span class="math inline">\([first,last)\)</span> 变为 <span class="math inline">\([middle, last) + [first, middle)\)</span>，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>replace(first, last, old_value, new_value)</code> 用 <code>new_value</code> 替换 <code>old_value</code>，复杂度 <span class="math inline">\(O(n)\)</span>。</li></ul><h3>随机化</h3><ul><li><code>shuffle(first, last, rng)</code> 将区间 <span class="math inline">\([first,last)\)</span> 随机化，复杂度 <span class="math inline">\(O(n)\)</span>（请不要再用 <code>random_shuffle</code>）。</li></ul><h2>numeric</h2><p>这个库提供了一些数值计算的函数。</p><ul><li><code>accumulate(first, last, init)</code> 累加区间 <span class="math inline">\([first,last)\)</span>，<code>init</code> 为初始值，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>inner_product(first1, last1, first2, init)</code> 计算两个区间 <span class="math inline">\([first1,last1)\)</span> 和 <span class="math inline">\([first2,last2)\)</span> 的内积，<code>init</code> 为初始值，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>partial_sum(first, last, out)</code> 计算区间 <span class="math inline">\([first,last)\)</span> 的前缀和，结果存入 <code>out</code>，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>adjacent_difference(first, last, out)</code> 计算区间 <span class="math inline">\([first,last)\)</span> 的相邻差，结果存入 <code>out</code>，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>iota(first, last, value)</code> 用 <code>value</code> 填充区间 <span class="math inline">\([first,last)\)</span>，复杂度 <span class="math inline">\(O(n)\)</span>。</li></ul><h2>initializer_list</h2><p>C++11 引入的一种新的数据结构，支持用大括号初始化列表，注意定义后不能修改。</p><p>常与 STL 容器一起使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; l = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::<span class="built_in">max</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><p>或者用于循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>iterator</h2><p>C++11 引入的一些迭代器相关的函数。</p><ul><li><code>distance(first, last)</code> 返回迭代器之间的距离，复杂度 <span class="math inline">\(O(1)\)</span>。</li><li><code>advance(it, n)</code> <strong>移动</strong> 迭代器 <code>it</code> 指向的位置 <code>n</code> 步，复杂度 <strong>依赖迭代器类型</strong>。</li><li><code>next(it, n)</code> <strong>返回</strong> 迭代器 <code>it</code> 指向的位置 <code>n</code> 步后的迭代器，复杂度 <strong>依赖迭代器类型</strong>。</li><li><code>prev(it, n)</code> <strong>返回</strong> 迭代器 <code>it</code> 指向的位置 <code>n</code> 步前的迭代器，复杂度 <strong>依赖迭代器类型</strong>。</li></ul><p>时间复杂度：</p><ul><li>对于 <code>vector</code>，<code>deque</code> 和 <code>array</code> 等，支持 <strong>直接跳跃</strong>，复杂度 <span class="math inline">\(O(1)\)</span>。</li><li>对于 <code>list</code>，<code>map</code> 和 <code>set</code> 等，时间复杂度 <span class="math inline">\(O(n)\)</span>。</li><li>对于单向迭代器，例如 <code>forward_list</code>，<code>istream_iterator</code> 等，时间复杂度 <span class="math inline">\(O(n)\)</span>，且只支持单向移动。</li></ul><h2>nullptr</h2><p>C++11 引入的 <code>nullptr</code> 关键字，用于表示空指针。</p><p>主要区别于 <code>NULL</code>，因为 <code>NULL</code> 被实现为 <code>#define NULL 0</code>。</p><h2>decltype</h2><p>C++11 引入的 <code>decltype</code> 关键字，用于获取表达式的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decltype(expression) var;</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> y = <span class="number">2.5</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) a = x; <span class="comment">// int</span></span><br><span class="line"><span class="keyword">decltype</span>(y) b = y; <span class="comment">// double</span></span><br><span class="line"><span class="keyword">decltype</span>(x+y) c = x+y; <span class="comment">// double, because (x+y) is a double expression</span></span><br></pre></td></tr></table></figure><h2>auto</h2><p>C++11 引入的 <code>auto</code> 关键字，用于自动推导类型。</p><h3>类型推导</h3><div class="note warning flat"><p>必须初始化，否则无法推导类型。</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">10</span>; <span class="comment">// int</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2.5</span>; <span class="comment">// double</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="string">&quot;hello&quot;</span>; <span class="comment">// const char*</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p>注意默认去掉引用和 const。</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> c = a;        <span class="comment">// int</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;a;       <span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;b;       <span class="comment">// const int*</span></span><br><span class="line"><span class="keyword">auto</span>&amp; f = a;       <span class="comment">// int&amp;，引用类型必须显示加 &amp;  </span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b; <span class="comment">// 返回值类型自动推导</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>循环</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : v) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : v) &#123; <span class="comment">// 如果要修改元素</span></span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>结构化绑定</h3><p>C++17 引入，但 C++14 可用，应该会报 warning。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> [x, y] = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; mp = &#123;&#123;<span class="string">&quot;a&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [key, value] : mp) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>if / switch 初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(key); it != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>C++20</h3><p>模板参数中使用 auto：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">auto</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; N &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>&lt;<span class="number">42</span>&gt;();  <span class="comment">// N 被推导为 int</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Beginning Contest 训练总结</title>
      <link href="/posts/f1ee858f/"/>
      <url>/posts/f1ee858f/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="6ba520ba7f4aed8aee7b5f2529b73ddb5addcfbc428ae3244139c0f9ebe43000">93024cf999deb8d8b2919f7e109263d4ccd8f9021329678d4b2ec637585ccd26ab88c90ee1df159818817646a36c38100a314d420b4be55583895e55a3c137e18c83895171c22bd5918ee4b2815231073bfeaa535d56274fe59f09ec023d1e9ee3038d4a5dd7e3751f7f50de9eb539e61437a2d6f8a2452b4c1bf94543e9a80130ad6598460374398a147eb5060c31c107d0396cb07f4565fbcb497666fcd8c591eb6411c8623ea15deca70c8db2d191127771c20ad329bb813ca3420ae6c9873d48d8de615e55917ed073605c46c45d374f6261697a723b931a7dbee7e87a3ea56cdb3d9baaa0cc65ac59c69fb7a4195ad009f52a1ba9c1a349890f2a445045cd6ecbbbac44657052754a2d4ff010fccb097809e832d48834787012b114aa5c0bbcb58eb31bf013ea2131142d28bad6903da47d3237405801042d4e24e42ad1d5af91e4936f0759b9b9b470ae7ca022d5b45cd33f6f375bd4bffc5289f23ead4f16f2f26c87e59711a9b1b3f9315a83cc372d1837f7c93960bd34628a2c14809f37c27fccaee218afe97dae9335e3cfe3d3160c5f212e7c2759c3e2403d68c0a6b911e59866241eba633b9793f80d7ab8ad1f084f8e8f373b3cd35ecaec4c63bc0aafa74c6d6aaf300abe519e3ba2e71ad39fa0ffcadd33efeea855368a2cef35e35ebb7f6a9cd68a50b4a37396370f920e0822c9247b364819c5f68e0c60f8f4d5286a1ec652900724e7e8a8f08d44e4b77e06a9082241e5fb3751f9575594f35c0df88817c4a8ca19b695554782988d8111fdf0123dc55dbde3ea3ee95cbe95d18dd7040078c5a22914ac39daf8d8f235a868fe33f780ae0732cfc4436c06e510a6e0f28e13109e542c5ca295cf45927224469eb55c2f68c89441a9e897b22e104edbd502440871030fc530dec2c2903dbffb9fed44160800e0499e29d4dea24928da8edb0f91e34420827920ff88d48bb4e02e50a63ebacb27bc22b91216db249aa08ecb631f482a610984ef89e8176348493a26f8bc949d2f88df9b54f6c1e662f8fe8124bd55fb9c82eeeed7ada6a299f45d0a23e128ac4e1d2bc9b240e536aae9565899d52897a298836d0624efb230d383b412583bb6f44c48b1cd283f73eb02282ed9fcfb158c0702587cd3b0107b32270485e50c9b6cfeb6fc260579b8a4158124d7f6dd380692560a457c7e2bd7a50f9211e45951d60953ed44aa7c66854188a9461b939b233d9f5e3f382895c36134979f9396497d6059de00315fff5c76cfa7de471b02c98a2dd83d219e07e2f34487524f1e6396f87b5fc02486872943452b91161721540704eca46af14b525109c0cb0eca2c1a8df300ecca3c4f61e03a626e0392d88ef70ec81843c6cb9a5a0445ca4da4386213366fcc9fc7680df885445ebdd82672bbc802721f8fbb2bae81b16022a482d95707d27364ec2e92e3cbe0408aae2f1f69450ef614b3fcb2436bd2bc02b7b9b48c94c1e6622057f3fd4ea04c99a34b460e3c609a78a988e2d71fcd2ba67eeab3033e8e2606e5aa1f61fd51b21a3fcab5fe58bda8ff284a0590d9eb50db1f7c78928f21864931abfb1c04fef49bb787043129019d8811f75c783768b3065bef3c108545207e2f1ffe3e7bbc90bc6adcd905a6dcfb08167ea9b5e0b151450cfe1f7a5fd6291e969ed95f44d64fe0666195e81dcc22890d1a3bf2a3eeabfa01addd531005ea955b6ab0a692762d5040344604b901c46f1ee4ce586a4884562cda1347fa8aaa01a12c12b309db8af9a005104244de5f63286e5a1cfeb15fda2024ba67fec2c95779ec2bbfa02944bf1b95c3b73f0b51e6f856cd5665e73f35467709081781495451622639fd0ed168bc343698a5a1cf06ba440552f7a44b55de940840c895fd795c0179d1a33a82b99e970bae3006f0b103e691e83f71168112948b82bfaa24bf63a70563989cccd6e573dda7fbcf6045df726def53db787b4148ec0ea05425bff457d0521d1ba6909d3bc8598b3ddd901dbffea0d214771821f28bf9a109f711e722c074fea87a684719696d962ff54b2c07fe64c2582a7988e251d525e968de0312c672878a95d2c804a02a0aaf77d7dac875e98f018b6dc9d6c2572e838c6f31f6c90283039ec1cb44aa92ba9010597d6ef2c482dccc591769099ebc63173c4fd805bd35d2509cf665ae5e4f0a1e9f9e7d5d70c5c448439a3b8ab3da2b6990123a617dc4ab7f1fa57d2499149fad8668e6b7f50f62335d2740a5ca26301b5df7a40d1ff92b98e53380d990d6d054d974001caaf5f8456e83a5ed18e8890531f48b6b8ee6d3db135d4442e904728adfd7965d30097dff609918a7605b94a30d913269674621c0849163deea7af58d8b5c66b4069bf7b17045ba4897134dadd164da498a32b43d7e81608a43f6d48fda944b3614c232e4e7bc3a7be2e95a19aa78e58ed73f838a5fca14d0a752e8008aa5bd2ad9866ed394e08b6bc725141e269151347e67c905fa78fac4c88ddc3c959bcfc483a4b04396582b9741dc6b709015fab94a05c57999e267952b6f1a52104ebcea1581e0761908a3904b236cdf8d670e8db5254447c82db029022582e1b66d5d80aeb13640db32129ccbbd367c3fd8ee8f66346a62e28e4fa80f714107b2fcf65d01a01e765f316b55d9745cf4e729ea4f4ee97ce54fb00a34f2229bc5fb14c73cd66c1c757802c35a28fb00d75fd1ea50dab325b1a8e2ee19e2551f315fab09f74aaff405ecee30e138b62bd589ce620a7d0dd85e114d34f386619c4cc3250f0c40fac6de8ac69da1235a57179d915e377225c9cf3de2a7e6f13e9aa3e74a751813eb3c7543632056f7883c934022465cb5f2fe1d2cc4d9074fe233779a3207f8166bd0dd8faf68445852b85c38f8cea26e09bf78cb2b3608217ff43a03df27942d91959134c00403519486a52dae510b5f67c8506cb9a5c98fec09ec5b1309ad9d84227d879ab81bbacaad08027644fa3c96834f3a25ded2124080af66252bd0a27c80b26ae19985d93a9fa8bffd584cf3dd4aa79415b3df3b5cf3e9b28ded456e6f6e21f6fe0cb6b4ee7dbd9cb292e5520beb0795add776df602b786b8ea61907cef10225fc39a9edc4935bcee33551d0ba9e81c36d04e4c3ebcbf55601717bb71e9264e69ff5013ed5fe42f88b51baeacd5d6c8d2ae6cbb7f114aabf3278d079ba6fd2605d0230632e99edca2f040db939e46973e84da12876e446b8f57093a34f2c870ff147b7f4ffa8e03a1c3b26fbd00383555b17e8b870dd18efb0cc3885f0fcfb2197e1b5d087f60e5ca834f31cd4ed0a523103c66c944b896603128ac4b8815a884100e21b5bb2db7a19ebc4f38ccc2cceb93075de9907b219d59992d1f4330d8f1b1e94b5f69031006ffb3bef30525620e8afe582d8b58560438cced4bb000a983d07b15a1c84dd1e19f92acbce21f982f641005153d2b9009baaa7a07371ea8ffc8af8b4f65170421eb3a1e013350239c297174b3bd2863188ee53ec9ff06851133490bbb7abc50823bddd2e1b6cf282acbf0fd43295737f4796e1891740e3155fca7eef31ab08d22213f61e31f3c37d8ed4a3ef6ed58ae66545d7fca2277efa289da310fd638c007993e11abb0e6ba763323775116eb7b411c25ba76ea88b6c8c31b1e12218e3b276f344b199557575d7cb6a4c9a83656f5ef85b81c0ccfa9a81111b4b04ea5fc16fddfd68ce29ad6a33b2bb14dcda043604ac96d2a4bfbd756e1290577cc7b797aa3787d815fa05dd54476c032d75537b83f5c055b8a8ac1eab4739d037ba69e688eabbd18c64e4b814375aaabcecd2ce744f023e2288a1678986e3e4874a594ebc0d0130cce3a688a4cbdf5e491765448b6352b565e7fba58a622cb6e47c0cd81cc45dc5aa3c2f83d7b67b826964646be211647df548a0fa2ef21ced725580827c70aeeb7b652ee2b9a20c90896c63101903d2419846a1a35105324eafe6627aac118120f410f6944203b69d6b9b0b0cf5eb9cc0c08b65cd4d47adfe817f9c1a88af3d14a5dd7f7e91f4fd29f1b32cf951c7ef2d1aabc6283b0e9968350815d3f146c393a34de6ed54223ad8af7400bbab5367426417ef12a4c2a1a57f262a0e15ff7a1f27283d146c3311c1c0cb049e9861e195ec58eb73b981849797acffc4787b7b3dfb6b82657dd6aa012543ac8f85592b17395b00e861daf038e2619ac98ccf0dd34f4d9e1502e6891fbf880c1457bf27ca780b5b9d9df2626f66133589924b4713164b3eaf3b4a246e6a2ac77fab31cfb53de19d7175023efd8602aa259e5a3c220582d5729c876cdcabb2a5f00d2cde7ba71b15f635bc8167cf19c19a91d8c3bd5388005ab48a1286ad824742e5caeb30446ce0bb57621a584b0122ffc0cc16cf1055ae1d469830cfffe07c303dd48e013626482281a1869790a033a0a80e9edf2abf03e0df08802a1c4db0426e05bc93897cbba7c3bdf73660fde9d913f9790ca9fefdcc73d6a3b85c655269088a22e7f4b0ac9471878ebb078f77acd569ac02d5db86afe6cb9776aefdf131</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> school </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP-S 2025 初赛题目解析</title>
      <link href="/posts/f1d582a1/"/>
      <url>/posts/f1d582a1/</url>
      
        <content type="html"><![CDATA[<h2>单项选择</h2><h3>T1</h3><p>有 <span class="math inline">\(5\)</span> 个红色球和 <span class="math inline">\(5\)</span> 个蓝色球，它们除了颜色之外完全相同。将这 <span class="math inline">\(10\)</span> 个球排成一排，要求任意两个蓝色球都不能相邻，有多少种不同的排列方法？</p><ul><li>A. 25</li><li>B. 30</li><li>C. 6</li><li>D. 120</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>C</p><p>将 <span class="math inline">\(5\)</span> 个红色球排成一排，共有 <span class="math inline">\(6\)</span> 个空隙（<code>_R_R_R_R_R_</code>）。</p><p>将 <span class="math inline">\(5\)</span> 个蓝色球，放在 <span class="math inline">\(6\)</span> 个空中，共 <span class="math inline">\(\binom{6}{5} = 6\)</span></p></div></details><h3>T2</h3><p>在 KMP 算法中，对于模式串 <span class="math inline">\(P = \text{abacaba}\)</span>，其 <code>next</code> 数组（ <span class="math inline">\(next[i]\)</span> 定义为模式串 <span class="math inline">\(P[0\dots i]\)</span> 最长公共前后缀的长度，且数组下标从 <span class="math inline">\(0\)</span> 开始）的值是什么？</p><ul><li>A. {0,0,1,0,1,2,3}</li><li>B. {0,1,2,3,4,5,6}</li><li>C. {0,0,1,1,2,2,3}</li><li>D. {0,0,0,0,1,2,3}</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>A</p><p>模拟即可。</p></div></details><h3>T3</h3><p>对一个大小为 <span class="math inline">\(16\)</span>（下标 <span class="math inline">\(0 \sim 15\)</span>）的数组上构建满线段树。查询区间 <span class="math inline">\([3,11]\)</span> 时，最少需要访问多少个树结点（包括路径上的父结点和完全包含在查询区间内的结点）？</p><ul><li>A. 7</li><li>B. 8</li><li>C. 9</li><li>D. 10</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>B</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    graph TD;    A[0,15] --&gt; B[0,7];    A --&gt; C[8,15];    B --&gt; D[0,3];    B --&gt; E[4,7];    C --&gt; F[8,11];    C --&gt; G[12,15];    D --&gt; H[0,1];    D --&gt; I[2,3];    I --&gt; J[2];    I --&gt; K[3];    style A fill:red;    style B fill:red;    style C fill:red;    style D fill:red;    style E fill:red;    style F fill:red;    style I fill:red;    style K fill:red;  </pre></div></div></details><h3>T4</h3><p>将字符串 <code>cat</code>, <code>car</code>, <code>cart</code>, <code>case</code>, <code>dog</code>, <code>do</code> 插入一个空的 Trie 树（前缀树）中。构建完成的 Trie 树（包括根结点）共有多少个结点？</p><ul><li>A. 8</li><li>B. 9</li><li>C. 10</li><li>D. 11</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>D</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    graph TD;    rt[root] --&gt; c0[c];    c0 --&gt; a1[a];    a1 --&gt; t2[t];    a1 --&gt; r2[r];    r2 --&gt; t3[t];    a1 --&gt; s2[s];    s2 --&gt; e3[e];    rt --&gt; d0[d];    d0 --&gt; o1[o];    o1 --&gt; g2[g];  </pre></div></div></details><h3>T5</h3><p>对于一个包含 <span class="math inline">\(n\)</span> 个顶点和 <span class="math inline">\(m\)</span> 条边的有向无环图（DAG），其拓扑排序的结果有多少种可能？</p><ul><li>A. 只有 <span class="math inline">\(1\)</span> 种</li><li>B. 最多 <span class="math inline">\(n\)</span> 种</li><li>C. 等于 <span class="math inline">\(n-m\)</span> 种</li><li>D. 以上都不对</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>D</p><p>拓扑排序的数量取决于图的具体结构，没有一个简单的公式可以计算。</p><p>如，没有边为 <span class="math inline">\(n!\)</span> 种，是链则只有 <span class="math inline">\(1\)</span> 种。</p></div></details><h3>T6</h3><p>在一个大小为 <span class="math inline">\(13\)</span> 的哈希表中，使用闭散列法的线性探查来解决冲突。哈希函数为 <span class="math inline">\(H(key)=key \mod 13\)</span>。依次插入关键字 <code>18</code>, <code>26</code>, <code>35</code>, <code>9</code>, <code>68</code>, <code>74</code>。插入 <code>74</code> 后，它最终被放置在哪个索引位置？</p><ul><li>A. 5</li><li>B. 7</li><li>C. 9</li><li>D. 11</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>D</p><ol type="1"><li><span class="math inline">\(18 \mod 13 = 5\)</span></li><li><span class="math inline">\(26 \mod 13 = 0\)</span></li><li><span class="math inline">\(35 \mod 13 = 9\)</span></li><li><span class="math inline">\(9 \mod 13 = 9\)</span>，<span class="math inline">\(9\)</span> 冲突，放在第 <span class="math inline">\(10\)</span> 个位置</li><li><span class="math inline">\(68 \mod 13 = 3\)</span></li><li><span class="math inline">\(74 \mod 13 = 9\)</span>，<span class="math inline">\(9,10\)</span> 冲突，放在第 <span class="math inline">\(11\)</span> 个位置</li></ol></div></details><h3>T7</h3><p>一个包含 <span class="math inline">\(8\)</span> 个顶点的完全图（顶点的编号为 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(8\)</span>），任意两点之间的边权重等于两顶点编号的差的绝对值。例如，顶点 <span class="math inline">\(3\)</span> 和 <span class="math inline">\(7\)</span> 之间的边权重为 <span class="math inline">\(|7 − 3| = 4\)</span>。该图的最小生成树的总权重是多少？</p><ul><li>A. 7</li><li>B. 8</li><li>C. 9</li><li>D. 10</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>A</p><p>用 Kruskal 算法求解：</p><p>边权最小分别为 <span class="math inline">\(1\rightarrow 2=1,2\rightarrow3=1,3\rightarrow4=1,4\rightarrow5=1,5\rightarrow6=1,6\rightarrow7=1\)</span>。</p><p>总权重为 <span class="math inline">\(7\)</span>。</p></div></details><h3>T8</h3><p>如果一棵二叉搜索树的后序遍历序列是 <code>2, 5, 4, 8, 12, 10, 6</code>，那么该树的前序遍历序列是什么？</p><ul><li>A. 6, 4, 2, 5, 10, 8, 12</li><li>B. 6, 4, 5, 2, 10, 12, 8</li><li>C. 2, 4, 5, 6, 8, 10, 12</li><li>D. 12, 8, 10, 5, 2, 4, 6</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>A</p><p>后序遍历 <code>2, 5, 4, 8, 12, 10, 6</code>，根是最后一个元素 <span class="math inline">\(6\)</span>。</p><p>二叉搜索树保证：左子树 &lt; 根 &lt; 右子树，所以左子树节点 <code>2, 5, 4</code>，右子树 <code>8, 12, 10</code>。</p><p>再结合后序遍历，可得：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    graph TD;    rt[6] --&gt; A[4];    rt --&gt; B[10];    A --&gt; C[2];    A --&gt; D[5];    B --&gt; E[8];    B --&gt; F[12];  </pre></div><p>即，前序遍历 <code>6, 4, 2, 5, 10, 8, 12</code>。</p></div></details><h3>T9</h3><p>一个 0-1 背包问题，背包容量为 <span class="math inline">\(20\)</span>。现有 <span class="math inline">\(5\)</span> 个物品，其重量和价值分别为 <code>7，5，4，3，6</code> 和 <code>15，12，9，7，13</code>。装入背包的物品能获得的最大总价值是多少？</p><ul><li>A. 43</li><li>B. 41</li><li>C. 45</li><li>D. 44</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>D</p><p>发现重量小的，价值也小，可以直接枚举。</p><ol type="1"><li><code>2, 3, 4, 5</code>，价值 <span class="math inline">\(41\)</span>。</li><li><code>1, 2, 3, 4</code>，价值 <span class="math inline">\(43\)</span>。</li><li><code>1, 3, 4, 5</code>，价值 <span class="math inline">\(44\)</span>。</li></ol></div></details><h3>T10</h3><p>在一棵以结点 <span class="math inline">\(1\)</span> 为根的树中，结点 <span class="math inline">\(12\)</span> 和结点 <span class="math inline">\(18\)</span> 的最近公共祖先 (LCA) 是结点 <span class="math inline">\(4\)</span>。那么下列哪个结点的 LCA 组合是不可能出现的？</p><ul><li>A. LCA(12, 4) = 4</li><li>B. LCA(18, 4) = 4</li><li>C. LCA(12, 18, 4) = 4</li><li>D. LCA(12, 1) = 4</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>D</p><p><span class="math inline">\(1\)</span> 是根节点，<span class="math inline">\(1\)</span> 与任何节点的 LCA 都是 <span class="math inline">\(1\)</span>。</p></div></details><h3>T11</h3><p>递归关系式 <span class="math inline">\(T(n) = 2T(\frac{n}{2}) + O(n^2)\)</span> 描述了某个分治算法的时间复杂度。请问该算法的时间复杂度是多少？</p><ul><li>A. <span class="math inline">\(O(n)\)</span></li><li>B. <span class="math inline">\(O(n\log n)\)</span></li><li>C. <span class="math inline">\(O(n^2)\)</span></li><li>D. <span class="math inline">\(O(n^2 \log n)\)</span></li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>C</p><p>主定理： <span class="math inline">\(\log_b a = \log_2 2 = 1\)</span>，<span class="math inline">\(2 &gt; 1\)</span>，因此为 <span class="math inline">\(O(n^2)\)</span>。</p></div></details><h3>T12</h3><p>在一个初始为空的最小堆（min-heap）中，依次插入元素 <code>20, 12, 15, 8, 10, 5</code>。然后连续执行两次“删除最小值”（delete-min）操作。请问此时堆顶元素是什么？</p><ul><li>A. 10</li><li>B. 12</li><li>C. 15</li><li>D. 20</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>A</p><p>即第三小的值。</p></div></details><h3>T13</h3><p><span class="math inline">\(1\)</span> 到 <span class="math inline">\(1000\)</span> 之间，不能被 <span class="math inline">\(2\)</span>、<span class="math inline">\(3\)</span>、<span class="math inline">\(5\)</span> 中任意一个数整除的整数有多少个？</p><ul><li>A. 266</li><li>B. 267</li><li>C. 333</li><li>D. 734</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>A</p><p>容斥原理。</p><ol type="1"><li>能被 <span class="math inline">\(2,3,5\)</span> 整除的数：<ul><li><span class="math inline">\(2\)</span>：<span class="math inline">\(\lfloor 1000/2 \rfloor = 500\)</span></li><li><span class="math inline">\(3\)</span>：<span class="math inline">\(\lfloor 1000/3 \rfloor = 333\)</span></li><li><span class="math inline">\(5\)</span>：<span class="math inline">\(\lfloor 1000/5 \rfloor = 200\)</span></li></ul></li><li>能被两两相乘整除的数：<ul><li><span class="math inline">\(2\times 3 = 6\)</span>: <span class="math inline">\(\lfloor 1000/6 \rfloor = 166\)</span></li><li><span class="math inline">\(2\times 5 = 10\)</span>: <span class="math inline">\(\lfloor 1000/10 \rfloor = 100\)</span></li><li><span class="math inline">\(3\times 5 = 15\)</span>: <span class="math inline">\(\lfloor 1000/15 \rfloor = 66\)</span></li></ul></li><li>能被 <span class="math inline">\(3\)</span> 个数整除的数：<ul><li><span class="math inline">\(2\times 3\times 5 = 30\)</span>: <span class="math inline">\(\lfloor 1000/30 \rfloor = 33\)</span></li></ul></li></ol><p>总答案即为 <span class="math inline">\(1000 - (500+333+200 - 166-100-66+33) = 266\)</span>。</p></div></details><h3>T14</h3><p>斐波那契数列的定义为 <span class="math inline">\(F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)\)</span>。使用朴素递归方法计算 <span class="math inline">\(F(n)\)</span> 的时间复杂度是指数级的。而使用动态规划（或迭代）方法的时间复杂度是线性的。造成这种巨大差异的根本原因是？</p><ul><li>A. 递归函数调用栈开销过大</li><li>B. 操作系统对递归深度有限制</li><li>C. 朴素递归中存在大量的重叠子问题未被重复利用</li><li>D. 动态规划使用了更少的数据存储空间</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>C</p><p>显然，朴素递归中存在大量的重叠子问题未被重复利用，这也是动态规划的优势所在。</p></div></details><h3>T15</h3><p>有 <span class="math inline">\(5\)</span> 个独立的、不可抢占的任务 <code>A1, A2, A3, A4, A5</code> 需要在一台机器上执行（从时间 <span class="math inline">\(0\)</span> 开始执行），每个任务都有对应的处理时长和截止时刻，按顺序分别为 <code>3, 4, 2, 5, 1</code> 和 <code>5, 10, 3, 15, 11</code>。如果某一个任务超时，相应的惩罚等于其处理时长。为了最小化总惩罚，应该优先执行哪个任务？</p><ul><li>A. 处理时间最短的任务 <code>A5</code></li><li>B. 截止时间最早的任务 <code>A3</code></li><li>C. 处理时间最长的任务 <code>A4</code></li><li>D. 任意一个任务都可以</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>B</p><p>贪心模拟即可。</p></div></details><h2>程序阅读</h2><h3>T16</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">bool</span> flag[<span class="number">27</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> p[<span class="number">27</span>];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == n + <span class="number">1</span>) &#123;</span><br><span class="line">++ans;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (flag[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (k &gt; <span class="number">1</span> &amp;&amp; i == p[k - <span class="number">1</span>] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">p[k] = i;</span><br><span class="line">flag[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs</span>(k + <span class="number">1</span>);</span><br><span class="line">flag[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断题</strong></p><ol type="1"><li>当输入的 <span class="math inline">\(n=3\)</span> 的时候，程序输出的答案为 <span class="math inline">\(3\)</span>。</li><li>在 <code>dfs</code> 函数运行过程中，<span class="math inline">\(k\)</span> 的取值会满足 <span class="math inline">\(1 \le k \le n+1\)</span>。</li><li>删除第 <span class="math inline">\(19\)</span> 行的 <code>flag[i]=false;</code>，对答案不会产生影响。</li></ol><p><strong>选择题</strong></p><ol type="1"><li>当输入的 <span class="math inline">\(n=4\)</span> 的时候, 程序输出的答案为？<ul><li>A. 11</li><li>B. 12</li><li>C. 24</li><li>D. 9</li></ul></li><li>如果因为某些问题，导致程序运行第 <span class="math inline">\(25\)</span> 行的 <code>dfs</code> 函数之前，数组 <code>p</code> 的初值并不全为 <span class="math inline">\(0\)</span>，则对程序的影响是？<ul><li>A. 输出的答案比原答案要小</li><li>B. 无法确定输出的答案</li><li>C. 程序可能陷入死循环</li><li>D. 没有影响</li></ul></li><li>假如删去第 <span class="math inline">\(14\)</span> 行的 <code>if(flag[i]) continue;</code>，输入 <span class="math inline">\(3\)</span>，得到的输出答案是？<ul><li>A. 27</li><li>B. 3</li><li>C. 16</li><li>D. 12</li></ul></li></ol><details class="toggle" ><summary class="toggle-button" style="">解析</summary><div class="toggle-content"><p>程序为求解 <span class="math inline">\(p_i +1 \neq p_{i+1}\)</span> 的长度为 <span class="math inline">\(n\)</span> 的 <strong>排列</strong> <span class="math inline">\(p\)</span> 的方案数。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>TTFADC</p><p><strong>判断题</strong></p><ol type="1"><li>手动模拟，得出答案为 <span class="math inline">\(3\)</span>。</li><li>显然，第 <span class="math inline">\(25\)</span> 行，<span class="math inline">\(k\)</span> 初值为 <span class="math inline">\(1\)</span>；第 <span class="math inline">\(9 \sim 12\)</span> 行，<span class="math inline">\(k = n+1\)</span> 就会返回。</li><li>显然，未清空标记，方案数会减少。</li></ol><p><strong>选择题</strong></p><ol type="1"><li>手动模拟。</li><li>不会影响，因为在计算 <span class="math inline">\(p_i\)</span> 时，<span class="math inline">\(p_{i-1}\)</span> <strong>一定</strong> 被重新赋值完。</li><li>删去，则去掉了 <strong>排列</strong> 的限制，还是手动模拟。</li></ol></div></details><h3>T17</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">int</span> cnt_broken = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt_check = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;now check:%d\n&quot;</span>, h);</span><br><span class="line">    ++cnt_check;</span><br><span class="line">    <span class="keyword">if</span> (cnt_broken == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You have no egg!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h &gt;= k) &#123;</span><br><span class="line">        ++cnt_broken;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">assert_ans</span><span class="params">(<span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == k) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You are Right using %d checks\n&quot;</span>, cnt_check);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Wrong answer!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">guess1</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(i)) &#123;</span><br><span class="line">            <span class="built_in">assert_ans</span>(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">guess2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (w = <span class="number">1</span>; w * (w + <span class="number">1</span>) / <span class="number">2</span> &lt; n; ++w)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ti = w, nh = w;; --ti, nh += ti, nh = std::<span class="built_in">min</span>(nh, n)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(nh)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = nh - ti + <span class="number">1</span>; j &lt; nh; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(j)) &#123;</span><br><span class="line">                    <span class="built_in">assert_ans</span>(j);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">assert_ans</span>(nh);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">guess1</span>(n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">guess2</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：下述的 “猜测数” 为调用 <code>check</code> 函数的次数（即 <code>cnt_check</code> 的值）；“猜测正确” 的含义为 <code>assert_ans</code> 函数 <code>return true</code>（执行第 <span class="math inline">\(25\)</span> 行所在分支）的情况；所有输入保证 <span class="math inline">\(1 \le k \le n\)</span>。</p><p><strong>判断题</strong></p><ol type="1"><li>当输入为 <code>6 5 1</code> 时，猜测次数为 <span class="math inline">\(5\)</span>；当输入为 <code>6 5 2</code> 时，猜测次数为 <span class="math inline">\(3\)</span>。</li><li>不管输入的 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(k\)</span> 具体为多少，<span class="math inline">\(t=2\)</span> 时的猜测数总是小于等于 <span class="math inline">\(t=1\)</span> 时的猜测数。</li><li>不管 <span class="math inline">\(t=1\)</span> 或 <span class="math inline">\(t=2\)</span>，程序都一定会猜到正确结果。</li></ol><p><strong>选择题</strong></p><ol type="1"><li>函数 <code>guess1</code> 在运行过程中，<code>cnt_broken</code> 的值最多为？<ul><li>A. 0</li><li>B. 1</li><li>C. 2</li><li>D. n</li></ul></li><li>函数 <code>guess2</code> 在运行过程中，最多使用的猜测次数的量级为？<ul><li>A. <span class="math inline">\(O(n)\)</span></li><li>B. <span class="math inline">\(O(n^2)\)</span></li><li>C. <span class="math inline">\(O(\sqrt{n})\)</span></li><li>D. <span class="math inline">\(O(\log n)\)</span></li></ul></li><li>当输入的 <span class="math inline">\(n=100\)</span> 时，代码中 <span class="math inline">\(t=1\)</span> 和 <span class="math inline">\(t=2\)</span> 分别需要的猜测次数最多分别为？<ul><li>A. 100,14</li><li>B. 100,13</li><li>C. 99,14</li><li>D. 99,13</li></ul></li></ol><details class="toggle" ><summary class="toggle-button" style="">解析</summary><div class="toggle-content"><p><sub><sub>今年最奇怪的题目</sub></sub></p><p>由 <code>egg</code>，<code>cnt_broken</code> 可以得出（？），我们假设这样一个情景：</p><p>现在你有两个一样的鸡蛋，你可以进行一种操作：</p><ul><li>把鸡蛋从一个高度 <span class="math inline">\(h\)</span> 扔下来，观察它有没有摔碎。如果鸡蛋碎了，这个鸡蛋就不能再用了，你需要用另一个鸡蛋继续尝试，如果两个都碎了（<code>You have no egg!</code>），则游戏结束。</li></ul><p>现在，你想知道会让鸡蛋摔碎的最小高度（<code>guess1</code>），和知道前者的最小操作次数（<code>guess2</code>）。</p><p><strong>guess1</strong></p><p><code>guess1</code> 函数比较好懂，就是枚举所有可能的高度，这样会一定会摔碎 <span class="math inline">\(1\)</span> 个鸡蛋。</p><p><strong>guess2</strong></p><p><code>guess2</code> 函数略复杂，它将高度分为了几个区间，我们以 <span class="math inline">\(n = 15\)</span> 为例，化为了 <span class="math inline">\([1,5],[6,9],[10,12],[13,14],[15,15]\)</span> 五段，它们的长度依次递减，分别为 <span class="math inline">\(5,4,3,2,1\)</span>。</p><p>对于每段区间，我们先尝试它的右端点，如果没摔碎说明高度足够，就尝试下一个区间。</p><p>如果摔碎了，因为只剩一个鸡蛋，只能模仿 <code>guess1</code> 从小到大依次尝试，求出最终答案。</p><p>这样摔碎鸡蛋的数量一定是 <span class="math inline">\(1\)</span> 或 <span class="math inline">\(2\)</span>。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>TFTBCA</p><p><strong>判断题</strong></p><ol type="1"><li>手动模拟，得出答案为 <span class="math inline">\(5\)</span>。</li><li>不一定，如果鸡蛋在很低的高度就碎了，<code>guess2</code> 需要额外尝试区间的右端点，多一次猜测。</li><li>显然正确。</li></ol><p><strong>选择题</strong></p><ol type="1"><li>显然为 <span class="math inline">\(1\)</span>。</li><li>猜测次数的最大值 <span class="math inline">\(m\)</span>，要满足 <span class="math inline">\(\frac{m(m-1)}{2} \ge n\)</span>，解二次不等式得 <span class="math inline">\(m\)</span> 的最小值为 <span class="math inline">\(\left\lceil\frac{1+\sqrt{1+8n}}{2}\right\rceil\)</span>，量级估算为 <span class="math inline">\(\sqrt{2n} \approx \sqrt{n}\)</span>。</li><li>手动模拟。</li></ol></div></details><h3>T18</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; k, p;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mpow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; k; k = k &gt;&gt; <span class="number">1</span>, x = x * x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; ans1, ans2;</span><br><span class="line"><span class="type">int</span> cnt1, cnt2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; ans, <span class="type">int</span>&amp; cnt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(ans, cnt, l + <span class="number">1</span>, r, v + k[l] * <span class="built_in">mpow</span>(i, p[l]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; cntans1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    k.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    p.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k[i], &amp;p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(ans1, cnt1, <span class="number">1</span>, n &gt;&gt; <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(ans2, cnt2, (n &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">    std::<span class="built_in">sort</span>(ans<span class="number">1.</span><span class="built_in">begin</span>(), ans<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> newcnt1 = <span class="number">1</span>;</span><br><span class="line">    cntans<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt1; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans1[i] == ans1[newcnt1 - <span class="number">1</span>]) &#123;</span><br><span class="line">            ++cntans1[newcnt1 - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans1[newcnt1++] = ans1[i];</span><br><span class="line">            cntans<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt1 = newcnt1;</span><br><span class="line">    std::<span class="built_in">sort</span>(ans<span class="number">2.</span><span class="built_in">begin</span>(), ans<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> las = <span class="number">0</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cnt2 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; las &lt; cnt1 &amp;&amp; ans1[las] + ans2[i] &lt; <span class="number">0</span>; ++las)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">if</span> (las &lt; cnt1 &amp;&amp; ans1[las] + ans2[i] == <span class="number">0</span>)</span><br><span class="line">            ans += cntans1[las];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断题</strong></p><ol type="1"><li>删除第 <span class="math inline">\(51\)</span> 行的 <code>std::sort(ans2.begin(), ans2.end());</code> 后，代码输出的结果不会受到影响。</li><li>假设计算过程中不发生溢出，函数 <code>mpow(x, k)</code> 的功能是求出 <span class="math inline">\(x^k\)</span>。</li><li>代码中第 <span class="math inline">\(39\)</span> 行到第 <span class="math inline">\(50\)</span> 行的目的是为了将 <code>ans1</code> 数组进行“去重”操作。</li></ol><p><strong>选择题</strong></p><ol type="1"><li>当输入为 <code>3 15 1 2 -1 2 1 2</code> 时，输出结果为？<ul><li>A. 4</li><li>B. 8</li><li>C. 0</li><li>D. 10</li></ul></li><li>记程序结束前 <code>p</code> 数组元素的最大值为 <span class="math inline">\(P\)</span>，则该代码的时间复杂度是？<ul><li>A. <span class="math inline">\(O(n)\)</span></li><li>B. <span class="math inline">\(O(m^n \log m^n)\)</span></li><li>C. <span class="math inline">\(O(m^\frac{n}{2} \log m^\frac{n}{2})\)</span></li><li>D. <span class="math inline">\(O(m^\frac{n}{2} (\log m^\frac{n}{2} + \log P))\)</span></li></ul></li><li>本题所求出的是？<ul><li>A. 满足 <span class="math inline">\(a,b,c \in [1,m]\)</span> 的整数方程 <span class="math inline">\(a^3+b^3=c^3\)</span> 的解的数量</li><li>B. 满足 <span class="math inline">\(a,b,c \in [1,m]\)</span> 的整数方程 <span class="math inline">\(a^2+b^2=c^2\)</span> 的解的数量</li><li>C. 满足 <span class="math inline">\(x_i \in [0,m]\)</span> 的整数方程 <span class="math inline">\(\sum_{i=1}^n k_i \cdot x_i^{p_i} = 0\)</span> 的解的数量</li><li>D. 满足 <span class="math inline">\(x_i \in [1,m]\)</span> 的整数方程 <span class="math inline">\(\sum_{i=1}^n k_i \cdot x_i^{p_i} = 0\)</span> 的解的数量</li></ul></li></ol><details class="toggle" ><summary class="toggle-button" style="">解析</summary><div class="toggle-content"><p>先看选择题第三问，首先排除 <code>A,B</code> 选项，根本没有出现输入的量。</p><p>观察第 <span class="math inline">\(24\)</span> 行，枚举从 <span class="math inline">\(1\)</span> 开始，故程序含义为：</p><ul><li>满足 <span class="math inline">\(x_i \in [1,m]\)</span> 的整数方程 <span class="math inline">\(\sum_{i=1}^n k_i \cdot x_i^{p_i} = 0\)</span> 的解的数量。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>FTTBDD</p><p><strong>判断题</strong></p><ol type="1"><li><span class="math inline">\(52\)</span> 到 <span class="math inline">\(59\)</span> 行是双指针计算答案，不排序显然会影响结果。</li><li>快速幂。</li><li>显然。</li></ol><p><strong>选择题</strong></p><ol type="1"><li>结合程序意义，即求 <span class="math inline">\(x_1^2+x_3^2=x_2^2，x_i \in [1,15]\)</span> 的方案数，可以手动枚举计算，也容易联想到就是求边长在 <span class="math inline">\(15\)</span> 以内的直角三角形的数量。</li></ol></div></details><h2>完善程序</h2><h3>T19 特殊最短路</h3><p>给定一个含 <span class="math inline">\(N\)</span> 个点、<span class="math inline">\(M\)</span> 条边的带权无向图，边权非负。起点为 <span class="math inline">\(S\)</span>，终点为 <span class="math inline">\(T\)</span>。对于一条 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 的路径，可以在整条路径中，至多选择一条边作为“免费边”：当第一次经过这条被选中的边时，费用视为 <span class="math inline">\(0\)</span>；如果之后再次经过该边，则仍按其原始权重计费。点和边均允许重复经过。求从 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 的最小总费用。</p><p>以下代码求解了上述问题。试补全程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> INF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="type">int</span> to;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dist;</span><br><span class="line"><span class="type">int</span> u;</span><br><span class="line"><span class="type">int</span> used_freebie;<span class="comment">//0 for not used, 1 for used</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> State &amp;other) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> dist &gt; other.dist;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m, s, t;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;Edge&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">adj[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">adj[v].<span class="built_in">push_back</span>(&#123;u, w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">d</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">2</span>, INF));</span><br><span class="line">priority_queue&lt;State, vector&lt;State&gt;, greater&lt;State&gt;&gt; pq;</span><br><span class="line"></span><br><span class="line">d[s][<span class="number">0</span>]= <span class="number">0</span>;</span><br><span class="line">pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s,   ①  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">State current =pq.<span class="built_in">top</span>();</span><br><span class="line">pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dist = current.dist;</span><br><span class="line"><span class="type">int</span> u= current.u;</span><br><span class="line"><span class="type">int</span> used = current.used_freebie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dist &gt;   ②  )&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;edge : adj[u]) &#123;</span><br><span class="line"><span class="type">int</span> v = edge.to;</span><br><span class="line"><span class="type">int</span> w = edge.weight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(d[u][used] + w &lt;   ③  )&#123;</span><br><span class="line">   ③  = d[u][used] + w;</span><br><span class="line">pq.<span class="built_in">push</span>(&#123;  ③  , v , used&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(used == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(  ④   &lt; d[v][<span class="number">1</span>])&#123;</span><br><span class="line">d[v][<span class="number">1</span>] =   ④  ;</span><br><span class="line">pq.<span class="built_in">push</span>(&#123;d[v][<span class="number">1</span>], v, <span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt;   ⑤   &lt;&lt;  endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li>① 处应填：<ul><li>A. 0</li><li>B. 1</li><li>C. -1</li><li>D. false</li></ul></li><li>② 处应填：<ul><li>A. d[u][!used]</li><li>B. d[u][used]</li><li>C. d[t][used]</li><li>D. INF</li></ul></li><li>③ 处应填：<ul><li>A. d[v][1]</li><li>B. d[v][used]</li><li>C. d[u][used]</li><li>D. d[v][0]</li></ul></li><li>④ 处应填：<ul><li>A. d[v][0]</li><li>B. d[v][1]</li><li>C. d[u][0]</li><li>D. d[u][1]</li></ul></li><li>⑤ 处应填：<ul><li>A. d[t][1]</li><li>B. d[t][0]</li><li>C. min(d[t][0], d[t][1])</li><li>D. d[t][0]+d[t][1]</li></ul></li></ol><h3>T20 最优测试</h3><p>工厂打算通过客户反馈来间接测试生产线，从而找到存在缺陷的生产线。工厂有 <span class="math inline">\(n\)</span> 条生产线（编号 <span class="math inline">\(0\sim n−1\)</span>），已知其中恰有一条生产线存在缺陷。每一轮测试为，从若干生产线的产品取样混合成一个批次发给客户。若该批次中包含缺陷生产线的产品，客户将要求退货（结果记为 <span class="math inline">\(1\)</span>），否则正常收货（记为 <span class="math inline">\(0\)</span>）。受售后压力限制，在所有发货批次中，最多只能有 <span class="math inline">\(k\)</span> 次退货（即结果为 <span class="math inline">\(1\)</span> 的次数 <span class="math inline">\(\le k\)</span>）。工厂的目标是，设计最少的间接测试轮数 <span class="math inline">\(w\)</span>（发货总批次），保证根据客户收货或退货的反馈结果，唯一确定存在缺陷的生产线。</p><p>以下程序实现了工厂的目标，包含两部分：</p><ol type="1"><li>确定 <span class="math inline">\(w\)</span> 的最小值，并设计最优测试方案；</li><li>根据测试结果推断存在缺陷的生产线。该程序确定 <span class="math inline">\(w\)</span> 最小值的方法为：由于不同的生产线故障时，测试应当返回不同的结果，因此 <span class="math inline">\(w\)</span> 轮测试的可能结果数不应少于生产线数量。</li></ol><p><code>test_subset()</code> 函数为抽象测试接口，输入所有批次的方案并返回一个二进制编码；该编码表示为每批次的检测结果（即最低位是第 <span class="math inline">\(1\)</span> 批次、最高位是第 <span class="math inline">\(w\)</span> 批次）；其实现在此处未给出。</p><p>试补全程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">comb</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; w) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= i; ++t) &#123;</span><br><span class="line">        res = res * (w - t + <span class="number">1</span>) / t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算长度为 w、1 的个数 ≤k 的码字总数 </span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">count_patterns</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="built_in">min</span>(w, k); ++t) &#123;</span><br><span class="line">        total += <span class="built_in">comb</span>(w, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象测试接口 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_subset</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; plan)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="comment">// === 第 1 步：求最小 w === </span></span><br><span class="line">    <span class="type">int</span> w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (  ① ) &#123; </span><br><span class="line">        ++w;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; w &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// === 第 2 步：生成测试方案 === </span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">code</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(w, <span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ones = <span class="number">0</span>; ones &lt;= k &amp;&amp; idx &lt; n; ++ones) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bits</span><span class="params">(w, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">fill</span>(bits.<span class="built_in">begin</span>(), bits.<span class="built_in">begin</span>() + ones, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; w; ++b) &#123;</span><br><span class="line">                code[idx][b] = bits[b];</span><br><span class="line">            &#125;</span><br><span class="line">            ++idx;</span><br><span class="line">            <span class="keyword">if</span> (idx &gt;= n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ( std::  ② );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">plan</span>(w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; w; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (  ③ ) &#123; </span><br><span class="line">                plan[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// === 第 3 步：调用测试接口 === </span></span><br><span class="line">    <span class="type">int</span> signature = <span class="built_in">test_subset</span>(plan);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// === 第 4 步：结果解码 === </span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sig_bits</span><span class="params">(w, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; w; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (  ④ ) &#123; </span><br><span class="line">            sig_bits[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (  ⑤ ) <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">solve</span>(n, k);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li>① 处应填：<ul><li>A. (1&lt;&lt;w)&lt;n</li><li>B. count_patterns(w,k) &lt; n</li><li>C. count_patterns(k,w) &lt; n</li><li>D. comb(w,k) &lt; n</li></ul></li><li>② 处应填：<ul><li>A. next_permutation(bits.begin(), bits.end())</li><li>B. prev_permutation(bits.begin(), bits.end())</li><li>C. next_permutation(bits.begin(), bits.begin()+ones)</li><li>D. prev_permutation(bits.begin(), bits.begin()+ones)</li></ul></li><li>③ 处应填：<ul><li>A. (j&gt;&gt;i) &amp; 1</li><li>B. (i&gt;&gt;j) &amp; 1</li><li>C. code[i][j] == 1</li><li>D. code[j][i] == 1</li></ul></li><li>④ 处应填：<ul><li>A. (signature &gt;&gt; i) &amp; 1</li><li>B. (signature &gt;&gt; i) ^ 1</li><li>C. signature | (1&lt;&lt;i)</li><li>D. (signature &gt;&gt; i) | 1</li></ul></li><li>⑤ 处应填：<ul><li>A. is_permutation(code[j].begin(), code[j].end(), sig_bits.begin())</li><li>B. code[j] == sig_bits</li><li>C. plan[j] == sig_bits</li><li>D. code[j][i] == sig_bits[i]</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP-S 2025 初赛题目解析</title>
      <link href="/posts/f1d582a1/"/>
      <url>/posts/f1d582a1/</url>
      
        <content type="html"><![CDATA[<h2>单项选择</h2><h3>T1</h3><p>有 <span class="math inline">\(5\)</span> 个红色球和 <span class="math inline">\(5\)</span> 个蓝色球，它们除了颜色之外完全相同。将这 <span class="math inline">\(10\)</span> 个球排成一排，要求任意两个蓝色球都不能相邻，有多少种不同的排列方法？</p><ul><li>A. 25</li><li>B. 30</li><li>C. 6</li><li>D. 120</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>C</p><p>将 <span class="math inline">\(5\)</span> 个红色球排成一排，共有 <span class="math inline">\(6\)</span> 个空隙（<code>_R_R_R_R_R_</code>）。</p><p>将 <span class="math inline">\(5\)</span> 个蓝色球，放在 <span class="math inline">\(6\)</span> 个空中，共 <span class="math inline">\(\binom{6}{5} = 6\)</span></p></div></details><h3>T2</h3><p>在 KMP 算法中，对于模式串 <span class="math inline">\(P = \text{abacaba}\)</span>，其 <code>next</code> 数组（ <span class="math inline">\(next[i]\)</span> 定义为模式串 <span class="math inline">\(P[0\dots i]\)</span> 最长公共前后缀的长度，且数组下标从 <span class="math inline">\(0\)</span> 开始）的值是什么？</p><ul><li>A. {0,0,1,0,1,2,3}</li><li>B. {0,1,2,3,4,5,6}</li><li>C. {0,0,1,1,2,2,3}</li><li>D. {0,0,0,0,1,2,3}</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>A</p><p>模拟即可。</p></div></details><h3>T3</h3><p>对一个大小为 <span class="math inline">\(16\)</span>（下标 <span class="math inline">\(0 \sim 15\)</span>）的数组上构建满线段树。查询区间 <span class="math inline">\([3,11]\)</span> 时，最少需要访问多少个树结点（包括路径上的父结点和完全包含在查询区间内的结点）？</p><ul><li>A. 7</li><li>B. 8</li><li>C. 9</li><li>D. 10</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>B</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    graph TD;    A[0,15] --&gt; B[0,7];    A --&gt; C[8,15];    B --&gt; D[0,3];    B --&gt; E[4,7];    C --&gt; F[8,11];    C --&gt; G[12,15];    D --&gt; H[0,1];    D --&gt; I[2,3];    I --&gt; J[2];    I --&gt; K[3];    style A fill:red;    style B fill:red;    style C fill:red;    style D fill:red;    style E fill:red;    style F fill:red;    style I fill:red;    style K fill:red;  </pre></div></div></details><h3>T4</h3><p>将字符串 <code>cat</code>, <code>car</code>, <code>cart</code>, <code>case</code>, <code>dog</code>, <code>do</code> 插入一个空的 Trie 树（前缀树）中。构建完成的 Trie 树（包括根结点）共有多少个结点？</p><ul><li>A. 8</li><li>B. 9</li><li>C. 10</li><li>D. 11</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>D</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    graph TD;    rt[root] --&gt; c0[c];    c0 --&gt; a1[a];    a1 --&gt; t2[t];    a1 --&gt; r2[r];    r2 --&gt; t3[t];    a1 --&gt; s2[s];    s2 --&gt; e3[e];    rt --&gt; d0[d];    d0 --&gt; o1[o];    o1 --&gt; g2[g];  </pre></div></div></details><h3>T5</h3><p>对于一个包含 <span class="math inline">\(n\)</span> 个顶点和 <span class="math inline">\(m\)</span> 条边的有向无环图（DAG），其拓扑排序的结果有多少种可能？</p><ul><li>A. 只有 <span class="math inline">\(1\)</span> 种</li><li>B. 最多 <span class="math inline">\(n\)</span> 种</li><li>C. 等于 <span class="math inline">\(n-m\)</span> 种</li><li>D. 以上都不对</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>D</p><p>拓扑排序的数量取决于图的具体结构，没有一个简单的公式可以计算。</p><p>如，没有边为 <span class="math inline">\(n!\)</span> 种，是链则只有 <span class="math inline">\(1\)</span> 种。</p></div></details><h3>T6</h3><p>在一个大小为 <span class="math inline">\(13\)</span> 的哈希表中，使用闭散列法的线性探查来解决冲突。哈希函数为 <span class="math inline">\(H(key)=key \mod 13\)</span>。依次插入关键字 <code>18</code>, <code>26</code>, <code>35</code>, <code>9</code>, <code>68</code>, <code>74</code>。插入 <code>74</code> 后，它最终被放置在哪个索引位置？</p><ul><li>A. 5</li><li>B. 7</li><li>C. 9</li><li>D. 11</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>D</p><ol type="1"><li><span class="math inline">\(18 \mod 13 = 5\)</span></li><li><span class="math inline">\(26 \mod 13 = 0\)</span></li><li><span class="math inline">\(35 \mod 13 = 9\)</span></li><li><span class="math inline">\(9 \mod 13 = 9\)</span>，<span class="math inline">\(9\)</span> 冲突，放在第 <span class="math inline">\(10\)</span> 个位置</li><li><span class="math inline">\(68 \mod 13 = 3\)</span></li><li><span class="math inline">\(74 \mod 13 = 9\)</span>，<span class="math inline">\(9,10\)</span> 冲突，放在第 <span class="math inline">\(11\)</span> 个位置</li></ol></div></details><h3>T7</h3><p>一个包含 <span class="math inline">\(8\)</span> 个顶点的完全图（顶点的编号为 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(8\)</span>），任意两点之间的边权重等于两顶点编号的差的绝对值。例如，顶点 <span class="math inline">\(3\)</span> 和 <span class="math inline">\(7\)</span> 之间的边权重为 <span class="math inline">\(|7 − 3| = 4\)</span>。该图的最小生成树的总权重是多少？</p><ul><li>A. 7</li><li>B. 8</li><li>C. 9</li><li>D. 10</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>A</p><p>用 Kruskal 算法求解：</p><p>边权最小分别为 <span class="math inline">\(1\rightarrow 2=1,2\rightarrow3=1,3\rightarrow4=1,4\rightarrow5=1,5\rightarrow6=1,6\rightarrow7=1\)</span>。</p><p>总权重为 <span class="math inline">\(7\)</span>。</p></div></details><h3>T8</h3><p>如果一棵二叉搜索树的后序遍历序列是 <code>2, 5, 4, 8, 12, 10, 6</code>，那么该树的前序遍历序列是什么？</p><ul><li>A. 6, 4, 2, 5, 10, 8, 12</li><li>B. 6, 4, 5, 2, 10, 12, 8</li><li>C. 2, 4, 5, 6, 8, 10, 12</li><li>D. 12, 8, 10, 5, 2, 4, 6</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>A</p><p>后序遍历 <code>2, 5, 4, 8, 12, 10, 6</code>，根是最后一个元素 <span class="math inline">\(6\)</span>。</p><p>二叉搜索树保证：左子树 &lt; 根 &lt; 右子树，所以左子树节点 <code>2, 5, 4</code>，右子树 <code>8, 12, 10</code>。</p><p>再结合后序遍历，可得：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    graph TD;    rt[6] --&gt; A[4];    rt --&gt; B[10];    A --&gt; C[2];    A --&gt; D[5];    B --&gt; E[8];    B --&gt; F[12];  </pre></div><p>即，前序遍历 <code>6, 4, 2, 5, 10, 8, 12</code>。</p></div></details><h3>T9</h3><p>一个 0-1 背包问题，背包容量为 <span class="math inline">\(20\)</span>。现有 <span class="math inline">\(5\)</span> 个物品，其重量和价值分别为 <code>7，5，4，3，6</code> 和 <code>15，12，9，7，13</code>。装入背包的物品能获得的最大总价值是多少？</p><ul><li>A. 43</li><li>B. 41</li><li>C. 45</li><li>D. 44</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>D</p><p>发现重量小的，价值也小，可以直接枚举。</p><ol type="1"><li><code>2, 3, 4, 5</code>，价值 <span class="math inline">\(41\)</span>。</li><li><code>1, 2, 3, 4</code>，价值 <span class="math inline">\(43\)</span>。</li><li><code>1, 3, 4, 5</code>，价值 <span class="math inline">\(44\)</span>。</li></ol></div></details><h3>T10</h3><p>在一棵以结点 <span class="math inline">\(1\)</span> 为根的树中，结点 <span class="math inline">\(12\)</span> 和结点 <span class="math inline">\(18\)</span> 的最近公共祖先 (LCA) 是结点 <span class="math inline">\(4\)</span>。那么下列哪个结点的 LCA 组合是不可能出现的？</p><ul><li>A. LCA(12, 4) = 4</li><li>B. LCA(18, 4) = 4</li><li>C. LCA(12, 18, 4) = 4</li><li>D. LCA(12, 1) = 4</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>D</p><p><span class="math inline">\(1\)</span> 是根节点，<span class="math inline">\(1\)</span> 与任何节点的 LCA 都是 <span class="math inline">\(1\)</span>。</p></div></details><h3>T11</h3><p>递归关系式 <span class="math inline">\(T(n) = 2T(\frac{n}{2}) + O(n^2)\)</span> 描述了某个分治算法的时间复杂度。请问该算法的时间复杂度是多少？</p><ul><li>A. <span class="math inline">\(O(n)\)</span></li><li>B. <span class="math inline">\(O(n\log n)\)</span></li><li>C. <span class="math inline">\(O(n^2)\)</span></li><li>D. <span class="math inline">\(O(n^2 \log n)\)</span></li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>C</p><p>主定理： <span class="math inline">\(\log_b a = \log_2 2 = 1\)</span>，<span class="math inline">\(2 &gt; 1\)</span>，因此为 <span class="math inline">\(O(n^2)\)</span>。</p></div></details><h3>T12</h3><p>在一个初始为空的最小堆（min-heap）中，依次插入元素 <code>20, 12, 15, 8, 10, 5</code>。然后连续执行两次“删除最小值”（delete-min）操作。请问此时堆顶元素是什么？</p><ul><li>A. 10</li><li>B. 12</li><li>C. 15</li><li>D. 20</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>A</p><p>即第三小的值。</p></div></details><h3>T13</h3><p><span class="math inline">\(1\)</span> 到 <span class="math inline">\(1000\)</span> 之间，不能被 <span class="math inline">\(2\)</span>、<span class="math inline">\(3\)</span>、<span class="math inline">\(5\)</span> 中任意一个数整除的整数有多少个？</p><ul><li>A. 266</li><li>B. 267</li><li>C. 333</li><li>D. 734</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>A</p><p>容斥原理。</p><ol type="1"><li>能被 <span class="math inline">\(2,3,5\)</span> 整除的数：<ul><li><span class="math inline">\(2\)</span>：<span class="math inline">\(\lfloor 1000/2 \rfloor = 500\)</span></li><li><span class="math inline">\(3\)</span>：<span class="math inline">\(\lfloor 1000/3 \rfloor = 333\)</span></li><li><span class="math inline">\(5\)</span>：<span class="math inline">\(\lfloor 1000/5 \rfloor = 200\)</span></li></ul></li><li>能被两两相乘整除的数：<ul><li><span class="math inline">\(2\times 3 = 6\)</span>: <span class="math inline">\(\lfloor 1000/6 \rfloor = 166\)</span></li><li><span class="math inline">\(2\times 5 = 10\)</span>: <span class="math inline">\(\lfloor 1000/10 \rfloor = 100\)</span></li><li><span class="math inline">\(3\times 5 = 15\)</span>: <span class="math inline">\(\lfloor 1000/15 \rfloor = 66\)</span></li></ul></li><li>能被 <span class="math inline">\(3\)</span> 个数整除的数：<ul><li><span class="math inline">\(2\times 3\times 5 = 30\)</span>: <span class="math inline">\(\lfloor 1000/30 \rfloor = 33\)</span></li></ul></li></ol><p>总答案即为 <span class="math inline">\(1000 - (500+333+200 - 166-100-66+33) = 266\)</span>。</p></div></details><h3>T14</h3><p>斐波那契数列的定义为 <span class="math inline">\(F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)\)</span>。使用朴素递归方法计算 <span class="math inline">\(F(n)\)</span> 的时间复杂度是指数级的。而使用动态规划（或迭代）方法的时间复杂度是线性的。造成这种巨大差异的根本原因是？</p><ul><li>A. 递归函数调用栈开销过大</li><li>B. 操作系统对递归深度有限制</li><li>C. 朴素递归中存在大量的重叠子问题未被重复利用</li><li>D. 动态规划使用了更少的数据存储空间</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>C</p><p>显然，朴素递归中存在大量的重叠子问题未被重复利用，这也是动态规划的优势所在。</p></div></details><h3>T15</h3><p>有 <span class="math inline">\(5\)</span> 个独立的、不可抢占的任务 <code>A1, A2, A3, A4, A5</code> 需要在一台机器上执行（从时间 <span class="math inline">\(0\)</span> 开始执行），每个任务都有对应的处理时长和截止时刻，按顺序分别为 <code>3, 4, 2, 5, 1</code> 和 <code>5, 10, 3, 15, 11</code>。如果某一个任务超时，相应的惩罚等于其处理时长。为了最小化总惩罚，应该优先执行哪个任务？</p><ul><li>A. 处理时间最短的任务 <code>A5</code></li><li>B. 截止时间最早的任务 <code>A3</code></li><li>C. 处理时间最长的任务 <code>A4</code></li><li>D. 任意一个任务都可以</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>B</p><p>贪心模拟即可。</p></div></details><h2>程序阅读</h2><h3>T16</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">bool</span> flag[<span class="number">27</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> p[<span class="number">27</span>];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == n + <span class="number">1</span>) &#123;</span><br><span class="line">++ans;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (flag[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (k &gt; <span class="number">1</span> &amp;&amp; i == p[k - <span class="number">1</span>] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">p[k] = i;</span><br><span class="line">flag[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs</span>(k + <span class="number">1</span>);</span><br><span class="line">flag[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断题</strong></p><ol type="1"><li>当输入的 <span class="math inline">\(n=3\)</span> 的时候，程序输出的答案为 <span class="math inline">\(3\)</span>。</li><li>在 <code>dfs</code> 函数运行过程中，<span class="math inline">\(k\)</span> 的取值会满足 <span class="math inline">\(1 \le k \le n+1\)</span>。</li><li>删除第 <span class="math inline">\(19\)</span> 行的 <code>flag[i]=false;</code>，对答案不会产生影响。</li></ol><p><strong>选择题</strong></p><ol type="1"><li>当输入的 <span class="math inline">\(n=4\)</span> 的时候, 程序输出的答案为？<ul><li>A. 11</li><li>B. 12</li><li>C. 24</li><li>D. 9</li></ul></li><li>如果因为某些问题，导致程序运行第 <span class="math inline">\(25\)</span> 行的 <code>dfs</code> 函数之前，数组 <code>p</code> 的初值并不全为 <span class="math inline">\(0\)</span>，则对程序的影响是？<ul><li>A. 输出的答案比原答案要小</li><li>B. 无法确定输出的答案</li><li>C. 程序可能陷入死循环</li><li>D. 没有影响</li></ul></li><li>假如删去第 <span class="math inline">\(14\)</span> 行的 <code>if(flag[i]) continue;</code>，输入 <span class="math inline">\(3\)</span>，得到的输出答案是？<ul><li>A. 27</li><li>B. 3</li><li>C. 16</li><li>D. 12</li></ul></li></ol><details class="toggle" ><summary class="toggle-button" style="">解析</summary><div class="toggle-content"><p>程序为求解 <span class="math inline">\(p_i +1 \neq p_{i+1}\)</span> 的长度为 <span class="math inline">\(n\)</span> 的 <strong>排列</strong> <span class="math inline">\(p\)</span> 的方案数。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>TTFADC</p><p><strong>判断题</strong></p><ol type="1"><li>手动模拟，得出答案为 <span class="math inline">\(3\)</span>。</li><li>显然，第 <span class="math inline">\(25\)</span> 行，<span class="math inline">\(k\)</span> 初值为 <span class="math inline">\(1\)</span>；第 <span class="math inline">\(9 \sim 12\)</span> 行，<span class="math inline">\(k = n+1\)</span> 就会返回。</li><li>显然，未清空标记，方案数会减少。</li></ol><p><strong>选择题</strong></p><ol type="1"><li>手动模拟。</li><li>不会影响，因为在计算 <span class="math inline">\(p_i\)</span> 时，<span class="math inline">\(p_{i-1}\)</span> <strong>一定</strong> 被重新赋值完。</li><li>删去，则去掉了 <strong>排列</strong> 的限制，还是手动模拟。</li></ol></div></details><h3>T17</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">int</span> cnt_broken = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt_check = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;now check:%d\n&quot;</span>, h);</span><br><span class="line">    ++cnt_check;</span><br><span class="line">    <span class="keyword">if</span> (cnt_broken == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You have no egg!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h &gt;= k) &#123;</span><br><span class="line">        ++cnt_broken;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">assert_ans</span><span class="params">(<span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == k) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You are Right using %d checks\n&quot;</span>, cnt_check);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Wrong answer!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">guess1</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(i)) &#123;</span><br><span class="line">            <span class="built_in">assert_ans</span>(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">guess2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (w = <span class="number">1</span>; w * (w + <span class="number">1</span>) / <span class="number">2</span> &lt; n; ++w)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ti = w, nh = w;; --ti, nh += ti, nh = std::<span class="built_in">min</span>(nh, n)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(nh)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = nh - ti + <span class="number">1</span>; j &lt; nh; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(j)) &#123;</span><br><span class="line">                    <span class="built_in">assert_ans</span>(j);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">assert_ans</span>(nh);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">guess1</span>(n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">guess2</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：下述的 “猜测数” 为调用 <code>check</code> 函数的次数（即 <code>cnt_check</code> 的值）；“猜测正确” 的含义为 <code>assert_ans</code> 函数 <code>return true</code>（执行第 <span class="math inline">\(25\)</span> 行所在分支）的情况；所有输入保证 <span class="math inline">\(1 \le k \le n\)</span>。</p><p><strong>判断题</strong></p><ol type="1"><li>当输入为 <code>6 5 1</code> 时，猜测次数为 <span class="math inline">\(5\)</span>；当输入为 <code>6 5 2</code> 时，猜测次数为 <span class="math inline">\(3\)</span>。</li><li>不管输入的 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(k\)</span> 具体为多少，<span class="math inline">\(t=2\)</span> 时的猜测数总是小于等于 <span class="math inline">\(t=1\)</span> 时的猜测数。</li><li>不管 <span class="math inline">\(t=1\)</span> 或 <span class="math inline">\(t=2\)</span>，程序都一定会猜到正确结果。</li></ol><p><strong>选择题</strong></p><ol type="1"><li>函数 <code>guess1</code> 在运行过程中，<code>cnt_broken</code> 的值最多为？<ul><li>A. 0</li><li>B. 1</li><li>C. 2</li><li>D. n</li></ul></li><li>函数 <code>guess2</code> 在运行过程中，最多使用的猜测次数的量级为？<ul><li>A. <span class="math inline">\(O(n)\)</span></li><li>B. <span class="math inline">\(O(n^2)\)</span></li><li>C. <span class="math inline">\(O(\sqrt{n})\)</span></li><li>D. <span class="math inline">\(O(\log n)\)</span></li></ul></li><li>当输入的 <span class="math inline">\(n=100\)</span> 时，代码中 <span class="math inline">\(t=1\)</span> 和 <span class="math inline">\(t=2\)</span> 分别需要的猜测次数最多分别为？<ul><li>A. 100,14</li><li>B. 100,13</li><li>C. 99,14</li><li>D. 99,13</li></ul></li></ol><details class="toggle" ><summary class="toggle-button" style="">解析</summary><div class="toggle-content"><p><sub><sub>今年最奇怪的题目</sub></sub></p><p>由 <code>egg</code>，<code>cnt_broken</code> 可以得出（？），我们假设这样一个情景：</p><p>现在你有两个一样的鸡蛋，你可以进行一种操作：</p><ul><li>把鸡蛋从一个高度 <span class="math inline">\(h\)</span> 扔下来，观察它有没有摔碎。如果鸡蛋碎了，这个鸡蛋就不能再用了，你需要用另一个鸡蛋继续尝试，如果两个都碎了（<code>You have no egg!</code>），则游戏结束。</li></ul><p>现在，你想知道会让鸡蛋摔碎的最小高度（<code>guess1</code>），和知道前者的最小操作次数（<code>guess2</code>）。</p><p><strong>guess1</strong></p><p><code>guess1</code> 函数比较好懂，就是枚举所有可能的高度，这样会一定会摔碎 <span class="math inline">\(1\)</span> 个鸡蛋。</p><p><strong>guess2</strong></p><p><code>guess2</code> 函数略复杂，它将高度分为了几个区间，我们以 <span class="math inline">\(n = 15\)</span> 为例，化为了 <span class="math inline">\([1,5],[6,9],[10,12],[13,14],[15,15]\)</span> 五段，它们的长度依次递减，分别为 <span class="math inline">\(5,4,3,2,1\)</span>。</p><p>对于每段区间，我们先尝试它的右端点，如果没摔碎说明高度足够，就尝试下一个区间。</p><p>如果摔碎了，因为只剩一个鸡蛋，只能模仿 <code>guess1</code> 从小到大依次尝试，求出最终答案。</p><p>这样摔碎鸡蛋的数量一定是 <span class="math inline">\(1\)</span> 或 <span class="math inline">\(2\)</span>。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>TFTBCA</p><p><strong>判断题</strong></p><ol type="1"><li>手动模拟，得出答案为 <span class="math inline">\(5\)</span>。</li><li>不一定，如果鸡蛋在很低的高度就碎了，<code>guess2</code> 需要额外尝试区间的右端点，多一次猜测。</li><li>显然正确。</li></ol><p><strong>选择题</strong></p><ol type="1"><li>显然为 <span class="math inline">\(1\)</span>。</li><li>猜测次数的最大值 <span class="math inline">\(m\)</span>，要满足 <span class="math inline">\(\frac{m(m-1)}{2} \ge n\)</span>，解二次不等式得 <span class="math inline">\(m\)</span> 的最小值为 <span class="math inline">\(\left\lceil\frac{1+\sqrt{1+8n}}{2}\right\rceil\)</span>，量级估算为 <span class="math inline">\(\sqrt{2n} \approx \sqrt{n}\)</span>。</li><li>手动模拟。</li></ol></div></details><h3>T18</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; k, p;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mpow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; k; k = k &gt;&gt; <span class="number">1</span>, x = x * x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; ans1, ans2;</span><br><span class="line"><span class="type">int</span> cnt1, cnt2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; ans, <span class="type">int</span>&amp; cnt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(ans, cnt, l + <span class="number">1</span>, r, v + k[l] * <span class="built_in">mpow</span>(i, p[l]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; cntans1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    k.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    p.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k[i], &amp;p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(ans1, cnt1, <span class="number">1</span>, n &gt;&gt; <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(ans2, cnt2, (n &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">    std::<span class="built_in">sort</span>(ans<span class="number">1.</span><span class="built_in">begin</span>(), ans<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> newcnt1 = <span class="number">1</span>;</span><br><span class="line">    cntans<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt1; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans1[i] == ans1[newcnt1 - <span class="number">1</span>]) &#123;</span><br><span class="line">            ++cntans1[newcnt1 - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans1[newcnt1++] = ans1[i];</span><br><span class="line">            cntans<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt1 = newcnt1;</span><br><span class="line">    std::<span class="built_in">sort</span>(ans<span class="number">2.</span><span class="built_in">begin</span>(), ans<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> las = <span class="number">0</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cnt2 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; las &lt; cnt1 &amp;&amp; ans1[las] + ans2[i] &lt; <span class="number">0</span>; ++las)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">if</span> (las &lt; cnt1 &amp;&amp; ans1[las] + ans2[i] == <span class="number">0</span>)</span><br><span class="line">            ans += cntans1[las];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断题</strong></p><ol type="1"><li>删除第 <span class="math inline">\(51\)</span> 行的 <code>std::sort(ans2.begin(), ans2.end());</code> 后，代码输出的结果不会受到影响。</li><li>假设计算过程中不发生溢出，函数 <code>mpow(x, k)</code> 的功能是求出 <span class="math inline">\(x^k\)</span>。</li><li>代码中第 <span class="math inline">\(39\)</span> 行到第 <span class="math inline">\(50\)</span> 行的目的是为了将 <code>ans1</code> 数组进行“去重”操作。</li></ol><p><strong>选择题</strong></p><ol type="1"><li>当输入为 <code>3 15 1 2 -1 2 1 2</code> 时，输出结果为？<ul><li>A. 4</li><li>B. 8</li><li>C. 0</li><li>D. 10</li></ul></li><li>记程序结束前 <code>p</code> 数组元素的最大值为 <span class="math inline">\(P\)</span>，则该代码的时间复杂度是？<ul><li>A. <span class="math inline">\(O(n)\)</span></li><li>B. <span class="math inline">\(O(m^n \log m^n)\)</span></li><li>C. <span class="math inline">\(O(m^\frac{n}{2} \log m^\frac{n}{2})\)</span></li><li>D. <span class="math inline">\(O(m^\frac{n}{2} (\log m^\frac{n}{2} + \log P))\)</span></li></ul></li><li>本题所求出的是？<ul><li>A. 满足 <span class="math inline">\(a,b,c \in [1,m]\)</span> 的整数方程 <span class="math inline">\(a^3+b^3=c^3\)</span> 的解的数量</li><li>B. 满足 <span class="math inline">\(a,b,c \in [1,m]\)</span> 的整数方程 <span class="math inline">\(a^2+b^2=c^2\)</span> 的解的数量</li><li>C. 满足 <span class="math inline">\(x_i \in [0,m]\)</span> 的整数方程 <span class="math inline">\(\sum_{i=1}^n k_i \cdot x_i^{p_i} = 0\)</span> 的解的数量</li><li>D. 满足 <span class="math inline">\(x_i \in [1,m]\)</span> 的整数方程 <span class="math inline">\(\sum_{i=1}^n k_i \cdot x_i^{p_i} = 0\)</span> 的解的数量</li></ul></li></ol><details class="toggle" ><summary class="toggle-button" style="">解析</summary><div class="toggle-content"><p>先看选择题第三问，首先排除 <code>A,B</code> 选项，根本没有出现输入的量。</p><p>观察第 <span class="math inline">\(24\)</span> 行，枚举从 <span class="math inline">\(1\)</span> 开始，故程序含义为：</p><ul><li>满足 <span class="math inline">\(x_i \in [1,m]\)</span> 的整数方程 <span class="math inline">\(\sum_{i=1}^n k_i \cdot x_i^{p_i} = 0\)</span> 的解的数量。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>FTTBDD</p><p><strong>判断题</strong></p><ol type="1"><li><span class="math inline">\(52\)</span> 到 <span class="math inline">\(59\)</span> 行是双指针计算答案，不排序显然会影响结果。</li><li>快速幂。</li><li>显然。</li></ol><p><strong>选择题</strong></p><ol type="1"><li>结合程序意义，即求 <span class="math inline">\(x_1^2+x_3^2=x_2^2，x_i \in [1,15]\)</span> 的方案数，可以手动枚举计算，也容易联想到就是求边长在 <span class="math inline">\(15\)</span> 以内的直角三角形的数量。</li></ol></div></details><h2>完善程序</h2><h3>T19 特殊最短路</h3><p>给定一个含 <span class="math inline">\(N\)</span> 个点、<span class="math inline">\(M\)</span> 条边的带权无向图，边权非负。起点为 <span class="math inline">\(S\)</span>，终点为 <span class="math inline">\(T\)</span>。对于一条 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 的路径，可以在整条路径中，至多选择一条边作为“免费边”：当第一次经过这条被选中的边时，费用视为 <span class="math inline">\(0\)</span>；如果之后再次经过该边，则仍按其原始权重计费。点和边均允许重复经过。求从 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 的最小总费用。</p><p>以下代码求解了上述问题。试补全程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> INF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="type">int</span> to;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dist;</span><br><span class="line"><span class="type">int</span> u;</span><br><span class="line"><span class="type">int</span> used_freebie;<span class="comment">//0 for not used, 1 for used</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> State &amp;other) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> dist &gt; other.dist;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m, s, t;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;Edge&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">adj[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">adj[v].<span class="built_in">push_back</span>(&#123;u, w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">d</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">2</span>, INF));</span><br><span class="line">priority_queue&lt;State, vector&lt;State&gt;, greater&lt;State&gt;&gt; pq;</span><br><span class="line"></span><br><span class="line">d[s][<span class="number">0</span>]= <span class="number">0</span>;</span><br><span class="line">pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s,   ①  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">State current =pq.<span class="built_in">top</span>();</span><br><span class="line">pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dist = current.dist;</span><br><span class="line"><span class="type">int</span> u= current.u;</span><br><span class="line"><span class="type">int</span> used = current.used_freebie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dist &gt;   ②  )&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;edge : adj[u]) &#123;</span><br><span class="line"><span class="type">int</span> v = edge.to;</span><br><span class="line"><span class="type">int</span> w = edge.weight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(d[u][used] + w &lt;   ③  )&#123;</span><br><span class="line">   ③  = d[u][used] + w;</span><br><span class="line">pq.<span class="built_in">push</span>(&#123;  ③  , v , used&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(used == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(  ④   &lt; d[v][<span class="number">1</span>])&#123;</span><br><span class="line">d[v][<span class="number">1</span>] =   ④  ;</span><br><span class="line">pq.<span class="built_in">push</span>(&#123;d[v][<span class="number">1</span>], v, <span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt;   ⑤   &lt;&lt;  endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li>① 处应填：<ul><li>A. 0</li><li>B. 1</li><li>C. -1</li><li>D. false</li></ul></li><li>② 处应填：<ul><li>A. d[u][!used]</li><li>B. d[u][used]</li><li>C. d[t][used]</li><li>D. INF</li></ul></li><li>③ 处应填：<ul><li>A. d[v][1]</li><li>B. d[v][used]</li><li>C. d[u][used]</li><li>D. d[v][0]</li></ul></li><li>④ 处应填：<ul><li>A. d[v][0]</li><li>B. d[v][1]</li><li>C. d[u][0]</li><li>D. d[u][1]</li></ul></li><li>⑤ 处应填：<ul><li>A. d[t][1]</li><li>B. d[t][0]</li><li>C. min(d[t][0], d[t][1])</li><li>D. d[t][0]+d[t][1]</li></ul></li></ol><h3>T20 最优测试</h3><p>工厂打算通过客户反馈来间接测试生产线，从而找到存在缺陷的生产线。工厂有 <span class="math inline">\(n\)</span> 条生产线（编号 <span class="math inline">\(0\sim n−1\)</span>），已知其中恰有一条生产线存在缺陷。每一轮测试为，从若干生产线的产品取样混合成一个批次发给客户。若该批次中包含缺陷生产线的产品，客户将要求退货（结果记为 <span class="math inline">\(1\)</span>），否则正常收货（记为 <span class="math inline">\(0\)</span>）。受售后压力限制，在所有发货批次中，最多只能有 <span class="math inline">\(k\)</span> 次退货（即结果为 <span class="math inline">\(1\)</span> 的次数 <span class="math inline">\(\le k\)</span>）。工厂的目标是，设计最少的间接测试轮数 <span class="math inline">\(w\)</span>（发货总批次），保证根据客户收货或退货的反馈结果，唯一确定存在缺陷的生产线。</p><p>以下程序实现了工厂的目标，包含两部分：</p><ol type="1"><li>确定 <span class="math inline">\(w\)</span> 的最小值，并设计最优测试方案；</li><li>根据测试结果推断存在缺陷的生产线。该程序确定 <span class="math inline">\(w\)</span> 最小值的方法为：由于不同的生产线故障时，测试应当返回不同的结果，因此 <span class="math inline">\(w\)</span> 轮测试的可能结果数不应少于生产线数量。</li></ol><p><code>test_subset()</code> 函数为抽象测试接口，输入所有批次的方案并返回一个二进制编码；该编码表示为每批次的检测结果（即最低位是第 <span class="math inline">\(1\)</span> 批次、最高位是第 <span class="math inline">\(w\)</span> 批次）；其实现在此处未给出。</p><p>试补全程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">comb</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; w) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= i; ++t) &#123;</span><br><span class="line">        res = res * (w - t + <span class="number">1</span>) / t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算长度为 w、1 的个数 ≤k 的码字总数 </span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">count_patterns</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="built_in">min</span>(w, k); ++t) &#123;</span><br><span class="line">        total += <span class="built_in">comb</span>(w, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象测试接口 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_subset</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; plan)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="comment">// === 第 1 步：求最小 w === </span></span><br><span class="line">    <span class="type">int</span> w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (  ① ) &#123; </span><br><span class="line">        ++w;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; w &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// === 第 2 步：生成测试方案 === </span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">code</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(w, <span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ones = <span class="number">0</span>; ones &lt;= k &amp;&amp; idx &lt; n; ++ones) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bits</span><span class="params">(w, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">fill</span>(bits.<span class="built_in">begin</span>(), bits.<span class="built_in">begin</span>() + ones, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; w; ++b) &#123;</span><br><span class="line">                code[idx][b] = bits[b];</span><br><span class="line">            &#125;</span><br><span class="line">            ++idx;</span><br><span class="line">            <span class="keyword">if</span> (idx &gt;= n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ( std::  ② );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">plan</span>(w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; w; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (  ③ ) &#123; </span><br><span class="line">                plan[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// === 第 3 步：调用测试接口 === </span></span><br><span class="line">    <span class="type">int</span> signature = <span class="built_in">test_subset</span>(plan);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// === 第 4 步：结果解码 === </span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sig_bits</span><span class="params">(w, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; w; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (  ④ ) &#123; </span><br><span class="line">            sig_bits[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (  ⑤ ) <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">solve</span>(n, k);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li>① 处应填：<ul><li>A. (1&lt;&lt;w)&lt;n</li><li>B. count_patterns(w,k) &lt; n</li><li>C. count_patterns(k,w) &lt; n</li><li>D. comb(w,k) &lt; n</li></ul></li><li>② 处应填：<ul><li>A. next_permutation(bits.begin(), bits.end())</li><li>B. prev_permutation(bits.begin(), bits.end())</li><li>C. next_permutation(bits.begin(), bits.begin()+ones)</li><li>D. prev_permutation(bits.begin(), bits.begin()+ones)</li></ul></li><li>③ 处应填：<ul><li>A. (j&gt;&gt;i) &amp; 1</li><li>B. (i&gt;&gt;j) &amp; 1</li><li>C. code[i][j] == 1</li><li>D. code[j][i] == 1</li></ul></li><li>④ 处应填：<ul><li>A. (signature &gt;&gt; i) &amp; 1</li><li>B. (signature &gt;&gt; i) ^ 1</li><li>C. signature | (1&lt;&lt;i)</li><li>D. (signature &gt;&gt; i) | 1</li></ul></li><li>⑤ 处应填：<ul><li>A. is_permutation(code[j].begin(), code[j].end(), sig_bits.begin())</li><li>B. code[j] == sig_bits</li><li>C. plan[j] == sig_bits</li><li>D. code[j][i] == sig_bits[i]</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csp </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流--最小费用最大流</title>
      <link href="/posts/5aab9e40/"/>
      <url>/posts/5aab9e40/</url>
      
        <content type="html"><![CDATA[<h2>介绍</h2><p>最小费用最大流，简称 <strong>费用流</strong>。</p><p>与 <strong>最大流</strong> 不同的是，每条边还有一个 <strong>费用</strong> <span class="math inline">\(c\)</span>，这条边每流过一个单位流量，就需要付出 <span class="math inline">\(c\)</span> 的费用。</p><p>在保证最大流的 <strong>前提</strong> 下，还要让总费用最小。</p><h2>算法</h2><p>费用流，常用的为 SSP（Successive Shortest Path）算法。</p><div class="note warning flat"><p>此算法不能处理带负环的情况，需使用消圈法。</p></div><p>它是一个贪心的算法，思路是每次寻找单位费用最小的增广路进行增广，直到图上不存在增广路为止。</p><h3>证明</h3><p>我们考虑使用数学归纳法和反证法来证明 SSP 算法的正确性。</p><p>设流量为 <span class="math inline">\(i\)</span> 的时候最小费用为 <span class="math inline">\(f_i\)</span>。我们假设最初的网络上 <strong>没有负圈</strong>，这种情况下 <span class="math inline">\(f_0=0\)</span>。</p><p>假设用 SSP 算法求出的 <span class="math inline">\(f_i\)</span> 是最小费用，我们在 <span class="math inline">\(f_i\)</span> 的基础上，找到一条最短的增广路，从而求出 <span class="math inline">\(f_{i+1}\)</span>。这时 <span class="math inline">\(f_{i+1}-f_i\)</span> 是这条最短增广路的长度。</p><p>假设存在更小的 <span class="math inline">\(f_{i+1}\)</span>，设它为 <span class="math inline">\(f_{i+1}&#39;\)</span>。因为 <span class="math inline">\(f_{i+1}-f_i\)</span> 已经是最短增广路了，所以 <span class="math inline">\(f&#39;_{i+1}-f_i\)</span> 一定对应一个经过 <strong>至少一个负圈</strong> 的增广路。</p><p>这时候矛盾就出现了：既然存在一条经过至少一个负圈的增广路，那么 <span class="math inline">\(f_i\)</span> 就不是最小费用了。因为只要给这个负圈添加流量，就可以在不增加 <span class="math inline">\(s\)</span> 流出的流量的前提下，使 <span class="math inline">\(f_i\)</span> 对应的费用更小。</p><p>综上，SSP 算法可以正确求出无负圈网络的最小费用最大流。</p><blockquote><p>证明过程摘自 <a href="https://oi-wiki.org/graph/flow/min-cost/#%E8%AF%81%E6%98%8E">OI-Wiki：SSP 算法</a></p></blockquote><h3>复杂度分析</h3><p>如果使用 spfa 求解最短路，每次找增广路的时间复杂度为 <span class="math inline">\(O(nm)\)</span>。设该网络的最大流为 <span class="math inline">\(f\)</span>，则最坏时间复杂度为 <span class="math inline">\(O(nmf)\)</span>。事实上，SSP 算法是 <strong>伪多项式时间</strong>。</p><h2>实现</h2><p>Dinic + spfa:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>, M = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> ll inf = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">graph</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> v, nt;</span><br><span class="line">        ll c, w;</span><br><span class="line">    &#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> hd[N], tot = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll c, ll w)</span> </span>&#123;</span><br><span class="line">        e[++tot].v = v, e[tot].nt = hd[u], e[tot].c = c, e[tot].w = w, hd[u] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">uadd</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll c, ll w)</span> </span>&#123; <span class="built_in">add</span>(u, v, c, w), <span class="built_in">add</span>(v, u, <span class="number">0</span>, -w); &#125;</span><br><span class="line">&#125; g;</span><br><span class="line"><span class="type">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">namespace</span> SSAP &#123;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> cur[N];</span><br><span class="line">ll dis[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dis[i] = inf, vis[i] = <span class="literal">false</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>, vis[s] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = g.hd[u]; i; i = g.e[i].nt) &#123;</span><br><span class="line">            <span class="type">int</span> v = g.e[i].v;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + g.e[i].w &amp;&amp; g.e[i].c) &#123;</span><br><span class="line">                dis[v] = dis[u] + g.e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v]) q.<span class="built_in">push</span>(v), vis[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t] != inf;</span><br><span class="line">&#125;</span><br><span class="line">ll mincost;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, ll f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t || f == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i = cur[u]; i; i = g.e[i].nt) &#123;</span><br><span class="line">        <span class="type">int</span> v = g.e[i].v;</span><br><span class="line">        cur[u] = i;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v] &amp;&amp; dis[v] == dis[u] + g.e[i].w &amp;&amp; g.e[i].c) &#123;</span><br><span class="line">            ll t = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(f, g.e[i].c));</span><br><span class="line">            <span class="keyword">if</span> (t) &#123;</span><br><span class="line">                g.e[i].c -= t, g.e[i ^ <span class="number">1</span>].c += t;</span><br><span class="line">                mincost += g.e[i].w * t;</span><br><span class="line">                sum += t, f -= t;</span><br><span class="line">                <span class="keyword">if</span> (f == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">flow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>, flow;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cur[i] = g.hd[i], vis[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> ((flow = <span class="built_in">dfs</span>(s, inf))) &#123;</span><br><span class="line">            ans += flow;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) vis[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace SSAP</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        ll c, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; c &gt;&gt; w;</span><br><span class="line">        g.<span class="built_in">uadd</span>(u, v, c, w);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = SSAP::<span class="built_in">flow</span>();</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; SSAP::mincost &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> network-flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Multiple Choice Test P</title>
      <link href="/posts/e1da9495/"/>
      <url>/posts/e1da9495/</url>
      
        <content type="html"><![CDATA[<h2>一句话题意</h2><p>给你 <span class="math inline">\(n\)</span> 组向量，从每组中选出一个向量，使被选出的向量的总和到远点的距离最大，<span class="math inline">\(2\le n \le 2\times 10^5\)</span>。</p><h2>前置</h2><ol type="1"><li>凸包</li><li>闵可夫斯基和</li></ol><h2>解法</h2><p>结论：所有被选出的向量一定在凸包上。</p><blockquote><p>简单证明：</p><p>与原点距离最大的点即为 <strong>欧几里得距离</strong> 的平方：<span class="math inline">\(f(p) = x_p^2+y_p^2\)</span>。</p><p>显然在凸包上时，距离最大。</p></blockquote><p>我们就可以对每个向量集合求出凸包，然后每次用 <strong>闵可夫斯基和</strong> 求出凸包的和。</p><p>最后遍历凸包上的点，求出最大的距离。</p><p>时间复杂度：<span class="math inline">\(O(n\log n)\)</span>，其中 <span class="math inline">\(n\)</span> 是向量个数。</p><h2>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">short</span> <span class="type">int</span> <span class="title">sgn</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> (<span class="built_in">abs</span>(x) == <span class="number">0</span>) ? <span class="number">0</span> : ((x &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>); &#125; <span class="comment">// 判断符号</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    db ang;  <span class="comment">// 极角，用 atan2 计算</span></span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="type">const</span> Point b) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;; &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="type">const</span> Point b) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;; &#125;</span><br><span class="line">    ll <span class="keyword">operator</span>*(<span class="type">const</span> Point b) <span class="type">const</span> &#123; <span class="keyword">return</span> x * b.y - y * b.x; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Point b) <span class="type">const</span> &#123; <span class="keyword">return</span> (x == b.x) ? (y &lt; b.y) : (x &lt; b.x); &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Point b) <span class="type">const</span> &#123; <span class="keyword">return</span> (y == b.y) ? (x &lt; b.x) : (y &gt; b.y); &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Cross</span><span class="params">(Point a)</span> </span>&#123; <span class="keyword">return</span> x * a.y - y * a.x; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; x = y = <span class="number">0</span>; &#125;</span><br><span class="line">&#125; sum; <span class="comment">// 点</span></span><br><span class="line">vector&lt;Point&gt; v;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Convex</span> &#123;</span><br><span class="line">    vector&lt;Point&gt; p;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Andrew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        p.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = v.<span class="built_in">size</span>(), cnt = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt &gt; <span class="number">1</span> &amp;&amp; ((p[cnt - <span class="number">1</span>] - p[cnt - <span class="number">2</span>]) * (v[i] - p[cnt - <span class="number">1</span>])) &lt;= <span class="number">0</span>)</span><br><span class="line">                p.<span class="built_in">pop_back</span>(), cnt--;</span><br><span class="line">            p.<span class="built_in">push_back</span>(v[i]), cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> basic = cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt &gt; basic &amp;&amp; <span class="built_in">sgn</span>(((p[cnt - <span class="number">1</span>] - p[cnt - <span class="number">2</span>]) * (v[i] - p[cnt - <span class="number">1</span>]))) &lt;= <span class="number">0</span>)</span><br><span class="line">                p.<span class="built_in">pop_back</span>(), cnt--;</span><br><span class="line">            p.<span class="built_in">push_back</span>(v[i]), cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">1</span>) p.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125; <span class="comment">// Andrew 算法实现凸包</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mincowsky</span><span class="params">(Convex coh)</span> </span>&#123;</span><br><span class="line">        Point minp&#123;inf, inf&#125;;</span><br><span class="line">        <span class="type">int</span> minid = <span class="number">0</span>, n = coh.p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (minp &gt; coh.p[i]) minid = i + <span class="number">1</span>, minp = coh.p[i];</span><br><span class="line"></span><br><span class="line">        sum.x += minp.x, sum.y += minp.y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = minid - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> x = (coh.p[j - <span class="number">1</span>].x - coh.p[j].x), y = (coh.p[j - <span class="number">1</span>].y - coh.p[j].y);</span><br><span class="line">            p.<span class="built_in">push_back</span>(Point&#123;x, y, <span class="built_in">atan2</span>(y, x)&#125;);</span><br><span class="line">        &#125; <span class="comment">// 上凸包</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x = (coh.p[n - <span class="number">1</span>].x - coh.p[<span class="number">0</span>].x), y = (coh.p[n - <span class="number">1</span>].y - coh.p[<span class="number">0</span>].y);</span><br><span class="line">            p.<span class="built_in">push_back</span>(Point&#123;x, y, <span class="built_in">atan2</span>(y, x)&#125;);</span><br><span class="line">        &#125; <span class="comment">// 连接点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= minid; j--) &#123;</span><br><span class="line">            <span class="type">int</span> x = (coh.p[j - <span class="number">1</span>].x - coh.p[j].x), y = (coh.p[j - <span class="number">1</span>].y - coh.p[j].y);</span><br><span class="line">            p.<span class="built_in">push_back</span>(Point&#123;x, y, <span class="built_in">atan2</span>(y, x)&#125;);</span><br><span class="line">        &#125; <span class="comment">// 下凸包</span></span><br><span class="line">    &#125; <span class="comment">// 闵可夫斯基和</span></span><br><span class="line"></span><br><span class="line">&#125; coh, maxcoh; <span class="comment">// 凸包</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,t; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">        v.<span class="built_in">resize</span>(t);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;v[j].x, &amp;v[j].y);</span><br><span class="line">        coh.<span class="built_in">Andrew</span>();</span><br><span class="line">        maxcoh.<span class="built_in">mincowsky</span>(coh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(maxcoh.p.<span class="built_in">begin</span>(), maxcoh.p.<span class="built_in">end</span>(), [](Point a, Point b) &#123; <span class="keyword">return</span> a.ang &gt; b.ang; &#125;); <span class="comment">// 最后按极角排序</span></span><br><span class="line"></span><br><span class="line">    ans = sum.x * sum.x + sum.y * sum.y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : maxcoh.p) &#123;</span><br><span class="line">        sum.x += p.x, sum.y += p.y;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, (sum.x * sum.x + sum.y * sum.y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>炽声音节旋题解</title>
      <link href="/posts/c1988da5/"/>
      <url>/posts/c1988da5/</url>
      
        <content type="html"><![CDATA[<h2>前置</h2><ul><li>模拟</li></ul><h2>解法</h2><p>为了方便描述每个音节的长度，我们定义一个 <strong>最小单位时间</strong>，<strong>四分音符</strong> 长 <span class="math inline">\(96\)</span> 的单位时间。</p><blockquote><p>为什么是 <span class="math inline">\(96\)</span> ？</p><p><sub><sub>大部分电脑音游用的 96。</sub></sub></p><p><span class="math inline">\(96 = 2^5 \times 3\)</span>，可以整除本题所有的 <strong>音符时长</strong>。</p></blockquote><h3>记录</h3><p>我们将每个音符记为多个事件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">    ll t;     <span class="comment">// 时间点</span></span><br><span class="line">    <span class="type">int</span> type; <span class="comment">// 0 为 Hold 起始，1 为 Hold 结束，2 为 Tap</span></span><br><span class="line">    <span class="type">int</span> btn;  <span class="comment">// 按键编号 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以将每一时刻的事件存在一起，方便处理。</p><blockquote><p>注：C++ 中 <code>stoi</code> 函数可以将 <code>string</code> 直接转为数字。</p></blockquote><h3>多押无理</h3><blockquote><p>在任意时刻，按下的按键不能大于 2。</p><p>按下的按键包括：</p><ol type="1"><li><p>Tap 和 Hold 的开始。</p></li><li><p>已按下的 Hold（包括刚好结束）。</p></li></ol></blockquote><p>直接开 <code>bool</code> 储存每一按键当前是否按下，再结合当前时刻的按键数累加判断。</p><h3>嵌套无理</h3><blockquote><p>在任意时刻，同一个按键不能按下两次。</p><p>按下的按键同上。</p></blockquote><p>同上，判断 <code>bool</code> 中当前按键是否按下，再结合当前时刻的按键判断。</p><p>每次记得更新 <code>bool</code> 中的状态。</p><p>上述两个无理只要有 <strong>其中之一</strong>，就为 <code>No</code>。</p><p>时间复杂度：<span class="math inline">\(O(T(n log n + n))\)</span>，<span class="math inline">\(n\)</span> 为事件总数。</p><h2>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">    <span class="built_in">Event</span>(ll t, <span class="type">int</span> type, <span class="type">int</span> btn) :</span><br><span class="line">        <span class="built_in">t</span>(t), <span class="built_in">type</span>(type), <span class="built_in">btn</span>(btn) &#123;&#125;</span><br><span class="line">    ll t;     <span class="comment">// 时间点</span></span><br><span class="line">    <span class="type">int</span> type; <span class="comment">// 0 为 Hold 起始，1 为 Hold 结束，2 为 Tap</span></span><br><span class="line">    <span class="type">int</span> btn;  <span class="comment">// 按键编号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BASE = <span class="number">96</span>; <span class="comment">// 一拍占用的最小单位时间</span></span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string t, line;</span><br><span class="line">vector&lt;Event&gt; events;            <span class="comment">// 时间</span></span><br><span class="line">vector&lt;string&gt; notes;            <span class="comment">// 每个音符</span></span><br><span class="line">map&lt;ll, vector&lt;Event&gt;&gt; timeline; <span class="comment">// 每个时刻的事件</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hold;    <span class="comment">// 当前按下的按键</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="built_in">getline</span>(cin, t);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        events.<span class="built_in">clear</span>(), <span class="built_in">getline</span>(cin, t);</span><br><span class="line">        ll now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">getline</span>(cin, line);</span><br><span class="line">            <span class="type">int</span> pos = line.<span class="built_in">find</span>(<span class="string">&#x27;&#125;&#x27;</span>); <span class="comment">// 结束位置</span></span><br><span class="line">            <span class="type">int</span> value = <span class="built_in">stoi</span>(line.<span class="built_in">substr</span>(<span class="number">1</span>, pos - <span class="number">1</span>));</span><br><span class="line">            ll unit = BASE * <span class="number">4</span> / value; <span class="comment">// 计算单位时间</span></span><br><span class="line">            string body = line.<span class="built_in">substr</span>(pos + <span class="number">2</span>), tmp;</span><br><span class="line">            notes.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> ch : body)</span><br><span class="line">                <span class="keyword">if</span> (ch == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">                    notes.<span class="built_in">push_back</span>(tmp), tmp.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tmp += ch;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; notes.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                ll time = now + i * unit; <span class="comment">// 按键时间</span></span><br><span class="line">                <span class="keyword">if</span> (notes[i].<span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="function">stringstream <span class="title">ss</span><span class="params">(notes[i])</span></span>;</span><br><span class="line">                string token;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, token, <span class="string">&#x27;/&#x27;</span>)) &#123; <span class="comment">// 以 &#x27;/&#x27; 分割音符</span></span><br><span class="line">                    <span class="keyword">if</span> (token.<span class="built_in">find</span>(<span class="string">&#x27;h&#x27;</span>) == string::npos) &#123;</span><br><span class="line">                        <span class="type">int</span> btn = <span class="built_in">stoi</span>(token);</span><br><span class="line">                        events.<span class="built_in">push_back</span>(<span class="built_in">Event</span>(time, <span class="number">2</span>, btn));</span><br><span class="line">                    &#125; <span class="comment">// Tap</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">int</span> btn = <span class="built_in">stoi</span>(token.<span class="built_in">substr</span>(<span class="number">0</span>, token.<span class="built_in">find</span>(<span class="string">&#x27;h&#x27;</span>)));</span><br><span class="line">                        <span class="type">int</span> l = token.<span class="built_in">find</span>(<span class="string">&#x27;[&#x27;</span>), m = token.<span class="built_in">find</span>(<span class="string">&#x27;:&#x27;</span>), r = token.<span class="built_in">find</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">                        <span class="type">int</span> value = <span class="built_in">stoi</span>(token.<span class="built_in">substr</span>(l + <span class="number">1</span>, m - l - <span class="number">1</span>));</span><br><span class="line">                        <span class="type">int</span> cnt = <span class="built_in">stoi</span>(token.<span class="built_in">substr</span>(m + <span class="number">1</span>, r - m - <span class="number">1</span>));</span><br><span class="line">                        ll duration = (BASE * <span class="number">4</span> / value) * cnt;           <span class="comment">// Hold 持续时间</span></span><br><span class="line">                        events.<span class="built_in">push_back</span>(<span class="built_in">Event</span>(time, <span class="number">0</span>, btn));            <span class="comment">// Hold 起始</span></span><br><span class="line">                        events.<span class="built_in">push_back</span>(<span class="built_in">Event</span>(time + duration, <span class="number">1</span>, btn)); <span class="comment">// Hold 结束</span></span><br><span class="line">                    &#125; <span class="comment">// Hold</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            now += unit * notes.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timeline.<span class="built_in">clear</span>(), hold.<span class="built_in">clear</span>();                                                <span class="comment">// 记得初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [t, type, btn] : events) timeline[t].<span class="built_in">push_back</span>(<span class="built_in">Event</span>(t, type, btn)); <span class="comment">// 储存每个时刻的事件</span></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [t, event] : timeline) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : hold)</span><br><span class="line">                <span class="keyword">if</span> (v &gt; <span class="number">0</span>) sum++; <span class="comment">// 统计当前按下的按键数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> e : event)</span><br><span class="line">                <span class="keyword">if</span> (e.type == <span class="number">2</span> || e.type == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (hold[e.btn] &gt; <span class="number">0</span>) flag = <span class="literal">true</span>; <span class="comment">// 重复按下</span></span><br><span class="line">                    sum++;                            <span class="comment">// 按下按键</span></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="number">2</span>) flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> e : event) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.type == <span class="number">0</span>)</span><br><span class="line">                    hold[e.btn]++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e.type == <span class="number">1</span>)</span><br><span class="line">                    hold[e.btn]--;</span><br><span class="line">            &#125; <span class="comment">// 更新按键状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; (flag ? <span class="string">&quot;No&quot;</span> : <span class="string">&quot;Yes&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> simulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024 年训练总结</title>
      <link href="/posts/5b679f7f/"/>
      <url>/posts/5b679f7f/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="f2fa05feb8379847773b652a019257ce7ee9f3c28d867f1914ca8f74c293a965">93024cf999deb8d8b2919f7e109263d48b8ddef76bd60d090b7778bf0c7a53278486c5c2f9602e28c2602ae6b420b396c68c4a0886c2ef7f683383e641347da07f9f47aaf96fe76f478a7ce968671ccc4bf280156222959bd36539cdc64e8ce2fd69cd7cde57b303274202fcc2f1b97aa0462f4b341ad09fb64a2d6640b5156f6f8607f4ff7bf0207dfacf32720327892e249de3c8ad9ffd6b859bd2dba1b075c24534b4ef80e8e8f9df63e4de2602aa245cda2caff0e4fe82e24727421b4291124965e69e244672f7f7126f27780db3ef48807d699ed4393221899c153cfb41d2a0b5935666f429c52f8d2159c7ff1e6ce77b66432710960554b4795a49410a4d9a306c6dcb36688c535352ed4a438d4b580288ad048b1157c2f5e94f9e81f6b9979b95d1986bb7a4f59de90891a8ba4e2ba332a9b4cc90bcb2b737eb6d01d7a8ab23a6fe881d00ecd1bcf760bfdadf0f1df5864e3c007d6af0d235b9d9e2508b4bdb083b801091bdf47b8c35d45455559badc25a230426c70dbf0bb86209896a1e607cf344ea9d8a49fee975693efd89aeb6380872fbbe33b833cdda50e9068457029ebe7158ca9c5927ed640e6efa36109815f0ad44a17bacbd3290cc741a7e4c9f0befe1a8857e0de90297dc2b00e5504697f6db6f024949172962bea166ff7d8a9bfb7e9cb980d948c29906373229ec0ed5c0c6e354801b12ffcde4b37010b7fbdffc99eba14f4e97bc168f22545f7d6b68665bc666bf0cdf8f604360bdf1cc0347d4bb836bedbfc3bf1b5af64081f6e5136f0b51aa5d513ddc0405d078627921703bd36dde98c669a6820b665e7a6177c1eb587f1bc51a4a089d3a8879e486addfe85814e612c6231779ec6d9c8fabc82a54e13d52e46b201725499671175e8b306ec885837f6912dbb38fcec999adbd2505cecd3e28effccb0a022e5a6094c49a80771fe35737bf00814128a654783073b1faf755a588e59bcbf414da97472c1455e9a32619845aed7e632d3cf11e488025a6ea05c4bb022b0b95649599efb249121d1ef501da20ca50f1873ce2891ad0145e52f30ac9fcfff188cff7f0d9b4ad34794c78229da1f721a954ddfc7b8f78d5c7639c7460b299202fcdd8bda6b90b433c63175f36e986f8ffeef19e6b2215fa32c9656c3a76364288d8bfbfeaf8fed39171ce353ca1597688b5b3bb9a26600edcfc96204f4a4b012448c203be4dfb2f478975847fa61ae910c85e2f8d04d2f604c4a9872a210f112c649e35d092da07078b1656d93f13c90303df7d0b8ea8059a091e8d1dea68997872f1355626efb9eaaba5e4ae362971077766e3f454b9f6d34526382866fa26adb7583e0469b70c177f81e600de7787679b63c9dcf3d15c306ee686f3eed19dc302647c133f051cd708afc54ddf29a751ad4303227a5b733958d27a150b26635b52fab679e10bbe8b1ff99c0dd01a7b732e09673f848eea56f036a7a9cf9d083cc64eaf39b91efd0b3aa50f1ea93c7f1b5fc39bd0fe99d5cd45f276a9f8daeb86223ef8734280dfb053fd03712d7e08cdc660310dc25fee551fe3a9a3ee874f8073a72b13744ffd27503d758529d0766da84e8e88ac05b55c302a30e5b40410c2e08d9a088bca8dbfba3f068841b085e285f1b59bcd7cc4756de2df15367fae8ae6bfbfba919b743aca2b0f93d4fba03ce818df6d02189064e5863a554c529484ea3aaafb8bb9e83c509f6e2974ae659f895c568c5ebe451b506355fe975c74d0a860538c3237df6a1788e470773ffcff057e7e272061313201c6033001d12882b343d043eb4e198f09fe16cd425235bdce3c8669c22f5ea479cbf076d41f25caca3523bf457b5ec8d447e27864a25e698f8c85f5bad2c766f82dd0b51f7a500abb821557c7ec5dc99e9fda08c7e51a4b1e6ff8c80716a1c499eae855568b880f417bc49e0f5820061cbf8393f841f3fc967d262e981195319293f18165e438f4ace1ad0089ebd2ba0fc74788ac986fe7237765f6398d9bbac5a772fb53e3ba82e3feb10038b7df81352c6dbcf067b047b34f29fea124b82f8dff80744c9ccf9246893832dd6f56c57ecdfd23bb14022cd174a994cdf6662203d08893c75266535bfedea5089d11498558d3bbfa7132ba504e2ebe1b2c3d7f787ce9dd53e395431ba06c8e5dce1409ee99d4ef9e509df82ec71639b0c355f62e13d15ccb7c3bc678ed59b13e05f63ae1c2e1a84fec2d88ec5438eafb3a087e0f38396ba9469c3d5e6cbc0adec754ed394df518097bfe729e158071fba75bb5d8ffcdc2bf05b322a13c02ad06b30f1f036a40939fb9c4794cebcafb1e1113504ae84e09e7d1a0cee0453e75bd0d1f3c04cfa3d5d005fc9f5fb095905cf7256583f92781e292ccac3e1ea656bb4181a03be4f536a1d0acc86c7339af2f86eb0059a625739ccba6f17cee30b84d3102141b89749cdf7091ea87683a95805e7c9a7fba4acb868c2a7239f092d80f706de3e0267a395199d78d15549232363d1ad06fbd6af9da13de515c478b964bfba45dbe4aea3e7fe327b6048c4e2bbaa6b76726a7aa6975f83bbe56e2e460073fae1be73527a9c16eff475c5ee611c7267f11704e7921ed0f25c0a788b9c9fe674c563a906cfd0a1f0dfbdb7fddc364ce7c22ae6e928639be54922718d074869753511ace2d451d26f74a3fe193b1c5a2535c027edd70818796efc393e3f70183584d5bbd304e17ec04996d2331d2a95a1b6e072abd004fe658861ce2d2cf3134f9474c11241d3b1f78cc14c1a32a7a71202760b6c56dd8e1aee9e882b99e1f4b853113027de22eba7ad08bfd25ad4a250c6c09bb963c0238a45556b58133c86f56c196d799fd98aa4662e51520244750b6f7526d7a5addb4d815b884ac442baec1b0c96236b03e8ade105e30000bc6de10b3c1163a16c23d8a82d9ea53c98d757ae8edfea28c87065c96b1d9033f1619b1ffc68f2a5e8421d89c9d383ce0ad918492a85875d7bd5e1a7268b11c2ecc7a764419230128e87b53d2e8fcf9e2bf6f718be818bbcdbf4d1f3db763e33895ddf3232fbd4ce5da2eed00b3ee8c7b102cb29e9307ed2b600a9523ae7f3d2ff67f8a1f1212660951f9fd60819e8755fe919d6db0f1f5852848fb1fe3799444174fde1de24f0dcd422c7e6775ad5dee1e4d06d98ce595571b8d24783932f08b3dc3676c3e148d8c8ff75bed2a5df8ad1919f0a803a198406c953f5e04ec5981ce946ca18f5ca48155e6cf8d029a3f5a4520d2f4112dcc5de08734db52be9383ed637a5ade318a71f433f44da43c993faebc950bdf913a4f90d685aae03a2bb023b572a325555dad2c0197594850617ded0c7d17579e9e9ed2ae4ead7980602cc5222d7b912c05356c3595d859204051fb9bc945a7d98205e3cccf8a220daaef959430cfc747114faa879e497101b8f88ce2f9a3608c698fded0815081996d4a979712f42cbcfc0a4a5a6bfa3d056a6b1bb8a12f30daa0cf20a3e0005b8a949fe676d4cca0e31d0e8e4a3ef95b88463c5fb4a09db192dfed5f24aeaf7790c85f01cfca24d6a1d217c77f75ea526e8fe55424c7613a60bd0086f09e824f5eef6003b49ea38484c8048d42cbbb37eec0d0185ebf5200440cc91c21ae7229e3827b32d8126980aed5fdfdc87c98c4680c48f828cbd4d0d8c898ea68fdbbd375bdae406a3a1d7e5be41a3c1d19109538f13bde50dfd99c24839f14d0ccc647498b3fad337e45ca1afef3f2f74e706d12458e5db0d847bad7b413a037e390ee53c242c48677218bfaccc0f228cdb35f92d0f53205884a3c535f16fea05f4d698d278f29dd75d0bcfe283445e1029b858f001c375518fb883eff4375617cd57389a7b8444a6681c92b677c3a6dcc7095824317e28e2d87b8e0e999c2e17d0d868fe113671c851145d9de85cf7025a37c52a5bc9d211ab46319b6601999dd7166aa4ee089962d5ac44ee6383d5500b4c2316ecda24d3f190dcaef998cddaecb540e7807cc45f82b1b0872ddc46e04b2895c6b87fcdabcde9bd9f25a2ab25c9702325c320f76fe03ff9910a0b9227ac4b51592bfe4ec08336de872c5ff7635f1688f7a126cdf3ea3c8630664a46a1476ad805e7ca6ca16c323060628465833960e0209a9421b4f331c0873c3a9c9d8756eae4d34bbf73bf60a62d2fc09032db98612299505b7a6c3cc3083db5be6336eb095b383158feeb12cd75b2d8c39f588177d61eced7288c631f5912502d145dca2540539f732feed6295a4da34a6f272519b0ac7c34d89c415013ab8c50e12b5d56f2a2d8123ef38c4cb7d4178d1bbcb664efb72ce77b14d701b8bc789d11741a2e685aec3368d0d9cc48e7f60cce4dbb64dbf84663711dadadcb9ae461a50b54998c4920e64ed8291c41560ec829e135d53c7b51b522d4b9f0c830a1ab4caea2b8bceb7bd9bf4f7c342c86f7e1191143a6b1ba2534458457f57981eaca2fad09115d24a5fe5e911450339312ea1f7b5825f5465336348562bccaa6ae9762296d00e92d38ec0eb4a930d350eddf3f38476a045f88d8df41bd558b46e013a714cfaa6bdedd525514275243f399da50a74aa71a9fc11977b0cb40a58b98570ba85b9b15c865f1c776079ac84a66a59ddf98098ad97edfda9554a0be205709f3b2f7ff53edb025d9f5870191c482463a2241fb058cfb3ba905cd823138024166b64207bb94a0b50f5828eefec2c842766b624ef792b5a940cbcf78ace32a52894f63d9bf261edad94498665c46111697925eaa56f41dcb9b36dc1accc0ebe21ac3ea1b252ef0ec182acdd0563e6de44f065368d3a192caadfa500d95fee764fa8bceaaa13e3994843b102ea4d77d4838bcc31e810bb1aaca2d8c8807f8676322faef5204eb9de6eb68f7965029c17306b9e1b9469e54cdd519c50c1756844062d201652caf9a3dc280b7ebdc0ed1ac44d33dd2f63ce027991199cbf3e8983470ace881c3b72afdf5849352ea1517be36226a4233e1672a04d25f6ecb070e8a3cbf659f4e889bf57d7dad04580508fcffaaa9cbc3debe0c8612a8a52de14f7f821a0c8aa0438dc94f11e62c80afbe4e2f7212c743066ca7426829e08c9444ca0598fb98b271851e019ac7957d0fb83ea7af6c0e54e2eea847b43f2e2d88a0556c485c4c8655be5691fc1177dbe76b7bf28ae059e5a8984418619e91d36e528645620e4095de6ff1f1a96db3eb0abb0491548e4fed65dfb6818572557ffb337ccf7b6e6c88c2c3909baf227e34a7eda0abd954a0172bb57a6691990ba839fbfbb173ff03245f0b0a4e736b5face9c11971ec736efd329701e0bce7a7b5e550d079a6717f3de52ba93319137cd715d9290bfde1e7131e1d75bcaa73a636811db68bcabd258f27815081112471943036d2e0097aaaf29c55869edd40d02c39f578500d8319ab770d0186a97b713162f7270b2980302b6e7fadbe2d3a1821379195e3eb1a832f49d89ea31c5215eeeea5dbed3712ad50f231aa0a6ca643a585ab5a8f679122d10d8dc0756876f88ddd663a7b4c304f621cc012f14d57424066576cd756bae3724e0643d802ed4e64366ef3826990062e537d0e881c642d2861fc8d0d3b5410f3be2093725f0cc738fabd03c7e55eec9d2fc888652b5d9b80d64224abcddf0a2335d46d77e49cb0747d3392a42e96395bde0c4d4eb17feed821fd239dde2a6b473ed84dfa4799105c744e9636085014a2b8694aea482e9d97cf0edc958f0791012262854c2eb9d541a9994df722927442d985c192c94ddda0c5fee5f45431495e1db11acf69513df782969af71c01cde8d71519c56aef3517c937a1044db6c2d5c1cb929f15006733d3c0da0fd94818af18bc54731f41d829176ce1259436cb48ff6efba6396b586d2282c98f08d676e61f6929610ead66f9995689606b863e5f8f71ee1f74e4f151886f43cc272d0c3f188640a3c765544da532e90338d6fe821151ca71a5717748ff37c22133c961b7cc1f76d7cfad46b6c16d373ef0890454abfab646ad7f4731205294edece26a577335c098ddbc4f975778681010dbc4f2489df9ac69534be1fa04b3c236b253648eba4b7db1d8c650f46e69b506b5ca91c09a98df41362e52debcd139de445dad3bc10bbe520483350876931fb122c7e8c1e2e6cd43791eddd73e41ed07eb68a702b8ced956171908730c837dfcd0f3eeedb6167ef6d1f6dd8fafafbea28328a45db92f15f8a94c8ec606971fb93dbeb465abfb9657c9416393944727421cde75f783662535481a349201a9300f0da9ef7a7d9c7ecc49991f7dceee6aa2cbf03136e635a02a59c1cebff071f7bafd8317301e909679f3c9d5ab00a1e1d9989eca05fbe33b6fae45836a78193faa303ea72fa78df28b23752a6b3bc070151a06d73e99f01649de580fc86902261669dd20dd2f5e9ad2f1eec02ae1d64f3d580c65397d8dec88873b36659e5a5c8f2bd172dd61bb9714ddde541ac4a266d484b70abbafd48030c40bd5a20b8a247a49eb1c79ace0675b315a53b5cf15f0db79bcc41c9366bfa2a2a0ef32fc1ca4ff3b041b587eb7fc5de56fead1bdd7363eb638e85e7d339073d017eeb9be0a5d2c2b89ec13768a1b2dede70afd5698fb0bc44530234ac9d60db51fdd84cba61777ca6955e12b2e0b50ee98ed012bdf335f5daa741eb8ecb3370d49c071363c9cf64d0f4b3c21f5cc8a92fe736a6841d0d0514985f3ecee2776e539ffc68454de124787271415dce201dce2396d918e0b3bddef4bfa38a86c55dab9304c8c3f3336a022fbd838cf920cc09d3da0508a43da64078d5e87d07ea7ae78b6df8f4537b4161f4441ea39b25df4abf235c39db66eb7f44b54c40f45d9f4eeb062e18a3567fc25388a5c7410e59b7520bbd060e8455de1893a6cf7d49f719d49791d1942eec49f4610374e9dd64e3e4cba9e2938c7d531adb5fd29d74d0cbbd26c77b80f9e6d8ba338353dbf1c59aeda08febfc39104039fdb9bdac8ed54396487485ee5b0d8a2ecd1181bc9c97bb21378fb2c89aebce86b20bf8ba239daf3ea32795dfa28b87804300bf8c4c2c5e99ec7f06f8ba161327f0a4eca32f33496e80eac525515341b831c1489b06d7e9b3ae0fa052a21cc8e21962f39772d02d07c557746677599a0cf87bdcb6aba1699cffa553c930a9ba65048e250a3075be69533d0dc9c15ef22c46d849062d62a88d51bf1f64ec903f056d747eb9f8358d9393d33da70e7c8cda259ba26b9bd081f7c9372f2a3300778a58ad4aec5c1f7ab8ee3fdbbcdbb5fc49ccc4a89b3a8b0f31757902a613166cd105fa6ffb3157174d2fc0e8debbab931aeb570ac0d6bc457cac48e398328ce7363ac69489f90ffcc60e96e241b415d3bb49e2f5f878052c0092e551199dc48dee22d3398bbfcedf417e8703e2046e37847af4ec01548c2d077c141eaa4643f9a140688936fdbb397f3ef493466a1931714edddbcd6d17693b4e74615c6d447e709fff431c775ed37961b1e2ad34a4a4aa6dfd9e8ebcf634e3849ea8a7cdd582ac2562571d772226a7b6fde20a041d13b4d6ec23e9f1ecb84590079efd77a008f6e1c7797851ceb3ae506e98be258d5e418737582177123473c4bb1dd98ad6c95230ebe490371f9189f49748e2830898d58cdb346d2de2ea17995dbc760c7218259762b31d68582892926ec5b0b6159fd58b7ecf2145eca15b55cbc32b90276649f73e1fc36814a451d904214da56e4c8b40e0ad221262429f5e9300f51d4a62fb7de594b7c0465350c85580e1df9532d68b917fa2b69ea1036a782057acaffc6e6a8e262159aa96810fba1cf6a5d57c910ae335419c445d6b5decda9e1072700b8ca11d50d81be1e5fc9eb2120db435819dd91f28d4cfa12f2e19ab881478d6499467813cae513f662a68c7a8905384f4e920ccdc5464c1b8f22b54cc0cbf9b39e41fb1b67cb1fc0f184b59c5b0ed83a87bd23cb8cadfb596a1b231b24caa21d4711854ac0e6d2c522ddad74fefc00413734b1f4b2689b7f7344d296655688029aae1cf5fbffb8d97b14ed7ed4a5bb4dc6eec0f733cae1378c0f3728a4d94cc9884cb577dc63d4b44b1e4ecaa59d879b5c28c5280238c4fba6fa31043b21bfcd84a4b2d983573a3eef36e2a674aca368ee58326877b264df017cf8def4b25d65319bd59359ceed716c87822ecb10689e5e91677e6b8522e6524177e0a08f39b9f5d671dd790f0c66060474f01d8d4074e9350f5986a7eb1714665e5d5725b356823358bc09cdb264886e0d4fdf7c0a6157c6e97905d3353ab3610a04ca6760b42d0482b627c5f501b1b28c704173f93584097b01d30e2b92e7594899353e3a19ef9f7684d93e728fd25ee2235cbcbe4e6b13bd8a1fe3ab3d5f81634e201e8c960ce538d5709e98356485843352ebc4bf87bbe5cd7467083920c50171774b8cb1c1db8156f2db10b122d914dacfb8b46fcaf60509b706eb6219a787c1cbd642d498623e8d73e0f17a22ad515a539afbd68d62ac7208f5ee6e2e35f95f7b6d4b9c7755fd24f237880d3671c26a5534635a92a5034c03f0b7899dbfc1c555fa39054c0ab2313aedeb4e68b5128fb84ec2b92e72f04ead90143bad3a8a0b4cfc8f7ca153521779454f8a529083c57b525a9dba957a4e0e603f826e5accd31b1a9720d79f7bb97310966f3e96482590e9f8147c78bf6f87b84b8cfafc1d36f94c10656e1025aa049711b23528eeb44227538796ac9b6148c51535d26ea2c9168ed160f9b07e158cad3e2de0cf0ef0106cfa757a1d5b75cbc0634b63b1bd9b64fa79873a1ad272bbb8426fc0828a385e4be80d508d972342d9978c3ec972b801bc5a05d0ae894572c46bf4bfe8ac6f32b8c430b7cd41630bb3cf233e38700cf188ea97f89df08762438d8a740aaae151269779b3df92872e8202b1399e0a606d8211f16f624010d5da547c83d36d68a9cdbdfe3291207a94cf29f80d686b6712a5939eaa7f1c1c6bbe5f1ac6cc0a20a2572eef5462c0d6e9430f1e38aed54674dad391625d9d7e7204e955eff2d74cdba34fbf9d8d99fef920e111a61a21073d2e7e10b4e7a6cd44662676fd8baed02d1a226bded8a94c0139769ec2dd33be5d2394ec76c8f9221b6487b5348588106a943c76f44f33600519dc4e123fd49be9750c3452a585282f696715c11f8113c9688aeb2ad59ce3d40d8ab75163e7dcd8462b1ddadc07936d601cd8f13d921d184dd824e88ac94c54daf70bf2acfd650db9c6f4287ce0e4faf7ce902c2aaddd670f5d8f08ed334f3598c6177b91c5b5e4807e5068129dcb7b439ce2951b1d1c38e51b9d52e3379f52eb7868d29b3b06f2fcd0aeb38a81c779796ca38a5319beb1e9ce21d34d59aafa937d0c7e43fb00d8767732beef6eea9e1dc0ba42d90b2fc4e5ee556c72dbba4987cd8541db66243cf9d3108741434bd4fd9ff70e46c2a619afa5b52fe5bdd5cb95cec80ebcf6d676dd4b6347e3965e293233e477a4e93e022a8326c6ac01ff9babd936a8d29e556254376274a7fe5ecae4bf5f7bd49723b584a9c9bda46894201d8310d3d495797cd5a1cf4a0b4e23641eee68534999fb6248b99cbf04e88ad2126c9c8999f387c9dc53a93bc8b01303660ac08f62ccc1e065f22c494097dec1633330436089b1482fdb90ea969d67cb0c2b8e39cb6dcf0b1640d18b356cb9f9c60a91a3782b4d49fe6ff9c7545e5eec786cd2f9a52912fb5a05faf72b068ee5b6b260ee7efa35a755bd1f130ada6c656e7418f1b092d7b1d607354e3211da1dd69bc233cd3e229b1aed02adaee9cbf8c2537d98e48e4d6f61a398cc0dd7c90632a6c84bfb7b9bc47a4a649aebc136f1e05b714f0229aa07d78a0a7c647cea34c69cda9f791de3d2e60131932c5306b0e90f69b36c7cf5ddf02b320fbe3f98ca8d83c1726d79060630220e77f3010a73f707775f180ceb3f1c1ba3818f161b59880b5c26c75fd22206201c8f0a947bff29ae17c47cb288ff9b715eedf6cd5df088f588f774b3fb7fdcc50a0d10698cf77cbcf8414e93482c1cd157b46060eb3b979079f0eb7a30a2626b75ffa24a9ef722913ee21334f499bc51e84e348a3094571a12067476ecaed0f4554a88b63b1d88e34c1149a70e1ab2ac86da207e3f1aa0932b92052b94ea02482b99fe7d8c972515bfd008ab577b3f023d7342c7722f91965868cead1a61553568e34185794eaf7e12330d73f971885f7ac741c317aa86b9c0af54b8cc9cf5803c621529d9f8a9231ac5f4474d72496a46e20124a6dd520f74c1ff4242d74a671b8730707cbb8e7ac4b25c38da04262b34d16c839f62f500c2a2fdf42fe93d65303a369c083b923d696b2bfe64f5b5a2e7c895f673864d3842603f1f43f09838712802e74fff0fe7c55bc88441f7e62d5af52e500a86adc4da63a4f2db20ab04573379419f6a5aa562b1f8c2fa6e6968351a0d3b2125480795985115b6326416007ee44f49695e2fa67e0b9f5fd29c64541a0bc5ffaf2646fc20ed4186481b5a741653227c4bbfb89ccf1be347736284b5f071a64ab846bb86cc959903ce98a881967cfd38b39d071031cc17cf9fd6bcc1124c553305df26216507297249fd90d29e09f7545165ace6c9450aa30a071f8a31a6a3a9385540ebdfc434ceb63259fc2219c029b880058fbf5f90e45e83a7e4f96dcb1602b6c5a523db21bc3be7afb276e66bd6a21c9578a8a80086046edf1780df0aa7afb6d4fc1c5c47ab021a2801e82b1298bbfdf7ce7d242e93b0b46046e4656f6fc641b3f7f9f99dd616c48a8609d4c9dc20e9efcf7b2e7a5fe91a5e3feac324c0824cc492e09a9db7f355eb6695e9d6bd16d04706900a76cf356cfa8e058cffdf2883f7578df740f910013651ee7c75a4b392684deeb18a9dd6f232b91df15a8d7e6e98e582c27aee3baf31f8b662c8be103526f6272445c35a022d71a9865f4af44cfe40409160cbacd3d1ccdbe76b31fd5ace70a5b76a889a8a1f58877f31e7f4887eda701882fc1fbf9c8a891ff8e6e8fd888c3086e5bfdbdeeed5fd7276fc400f321b6a6662f9004b0c990bb9190a644f8fedbe8825529abb8f7e7021665a6d95889c613a177ccf12cab3f56c801f1b036a5b2289fb3491f2d00a93c7c40baa674b9da9ddd711677666fe00dbc8ea6d13688ec5ef1081598df78469060eaadb2060303e0f8a0956bfde293664db9c37df4bb69b24a0211b09e14494968d938099784358f8dedfaf3b80198dd573caf5205bc970e3c98f23771cef18e5b1036c04a30848d67f7078c4ea7782b0b830dcb5e45caaff927568fa8c997451321ac107006ed3ff9d5d6c1d334f947b25a93db999c07085fc089158de7e22533710840a85793f4ab5fa887e9d4b75fbf53e4b67b356d5eba341adf7a2ea1b9b5bb4711b591288fa56382d8b96fd17b34d40c908e3082859aabd7404cc8bbe855f17197245a507014c81c9f4241a037fa8a5e264720f300cb9b8ca113049d3be336ab7cb34a63980126ab0035efeb01d3ffc51922b1197a52e72defc628a0cc70a800c06fa05711703d91cd43ac406e07e84b7ba69a58c94e371a0fe36fc372b8df5b994146a33a0d4073680ea0da9a4d66e76da4e6d2678315cea5048b9c21fd4d7fb444dc4651a23514520e2ced5e3e9457dfb5cdbaba7003616bfefa795dd857b53206b998528e8d0068a0ce0a5fd5fcb7ed57d32af17bd44748ab55a7e76acddee8a3d7231e6cdb77bcc303ff70404ceff6f11318b65e04d6df0855558a1d14fa27f703ff295ae4ec701fd904e96ca46d1e41d4547b7fccfdc1962c6b7f2aef6a046e0532cb5085943ab651ace105dbeb43d2a3d7b4365d5bae0c67ffb17acfb2f4637cab17c895729a54e6ef90598b81b62c25fc2dc97afbe78bb2962a680a5409bfbe3c1a1a276c8b7ff8c8aa8dc67b1eb6438d4ed92aad30d095b2084e7724eac69db4fc2816550d238519a3701fdc3165253e47e7a76fe047443796a049412ab2e46e19ebc29ae3470d77a92ee5edebc5c43e3dfeffb192572d73f3c51b576c28e2e6b37d993034fa0c06482b1e484125762e7b97fb49e3f40717218988e31b9253d35c01dc2cf96afe631e66daf7118f1e03d502dd5bc20a6b1e0ad220550c919ec73c058d64e89f02a0cd473b65a8dcb36804b9763c96cd9b264d07333af215f778b1d14c0b3b1f6bc6f53b9bd1717a04ead39de4db540ac1cab2a68f5b365628f5da72084099f377cae2b2755158b547bed012c808a3707a0efa04739e720a23c91f16f2851fcdfcd319a4d7f8f120588be79193ddf285e1ff6c832cca5e0898ced3e1ce5b516002cdaf08ff75300b42b0e9b5abbaa33b8a2830a41abab4577349c4bd1a3e60a97bd6e2d42a65a307a5e9f9496aef9ed5fc6597d571af0d6a48b3d409df1c345233dc46ac7cd18bbcf487f827a893c44e4cb07cb88e93045ec18dd46311c645eaec7b91f756e2bd17177d42e35657241fb25db67d099743f73fbf4dfc7ced01031554881278fa5ae1e757bbde4fef2c815b14334e225625a8d58749b07c43f0b161f0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> school </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024NOIP游记</title>
      <link href="/posts/cfc318c/"/>
      <url>/posts/cfc318c/</url>
      
        <content type="html"><![CDATA[<h2>Day 1</h2><p>今天是 NOIP，<sub><sub>又能逃课出去了</sub></sub>。</p><p>进入赛场，先开 T1，很快想出了贪心，但对拍比较久，打了 40 min。</p><p>T2 开始，先是推结论，发现推不出来，进而想到 DP，但最后一个大样例一直过不去，赛场上灵光炸现，想出来了。</p><p>一看时间还剩 90 min，开始写 T3 暴力，不过到结束还是没写出来。</p><p>成绩：100+100+0+0=200</p><h2>总结</h2><p>这次打的比较稳健，但速度还是太慢，希望明年能有所进步。</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> noip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024CSP游记</title>
      <link href="/posts/167da4e1/"/>
      <url>/posts/167da4e1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>坐标： gd-zs</p></blockquote><h2>Day0</h2><p>明天就要打 CSP 了，当天晚上把算法都看了一遍。</p><h2>Day1</h2><h3>J</h3><p>7:30 就到了考场，等了好久。</p><p>T1,T2 30 分钟就做完了，T3 调试加对拍花了大概 40 分钟，开始想 T4。</p><p>先打了一个暴力模拟，感觉没什么问题，然后开始优化，过了大样例。</p><p>不过没想到 DP 有点可惜。</p><h3>S</h3><p>中午睡了 1 小时。</p><p>打开 T1,30 分钟就打完了。</p><p>T2 直接用了二分+树状数组，对拍花了 1.5 小时。</p><p>T3 不太会，只打了 30 到 50 pts 的 DP。</p><p>T4 似乎暴力有 35 pts，我考场上没打。</p><h2>总结</h2><p>这次发挥还算稳定，希望今年分数线不高。</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 的 mathjax 渲染</title>
      <link href="/posts/4e95c1db/"/>
      <url>/posts/4e95c1db/</url>
      
        <content type="html"><![CDATA[<h2>前言</h2><p>本来 mathjax 的渲染一直用的十分顺手，直到有一天，我打了一个超级复杂的公式，发现渲染出来的效果不太好，于是我开始了寻找解决方案。</p><p>比如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> x<span class="built_in">_</span>0 <span class="built_in">&amp;</span> x<span class="built_in">_</span>0<span class="built_in">^</span>2 <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> x<span class="built_in">_</span>0<span class="built_in">^</span>n <span class="keyword">\\</span></span><br><span class="line">1 <span class="built_in">&amp;</span> x<span class="built_in">_</span>1 <span class="built_in">&amp;</span> x<span class="built_in">_</span>1<span class="built_in">^</span>2 <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> x<span class="built_in">_</span>1<span class="built_in">^</span>n <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\ddots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="keyword">\\</span></span><br><span class="line">    1 <span class="built_in">&amp;</span> x<span class="built_in">_</span>n <span class="built_in">&amp;</span> x<span class="built_in">_</span>n<span class="built_in">^</span>2 <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> x<span class="built_in">_</span>n<span class="built_in">^</span>n  </span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">a<span class="built_in">_</span>0 <span class="keyword">\\</span> a<span class="built_in">_</span>1 <span class="keyword">\\</span> <span class="keyword">\vdots</span> <span class="keyword">\\</span> a<span class="built_in">_</span>n</span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line">=</span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">y<span class="built_in">_</span>0 <span class="keyword">\\</span> y<span class="built_in">_</span>1 <span class="keyword">\\</span> <span class="keyword">\vdots</span> <span class="keyword">\\</span> y<span class="built_in">_</span>n</span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure><h2>分析问题</h2><p>hexo 常用的渲染插件为 <code>hexo-renderer-marked</code>，原理是将公式块渲染为一个元素，然后用 <code>MathJax</code> 进行渲染。</p><p>但插件会优先转义 Markdown 语法，当语法冲突时，会导致公式无法正常渲染。</p><h2>解决方案</h2><p>换渲染插件，使用 <code>hexo-renderer-pandoc</code>。</p><div class="note warning flat"><p>如果你有下载过任何其他的渲染插件，请务必卸载，否则可能会导致渲染问题。</p></div><div class="note info flat"><p>需要本机下载 Pandoc 并配置环境变量。</p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure><p>还要在 hexo 配置文件 <code>_config.yml</code> 中添加以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pandoc:</span></span><br><span class="line">  <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;-f&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;commonmark_x&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;-t&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;html&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;--mathjax&#x27;</span></span><br><span class="line">  <span class="attr">extensions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;-implicit_figures&#x27;</span></span><br></pre></td></tr></table></figure><h2>Github Action 自动部署</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- name: 安装 Pandoc</span><br><span class="line">  run: |</span><br><span class="line">    wget https://github.com/jgm/pandoc/releases/download/2.10.1/pandoc-2.10.1-1-amd64.deb</span><br><span class="line">    sudo dpkg -i pandoc-2.10.1-1-amd64.deb</span><br></pre></td></tr></table></figure><h2>Mathjax 版本</h2><p>可以自己改 CDN，具体在 <strong>主题配置文件</strong> 配置项 <code>CDN</code> 处。（一般在文件末尾）</p><p>找到 <code>option</code> 中的 <code>mathjax</code> 项，去掉注释，后面加上 <code>CDN</code> 链接。</p><table><thead><tr class="header"><th style="text-align: left;">文件名</th><th style="text-align: left;">输入格式支持</th><th style="text-align: left;">输出格式</th><th style="text-align: left;">含可访问性扩展 (assistive / complexity / explorer)</th><th style="text-align: left;">是否含 Speech Rule Engine</th><th style="text-align: left;">文件大小 (约)</th><th style="text-align: left;">推荐用途</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>tex-chtml.js</strong></td><td style="text-align: left;">TeX</td><td style="text-align: left;">CHTML</td><td style="text-align: left;">❌ 无</td><td style="text-align: left;">❌ 无</td><td style="text-align: left;">~300KB</td><td style="text-align: left;">一般网页、轻量渲染</td><td style="text-align: left;">最轻版本，只支持 TeX→CHTML</td></tr><tr class="even"><td style="text-align: left;"><strong>tex-svg.js</strong></td><td style="text-align: left;">TeX</td><td style="text-align: left;">SVG</td><td style="text-align: left;">❌ 无</td><td style="text-align: left;">❌ 无</td><td style="text-align: left;">~350KB</td><td style="text-align: left;">需要高质量矢量公式</td><td style="text-align: left;">输出为 SVG，适合打印或 PDF</td></tr><tr class="odd"><td style="text-align: left;"><strong>tex-mml-chtml.js</strong></td><td style="text-align: left;">TeX + MathML</td><td style="text-align: left;">CHTML</td><td style="text-align: left;">✅ 有</td><td style="text-align: left;">✅ 有</td><td style="text-align: left;">~450KB</td><td style="text-align: left;">✅ 最完整常用版本</td><td style="text-align: left;">官方推荐版，支持屏幕阅读器</td></tr><tr class="even"><td style="text-align: left;"><strong>tex-mml-svg.js</strong></td><td style="text-align: left;">TeX + MathML</td><td style="text-align: left;">SVG</td><td style="text-align: left;">✅ 有</td><td style="text-align: left;">✅ 有</td><td style="text-align: left;">~500KB</td><td style="text-align: left;">可访问 + 高质量公式</td><td style="text-align: left;">含语音朗读与 Explorer</td></tr><tr class="odd"><td style="text-align: left;"><strong>mml-chtml.js</strong></td><td style="text-align: left;">MathML</td><td style="text-align: left;">CHTML</td><td style="text-align: left;">⚠️ 部分</td><td style="text-align: left;">❌ 无</td><td style="text-align: left;">~250KB</td><td style="text-align: left;">原生 MathML 网站</td><td style="text-align: left;">无 TeX 支持</td></tr><tr class="even"><td style="text-align: left;"><strong>mml-svg.js</strong></td><td style="text-align: left;">MathML</td><td style="text-align: left;">SVG</td><td style="text-align: left;">⚠️ 部分</td><td style="text-align: left;">❌ 无</td><td style="text-align: left;">~280KB</td><td style="text-align: left;">MathML + SVG 输出</td><td style="text-align: left;">纯 MathML 渲染</td></tr><tr class="odd"><td style="text-align: left;"><strong>tex-mml-chtml-full.js</strong></td><td style="text-align: left;">TeX + MathML + AsciiMath</td><td style="text-align: left;">CHTML</td><td style="text-align: left;">✅ 有</td><td style="text-align: left;">✅ 有</td><td style="text-align: left;">~900KB–1MB</td><td style="text-align: left;">🧩 全功能版（全家桶）</td><td style="text-align: left;">包含所有输入 / 输出 / 辅助模块</td></tr><tr class="even"><td style="text-align: left;"><strong>tex-mml-svg-full.js</strong></td><td style="text-align: left;">TeX + MathML + AsciiMath</td><td style="text-align: left;">SVG</td><td style="text-align: left;">✅ 有</td><td style="text-align: left;">✅ 有</td><td style="text-align: left;">~1.1MB</td><td style="text-align: left;">大型项目、演示系统</td><td style="text-align: left;">所有模块 + SVG 输出</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022 CSP-S 初赛部分解析</title>
      <link href="/posts/92783d13/"/>
      <url>/posts/92783d13/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考：<a href="https://blog.csdn.net/lq1990717/article/details/141991949">https://blog.csdn.net/lq1990717/article/details/141991949</a></p></blockquote><h2>单项选择题</h2><h3>2</h3><p>你同时用 time 命令和秒表为某个程序在单核 CPU 的运行计时。假如 time 命令的输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real 0m30.721s</span><br><span class="line">user 0m24.579s</span><br><span class="line">sys  0m6.123s</span><br></pre></td></tr></table></figure><p>以下最接近秒表计时时长为：</p><p>A. 30s</p><p>B. 24s</p><p>C. 18s</p><p>D. 6s</p><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>A。</p><p>real： 总的运行时间，从命令开始执行到结束的时间，包括等待CPU时间和其他进程时间。</p><p>user： 用户CPU时间，即在用户态下花费的时间，不包括用于内核操作的时间。</p><p>sys：系统CPU时间，即在内核态下花费的时间，比如执行系统调用所花费的时间。</p><p>秒表计时的时长接近于程序运行的总时间，即real后面显示的时间。</p></div></details><h3>10</h3><p>共有 8 人选修了程序设计课程，期末大作业要求由 2 人组成的团队完成。假设不区分每个团队内 2 人的角色和作用，请问共有多少种可能的组队方案。</p><p>A. 28</p><p>B. 32</p><p>C. 56</p><p>D. 64</p><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>A。</p><p>题目问的是组队的方案，<strong>并没有要求组成 4 队</strong>。8人中选出 2 人组队，选出的 2 人不区分角色作用，也就是选出的 2 人没有顺序，是组合。因此该问题就是求 8 个不同元素中选出 2 个元素的组合数，为 <span class="math inline">\(C_{8}^{2}\)</span>。</p></div></details><h2>阅读程序</h2><h3>22</h3><p>判断：这是一个不稳定的排序算法。</p><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>错。</p><p>程序为 <strong>基数排序</strong>。</p></div></details><h3>32</h3><p>当输入为 <code>100 7</code> 时，输出为：</p><p>A. 1400</p><p>B. 1401</p><p>C. 417</p><p>D. 400</p><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>B。</p><p>程序给出十进制数 <span class="math inline">\(n\)</span>，将 <span class="math inline">\(n\)</span> 在 <span class="math inline">\(k\)</span> 进制下进行数位分离，但是每分离出一位后，该数值的符号取反（比较特殊的进制转换）。</p><p>这里说一下 <span class="math inline">\(-a \% b\)</span> 的值。</p><p>设 <span class="math inline">\(a = q*b+r\)</span>，则 <span class="math inline">\(a \% b = r\)</span>。</p><p>当 <span class="math inline">\(a&lt;0\)</span> 时，仍然满足 <span class="math inline">\(a = q*b+r\)</span>。</p><p>例：</p><p>输入： <code>-255 8</code>。</p><table><thead><tr class="header"><th style="text-align: center;">除法式</th><th style="text-align: center;">商</th><th style="text-align: center;">余数</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(-255/8\)</span></td><td style="text-align: center;"><span class="math inline">\(-32\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><span class="math inline">\(-32*8+1 = -255\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(32/8\)</span></td><td style="text-align: center;"><span class="math inline">\(4\)</span></td><td style="text-align: center;"><span class="math inline">\(0\)</span></td><td style="text-align: center;"><span class="math inline">\(4*8+0 = 32\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(-4/8\)</span></td><td style="text-align: center;"><span class="math inline">\(-1\)</span></td><td style="text-align: center;"><span class="math inline">\(4\)</span></td><td style="text-align: center;"><span class="math inline">\(-1*8+4 = -4\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(1/8\)</span></td><td style="text-align: center;"><span class="math inline">\(0\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><span class="math inline">\(0*8+1=1\)</span></td></tr></tbody></table><p>因此结果为 <code>1401</code>。</p></div></details>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csp </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更新日志</title>
      <link href="/posts/5a717bf0/"/>
      <url>/posts/5a717bf0/</url>
      
        <content type="html"><![CDATA[<div class="timeline "><div class='timeline-item headline'>        <div class='timeline-item-title'>          <div class='item-circle'><p>2025</p></div>        </div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>10-09</p></div>        </div>        <div class='timeline-item-content'><ol type="1"><li>增加了主页文章轮播图</li><li>增加了分类图</li></ol></div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>10-07</p></div>        </div>        <div class='timeline-item-content'><ol type="1"><li>增加了文章锁</li></ol></div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>09-20</p></div>        </div>        <div class='timeline-item-content'><ol type="1"><li>更新 hexo 至 8.0.0</li><li>更新 butterfly 至 5.5.0</li><li>优化博客布局</li><li>修复 Pandoc 公式渲染问题</li><li>优化 gulp 压缩</li><li>把 live2d 去掉了</li></ol></div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>01-25</p></div>        </div>        <div class='timeline-item-content'><ol start="7" type="1"><li>添加 RSS 订阅功能</li></ol></div>      </div></div><div class="timeline "><div class='timeline-item headline'>        <div class='timeline-item-title'>          <div class='item-circle'><p>2024</p></div>        </div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>11-02</p></div>        </div>        <div class='timeline-item-content'><ol type="1"><li>升级 twikoo 至 1.6.39</li><li>更换 mathjax 引擎为 Pandoc</li></ol></div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>09-15</p></div>        </div>        <div class='timeline-item-content'><ol type="1"><li>更换评论系统为 twikoo</li></ol></div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>09-07</p></div>        </div>        <div class='timeline-item-content'><p>增加部署至 netlify</p></div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>08-25</p></div>        </div>        <div class='timeline-item-content'><p>优化友联样式</p></div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>08-24</p></div>        </div>        <div class='timeline-item-content'><ol type="1"><li>增加 gulp 压缩</li><li>增加外链跳转提示</li><li>增加外挂标签</li><li>增加随机文章</li><li>优化 cdn</li><li>适配 pjax</li></ol></div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>08-22</p></div>        </div>        <div class='timeline-item-content'><ol type="1"><li>添加 gitalk 评论插件，实现了文章评论功能。</li><li>添加文章封面、文章动画</li><li>添加加载动画</li><li>添加首页标签</li><li>美化版权样式</li><li>添加文章置顶功能</li><li>实现博客自动部署</li></ol></div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>08-19</p></div>        </div>        <div class='timeline-item-content'><ol type="1"><li>添加 live-2d 模块，实现了动态的 2D 人物动画。</li></ol></div>      </div><div class='timeline-item'>        <div class='timeline-item-title'>          <div class='item-circle'><p>04-02</p></div>        </div>        <div class='timeline-item-content'><p>正式建站，采用 hexo 框架，butterfly 主题，部署到 Github Pages。 <sub><sub>其实之前有一个，不过寄掉了。</sub></sub></p></div>      </div></div>]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>On the mathematics behind rolling hashes and anti-hash tests</title>
      <link href="/posts/96efb74b/"/>
      <url>/posts/96efb74b/</url>
      
        <content type="html"><![CDATA[<p>This blog assumes the reader is familiar with the basic concept of rolling hashes. There are some math-heavy parts, but one can get most of the ideas without understanding every detail.</p><p>The main focus of this blog is on how to choose the rolling-hash parameters to avoid getting hacked and on how to hack codes with poorly chosen parameters.</p><h2>Designing hard-to-hack rolling hashes</h2><h3>Recap on rolling hashes and collisions</h3><p>Recall that a rolling hash has two parameters <span class="math inline">\((p,a)\)</span> where <span class="math inline">\(p\)</span> is the modulo and <span class="math inline">\(0\le a &lt; p\)</span> the base. (We’ll see that <span class="math inline">\(p\)</span> should be a big prime and <span class="math inline">\(a\)</span> larger than the size of alphabet.) The hash value of a string <span class="math inline">\(S = s_0 \cdots s_{n-1}\)</span> is given by:</p><p><span class="math display">\[h(S) = (\sum^{n-1}_{i=0} a^{n-i-1} s_i) \mod P\]</span></p><p>For now, lets consider the simple problem of: given two strings <span class="math inline">\(S,T\)</span> of equal length, decide whether they’re equal by comparing their hash values <span class="math inline">\(h(S), h(T)\)</span>. Our algorithm declares <span class="math inline">\(S\)</span> and <span class="math inline">\(T\)</span> to be equal if <span class="math inline">\(h(S) = h(T)\)</span>. Most rolling hash solutions are built on multiple calls to this subproblem or rely on the correctness of such calls.</p><p>Let’s call two strings <span class="math inline">\(S, T\)</span> of equal length with <span class="math inline">\(S \neq T\)</span> and <span class="math inline">\(h(S) = h(T)\)</span> an equal-length collision. We want to avoid equal-length collisions, as they cause our algorithm to incorrectly assesses <span class="math inline">\(S\)</span> and <span class="math inline">\(T\)</span> as equal. (Note that our algorithms never incorrectly assesses strings a different.) For fixed parameters and reasonably small length, there are many more strings than possible hash values, so there always are equal-length collisions. Hence you might think that, for any rolling hash, there are inputs for which it is guaranteed to fail.</p><p>Luckily, randomization comes to the rescue. Our algorithm does not have to fix <span class="math inline">\((p, a)\)</span>, it can randomly pick then according to some scheme instead. <span class="math inline">\(A\)</span> scheme is reliable if we can prove that for arbitrary two string <span class="math inline">\(S, T\)</span>, <span class="math inline">\(S\neq T\)</span> the scheme picks <span class="math inline">\((p, a)\)</span> such that <span class="math inline">\(h(S) \neq h(T)\)</span> with high probability. Note that the probability space only includes the random choices done inside the scheme; the input <span class="math inline">\((S, T)\)</span> is arbitrary, fixed and not necessarily random. (If you think of the input coming from a hack, then this means that no matter what the input is, our solution will not fail with high probability.)</p><p>I’ll show you two reliable schemes. (Note that just because a scheme is reliable does not mean that your implementation is good. Some care has to be taken with the random number generator that is used.)</p><h3>Randomizing base</h3><blockquote><p>This part is based on a <a href="https://rng-58.blogspot.com/2017/02/hashing-and-probability-of-collision.html">blog</a> by <a href="https://codeforces.com/profile/rng_58"><font color = "red">rng_58</font></a>. His post covers a more general hashing problem and is worth checking out.</p></blockquote><p>This scheme uses <span class="math inline">\(a\)</span> fixed <strong>prime</strong> <span class="math inline">\(p\)</span> (i.e. <span class="math inline">\(10^9 + 7\)</span> or <span class="math inline">\(4\cdot 10^9 + 7\)</span>) and picks <span class="math inline">\(a\)</span> uniformly at random from <span class="math inline">\([0,p-1]\)</span>. Let <span class="math inline">\(A\)</span> be a random variable for the choice of <span class="math inline">\(a\)</span>.</p><p>To prove that this scheme is good, consider two strings <span class="math inline">\((S, T)\)</span> of equal length and do some calculations：</p><p><span class="math display">\[\begin{aligned}h(S)&amp;=h(T)\\(\sum_{i=0}^{n-1} A^{n-i-1} S_i) \mod p &amp; = (\sum_{i=0}^{n-1} A^{n-i-1} T_i) \mod p\end{aligned}\]</span></p><p>Therefore,we have:</p><p><span class="math display">\[\sum_{i=0}^{n-1} A^{n-i-1} S_i \equiv \sum_{i=0}^{n-1} A^{n-i-1} T_i \pmod p\\\]</span></p><p>Let us let <span class="math inline">\(P(A)\)</span> denote a polynomial in <span class="math inline">\(A\)</span> of degree <span class="math inline">\(\le n-1\)</span>:</p><p><span class="math display">\[P(A) = \sum_{i=0}^{n-1} A^{n-i-1}(S_i-T_i) \equiv 0 \pmod p\]</span></p><p><span class="math inline">\(P\)</span> is non-zero as <span class="math inline">\(S \neq T\)</span>. The calculations show that <span class="math inline">\(h(S) = h(T)\)</span> if and only if <span class="math inline">\(A\)</span> is a root of <span class="math inline">\(P(A)\)</span>.</p><p>As <span class="math inline">\(p\)</span> is prime and we are doing computations <span class="math inline">\(\mod p\)</span>, we are working in a field. Over a field, any polynomial of degree <span class="math inline">\(\le n - 1\)</span> has at most <span class="math inline">\(n-1\)</span> roots. Hence there are at most <span class="math inline">\(n - 1\)</span> choices of a that lead to <span class="math inline">\(h(S) = h(T)\)</span>. Therefore：</p><p><span class="math display">\[Pr[h(S)=h(T)]=Pr[P(A)=0] \le \frac{n-1} {p}\]</span></p><p>So for any two strings <span class="math inline">\((S, T)\)</span> of equal length, the probability that they form an equal-length collision is at most . This is around <span class="math inline">\(10^{-4}\)</span> for <span class="math inline">\(n = 10^5, p = 10^9 + 7\)</span>. Picking larger primes such as <span class="math inline">\(2^{31} - 1\)</span> or <span class="math inline">\(4\cdot 10^9 + 7\)</span> can improve this a bit, but one needs more care with overflows.</p><h3>Tightness of bound</h3><p>For now, this part only applies to primes with smooth <span class="math inline">\(p - 1\)</span>, so it doesn’t work for <span class="math inline">\(p = 10^9 + 7\)</span> for example. It would be interesting to find a construction that is computable and works in the general case.</p><p>The bound <span class="math inline">\(\frac{p-1} {p}\)</span> for this scheme is actually tight if <span class="math inline">\(n-1|p-1\)</span>. Consider <span class="math inline">\(S=ba...a\)</span> and <span class="math inline">\(T=aa...b\)</span> with <span class="math inline">\(P(A)=A^{n-1}-1\)</span>.</p><p>As <span class="math inline">\(p\)</span> is prime,<span class="math inline">\(\frac{\mathbb{Z} } {p\mathbb{Z} }\)</span> is cyclic of order <span class="math inline">\(p - 1\)</span>, hence there is a subgroup <span class="math inline">\(G \subseteq \frac{\mathbb{Z} } {p\mathbb{Z} }\)</span> of order <span class="math inline">\(n - 1\)</span>. Any <span class="math inline">\(g\subseteq G\)</span> then satisfies <span class="math inline">\(g^{n - 1} = 1\)</span>, so <span class="math inline">\(P(A)\)</span> has <span class="math inline">\(n - 1\)</span> distinct roots.</p><h3>Randomizing modulo</h3><p>This scheme fixes a base <span class="math inline">\(a \le |\sum|\)</span> and a bound <span class="math inline">\(N &gt; a\)</span> and picks a <strong>prime</strong> p uniformly at random from <span class="math inline">\([N, 2N - 1]\)</span>.</p><p>To prove that this scheme is good, again, consider two strings <span class="math inline">\((S, T)\)</span> of equal length and do some calculations:</p><p><span class="math display">\[\begin{aligned}h(S)&amp;=h(T)\\(\sum_{i=0}^{n-1} a^{n-i-1} S_i) \mod p &amp; = (\sum_{i=0}^{n-1} a^{n-i-1} T_i) \mod p\end{aligned}\]</span></p><p>Therefore,we have:</p><p><span class="math display">\[\sum_{i=0}^{n-1} a^{n-i-1} S_i \equiv \sum_{i=0}^{n-1} a^{n-i-1} T_i \pmod p\\\]</span></p><p>So:</p><p><span class="math display">\[X = \sum_{i=0}^{n-1}a^{n-i-1}(S_i-T_i) \equiv 0 \pmod p\]</span></p><p>As <span class="math inline">\(X \equiv 0 \pmod p,p|X\)</span>.As we chose a large enough, <span class="math inline">\(X \neq 0\)</span>. Moreover <span class="math inline">\(|X| &lt; a^n\)</span>. An upper bound for the number of distinct prime divisors of <span class="math inline">\(X\)</span> in <span class="math inline">\([N, 2N - 1]\)</span> is given by <span class="math inline">\(\log_N (|X|) = \frac{n\ln (a)} {\ln N}\)</span>. By the prime density theorem, there are around <span class="math inline">\(\frac{X} {\ln{N} }\)</span> primes in <span class="math inline">\([N, 2N - 1]\)</span>. Therefore:</p><p><span class="math display">\[Pr[h(S)=h(T)] = Pr[p|X] \le \sim \frac{n\ln(a)} {N}\]</span></p><p>Note that this bound is slightly worse than the one for randomizing the base. It is around <span class="math inline">\(3\cdot 10{-4}\)</span> for <span class="math inline">\(n = 10^5, a = 26, N = 10^9\)</span>.</p><h3>How to randomize properly</h3><p>The following are good ways of initializing your random number generator.</p><ul><li><p>high precision time.</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrono::<span class="built_in">duration_cast</span>&lt;chrono::nanoseconds&gt;(chrono::high_resolution_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">chrono::<span class="built_in">duration_cast</span>&lt;chrono::nanoseconds&gt;(chrono::steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br></pre></td></tr></table></figure><blockquote><p>Either of the two should be fine. (In theory, <code>high_resolution_clock</code> should be better, but it somehow has lower precision than <code>steady_clock</code> on codeforces??)</p></blockquote></li><li><p>processor cycle counter</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_ia32_rdtsc();</span><br></pre></td></tr></table></figure></li><li><p>some heap address converted to an integer</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">uintptr_t</span>) <span class="built_in">make_unique</span>&lt;<span class="type">char</span>&gt;().<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure></li><li><p>processor randomness (needs either pragma or asm) (Thanks <a href="https://codeforces.com/profile/halyavin"><font color = "red">halyavin</font></a> for <a href="https://codeforces.com/blog/entry/60442?#comment-443083">suggesting</a> this.)</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pragma version</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC target (<span class="string">&quot;rdrnd&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">rdrand32</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> ret;</span><br><span class="line">    <span class="built_in">assert</span>(__builtin_ia32_rdrand32_step (&amp;ret));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// asm version</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> ret;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;rdrand %0&quot;</span> :<span class="string">&quot;=a&quot;</span>(ret) ::<span class="string">&quot;cc&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>If you use a C++11-style rng (you should), you can use a combination of the above:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seed_seq seq&#123;</span><br><span class="line">    (<span class="type">uint64_t</span>) chrono::<span class="built_in">duration_cast</span>&lt;chrono::nanoseconds&gt;(chrono::high_resolution_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>(),</span><br><span class="line">    (<span class="type">uint64_t</span>) __builtin_ia32_rdtsc(),</span><br><span class="line">    (<span class="type">uint64_t</span>) (<span class="type">uintptr_t</span>) <span class="built_in">make_unique</span>&lt;<span class="type">char</span>&gt;().<span class="built_in">get</span>()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">mt19937 <span class="title">rng</span><span class="params">(seq)</span></span>;</span><br><span class="line"><span class="type">int</span> base = <span class="built_in">uniform_int_distribution</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, p<span class="number">-1</span>)(rng);</span><br></pre></td></tr></table></figure><p>Note that this does internally discard the upper 32 bits from the arguments and that this doesn’t really matter, as the lower bits are harder to predict (especially in the first case with chrono.).</p><p><strong>See the section on ‘Abusing bad randomization’ for some bad examples.</strong></p><h3>Extension to multiple hashes</h3><p>We can use multiple hashes (Even with the same scheme and same fixed parameters) and the hashes are independent so long as the random samples are independent. If the single hashes each fail with probability at most <span class="math inline">\(a_1,\cdots, a_k\)</span>, the probability that all hashes fail is at most <span class="math inline">\(\prod_{i=1}^k a_i\)</span>.</p><p>For example, if we use two hashes with <span class="math inline">\(p = 10^9 + 7\)</span> and randomized base, the probability of a collision is at most <span class="math inline">\(10^{ - 8}\)</span>; for four hashes it is at most <span class="math inline">\(10 ^{- 16}\)</span>. Here the constants from slightly larger primes are more significant, for <span class="math inline">\(p = 2^{31} - 1\)</span> the probabilities are around <span class="math inline">\(2.1\cdot 10^{ - 9}\)</span> and <span class="math inline">\(4.7\cdot 10^{ - 18}\)</span>.</p><h3>Larger modulo</h3><p>Using larger (i.e. 60 bit) primes would make collision less likely and not suffer from the accumulated factors of <span class="math inline">\(n\)</span> in the error bounds. However, the computation of the rolling hash gets slower and more difficult, as there is no <code>__int128</code> on codeforces.</p><p>One exception to this is the Mersenne prime <span class="math inline">\(p = 2^{61} - 1\)</span>; we can reduce <span class="math inline">\(\mod p\)</span> by using bitshifts instead. (Thanks <a href="https://codeforces.com/profile/dmkz"><font color = "blue">dmkz</font></a> for suggesting this.) The following code computes <span class="math inline">\(a\cdot b \mod p\)</span> without <code>__int128</code> and is only around <span class="math inline">\(5\%\)</span> slower than a <span class="math inline">\(30\)</span> bit hash with modulo.</p><p>For the argument, the condition <span class="math inline">\(0\le a,b &lt; mod\)</span> should hold.The return value then also satisfies this.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">uint64_t</span> mod = (<span class="number">1ull</span>&lt;&lt;<span class="number">61</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">modmul</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> l1 = (<span class="type">uint32_t</span>)a, h1 = a&gt;&gt;<span class="number">32</span>, l2 = (<span class="type">uint32_t</span>)b, h2 = b&gt;&gt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">uint64_t</span> l = l1*l2, m = l1*h2 + l2*h1, h = h1*h2;</span><br><span class="line">    <span class="type">uint64_t</span> ret = (l&amp;mod) + (l&gt;&gt;<span class="number">61</span>) + (h &lt;&lt; <span class="number">3</span>) + (m &gt;&gt; <span class="number">29</span>) + (m &lt;&lt; <span class="number">35</span> &gt;&gt; <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    ret = (ret &amp; mod) + (ret&gt;&gt;<span class="number">61</span>);</span><br><span class="line">    ret = (ret &amp; mod) + (ret&gt;&gt;<span class="number">61</span>);</span><br><span class="line">    <span class="keyword">return</span> ret<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A smaller factor can be gained by using unsigned types and <span class="math inline">\(p=4\cdot 10^9 + 7\)</span>.</p><p>Note that <span class="math inline">\(p=2^{64}\)</span>(overflow of unsigned long long) is not prime and can be hacked regardless of randomization (see below).</p><h3>Extension to multiple comparisons</h3><p>Usually, rolling hashes are used in more than a single comparison. If we rely on m comparison and the probability that a single comparison fails is <span class="math inline">\(p\)</span> then the probability that any of the fail is at most <span class="math inline">\(m\cdot p\)</span> by a union bound. Note that when <span class="math inline">\(m = 10^5\)</span>, we need at least two or three hashes for this to be small.</p><p>One has to be quite careful when estimating the number comparison we need to succeed. If we sort the hashes or put them into a set, we need to have pair-wise distinct hashes, so for <span class="math inline">\(n\)</span> string a total of <span class="math inline">\(\binom{n} {2}\)</span> comparisons have to succeed. If <span class="math inline">\(n = 3\cdot 10^5\)</span>, <span class="math inline">\(m 4.5\cdot 10^9\)</span>, so we need three or four hashes (or only two if we use <span class="math inline">\(p = 2^{61} - 1\)</span>).</p><h3>Extension to strings of different length</h3><p>If we deal with strings of different length, we can avoid comparing them by storing the length along the hash. This is not necessarily however, if we assume that <strong>no character hashes to</strong> <span class="math inline">\(0\)</span>. In that case, we can simple imagine we prepend the shorter strings with null-bytes to get strings of equal length without changing the hash values. Then the theory above applies just fine. (If some character (i.e. <code>a</code>) hashes to <span class="math inline">\(0\)</span>, we might produce strings that look the same but aren’t the same in the prepending process (i.e. <code>a</code> and <code>aa</code>).)</p><h2>Computing anti-hash tests</h2><p>This section cover some technique that take advantage of common mistakes in rolling hash implementations and can mainly be used for hacking other solutions. Here’s a table with a short summary of the methods.</p><table><thead><tr class="header"><th style="text-align: center;"><strong>Name</strong></th><th style="text-align: center;"><strong>Use case</strong></th><th style="text-align: center;"><strong>Run time</strong></th><th style="text-align: center;"><strong>String lenth</strong></th><th style="text-align: center;"><strong>Notes</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Thue-Morse</td><td style="text-align: center;">Hash with overflow</td><td style="text-align: center;"><span class="math inline">\(O(1)\)</span></td><td style="text-align: center;"><span class="math inline">\(2^{10}\)</span></td><td style="text-align: center;">Works for all bases simultaneously.</td></tr><tr class="even"><td style="text-align: center;">Birthday</td><td style="text-align: center;">Small modulo</td><td style="text-align: center;"><span class="math inline">\(O(\sqrt{p}\log p)\)</span></td><td style="text-align: center;"><span class="math inline">\(\approx2\log_{|\sum|}p\)</span></td><td style="text-align: center;">Can find multiple collisions.</td></tr><tr class="odd"><td style="text-align: center;">Tree</td><td style="text-align: center;">Large modulo</td><td style="text-align: center;"><span class="math inline">\(O(2^{\sqrt{p\lg p}})\)</span></td><td style="text-align: center;"><span class="math inline">\(O(2^{\sqrt{p\lg p}}+1)\)</span></td><td style="text-align: center;">faster; longer strings</td></tr><tr class="even"><td style="text-align: center;">Multi-tree</td><td style="text-align: center;">Large modulo</td><td style="text-align: center;"><span class="math inline">\(O((2^{\sqrt{2\lg m p} }+\log_{|\sum|}m)\cdot m\log m)\)</span></td><td style="text-align: center;"><span class="math inline">\(\approx O((2^{\sqrt{2\lg m p} }+\log_{ |\sum |}m))\)</span></td><td style="text-align: center;">slower; shorter strings</td></tr><tr class="odd"><td style="text-align: center;">Lattice reduction</td><td style="text-align: center;">Medium-large alphabet, Multiple hashes</td><td style="text-align: center;"><span class="math inline">\(O(length^3)\)</span></td><td style="text-align: center;"><span class="math inline">\(\approx \sum_{i=0}^{n-1}\log_{|\sum|}(p_n)\)</span></td><td style="text-align: center;">Great results for <span class="math inline">\(|\sum| =26\)</span>, good against multiple hashes. Bad on binary alphabet.</td></tr><tr class="even"><td style="text-align: center;">Composition</td><td style="text-align: center;">Multiple hashes</td><td style="text-align: center;">Sum of single runtimes</td><td style="text-align: center;">Product of single string lengths</td><td style="text-align: center;">Combines two attacks.</td></tr></tbody></table><h3>Single hashes</h3><h4>Thue–Morse sequence: Hashing with unsigned overflow (<span class="math inline">\(p = 2^{64}\)</span>, <span class="math inline">\(q\)</span> arbitrary)</h4><p>One anti-hash test that works for any base is the Thue–Morse sequence, generated by the following code.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Q = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1</span> &lt;&lt; Q;</span><br><span class="line"><span class="function">std::string <span class="title">S</span><span class="params">(N, <span class="string">&#x27; &#x27;</span>)</span>, <span class="title">T</span><span class="params">(N, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    S[i] = <span class="string">&#x27;A&#x27;</span> + __builtin_popcount(i) % <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    T[i] = <span class="string">&#x27;B&#x27;</span> - __builtin_popcount(i) % <span class="number">2</span>; </span><br></pre></td></tr></table></figure><p><span class="math inline">\(S\)</span>, <span class="math inline">\(T\)</span> form an equal-length collision, regardless of the chosen base.</p><p>See this <a href="https://codeforces.com/blog/entry/4898">blog</a> for a detailed discussion. Note that the bound on the linked blog can be improved slightly, as <span class="math inline">\(X^2 - 1\)</span> is always divisible by <span class="math inline">\(8\)</span> for odd <span class="math inline">\(X\)</span>. (So we can use <span class="math inline">\(Q = 10\)</span> instead of <span class="math inline">\(Q = 11\)</span>.)</p><h4>Birthday-attack: Hashing with 32-bit prime and fixed base (<span class="math inline">\(p &lt; 2^{32}\)</span> fixed, <span class="math inline">\(q\)</span> fixed)</h4><p>Hashes with a single small prime can be attacked via the birthday paradox. Fix a length <span class="math inline">\(l\)</span> and the size of alphabet <span class="math inline">\(d\)</span>, and pick <span class="math inline">\(k\)</span> strings of length <span class="math inline">\(l\)</span> uniformly at random. If <span class="math inline">\(l\)</span> is not to small, the resulting hash values will approximately be uniformly distributed. By the birthday paradox, the probability that all of our picked strings hash to different values is:</p><p><span class="math display">\[\sum_{i=0}^{k-1}(1-\frac{i} {d} ) &lt; \sum_{i=0}^{k-1}(e^{-\frac{i} {d} } ) =e^{-\frac{k(k-1)} {2d} } &lt; e^{-\ln 2} = \frac{1} {2}\]</span></p><p>Hence with probability <span class="math inline">\(&gt; \frac{1} {2}\)</span> we found two strings hashing to the same value. By repeating this, we can find an equal-length collision with high probability in <span class="math inline">\(O(\sqrt{p} )\)</span>. In practice, the resulting strings can be quite small (<span class="math inline">\(length  \approx  6\)</span> and <span class="math inline">\(d=62\)</span> for <span class="math inline">\(p = 10^9 + 7\)</span>, not sure how to upper-bound this.).</p><p>More generally, we can compute <span class="math inline">\(m\)</span> strings with equal hash value in <span class="math inline">\(O(m\cdot p^{1-\frac{1} {m} } )\)</span> using the same technique with <span class="math inline">\(r = m \cdot p^{1-\frac{1} {m} }\)</span>.</p><h4>Tree-attack: Hashing with larger prime and fixed base (<span class="math inline">\(p\)</span> fixed, <span class="math inline">\(q\)</span> fixed)</h4><blockquote><p>Thanks <a href="https://codeforces.com/profile/Kaban-5"><font color="red">Kaban-5</font></a> and <a href="https://codeforces.com/profile/pavel.savchenkov"><font color="red">pavel.savchenkov</font></a> for the <a href="https://codeforces.com/blog/entry/17507?locale=ru#comment-223614">link</a> to some Russian comments describing this idea.</p></blockquote><p>For large primes, the birthday-attack is to slow. Recall that for two strings <span class="math inline">\((S, T)\)</span> of equal length:</p><p><span class="math display">\[h(S)=h(T)\]</span></p><p><span class="math display">\[\sum_{i=0}^{n-1}a^{n-i-1}(S_i-T_i) \equiv 0 \pmod{p}\]</span></p><p>we set <span class="math inline">\(\alpha_i = S_i - T_i\)</span> satisfies <span class="math inline">\(-|\sum| \le \alpha_i \le |\sum|\)</span>.The tree-attack tries to find <span class="math inline">\(\alpha_i \in\{-1,0,1\}\)</span> such that:</p><p><span class="math display">\[\sum_{i=0}^{n-1} (a_{n-i-1} \mod p) \cdot \alpha_i = 0\]</span></p><p>The attack maintains clusters <span class="math inline">\(C_1, ..., C_k\)</span> of coefficients. The <strong>sum</strong> <span class="math inline">\(S(C)\)</span> of a cluster <span class="math inline">\(C\)</span> is given by:</p><p><span class="math display">\[S(C) = \sum_{i\in C} (a_{n-i-1} \mod p) \cdot \alpha_i\]</span></p><p>We can merge two clusters <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> to a cluster <span class="math inline">\(C_3\)</span> of sum <span class="math inline">\(S(C_1) - S(C_2)\)</span> by multiplying all the <span class="math inline">\(\alpha_i\)</span> from <span class="math inline">\(C_2\)</span> with $ - 1$ and joining the set of coefficients of <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span>. This operation can be implemented in constant time by storing the clusters as binary trees where each node stores its sum; the merge operation then adds a new node for <span class="math inline">\(C_3\)</span> with children <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> and sum <span class="math inline">\(S(C_1) - S(C_2)\)</span>. To ensure that the <span class="math inline">\(S(C_3) \ge 0\)</span>, swap <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> if necessary. The values of the <span class="math inline">\(\alpha_i\)</span> are not explicitly stored, but they can be recomputed in the end by traversing the tree.</p><p>Initially, we start with <span class="math inline">\(n = 2k\)</span> and each <span class="math inline">\(\alpha_i=1\)</span> in its own cluster. In a phase, we first sort the clusters by their sum and then merge adjacent pairs of clusters. If we encounter a cluster of sum <span class="math inline">\(0\)</span> at any point, we finish by setting all <span class="math inline">\(\alpha_j\)</span> not in that cluster to <span class="math inline">\(0\)</span>. If we haven’t finished after <span class="math inline">\(k\)</span> phases, try again with a bigger value of <span class="math inline">\(k\)</span>.</p><p>For which values of <span class="math inline">\(k\)</span> can we expect this to work? If we assume that the sums are initially uniformly distributed in <span class="math inline">\([0,p-1]\)</span>, the maximum sum should decrease by a factor <span class="math inline">\(\sim 2^{k-i}\)</span> in phase <span class="math inline">\(i\)</span>. After <span class="math inline">\(k\)</span> phases, the maximum sum is around <span class="math inline">\(\frac{p} {2^{\binom{k} {2} } }\)</span>, so <span class="math inline">\(k\approx \sqrt{2\lg p}+1\)</span> works. This produces strings of length <span class="math inline">\(n=2^{\sqrt{2\lg p}+1}\)</span> in <span class="math inline">\(O(n)\)</span> time. (A more formal analysis can be found in the paper ‘<a href="ftp://ftp.inf.ethz.ch/pub/crypto/publications/FlaPrz05.pdf">Solving Medium-Density Subset Sum Problems in Expected Polynomial Time</a>’, section 2.2. The problem and algorithms in the paper are slightly different, but the approach similar.)</p><h5>Multi-tree-attack</h5><p>While the tree-attacks runs really fast, the resulting strings can get a little long. (<span class="math inline">\(n = 2048\)</span> for <span class="math inline">\(p = 2^{61} - 1\)</span>.) We can spend more runtime to search for a shorter collision by storing the smallest m sums we can get in each cluster. (The single-tree-attack just uses <span class="math inline">\(m = 1\)</span>.) Merging two clusters can be done in <span class="math inline">\(O(m\log m)\)</span> with a min-heap and a <span class="math inline">\(2m\)</span>-pointer walk. In order to get to m strings ASAP, we allow all values <span class="math inline">\(\alpha_i\in[-|\sum|,|\sum|]\)</span> and exclude the trivial case where all <span class="math inline">\(\alpha_i\)</span> are zero.</p><p>Analysing the expected value of <span class="math inline">\(k\)</span> for this to work is quite difficult. Under the optimistic assumption that we reach m sums per node after <span class="math inline">\(\log_{\left |\sum \right |} m\)</span> steps, that the sums decrease as in the single tree attack and that we can expected a collision when they get smaller than <span class="math inline">\(m^2\)</span> by the birthday-paradox, we get <span class="math inline">\(k = \sqrt{2\frac{\lg p} {\lg m} }+\log_{|\sum|} m\)</span>. (A more realistic bound would be <span class="math inline">\(k=\frac{\lg p} {\lg m}+log_{|\sum|}m\)</span>, which might be gotten by accounting for the birthday-paradox in the bound proven in the paper ‘<a href="https://www.semanticscholar.org/paper/On-Random-High-Density-Subset-Sums-Lyubashevsky/08d901a94599ab95b1138f0ee68c5d0cda31bd68?p2df">On Random High Density Subset Sums</a>’, Theorem 3.1.)</p><p>In practice, we can use <span class="math inline">\(m \approx 10^5\)</span> to find a collision of length <span class="math inline">\(128\)</span> for <span class="math inline">\(|\sum|=2\)</span>, <span class="math inline">\(p = 2^{61} - 1\)</span> in around 0.4 seconds.</p><h4>Lattice-reduction attack: Single or multiple hashes over not-to-small alphabet</h4><blockquote><p>Thanks to <a href="https://codeforces.com/profile/hellman_"><font color="orange">hellman_</font></a> for mentioning this, check out his write-up on this topic here. There’s also a write-up by someone else <a href="https://galhacktictrendsetters.wordpress.com/2017/09/05/tokyo-westerns-ctf-2017-palindromes-pairs-challenge-phase/">here</a>.</p></blockquote><p>As in the tree attack, we’re looking for <span class="math inline">\(\alpha_i\in[-|\sum|,|\sum|]\)</span> such that:</p><p><span class="math display">\[\sum_{i=0}^{n-1} (a_{n-i-1} \mod p) \cdot \alpha_i = 0\]</span></p><p>The set:</p><p><span class="math display">\[{\alpha_0,\cdots,a_{n-1},\beta} | \beta \equiv \sum_{i=0}^{n-1} (a_{n-i-1} \mod p)\cdot \alpha_i\]</span></p><p>forms a lattice (A free <span class="math inline">\(\mathbb{Z}\)</span>-module embedded in a subspace of <span class="math inline">\(\mathbb{R}^n\)</span>.) We’re looking for an element in the lattice such that <span class="math inline">\(\beta = 0\)</span> and <span class="math inline">\(|\alpha_i| \le |\sum|\)</span>. We can penalize non-zero values of <span class="math inline">\(\beta\)</span> by considering:</p><p><span class="math display">\[\beta = 10^5((\sum_{i=0}^{n-1} (a_{n-i-1} \mod p)\cdot \alpha_i)) \mod p\]</span></p><p>instead, then we seek to minimize <span class="math inline">\(\max\{|\alpha_0|,\cdots,|a_{n-1}|,|\beta|\}\)</span>. Unfortunately, this optimization problem is quite hard, so we try to minimize:</p><p><span class="math display">\[\alpha_0^2 + \cdots + \alpha_{n-1}^2 + \beta^2\]</span></p><p>instead. The resulting problem is still hard, possibly NP-complete, but there are some good approximation algorithms available.</p><p>Similar to a vector space, we can define a basis in a lattice. For our case, a basis is given by:</p><p><span class="math display">\[\{e_\beta+10^5(a_{n-i-1} \mod p)e_{a_i} | 0\le i &lt; n\} \cup \{p\cdot 10^5e_\beta\}\]</span></p><p>A lattice reduction algorithm takes this basis and transforms it (by invertible matrices with determinant <span class="math inline">\(\pm\)</span>) into another basis with approximately shortest vectors. Implementing them is quite hard (and suffers from precision errors or bignum slowdown), so I decided to use the builtin implementation in sage.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Anti-rolling-hash test generation by lattice reduction</span></span><br><span class="line"><span class="string">original code by Hellman_, modified by dacin21</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">anti_hash</span>(<span class="params">PAs, string_length, sigma, block_size = <span class="number">0</span>, MULTIPLIER = <span class="number">100000</span>, sigma_base = <span class="built_in">ord</span>(<span class="params"><span class="string">&#x27;a&#x27;</span></span>)</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(PAs)</span><br><span class="line">    N = string_length</span><br><span class="line">    As = [a <span class="keyword">for</span> p, a <span class="keyword">in</span> PAs]</span><br><span class="line">    Ps = [p <span class="keyword">for</span> p, a <span class="keyword">in</span> PAs]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;polynomial hash modulo &lt;n&gt; primes&quot;&quot;&quot;</span></span><br><span class="line">        v = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            v = [(x * q + <span class="built_in">ord</span>(c))%p <span class="keyword">for</span> x, q, p <span class="keyword">in</span> <span class="built_in">zip</span>(v, As, Ps)]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tuple</span>(v % p <span class="keyword">for</span> v, p <span class="keyword">in</span> <span class="built_in">zip</span>(v, Ps))</span><br><span class="line"></span><br><span class="line">    mv = matrix(ZZ, N, N)</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> xrange(N):</span><br><span class="line">        <span class="keyword">for</span> x, q, p <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(n), As, Ps):</span><br><span class="line">            mv[y,x] = <span class="built_in">pow</span>(q, N-y-<span class="number">1</span>, p);</span><br><span class="line"></span><br><span class="line">    m = matrix(ZZ, N + n, N + n)</span><br><span class="line">    <span class="comment"># submatrix with terms</span></span><br><span class="line">    m.set_block(<span class="number">0</span>, <span class="number">0</span>, MULTIPLIER * mv)</span><br><span class="line">    <span class="comment"># modulo reductions</span></span><br><span class="line">    m.set_block(N, <span class="number">0</span>, MULTIPLIER * diagonal_matrix(Ps))</span><br><span class="line">    <span class="comment"># term coefficients</span></span><br><span class="line">    m.set_block(<span class="number">0</span>, n, identity_matrix(N))</span><br><span class="line">    <span class="comment"># 4th submatrix is zero</span></span><br><span class="line"></span><br><span class="line">    m_reduced = m.LLL()</span><br><span class="line">    <span class="keyword">if</span> block_size &gt; <span class="number">0</span>:</span><br><span class="line">        m_reduced = m_reduced.BKZ(block_size = block_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> m_reduced:</span><br><span class="line">        <span class="built_in">print</span> row[:n], <span class="built_in">min</span>(row[n:]), <span class="string">&quot;~&quot;</span>, <span class="built_in">max</span>(row[n:])</span><br><span class="line">        delta = <span class="built_in">max</span>(<span class="built_in">abs</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> row[n:])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">set</span>(row[:n]) == &#123;<span class="number">0</span>&#125; <span class="keyword">and</span> delta &lt; sigma:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;Found collision!&quot;</span></span><br><span class="line">            s = [<span class="literal">None</span>] * N</span><br><span class="line">            t = [<span class="literal">None</span>] * N</span><br><span class="line">            <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(row[n:]):</span><br><span class="line">                a = sigma_base</span><br><span class="line">                b = a + <span class="built_in">abs</span>(v)</span><br><span class="line">                <span class="keyword">if</span> v &gt; <span class="number">0</span>:</span><br><span class="line">                    a, b = b, a</span><br><span class="line">                s[i] = a</span><br><span class="line">                t[i] = b</span><br><span class="line">            s = <span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, s))</span><br><span class="line">            t = <span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, t))</span><br><span class="line">            <span class="built_in">print</span> s + <span class="string">&quot; &quot;</span> + t</span><br><span class="line">            <span class="comment"># print h(s)</span></span><br><span class="line">            <span class="comment"># print h(t)</span></span><br><span class="line">            <span class="keyword">assert</span> h(s) == h(t)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Failed to find collision, try a larger string_length&quot;</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;For lengths &gt; 30, setting block_size to 10 or 15 is recommended&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;hash.in&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> infile:</span><br><span class="line">        n, k, sigma = <span class="built_in">map</span>(<span class="built_in">int</span>, infile.readline().strip().split())</span><br><span class="line">        PAs = [<span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, infile.readline().strip().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        anti_hash(PAs, k, sigma)</span><br></pre></td></tr></table></figure><p>Input is taken from a file named <code>hash.in</code> in the format. To use the BKZ algorithm, set the <code>block_size</code> argument.</p><p>Input format:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n length sigma</span><br><span class="line">p_1 a_1</span><br><span class="line">...</span><br><span class="line">p_n a_n</span><br></pre></td></tr></table></figure><p>Sage offers two algorithms: LLL and BKZ, the former is faster but produces worse approximations, especially for longer strings. Analyzing them is difficult, so I experimented a bit by fixing <span class="math inline">\(|\sum|=26\)</span>, <span class="math inline">\(p = 2^{61} - 1\)</span> and fixing <span class="math inline">\(a_1,\cdots ,a_n\)</span> randomly and searching for a short anti-hash test with both algorithms. The results turned out really well.</p><p>LLL algorithm:</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n\)</span></th><th style="text-align: center;">minimal length</th><th style="text-align: center;">time spent (seconds)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">12</td><td style="text-align: center;">0.02</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">23</td><td style="text-align: center;">0.04</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">34</td><td style="text-align: center;">0.08</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">48</td><td style="text-align: center;">0.18</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">60</td><td style="text-align: center;">0.34</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">77</td><td style="text-align: center;">0.75</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">301</td><td style="text-align: center;">5.14</td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: center;"><span class="math inline">\(&gt; 1500\)</span></td><td style="text-align: center;"><span class="math inline">\(&gt; 990\)</span></td></tr></tbody></table><p>for <span class="math inline">\(n = 8\)</span> the algorithm couldn’t find a collision of length <span class="math inline">\(\le 1500\)</span>.</p><p>BKZ algorithm with <code>block_size = 10</code>:</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n\)</span></th><th style="text-align: center;">minimal length</th><th style="text-align: center;">time spent (seconds)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">12</td><td style="text-align: center;">0.02</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">23</td><td style="text-align: center;">0.04</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">33</td><td style="text-align: center;">0.09</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">45</td><td style="text-align: center;">0.21</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">57</td><td style="text-align: center;">0.58</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">72</td><td style="text-align: center;">1.12</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">88</td><td style="text-align: center;">2.59</td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: center;">108</td><td style="text-align: center;">5.33</td></tr></tbody></table><p>BKZ algorithm with <code>block_size = 15</code>:</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n\)</span></th><th style="text-align: center;">minimal length</th><th style="text-align: center;">time spent (seconds)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">12</td><td style="text-align: center;">0.02</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">23</td><td style="text-align: center;">0.04</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">33</td><td style="text-align: center;">0.09</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">45</td><td style="text-align: center;">0.21</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">57</td><td style="text-align: center;">0.52</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">70</td><td style="text-align: center;">1.24</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">85</td><td style="text-align: center;">2.41</td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: center;">102</td><td style="text-align: center;">5.20</td></tr></tbody></table><p>BKZ algorithm with <code>block_size = 25</code>:</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n\)</span></th><th style="text-align: center;">minimal length</th><th style="text-align: center;">time spent (seconds)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">12</td><td style="text-align: center;">0.02</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">23</td><td style="text-align: center;">0.04</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">33</td><td style="text-align: center;">0.10</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">46</td><td style="text-align: center;">0.58</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">57</td><td style="text-align: center;">1.14</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">70</td><td style="text-align: center;">3.67</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">84</td><td style="text-align: center;">6.96</td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: center;">96</td><td style="text-align: center;">26.70</td></tr></tbody></table><p>Note that this attack does not work well for small (i.e binary) alphabets when <span class="math inline">\(n &gt; 1\)</span> and that the characters have to <strong>hash to consecutive</strong> values, so this has to be the first attack if used in a composition attack.</p><h3>Composition-attack: Multiple hashes</h3><blockquote><p>Credit for this part goes to <a href="https://codeforces.com/profile/ifsmirnov"><font color="red">ifsmirnov</font></a>, I found this technique in his <a href="https://github.com/ifsmirnov/jngen">jngen</a> library.</p></blockquote><p>Using two or more hashes is usually sufficient to protect from a direct birthday-attack. For two primes, there are <span class="math inline">\(N = p_1·p_2\)</span> possible hash values. The birthday-attack runs in <span class="math inline">\(O(\sqrt{N})\)</span>, which is <span class="math inline">\(\approx 10^{10}\)</span> for primes around <span class="math inline">\(10^9\)</span>. Moreover, the memory usage is more than <span class="math inline">\(\sqrt{ (2 \ln 2)N}\cdot 8\)</span> bytes (If you only store the hashes and the rng-seed), which is around 9.5 GB.</p><p>The key idea used to break multiple hashes is to break them one-by-one.</p><ul><li>First find an equal-length collision (by birthday-attack) for the first hash <span class="math inline">\(h_1\)</span>, i.e. two strings <span class="math inline">\(S, T, S \neq T\)</span> of equal length with <span class="math inline">\(h_1(S) = h_1(T)\)</span>. Note that strings of equal length built over the alphabet <span class="math inline">\(S, T\)</span> (i.e. by concatenation of some copies of <span class="math inline">\(S\)</span> with some copies of <span class="math inline">\(T\)</span> and vice-versa) will now hash to the same value under <span class="math inline">\(h_1\)</span>.</li><li>Then use <span class="math inline">\(S\)</span> and <span class="math inline">\(T\)</span> as the alphabet when searching for an equal-length collision (by birthday-attack again) for the second hash <span class="math inline">\(h_2\)</span>. The result will automatically be a collision for <span class="math inline">\(h_1\)</span> as well, as we used <span class="math inline">\(S, T\)</span> as the alphabet.</li></ul><p>This reduces the runtime <span class="math inline">\(O(\sqrt{p_1}+\sqrt{p_2} )\)</span> . Note that this also works for combinations of a 30-bit prime hash and a hash mod <span class="math inline">\(2^{64}\)</span> if we use the Thue–Morse sequence in place of the second birthday attack. Similarly, we can use tree- instead of birthday-attacks for larger modulos.</p><p>Another thing to note is that string length grows rapidly in the number of hashes. (Around <span class="math inline">\(2\log_{|\sum|}(\sqrt{ (2\ln 2)p_1} )\cdot\log_2 (\sqrt{ (2\ln 2)p_2} )\cdots \log_2(\sqrt{ (2\ln 2)p_k} )\)</span>, the alphabet size is reduced to <span class="math inline">\(2\)</span> after the first birthday-attack. The first iteration has a factor of <span class="math inline">\(2\)</span> in practice.) If we search for more than 2 strings with equal hash value in the intermediate steps, the alphabet size will be bigger, leading to shorter strings, but the runtime of the birthday-attacks gets slower (<span class="math inline">\(O(p^{\frac{2} {3} } )\)</span> for <span class="math inline">\(3\)</span> strings, for example.).</p><h2>Abusing bad randomization</h2><p>On codeforces, quite a lot of people randomize their hashes. (Un-)Fortunately, many of them do it an a suboptimal way. This section covers some of the ways people screw up their hash randomizations and ways to hack their code.</p><p>This section applies more generally to any type of randomized algorithm in an environment where other participants can hack your solutions.</p><h3>Fixed seed</h3><p>If the seed of the rng is fixed, it always produces the same sequence of random numbers. You can just run the code to see which numbers get randomly generated and then find an anti-hash test for those numbers.</p><h3>Picking from a small pool of bases(<code>rand()%100</code>)</h3><p>Note that <code>rand() % 100</code> produced at most 100 distinct values <span class="math inline">\([0,99]\)</span>. We can just find a separate anti-hash test for every one of them and then combine the tests into a single one. (The way your combine tests is problem-specific, but it works for most of the problems.)</p><h3>More issues with <code>rand()</code></h3><p>On codeforces, <code>rand()</code> produces only <span class="math inline">\(15\)</span>-bit values, so at most <span class="math inline">\(2^{15}\)</span> different values. While it may take a while to run <span class="math inline">\(2^{15}\)</span> birthday-attacks (estimated <span class="math inline">\(111\)</span> minutes for <span class="math inline">\(p = 10^9 + 7\)</span> using a single thread on my laptop), this can cause some big issues with some other randomized algorithms.</p><p>Edit: This type of hack might be feasible if we use multi-tree-attacks. For $ p =10^9+7,|\sum|=26$, running <span class="math inline">\(2^{15}\)</span> multi-tree attacks with <span class="math inline">\(m = 10^4\)</span> takes around <span class="math inline">\(2\)</span> minutes and produces an output of <span class="math inline">\(5.2\cdot 10^5\)</span> characters. This is still slightly to large for most problems, but could be split up into multiple hacks in an open hacking phase, for example.</p><p>In C++11 you can use <code>mt19937</code> and <code>uniform_int_distribution</code> instead of <code>rand()</code>.</p><h3>Low-precision time(<code>Time(NULL)</code>)</h3><p><code>Time(NULL)</code> only changes once per second. This can be exploited as follows</p><ol type="1"><li>Pick a timespan <span class="math inline">\(\Delta T\)</span>.</li><li>Find an upper bound <span class="math inline">\(T\)</span> for the time you’ll need to generate your tests.</li><li>Figure out the current value <span class="math inline">\(T_0\)</span> of <code>Time(NULL)</code> via custom invocation.</li><li>For <span class="math inline">\(t = 0,\cdots,(\Delta T) - 1\)</span>, replace <code>Time(NULL)</code> with <span class="math inline">\(T_0 + T + t\)</span> and generate an anti-test for this fixed seed.</li><li>Submit the hack at time <span class="math inline">\(T_0 + T\)</span>.</li></ol><p>If your hack gets executed within the next <span class="math inline">\(\Delta T\)</span> seconds, <code>Time(NULL)</code> will be a value for which you generated an anti-test, so the solution will fail.</p><h3>Random device on MinGW(<code>std::random_device</code>)</h3><p>Note that on codeforces specifically, <code>std::random_device</code> is deterministic and will produce the same sequence of numbers. Solutions using it can be hacked just like fixed seed solutions.</p><blockquote><p>本文选取自 <a href="https://codeforces.com/blog/entry/60442">Anti-rolling-hash test generation by lattice reduction</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于滚动哈希与反哈希测试背后的数学原理</title>
      <link href="/posts/951dcf71/"/>
      <url>/posts/951dcf71/</url>
      
        <content type="html"><![CDATA[<p>本博文假设读者已经熟悉滚动哈希（rolling hash）的基本概念。文中包含若干偏重数学的部分，但即使不抓住每一个细节，也能理解核心思想。</p><p>本文的主要焦点是：如何选择滚动哈希参数以降低被攻击的风险，以及如何利用不当参数去攻击实现。</p><h2>设计难以被破解的滚动哈希</h2><h3>回顾滚动哈希与碰撞</h3><p>滚动哈希有两个参数 <span class="math inline">\((p,a)\)</span>，其中 <span class="math inline">\(p\)</span> 是模数，<span class="math inline">\(0\le a &lt; p\)</span> 是基数。（我们将看到 <span class="math inline">\(p\)</span> 应该是一个较大的素数，而 <span class="math inline">\(a\)</span> 应大于字母表大小。）字符串 <span class="math inline">\(S = s_0 \cdots s_{n-1}\)</span> 的哈希值定义为：</p><p><span class="math display">\[h(S) = \Big(\sum_{i=0}^{n-1} a^{n-i-1} s_i\Big) \bmod p\]</span></p><p>先考虑一个子问题：给定两个等长字符串 <span class="math inline">\(S,T\)</span>，通过比较各自哈希 <span class="math inline">\(h(S), h(T)\)</span> 判断是否相等。算法在 <span class="math inline">\(h(S) = h(T)\)</span> 时认定 <span class="math inline">\(S\)</span> 与 <span class="math inline">\(T\)</span> 相等。多数滚动哈希的解决方案要么多次调用这个子问题，要么依赖于其正确性。</p><p>我们称满足 <span class="math inline">\(S \ne T\)</span> 且 <span class="math inline">\(h(S) = h(T)\)</span> 的两条等长字符串为等长碰撞。等长碰撞会导致算法错误地把不同的字符串判断为相同（注意：此处的误判不会把本应不同长度的字符串混淆为相同）。在固定参数且长度不算大时，可取的字符串远多于哈希值空间，因此必然存在等长碰撞。于是你可能会认为：对任何滚动哈希，都存在让其失败的输入。</p><p>幸运的是，随机化可以帮忙。算法不必固定 <span class="math inline">\((p,a)\)</span>，而是可以按某种方案随机选择。若能证明：对于任意固定的输入 <span class="math inline">\((S,T)\)</span>，只要 <span class="math inline">\(S\ne T\)</span>，该方案以高概率选出使得 <span class="math inline">\(h(S) \ne h(T)\)</span> 的 <span class="math inline">\((p,a)\)</span>，就称该方案可靠。概率空间仅包含方案内部的随机选择；输入 <span class="math inline">\((S,T)\)</span> 是固定的、可以视为对抗性选择。（从“被黑”的角度看，就是无论对方怎么挑输入，我们的方案都将以高概率不失败。）</p><p>下面给出两种可靠方案。（方案可靠不代表你的实现就一定好；随机数生成器的使用需要谨慎。）</p><h3>随机化基数</h3><blockquote><p>本部分基于 <a href="https://codeforces.com/profile/rng_58">rng_58</a> 的<a href="https://rng-58.blogspot.com/2017/02/hashing-and-probability-of-collision.html">博文</a>，原文讨论了更一般的哈希问题，值得一读。</p></blockquote><p>该方案固定一个<strong>素数</strong>模 <span class="math inline">\(p\)</span>（如 <span class="math inline">\(10^9+7\)</span> 或 <span class="math inline">\(4\cdot 10^9+7\)</span>），并从区间 <span class="math inline">\([0,p-1]\)</span> 上对 <span class="math inline">\(a\)</span> 做均匀随机。令随机变量 <span class="math inline">\(A\)</span> 表示所选的 <span class="math inline">\(a\)</span>。</p><p>对任意两条等长字符串 <span class="math inline">\((S,T)\)</span>，有如下计算：</p><p><span class="math display">\[\begin{aligned}h(S) &amp;= h(T)\\\Big(\sum_{i=0}^{n-1} A^{n-i-1} S_i\Big) \bmod p &amp;= \Big(\sum_{i=0}^{n-1} A^{n-i-1} T_i\Big) \bmod p\end{aligned}\]</span></p><p>于是：</p><p><span class="math display">\[\sum_{i=0}^{n-1} A^{n-i-1} S_i \equiv \sum_{i=0}^{n-1} A^{n-i-1} T_i \pmod p\]</span></p><p>令 <span class="math inline">\(P(A)\)</span> 为关于 <span class="math inline">\(A\)</span> 的次数不超过 <span class="math inline">\(n-1\)</span> 的多项式：</p><p><span class="math display">\[P(A) = \sum_{i=0}^{n-1} A^{n-i-1}(S_i - T_i) \equiv 0 \pmod p\]</span></p><p>当 <span class="math inline">\(S \ne T\)</span> 时，<span class="math inline">\(P\)</span> 是非零多项式。由上式可见：当且仅当 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(P(A)\)</span> 的根时，<span class="math inline">\(h(S) = h(T)\)</span>。</p><p>因为 <span class="math inline">\(p\)</span> 是素数，模 <span class="math inline">\(p\)</span> 的运算在域上进行。域上次数不超过 <span class="math inline">\(n-1\)</span> 的多项式至多有 <span class="math inline">\(n-1\)</span> 个根。因此，导致 <span class="math inline">\(h(S) = h(T)\)</span> 的 <span class="math inline">\(a\)</span> 的选择至多有 <span class="math inline">\(n-1\)</span> 个。于是：</p><p><span class="math display">\[\Pr[h(S)=h(T)] = \Pr[P(A)=0] \le \frac{n-1}{p}\]</span></p><p>也就是说，任意两条等长字符串发生等长碰撞的概率最多为 <span class="math inline">\(\frac{n-1}{p}\)</span>。当 <span class="math inline">\(n=10^5, p=10^9+7\)</span> 时，大约是 <span class="math inline">\(10^{-4}\)</span>。若取更大的素数（如 <span class="math inline">\(2^{31}-1\)</span> 或 <span class="math inline">\(4\cdot 10^9+7\)</span>）可稍有改善，但需注意溢出问题。</p><h3>界的紧致性</h3><p>目前该部分仅适用于 <span class="math inline">\(p-1\)</span> 为“平滑数”的素数，因此并不适用于 <span class="math inline">\(p=10^9+7\)</span> 等情形。若能给出可计算且适用一般情形的构造会更好。</p><p>当 <span class="math inline">\(n-1\mid p-1\)</span> 时，上述界 <span class="math inline">\(\frac{n-1}{p}\)</span> 是紧的。取 <span class="math inline">\(S=ba\dots a\)</span>、<span class="math inline">\(T=aa\dots b\)</span>，则有 <span class="math inline">\(P(A)=A^{n-1}-1\)</span>。</p><p>由于 <span class="math inline">\(p\)</span> 为素数，群 <span class="math inline">\(\mathbb{Z}/p\mathbb{Z}\)</span> 是阶为 <span class="math inline">\(p-1\)</span> 的循环群，因此存在一个阶为 <span class="math inline">\(n-1\)</span> 的子群 <span class="math inline">\(G\subseteq \mathbb{Z}/p\mathbb{Z}\)</span>。对任意 <span class="math inline">\(g\in G\)</span>，均有 <span class="math inline">\(g^{n-1}=1\)</span>，故 <span class="math inline">\(P(A)\)</span> 有 <span class="math inline">\(n-1\)</span> 个不同的根。</p><h3>随机化模数</h3><p>该方案固定一个基数 <span class="math inline">\(a\le |\Sigma|\)</span> 以及一个界 <span class="math inline">\(N&gt;a\)</span>，然后从区间 <span class="math inline">\([N,2N-1]\)</span> 上均匀随机选择一个<strong>素数</strong>模 <span class="math inline">\(p\)</span>。</p><p>同样对任意两条等长字符串 <span class="math inline">\((S,T)\)</span>，有：</p><p><span class="math display">\[\begin{aligned}h(S) &amp;= h(T)\\\Big(\sum_{i=0}^{n-1} a^{n-i-1} S_i\Big) \bmod p &amp;= \Big(\sum_{i=0}^{n-1} a^{n-i-1} T_i\Big) \bmod p\end{aligned}\]</span></p><p>因此：</p><p><span class="math display">\[\sum_{i=0}^{n-1} a^{n-i-1} S_i \equiv \sum_{i=0}^{n-1} a^{n-i-1} T_i \pmod p\]</span></p><p>令：</p><p><span class="math display">\[X = \sum_{i=0}^{n-1} a^{n-i-1}(S_i - T_i) \equiv 0 \pmod p\]</span></p><p>当 <span class="math inline">\(X \equiv 0 \pmod p\)</span> 即 <span class="math inline">\(p\mid X\)</span>。我们选择足够大的 <span class="math inline">\(a\)</span>，保证 <span class="math inline">\(X\ne 0\)</span>；且有 <span class="math inline">\(|X| &lt; a^n\)</span>。在区间 <span class="math inline">\([N,2N-1]\)</span> 中，<span class="math inline">\(X\)</span> 的不同素因子个数的上界约为 <span class="math inline">\(\log_N(|X|) = \frac{n\ln a}{\ln N}\)</span>。由素数分布定理，区间 <span class="math inline">\([N,2N-1]\)</span> 中约有 <span class="math inline">\(\frac{N}{\ln N}\)</span> 个素数。因此：</p><p><span class="math display">\[\Pr[h(S)=h(T)] = \Pr[p\mid X] \lesssim \frac{n\ln a}{N}\]</span></p><p>该界略逊于“随机化基数”的界。以 <span class="math inline">\(n=10^5, a=26, N=10^9\)</span> 为例，约为 <span class="math inline">\(3\cdot 10^{-4}\)</span>。</p><h3>如何正确随机化</h3><p>以下是初始化随机数生成器的较好方式：</p><ul><li><p>高精度时间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrono::<span class="built_in">duration_cast</span>&lt;chrono::nanoseconds&gt;(chrono::high_resolution_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">chrono::<span class="built_in">duration_cast</span>&lt;chrono::nanoseconds&gt;(chrono::steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br></pre></td></tr></table></figure><blockquote><p>二者皆可。（理论上 <code>high_resolution_clock</code> 更好，但在 Codeforces 上其精度竟低于 <code>steady_clock</code>？？）</p></blockquote></li><li><p>处理器周期计数器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_ia32_rdtsc();</span><br></pre></td></tr></table></figure></li><li><p>将某个堆地址转为整数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">uintptr_t</span>) <span class="built_in">make_unique</span>&lt;<span class="type">char</span>&gt;().<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure></li><li><p>处理器随机数（需 pragma 或 asm）（感谢 <a href="https://codeforces.com/profile/halyavin">halyavin</a> 的<a href="https://codeforces.com/blog/entry/60442?#comment-443083">建议</a>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pragma 版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC target (<span class="string">&quot;rdrnd&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">rdrand32</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> ret;</span><br><span class="line">    <span class="built_in">assert</span>(__builtin_ia32_rdrand32_step(&amp;ret));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// asm 版本</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> ret;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;rdrand %0&quot;</span> :<span class="string">&quot;=a&quot;</span>(ret) ::<span class="string">&quot;cc&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>若使用 C++11 风格 RNG（推荐），可将上述来源组合：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seed_seq seq&#123;</span><br><span class="line">    (<span class="type">uint64_t</span>) chrono::<span class="built_in">duration_cast</span>&lt;chrono::nanoseconds&gt;(chrono::high_resolution_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>(),</span><br><span class="line">    (<span class="type">uint64_t</span>) __builtin_ia32_rdtsc(),</span><br><span class="line">    (<span class="type">uint64_t</span>) (<span class="type">uintptr_t</span>) <span class="built_in">make_unique</span>&lt;<span class="type">char</span>&gt;().<span class="built_in">get</span>()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">mt19937 <span class="title">rng</span><span class="params">(seq)</span></span>;</span><br><span class="line"><span class="type">int</span> base = <span class="built_in">uniform_int_distribution</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, p<span class="number">-1</span>)(rng);</span><br></pre></td></tr></table></figure><p>注意：内部会丢弃参数的高 32 位，但影响不大；低位反而更难预测（尤其首项的 chrono）。</p><p>参见“滥用不良随机化”部分中的反例。</p><h3>扩展到多重哈希</h3><p>可以使用多个哈希（即便采用同一方案与相同固定参数），只要随机样本独立，各哈希相互独立。若单个哈希失败概率不超过 <span class="math inline">\(a_1,\dots,a_k\)</span>，则全部失败的概率不超过 <span class="math inline">\(\prod_{i=1}^k a_i\)</span>。</p><p>例如使用两重哈希，取 <span class="math inline">\(p=10^9+7\)</span> 并随机化基数，碰撞概率最多为 <span class="math inline">\(10^{-8}\)</span>；四重哈希则最多为 <span class="math inline">\(10^{-16}\)</span>。在此更大的素数常数项更显著；以 <span class="math inline">\(p=2^{31}-1\)</span> 为例，概率约为 <span class="math inline">\(2.1\cdot 10^{-9}\)</span> 与 <span class="math inline">\(4.7\cdot 10^{-18}\)</span>。</p><h3>更大的模数</h3><p>采用更大的（如 60 位）素数能降低碰撞概率，并避免误差界中关于 <span class="math inline">\(n\)</span> 的累积因子。但滚动哈希的计算会更慢、更复杂，因为 Codeforces 上无 <code>__int128</code>。</p><p>一个例外是梅森素数 <span class="math inline">\(p=2^{61}-1\)</span>；此时可用位操作来做模约简。（感谢 <a href="https://codeforces.com/profile/dmkz">dmkz</a> 的建议。）下述代码在无 <code>__int128</code> 的情况下计算 $a\cdot b \bmod p`，仅比 30 位取模哈希慢约 5%。参数需满足 <span class="math inline">\(0\le a,b&lt;mod\)</span>，返回值也满足该条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">uint64_t</span> mod = (<span class="number">1ull</span>&lt;&lt;<span class="number">61</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">modmul</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> l1 = (<span class="type">uint32_t</span>)a, h1 = a&gt;&gt;<span class="number">32</span>, l2 = (<span class="type">uint32_t</span>)b, h2 = b&gt;&gt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">uint64_t</span> l = l1*l2, m = l1*h2 + l2*h1, h = h1*h2;</span><br><span class="line">    <span class="type">uint64_t</span> ret = (l&amp;mod) + (l&gt;&gt;<span class="number">61</span>) + (h &lt;&lt; <span class="number">3</span>) + (m &gt;&gt; <span class="number">29</span>) + (m &lt;&lt; <span class="number">35</span> &gt;&gt; <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    ret = (ret &amp; mod) + (ret&gt;&gt;<span class="number">61</span>);</span><br><span class="line">    ret = (ret &amp; mod) + (ret&gt;&gt;<span class="number">61</span>);</span><br><span class="line">    <span class="keyword">return</span> ret<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用无符号类型并取 <span class="math inline">\(p=4\cdot 10^9+7\)</span> 可略有增益。</p><p>注意：<span class="math inline">\(p=2^{64}\)</span>（<code>unsigned long long</code> 溢出）并非素数，即便做随机化也可被攻击（见下文）。</p><h3>扩展到多次比较</h3><p>滚动哈希通常用于不止一次的比较。若我们依赖 <span class="math inline">\(m\)</span> 次比较且单次失败概率为 <span class="math inline">\(p\)</span>，则任一失败的概率至多为 <span class="math inline">\(m\cdot p\)</span>（并用联合界）。当 <span class="math inline">\(m=10^5\)</span> 时，通常需要两到三个哈希使该概率足够小。</p><p>估计所需比较次数时要格外谨慎。若我们对哈希排序或放入集合，需要两两不相同；于是对 <span class="math inline">\(n\)</span> 条字符串共有 <span class="math inline">\(\binom{n}{2}\)</span> 次比较需成功。以 <span class="math inline">\(n=3\cdot 10^5\)</span> 为例，<span class="math inline">\(m\approx 4.5\cdot 10^9\)</span>，因此需要三到四重哈希（若采用 <span class="math inline">\(p=2^{61}-1\)</span>，两重即可）。</p><h3>扩展到不同长度的字符串</h3><p>若处理不同长度的字符串，可以在哈希中同时存储长度以避免比较。不过在假设<strong>无字符哈希为 0</strong> 的前提下，这并非必要。此时可以把较短字符串视作在前缀补齐若干空字节，使其与较长者等长，同时不改变哈希值；于是上述理论仍适用。（若存在某字符（如 <code>a</code>）哈希为 0，则补齐过程可能将原本不同的字符串映射为看上去相同的形式，例如 <code>a</code> 与 <code>aa</code>。）</p><h2>计算反哈希测试</h2><p>本节介绍若干利用滚动哈希实现中常见错误的技巧，主要用于攻击其他方案。下表给出方法的简要概览。</p><table><thead><tr class="header"><th style="text-align: center;">名称</th><th style="text-align: center;">用例</th><th style="text-align: center;">运行时间</th><th style="text-align: center;">字符串长度</th><th style="text-align: center;">备注</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Thue–Morse</td><td style="text-align: center;">带溢出的哈希</td><td style="text-align: center;"><span class="math inline">\(O(1)\)</span></td><td style="text-align: center;"><span class="math inline">\(2^{10}\)</span></td><td style="text-align: center;">可同时适用于所有基数（任意 <span class="math inline">\(a\)</span>）。</td></tr><tr class="even"><td style="text-align: center;">生日攻击</td><td style="text-align: center;">小模数</td><td style="text-align: center;"><span class="math inline">\(O(\sqrt{p}\log p)\)</span></td><td style="text-align: center;"><span class="math inline">\(\approx 2\log_{|\Sigma|}p\)</span></td><td style="text-align: center;">可同时找出多个碰撞。</td></tr><tr class="odd"><td style="text-align: center;">树攻击</td><td style="text-align: center;">大模数</td><td style="text-align: center;"><span class="math inline">\(O(2^{\sqrt{p\lg p}})\)</span></td><td style="text-align: center;"><span class="math inline">\(O(2^{\sqrt{p\lg p}}+1)\)</span></td><td style="text-align: center;">更快；字符串更长</td></tr><tr class="even"><td style="text-align: center;">多树攻击</td><td style="text-align: center;">大模数</td><td style="text-align: center;"><span class="math inline">\(O((2^{\sqrt{2\lg m\,p}}+\log_{|\Sigma|}m)\,m\log m)\)</span></td><td style="text-align: center;"><span class="math inline">\(\approx O(2^{\sqrt{2\lg m\,p}}+\log_{|\Sigma|}m)\)</span></td><td style="text-align: center;">更慢；字符串更短</td></tr><tr class="odd"><td style="text-align: center;">格子约减</td><td style="text-align: center;">中大型字母表，多哈希</td><td style="text-align: center;"><span class="math inline">\(O(\text{length}^3)\)</span></td><td style="text-align: center;"><span class="math inline">\(\approx \sum_{i=0}^{n-1}\log_{|\Sigma|}(p_i)\)</span></td><td style="text-align: center;"><span class="math inline">\(| \Sigma | =26\)</span> 时效果佳；对二进制较差；对多重哈希有效。</td></tr><tr class="even"><td style="text-align: center;">组合</td><td style="text-align: center;">多重哈希</td><td style="text-align: center;">单个方法运行时间之和</td><td style="text-align: center;">单个字符串长度的乘积</td><td style="text-align: center;">组合两种攻击。</td></tr></tbody></table><h3>单重哈希</h3><h4>Thue–Morse 序列：无符号溢出哈希（<span class="math inline">\(p=2^{64}\)</span>，<span class="math inline">\(a\)</span> 任意）</h4><p>一种对任意基数均有效的反哈希测试是 Thue–Morse 序列，生成代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Q = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1</span> &lt;&lt; Q;</span><br><span class="line"><span class="function">std::string <span class="title">S</span><span class="params">(N, <span class="string">&#x27; &#x27;</span>)</span>, <span class="title">T</span><span class="params">(N, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    S[i] = <span class="string">&#x27;A&#x27;</span> + __builtin_popcount(i) % <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    T[i] = <span class="string">&#x27;B&#x27;</span> - __builtin_popcount(i) % <span class="number">2</span>; </span><br></pre></td></tr></table></figure><p><span class="math inline">\(S\)</span> 与 <span class="math inline">\(T\)</span> 构成等长碰撞，无论选择何种基数。</p><p>详见这篇<a href="https://codeforces.com/blog/entry/4898">博文</a>。其中的界还可略微改进，因为对奇数 <span class="math inline">\(X\)</span>，<span class="math inline">\(X^2-1\)</span> 总能被 8 整除（因此可取 <span class="math inline">\(Q=10\)</span> 而非 <span class="math inline">\(Q=11\)</span>）。</p><h4>生日攻击：32 位素数、固定基数（<span class="math inline">\(p&lt;2^{32}\)</span> 固定，<span class="math inline">\(a\)</span> 固定）</h4><p>对仅用一个小素数的哈希可用生日悖论攻击。固定长度 <span class="math inline">\(l\)</span> 与字母表大小 <span class="math inline">\(d\)</span>，在长度为 <span class="math inline">\(l\)</span> 的字符串集合中均匀随机选取 <span class="math inline">\(k\)</span> 条字符串。若 <span class="math inline">\(l\)</span> 不过小，其哈希值近似均匀分布。由生日悖论，所选 <span class="math inline">\(k\)</span> 条字符串的哈希值两两不同的概率为：</p><p><span class="math display">\[\prod_{i=0}^{k-1}\Big(1-\frac{i}{d}\Big) &lt; \prod_{i=0}^{k-1} e^{-\frac{i}{d}} = e^{-\frac{k(k-1)}{2d}} &lt; e^{-\ln 2} = \frac{1}{2}\]</span></p><p>因此，以大于 <span class="math inline">\(\tfrac12\)</span> 的概率，能找到两条字符串的哈希相同。重复上述过程，在 <span class="math inline">\(O(\sqrt{p})\)</span> 时间内即可高概率找到等长碰撞。实际中得到的字符串可相当短（例如当 <span class="math inline">\(p=10^9+7\)</span>、<span class="math inline">\(d=62\)</span> 时长度约为 6；尚不明确如何严格上界）。</p><p>更一般地，利用类似技巧可在 <span class="math inline">\(O(m\,p^{1-1/m})\)</span> 时间内找到 <span class="math inline">\(m\)</span> 条哈希相同的字符串，取样次数 <span class="math inline">\(r=m\,p^{1-1/m}\)</span>。</p><h4>树攻击：较大素数、固定基数（<span class="math inline">\(p\)</span> 固定，<span class="math inline">\(a\)</span> 固定）</h4><blockquote><p>感谢 <a href="https://codeforces.com/profile/Kaban-5">Kaban-5</a> 与 <a href="https://codeforces.com/profile/pavel.savchenkov">pavel.savchenkov</a> 提供的<a href="https://codeforces.com/blog/entry/17507?locale=ru#comment-223614">链接</a>（俄语评论，描述了此思路）。</p></blockquote><p>当素数较大时，生日攻击过慢。回忆两条等长字符串 <span class="math inline">\((S,T)\)</span>：</p><p><span class="math display">\[h(S) = h(T)\]</span></p><p><span class="math display">\[\sum_{i=0}^{n-1} a^{n-i-1}(S_i - T_i) \equiv 0 \pmod p\]</span></p><p>令 <span class="math inline">\(\alpha_i = S_i - T_i\)</span>，则 <span class="math inline">\(-|\Sigma| \le \alpha_i \le |\Sigma|\)</span>。树攻击尝试寻找 <span class="math inline">\(\alpha_i\in\{-1,0,1\}\)</span> 使得：</p><p><span class="math display">\[\sum_{i=0}^{n-1} (a^{n-i-1} \bmod p)\cdot \alpha_i = 0\]</span></p><p>算法维护若干系数簇 <span class="math inline">\(C_1,\dots,C_k\)</span>。某簇 <span class="math inline">\(C\)</span> 的<strong>和</strong>定义为：</p><p><span class="math display">\[S(C) = \sum_{i\in C} (a^{n-i-1} \bmod p)\cdot \alpha_i\]</span></p><p>可将两簇 <span class="math inline">\(C_1,C_2\)</span> 合并为新簇 <span class="math inline">\(C_3\)</span>，其和为 <span class="math inline">\(S(C_1)-S(C_2)\)</span>：做法是将 <span class="math inline">\(C_2\)</span> 中所有 <span class="math inline">\(\alpha_i\)</span> 乘以 <span class="math inline">\(-1\)</span> 并合并两簇的系数集合。实现上可用二叉树存簇，每个结点存其总和；合并即创建新结点，其子为 <span class="math inline">\(C_1,C_2\)</span>，和为 <span class="math inline">\(S(C_1)-S(C_2)\)</span>。为保证 <span class="math inline">\(S(C_3)\ge 0\)</span>，必要时交换 <span class="math inline">\(C_1,C_2\)</span>。<span class="math inline">\(\alpha_i\)</span> 的取值不显式存储，最终可通过树回溯得到。</p><p>初始化时取 <span class="math inline">\(n=2k\)</span>，每个 <span class="math inline">\(\alpha_i=1\)</span> 独自形成一簇。每一轮先按簇和排序，再两两相邻合并。若在某处出现和为 0 的簇，则令不在该簇中的所有 <span class="math inline">\(\alpha_j=0\)</span> 并结束。若 <span class="math inline">\(k\)</span> 轮后仍未结束，则取更大的 <span class="math inline">\(k\)</span> 重试。</p><p>取何值的 <span class="math inline">\(k\)</span> 可期望成功？若假设初始的簇和在 <span class="math inline">\([0,p-1]\)</span> 上均匀分布，则第 <span class="math inline">\(i\)</span> 轮后最大簇和应约按因子 <span class="math inline">\(\sim 2^{k-i}\)</span> 下降。<span class="math inline">\(k\)</span> 轮后最大和约为 <span class="math inline">\(\frac{p}{2^{\binom{k}{2}}}\)</span>，故取 <span class="math inline">\(k\approx \sqrt{2\lg p}+1\)</span> 可行。对应字符串长度为 <span class="math inline">\(n=2^{\sqrt{2\lg p}+1}\)</span>，时间 <span class="math inline">\(O(n)\)</span>。（更形式化的分析可见论文《Solving Medium-Density Subset Sum Problems in Expected Polynomial Time》2.2 节。问题与算法略有差异，但思路相近。）</p><h5>多树攻击</h5><p>树攻击很快，但得到的字符串可能较长（如 <span class="math inline">\(p=2^{61}-1\)</span> 时 <span class="math inline">\(n=2048\)</span>）。若希望更短的碰撞，可增加运行时间：在每个簇中维护能得到的最小 <span class="math inline">\(m\)</span> 个和（单树攻击相当于 <span class="math inline">\(m=1\)</span>）。合并两簇可用最小堆与 <span class="math inline">\(2m\)</span> 指针遍历在 <span class="math inline">\(O(m\log m)\)</span> 内完成。为尽快得到 <span class="math inline">\(m\)</span> 条字符串，允许 <span class="math inline">\(\alpha_i\in[-|\Sigma|,|\Sigma|]\)</span>，并排除所有 <span class="math inline">\(\alpha_i\)</span> 为 0 的平凡情形。</p><p>分析其期望 <span class="math inline">\(k\)</span> 较难。乐观地假设：在 <span class="math inline">\(\log_{|\Sigma|} m\)</span> 步后每结点都能得到 <span class="math inline">\(m\)</span> 个和；和的下降与单树攻击一致；当和小于 <span class="math inline">\(m^2\)</span> 时由生日悖论可期望出现碰撞；则有</p><p><span class="math display">\[k = \sqrt{\frac{2\lg p}{\lg m}} + \log_{|\Sigma|} m.\]</span></p><p>（更现实的界为 <span class="math inline">\(k = \frac{\lg p}{\lg m} + \log_{|\Sigma|} m\)</span>，可参考论文《On Random High Density Subset Sums》定理 3.1 中的推导。）</p><p>实践中，取 <span class="math inline">\(m\approx 10^5\)</span>、<span class="math inline">\(|\Sigma|=2\)</span>、<span class="math inline">\(p=2^{61}-1\)</span>，能在约 0.4 秒内找到长度 128 的碰撞。</p><h4>格子约减攻击：不太小的字母表下的单/多重哈希</h4><blockquote><p>感谢 <a href="https://codeforces.com/profile/hellman_">hellman_</a> 的提示，可参考他的写作；另有他人写作见<a href="https://galhacktictrendsetters.wordpress.com/2017/09/05/tokyo-westerns-ctf-2017-palindromes-pairs-challenge-phase/">此处</a>。</p></blockquote><p>与树攻击类似，我们寻找满足：</p><p><span class="math display">\[\sum_{i=0}^{n-1} (a^{n-i-1} \bmod p)\cdot \alpha_i = 0\]</span></p><p>且 <span class="math inline">\(\alpha_i\in[-|\Sigma|,|\Sigma|]\)</span> 的向量。考虑集合：</p><p><span class="math display">\[\{\alpha_0,\dots,\alpha_{n-1},\beta\}\quad\text{其中}\quad \beta \equiv \sum_{i=0}^{n-1} (a^{n-i-1} \bmod p)\cdot \alpha_i\]</span></p><p>这形成一个格（嵌入到 <span class="math inline">\(\mathbb{R}^n\)</span> 子空间的自由 <span class="math inline">\(\mathbb{Z}\)</span> 模）。我们要在格中找一个元素，使得 <span class="math inline">\(\beta=0\)</span> 且 <span class="math inline">\(|\alpha_i|\le |\Sigma|\)</span>。可通过惩罚非零 <span class="math inline">\(\beta\)</span> 来实现：</p><p><span class="math display">\[\beta = 10^5\cdot \Big(\sum_{i=0}^{n-1} (a^{n-i-1} \bmod p)\cdot \alpha_i\Big) \bmod p\]</span></p><p>随后目标转为最小化 <span class="math inline">\(\max\{|\alpha_0|,\dots,|\alpha_{n-1}|,|\beta|\}\)</span>。这一优化问题很难，于是改为最小化二范数：</p><p><span class="math display">\[\alpha_0^2 + \cdots + \alpha_{n-1}^2 + \beta^2.\]</span></p><p>该问题仍然困难，可能为 NP 完全，但存在较好的近似算法。</p><p>与向量空间类似，格中也可定义基。对本问题，一组基为：</p><p><span class="math display">\[\{\,e_\beta + 10^5(a^{n-i-1} \bmod p)\,e_{\alpha_i} \mid 0\le i&lt;n\,\} \cup \{\,p\cdot 10^5\,e_\beta\,\}.\]</span></p><p>格约减算法以该基为输入，利用行列式为 <span class="math inline">\(\pm 1\)</span> 的可逆整矩阵，将其转化为“近似最短向量”的另一组基。自行实现较难（会受精度或大整数性能影响），因此使用 Sage 的内置实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Anti-rolling-hash test generation by lattice reduction</span></span><br><span class="line"><span class="string">original code by Hellman_, modified by dacin21</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">anti_hash</span>(<span class="params">PAs, string_length, sigma, block_size = <span class="number">0</span>, MULTIPLIER = <span class="number">100000</span>, sigma_base = <span class="built_in">ord</span>(<span class="params"><span class="string">&#x27;a&#x27;</span></span>)</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(PAs)</span><br><span class="line">    N = string_length</span><br><span class="line">    As = [a <span class="keyword">for</span> p, a <span class="keyword">in</span> PAs]</span><br><span class="line">    Ps = [p <span class="keyword">for</span> p, a <span class="keyword">in</span> PAs]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;polynomial hash modulo &lt;n&gt; primes&quot;&quot;&quot;</span></span><br><span class="line">        v = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            v = [(x * q + <span class="built_in">ord</span>(c))%p <span class="keyword">for</span> x, q, p <span class="keyword">in</span> <span class="built_in">zip</span>(v, As, Ps)]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tuple</span>(v % p <span class="keyword">for</span> v, p <span class="keyword">in</span> <span class="built_in">zip</span>(v, Ps))</span><br><span class="line"></span><br><span class="line">    mv = matrix(ZZ, N, N)</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> xrange(N):</span><br><span class="line">        <span class="keyword">for</span> x, q, p <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(n), As, Ps):</span><br><span class="line">            mv[y,x] = <span class="built_in">pow</span>(q, N-y-<span class="number">1</span>, p);</span><br><span class="line"></span><br><span class="line">    m = matrix(ZZ, N + n, N + n)</span><br><span class="line">    <span class="comment"># submatrix with terms</span></span><br><span class="line">    m.set_block(<span class="number">0</span>, <span class="number">0</span>, MULTIPLIER * mv)</span><br><span class="line">    <span class="comment"># modulo reductions</span></span><br><span class="line">    m.set_block(N, <span class="number">0</span>, MULTIPLIER * diagonal_matrix(Ps))</span><br><span class="line">    <span class="comment"># term coefficients</span></span><br><span class="line">    m.set_block(<span class="number">0</span>, n, identity_matrix(N))</span><br><span class="line">    <span class="comment"># 4th submatrix is zero</span></span><br><span class="line"></span><br><span class="line">    m_reduced = m.LLL()</span><br><span class="line">    <span class="keyword">if</span> block_size &gt; <span class="number">0</span>:</span><br><span class="line">        m_reduced = m_reduced.BKZ(block_size = block_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> m_reduced:</span><br><span class="line">        <span class="built_in">print</span> row[:n], <span class="built_in">min</span>(row[n:]), <span class="string">&quot;~&quot;</span>, <span class="built_in">max</span>(row[n:])</span><br><span class="line">        delta = <span class="built_in">max</span>(<span class="built_in">abs</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> row[n:])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">set</span>(row[:n]) == &#123;<span class="number">0</span>&#125; <span class="keyword">and</span> delta &lt; sigma:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;Found collision!&quot;</span></span><br><span class="line">            s = [<span class="literal">None</span>] * N</span><br><span class="line">            t = [<span class="literal">None</span>] * N</span><br><span class="line">            <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(row[n:]):</span><br><span class="line">                a = sigma_base</span><br><span class="line">                b = a + <span class="built_in">abs</span>(v)</span><br><span class="line">                <span class="keyword">if</span> v &gt; <span class="number">0</span>:</span><br><span class="line">                    a, b = b, a</span><br><span class="line">                s[i] = a</span><br><span class="line">                t[i] = b</span><br><span class="line">            s = <span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, s))</span><br><span class="line">            t = <span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, t))</span><br><span class="line">            <span class="built_in">print</span> s + <span class="string">&quot; &quot;</span> + t</span><br><span class="line">            <span class="comment"># print h(s)</span></span><br><span class="line">            <span class="comment"># print h(t)</span></span><br><span class="line">            <span class="keyword">assert</span> h(s) == h(t)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Failed to find collision, try a larger string_length&quot;</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;For lengths &gt; 30, setting block_size to 10 or 15 is recommended&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;hash.in&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> infile:</span><br><span class="line">        n, k, sigma = <span class="built_in">map</span>(<span class="built_in">int</span>, infile.readline().strip().split())</span><br><span class="line">        PAs = [<span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, infile.readline().strip().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        anti_hash(PAs, k, sigma)</span><br></pre></td></tr></table></figure><p>程序从名为 <code>hash.in</code> 的文件读取输入；如需使用 BKZ 算法，设置 <code>block_size</code> 参数。</p><p>输入格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n length sigma</span><br><span class="line">p_1 a_1</span><br><span class="line">...</span><br><span class="line">p_n a_n</span><br></pre></td></tr></table></figure><p>Sage 提供两种算法：LLL 与 BKZ。LLL 更快但近似更差，尤其在较长字符串时。分析不易，故做了一些实验：固定 <span class="math inline">\(|\Sigma|=26\)</span>、<span class="math inline">\(p=2^{61}-1\)</span>，随机取 <span class="math inline">\(a_1,\dots,a_n\)</span>，分别用两种算法搜索短的反哈希测试，效果非常好。</p><p>LLL 算法：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n\)</span></th><th style="text-align: center;">最小长度</th><th style="text-align: center;">用时（秒）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">12</td><td style="text-align: center;">0.02</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">23</td><td style="text-align: center;">0.04</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">34</td><td style="text-align: center;">0.08</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">48</td><td style="text-align: center;">0.18</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">60</td><td style="text-align: center;">0.34</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">77</td><td style="text-align: center;">0.75</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">301</td><td style="text-align: center;">5.14</td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: center;">&gt;1500</td><td style="text-align: center;">&gt;990</td></tr></tbody></table><p>当 <span class="math inline">\(n=8\)</span> 时未能找到长度 <span class="math inline">\(\le 1500\)</span> 的碰撞。</p><p>BKZ 算法（<code>block_size=10</code>）：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n\)</span></th><th style="text-align: center;">最小长度</th><th style="text-align: center;">用时（秒）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">12</td><td style="text-align: center;">0.02</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">23</td><td style="text-align: center;">0.04</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">33</td><td style="text-align: center;">0.09</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">45</td><td style="text-align: center;">0.21</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">57</td><td style="text-align: center;">0.58</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">72</td><td style="text-align: center;">1.12</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">88</td><td style="text-align: center;">2.59</td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: center;">108</td><td style="text-align: center;">5.33</td></tr></tbody></table><p>BKZ 算法（<code>block_size=15</code>）：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n\)</span></th><th style="text-align: center;">最小长度</th><th style="text-align: center;">用时（秒）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">12</td><td style="text-align: center;">0.02</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">23</td><td style="text-align: center;">0.04</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">33</td><td style="text-align: center;">0.09</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">45</td><td style="text-align: center;">0.21</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">57</td><td style="text-align: center;">0.52</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">70</td><td style="text-align: center;">1.24</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">85</td><td style="text-align: center;">2.41</td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: center;">102</td><td style="text-align: center;">5.20</td></tr></tbody></table><p>BKZ 算法（<code>block_size=25</code>）：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n\)</span></th><th style="text-align: center;">最小长度</th><th style="text-align: center;">用时（秒）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">12</td><td style="text-align: center;">0.02</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">23</td><td style="text-align: center;">0.04</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">33</td><td style="text-align: center;">0.10</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">46</td><td style="text-align: center;">0.58</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">57</td><td style="text-align: center;">1.14</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">70</td><td style="text-align: center;">3.67</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">84</td><td style="text-align: center;">6.96</td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: center;">96</td><td style="text-align: center;">26.70</td></tr></tbody></table><p>注意：当 <span class="math inline">\(n&gt;1\)</span> 且字母表很小（如二进制）时，此攻击效果不佳；另外字符需<strong>映射到连续值</strong>，因此在组合攻击中应优先使用该方法。</p><h3>组合攻击：多重哈希</h3><blockquote><p>本思路归功于 <a href="https://codeforces.com/profile/ifsmirnov">ifsmirnov</a>，其 <a href="https://github.com/ifsmirnov/jngen">jngen</a> 库中使用了该技巧。</p></blockquote><p>使用两个或更多哈希通常可抵御直接的生日攻击。对两个素数而言，可能的哈希数为 <span class="math inline">\(N=p_1p_2\)</span>。生日攻击的复杂度为 <span class="math inline">\(O(\sqrt{N})\)</span>，当素数约为 <span class="math inline">\(10^9\)</span> 时，<span class="math inline">\(\sqrt{N}\approx 10^{10}\)</span>。此外，若仅存储哈希与 RNG 种子，内存至少为 <span class="math inline">\(\sqrt{(2\ln 2)N}\cdot 8\)</span> 字节，约 9.5 GB。</p><p>破解多重哈希的关键在于逐个突破：</p><ul><li>先对第一个哈希 <span class="math inline">\(h_1\)</span> 做生日攻击，找到等长碰撞，即 <span class="math inline">\(S\ne T\)</span>、<span class="math inline">\(h_1(S)=h_1(T)\)</span>。注意：在字母表 <span class="math inline">\(\{S,T\}\)</span> 上构造的等长字符串（例如将若干个 <span class="math inline">\(S\)</span> 与若干个 <span class="math inline">\(T\)</span> 拼接）在 <span class="math inline">\(h_1\)</span> 下仍会哈希到相同值。</li><li>然后以 <span class="math inline">\(\{S,T\}\)</span> 作为字母表，对第二个哈希 <span class="math inline">\(h_2\)</span> 做生日攻击，寻找新的等长碰撞。因为使用的是 <span class="math inline">\(\{S,T\}\)</span>，得到的碰撞自动也是 <span class="math inline">\(h_1\)</span> 的碰撞。</li></ul><p>这样总体复杂度降为 <span class="math inline">\(O(\sqrt{p_1}+\sqrt{p_2})\)</span>。该策略也适用于“30 位素数哈希 + 模 <span class="math inline">\(2^{64}\)</span> 哈希”的组合：第二步可用 Thue–Morse 序列替代生日攻击。对更大的模数也可将第二步替换为树攻击。</p><p>需要注意的是，字符串长度会随哈希的个数迅速增长（大致为 <span class="math inline">\(2\log_{|\Sigma|}\!\big(\sqrt{(2\ln 2)p_1}\big)\cdot \log_2\!\big(\sqrt{(2\ln 2)p_2}\big)\cdots \log_2\!\big(\sqrt{(2\ln 2)p_k}\big)\)</span>；第一次生日攻击后字母表缩至 2，实操中首轮常有额外的因子 2）。若在中间步骤搜索多于 2 条哈希相同的字符串，字母表更大、字符串更短，但生日攻击的时间也更长（例如对 3 条字符串，复杂度为 <span class="math inline">\(O(p^{2/3})\)</span>）。</p><h2>滥用不良随机化</h2><p>在 Codeforces 上，许多人会对哈希做随机化。（不幸的是）不少人采用了次优的方式。本节覆盖一些常见的随机化误用以及相应的攻击手段。</p><p>其适用范围更广：任何参与者可攻击你方案的环境下，随机化算法都可能遭遇类似问题。</p><h3>固定种子</h3><p>若 RNG 种子固定，生成的随机数序列也固定。你只需运行其代码查看生成了哪些“随机数”，再针对这些数构造反哈希测试即可。</p><h3>从小集合中取基数（如 <code>rand()%100</code>）</h3><p><code>rand()%100</code> 至多生成 100 种取值（0 到 99）。可以为每个可能的基数分别构造反哈希测试，再按题目场景组合这些测试（组合方式依题而异，但多数问题可行）。</p><h3><code>rand()</code> 的更多问题</h3><p>在 Codeforces 上，<code>rand()</code> 仅生成 15 位的值，最多 <span class="math inline">\(2^{15}\)</span> 种取值。虽然运行 <span class="math inline">\(2^{15}\)</span> 次生日攻击需要时间（以我的笔记本单线程估计，针对 <span class="math inline">\(p=10^9+7\)</span> 约需 111 分钟），但这会给其他随机化算法带来麻烦。</p><p>补充：若使用多树攻击，上述黑箱可能可行。以 <span class="math inline">\(p=10^9+7, |\Sigma|=26\)</span> 为例，运行 <span class="math inline">\(2^{15}\)</span> 次、取 <span class="math inline">\(m=10^4\)</span> 的多树攻击约需 2 分钟，输出约 <span class="math inline">\(5.2\cdot 10^5\)</span> 个字符。对多数题目仍稍大，但在开放黑客阶段可拆分为多次攻击。</p><p>在 C++11 中，建议使用 <code>mt19937</code> 与 <code>uniform_int_distribution</code> 替代 <code>rand()</code>。</p><h3>低精度时间（<code>Time(NULL)</code>）</h3><p><code>Time(NULL)</code> 每秒仅变化一次。可按如下步骤利用之：</p><ol type="1"><li>选定时间跨度 <span class="math inline">\(\Delta T\)</span>。</li><li>估计生成你的测试所需时间的上界 <span class="math inline">\(T\)</span>。</li><li>通过自定义运行获取当前 <code>Time(NULL)</code> 的值 <span class="math inline">\(T_0\)</span>。</li><li>对 <span class="math inline">\(t=0,\dots,\Delta T-1\)</span>，用 <span class="math inline">\(T_0+T+t\)</span> 替代 <code>Time(NULL)</code> 并针对该固定种子生成反测试。</li><li>在时间 <span class="math inline">\(T_0+T\)</span> 提交攻击。</li></ol><p>若你的攻击在接下来的 <span class="math inline">\(\Delta T\)</span> 秒内执行，则 <code>Time(NULL)</code> 会取到你已覆盖的值，于是目标方案失败。</p><h3>MinGW 上的 <code>std::random_device</code></h3><p>在 Codeforces 的 MinGW 环境中，<code>std::random_device</code> 是确定性的，会生成相同的数列。使用它的方案可像固定种子的方案一样被攻击。</p><blockquote><p>本文选自 <a href="https://codeforces.com/blog/entry/60442">Anti-rolling-hash test generation by lattice reduction</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>splay</title>
      <link href="/posts/79d6ca4/"/>
      <url>/posts/79d6ca4/</url>
      
        <content type="html"><![CDATA[<h2>前言</h2><p>总所周知，平衡树是一个喜闻乐见的算法，它种类多样，功能强大，应用广泛。</p><h2>介绍</h2><p>Splay 树（伸展树），是一种平衡二叉查找树，它通过 <strong>Splay/伸展操作</strong> 不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，能够在<strong>均摊</strong> <span class="math inline">\(O(\log N)\)</span> 时间内完成 <strong>插入</strong>，<strong>查找</strong> 和 <strong>删除</strong> 操作，并且保持平衡而不至于退化为链。</p><p>Splay 树由 Daniel Sleator 和 Robert Tarjan 于 1985 年发明。</p><p>Splay 树的 <strong>基本思想</strong> 是：每次操作都将某节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质。</p><h2>操作</h2><h3>记号规定</h3><ul><li><span class="math inline">\(rt\)</span>：根节点</li><li><span class="math inline">\(tot\)</span>：树的总节点数</li><li><span class="math inline">\(fa_i\)</span>：节点 <span class="math inline">\(i\)</span> 的父节点</li><li><span class="math inline">\(ch_{i,0}\)</span>：节点 <span class="math inline">\(i\)</span> 的左孩子</li><li><span class="math inline">\(ch_{i,1}\)</span>：节点 <span class="math inline">\(i\)</span> 的右孩子</li><li><span class="math inline">\(val_i\)</span>：节点 <span class="math inline">\(i\)</span> 的值</li><li><span class="math inline">\(cnt_i\)</span>：值 <span class="math inline">\(i\)</span> 出现的次数</li><li><span class="math inline">\(sz_i\)</span>：以节点 <span class="math inline">\(i\)</span> 为根的子树的权值个数（包括重复权值）</li></ul><h3>基本操作</h3><ul><li><code>pushup(x)</code> ：更新节点的 <span class="math inline">\(sz\)</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; sz[x] = sz[son[x][<span class="number">0</span>]] + sz[son[x][<span class="number">1</span>]] + cnt[x]; &#125;</span><br></pre></td></tr></table></figure><ul><li><code>getson(x)</code> ：判断 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(fa_x\)</span> 的左儿子还是右儿子</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getson</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == son[fa[x]][<span class="number">1</span>]; &#125;</span><br></pre></td></tr></table></figure><ul><li><code>clear(x)</code> ：销毁节点 <span class="math inline">\(x\)</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; son[x][<span class="number">0</span>] = son[x][<span class="number">1</span>] = fa[x] = val[x] = cnt[x] = sz[x] = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><h3>旋转</h3><p>还记得 Splay 的基本思想吗：</p><blockquote><p>每次操作都将某节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质。</p></blockquote><p>因此旋转操作的本质为将某个节点上升一个位置。</p><p>因为 Splay 树是一颗二叉查找树，所以旋转需要保证 <strong>Splay 树的中序遍历不变</strong>。</p><p>在 Splay 中，旋转分为两种：<strong>左旋</strong> 和 <strong>右旋</strong>。</p><p>这里我们以右旋为例，详细讲解：</p><p>现在有一个节点 <span class="math inline">\(x\)</span>，有他的父节点 <span class="math inline">\(fx\)</span> 和爷爷节点 <span class="math inline">\(gx\)</span>（<span class="math inline">\(fa_{fa_x}\)</span>）。</p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_1.png" /></p><ol type="1"><li><p>将 <span class="math inline">\(x\)</span> 的 <strong>右儿子</strong> 设为 <span class="math inline">\(fx\)</span> 的 <strong>左儿子</strong>，并将它的父亲设为 <span class="math inline">\(fx\)</span>。</p><p><code>son[fx][0]=son[x][1],fa[son[x][1]] = fx;</code></p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_2.png" /></p></li><li><p>将 <span class="math inline">\(fx\)</span> 设为 <span class="math inline">\(x\)</span> 的 <strong>右儿子</strong>，并将它的父亲设为 <span class="math inline">\(x\)</span>。</p><p><code>son[x][1]=fx,fa[fx]=x;</code></p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_3.png" /></p></li><li><p>将 <span class="math inline">\(x\)</span> 设为 <span class="math inline">\(gx\)</span> 的 <strong>左儿子</strong>，并将它的父亲设为 <span class="math inline">\(gx\)</span>。</p><p><code>son[gx][1]=x,fa[x]=gx;</code></p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_4.png" /></p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fx = fa[x], gx = fa[fx];</span><br><span class="line">        <span class="type">bool</span> ch = <span class="built_in">getson</span>(x);</span><br><span class="line">        son[fx][ch] = son[x][ch ^ <span class="number">1</span>], fa[son[x][ch ^ <span class="number">1</span>]] = fx;</span><br><span class="line">        son[gx][<span class="built_in">getson</span>(fx)] = x, fa[x] = gx;</span><br><span class="line">        son[x][ch ^ <span class="number">1</span>] = fx, fa[fx] = x;</span><br><span class="line">        <span class="built_in">pushup</span>(fx), <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3>Splay/伸展操作</h3><p>Splay/伸展操作是 Splay 树的核心操作，它通过旋转操作将某节点旋转到根节点，并将其上升到树的最高层，使得整棵树仍然满足二叉查找树的性质。</p><p>同时，Splay 操作规定：每访问一个节点 <span class="math inline">\(x\)</span> 后都要强制将其旋转到根节点。</p><p>Splay 操作大体可以分为三种，一共六种情况。</p><p>规定记号：</p><ul><li><span class="math inline">\(x\)</span>：待旋转节点</li><li><span class="math inline">\(fx\)</span>：<span class="math inline">\(x\)</span> 的父节点</li><li><span class="math inline">\(gx\)</span>：<span class="math inline">\(fx\)</span> 的父节点</li></ul><ol type="1"><li><p><strong>zig</strong>：当 <span class="math inline">\(fx\)</span> 为根节点时操作，直接将 <span class="math inline">\(x\)</span> 左旋/右旋到根节点。</p></li><li><p><strong>zig-zig</strong>：当 <span class="math inline">\(fx\)</span> 与 <span class="math inline">\(x\)</span> 都在同一侧子树时操作（即 <span class="math inline">\(x\)</span>、<span class="math inline">\(fx\)</span>、<span class="math inline">\(gx\)</span> 在同一条线上），先将 <span class="math inline">\(fx\)</span> 左旋/右旋，再将 <span class="math inline">\(x\)</span> 右旋/左旋。</p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_10.png" /></p><p>先将 <span class="math inline">\(fx\)</span> 右旋</p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_5.png" /></p><p>再将 <span class="math inline">\(x\)</span> 左旋</p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_6.png" /></p></li><li><p><strong>zig-zag</strong>：当 <span class="math inline">\(fx\)</span> 与 <span class="math inline">\(x\)</span> 都在不同侧子树时操作（即 <span class="math inline">\(x\)</span>、<span class="math inline">\(fx\)</span>、<span class="math inline">\(gx\)</span> 在不同一条线上），先将 <span class="math inline">\(x\)</span> 右旋/左旋，再将 <span class="math inline">\(x\)</span> 左旋/右旋。</p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_7.png" /></p><p>先将 <span class="math inline">\(x\)</span> 左旋</p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_8.png" /></p><p>再将 <span class="math inline">\(x\)</span> 右旋</p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_9.png" /></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> tree </tag>
            
            <tag> splay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好文收集</title>
      <link href="/posts/516cc39d/"/>
      <url>/posts/516cc39d/</url>
      
        <content type="html"><![CDATA[<h2>介绍</h2><p>这里放了很多不错的文章。</p><h2>字符串</h2><ul><li><a href="https://codeforces.com/blog/entry/129538">A tool for hacking rolling hashes with fixed modulos and bases</a></li><li><a href="https://codeforces.com/blog/entry/60442">On the mathematics behind rolling hashes and anti-hash tests</a></li></ul><h2>图论</h2><ul><li><a href="https://www.cnblogs.com/cjjsb/p/9771868.html">2-SAT 超入门讲解</a></li></ul><h2>数学</h2><ul><li><a href="https://www.cnblogs.com/Hanghang007/p/18159136">组合数学和线性代数</a></li><li><a href="https://blog.cyx2009.top/archives/OLS/">正交拉丁方的构造与应用</a></li></ul><h2>文化课</h2><ul><li><a href="https://www.luogu.com.cn/article/ubd4ucn3">高中数学笔记</a></li></ul><h2>其他</h2><ul><li><a href="https://blog.anxy.top/posts/5.html">Alist 美化</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毒瘤题收集</title>
      <link href="/posts/244d3e22/"/>
      <url>/posts/244d3e22/</url>
      
        <content type="html"><![CDATA[<h2>前言</h2><p>也许是一个很不错的题单。</p><blockquote><p>在<a href="https://uoj.ac/problem/98">未来的程序·改</a>中，我们面临着诸多挑战，包括<a href="https://loj.ac/p/2288">大葱的神力</a>、<a href="Https://www.luogu.com.cn/problem/P8422">德州消消乐</a>、<a href="Https://www.luogu.com.cn/problem/P5645">斗地主</a>等游戏的<a href="https://www.luogu.com.cn/problem/P5370">主斗地</a>技能。与此同时，<a href="https://www.luogu.com.cn/problem/P7196">灭鼠行动</a>和<a href="https://www.luogu.com.cn/problem/P4911">河童重工的计算机</a>技术也在飞速发展。<a href="https://www.luogu.com.cn/problem/P7610">群星连结</a>让我们与<a href="https://www.luogu.com.cn/problem/P3695">CYaRon!语</a>一起探索宇宙的奥秘，而<a href="https://www.luogu.com.cn/problem/P3798">辉夜姬的十道难题</a>则考验着我们的智慧。在<a href="https://www.luogu.com.cn/problem/P2337">喵星人的入侵</a>中，我们像<a href="https://www.luogu.com.cn/problem/P5822">大航海时代</a>的探险家一样，勇敢决战于<a href="https://www.luogu.com.cn/problem/P1737">旷野大计算</a>之中。</p></blockquote><blockquote><p>在<a href="https://www.luogu.com.cn/problem/P9141">乱西星上的空战</a>中，<a href="https://www.luogu.com.cn/problem/P3693">琪露诺的冰雪小屋</a>成了我们唯一的避难所。面对<a href="https://www.luogu.com.cn/problem/P4426">毒瘤</a>般的困难，我们需要掌握<a href="https://www.luogu.com.cn/problem/P5608">文化课</a>的知识，从<a href="https://www.luogu.com.cn/problem/T346974">helloworld</a>开始，逐步<a href="https://www.luogu.com.cn/problem/T347033">迭代幂次</a>，解决<a href="https://www.luogu.com.cn/problem/T347591">六则运算</a>，最终战胜<a href="https://www.luogu.com.cn/problem/P2482">猪国杀</a>的封锁。在组合数问题和鸭棋的博弈中，我们像魔兽世界的英雄一样，击败杀蚂蚁的敌人，建设大美江湖。</p></blockquote><blockquote><p>最终，我们用<a href="https://www.luogu.com.cn/problem/P7075">儒略日</a>的算法记录下这一切的辉煌历程。</p></blockquote><h2>题单</h2><ul><li><a href="https://www.luogu.com.cn/training/3210#information">保证有一大堆你不知道的珂怕的码农题大集合</a></li></ul><h2>题目</h2><ul><li><a href="https://uoj.ac/problem/98">集训队互测2015 未来程序·改</a></li><li><a href="https://www.luogu.com.cn/problem/P4920">WC2015 未来程序</a></li><li><a href="https://www.luogu.com.cn/problem/P4604">WC2017 挑战</a></li><li><a href="https://atcoder.jp/contests/birthday0410/tasks/birthday0410_x">Atcoder AT_birthday0410_x この问题はほんとうにひどい问题であるため，できれば先に他の问题のほうをお楽しみいただければと思っておりまして，ですので他の问题を通し終えて暇になり，かつその暇を</a></li><li><a href="https://loj.ac/p/3233">POI2019 R1 Pisarze</a></li><li><a href="https://loj.ac/p/2288">THUWC2017 大葱的神力</a></li><li><a href="https://www.luogu.com.cn/problem/UVA10966">UVA10966 3KP-BASH Project</a></li><li><a href="https://www.luogu.com.cn/problem/P8422">THUPC2022 决赛 德州消消乐</a></li><li><a href="https://www.luogu.com.cn/problem/P4118">Ynoi2018 末日时在做什么？有没有空？可以来拯救吗？</a></li><li><a href="https://www.luogu.com.cn/problem/P2540">NOIP2015 斗地主 加强版</a></li><li><a href="https://www.luogu.com.cn/problem/P5370">PKUSC2018 主斗地</a></li><li><a href="https://www.luogu.com.cn/problem/P5645">PKUWC2018 斗地主</a></li><li><a href="https://www.luogu.com.cn/problem/P7196">CTSC2002 灭鼠行动</a></li><li><a href="https://www.luogu.com.cn/problem/P4911">Luogu P4911 河童重工的计算机</a></li><li><a href="https://www.luogu.com.cn/problem/P3695">Luogu P3695 CYaRon!语</a></li><li><a href="https://www.luogu.com.cn/problem/P7610">THUPC2021 群星连结</a></li><li><a href="https://www.luogu.com.cn/problem/UVA12413">UVA12413 Big Decimal Calculator</a></li><li><a href="https://www.luogu.com.cn/problem/P7827">RdOI R3 附加 ACP-I</a></li><li><a href="https://www.luogu.com.cn/problem/P3798">Luogu P3798 辉夜姬的十道难题</a></li><li><a href="https://www.luogu.com.cn/problem/P2337">SCOI2012 喵星人的入侵</a></li><li><a href="https://www.luogu.com.cn/problem/P5822">L&amp;K R-03 大航海时代</a></li><li><a href="https://www.luogu.com.cn/problem/P5511">Luogu P5511 决战</a></li><li><a href="https://www.luogu.com.cn/problem/P1737">NOI2016 旷野大计算</a></li><li><a href="https://www.luogu.com.cn/problem/UVA12313">UVA12313 A Tiny Raytracer</a></li><li><a href="https://www.luogu.com.cn/problem/UVA12423">UVA12423 (Last) Mua(III) - Full Interpreter</a></li><li><a href="https://www.luogu.com.cn/problem/UVA12422">UVA12422 (Kengdie) Mua (II) - Expression Evaluator</a></li><li><a href="https://codeforces.com/problemset/problem/1545/E2">Codefoces 1545 E2</a></li><li><a href="https://www.luogu.com.cn/problem/P9141">THUPC2023 初赛 乱西星上的空战</a></li><li><a href="https://www.luogu.com.cn/problem/P3693">Luogu P3693 琪露诺的冰雪小屋</a></li><li><a href="https://www.luogu.com.cn/problem/P4426">HNOI/AHOI2018 毒瘤</a></li><li><a href="https://www.luogu.com.cn/problem/P5608">Ynoi2013 文化课</a></li><li><a href="https://www.luogu.com.cn/problem/T346974">Luogu T346974 helloworld 加强版</a></li><li><a href="https://www.luogu.com.cn/problem/T347033">Luogu T347033 迭代幂次</a></li><li><a href="https://www.luogu.com.cn/problem/T347591">Luogu T347591 六则运算</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串 Hash 的攻击</title>
      <link href="/posts/9379dc77/"/>
      <url>/posts/9379dc77/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>强烈建议尝试 <a href="https://www.luogu.com.cn/problem/U461211">Luogu U461211 字符串 Hash（数据加强）</a></p></div><h2>大模数哈希</h2><h3>前言</h3><p>我们知道，要想卡掉 hash，本质上就是让两个字符串有相同的 hash 值，我们称为<strong>哈希碰撞</strong>。</p><p>假设 hash 中每个值生成概率相同，则碰撞概率取决于两个因素：</p><ul><li>取值空间大小</li><li>hash 的计算次数</li></ul><p>这个问题在数学中有一个经典的问题，叫 <a href="https://baike.baidu.com/item/%E7%94%9F%E6%97%A5%E6%82%96%E8%AE%BA/2715290">生日问题</a>。</p><p>简单来说，就是在一个有 d 人的班中，有人生日相同的概率为多少。</p><p>实际上，这个问题的答案并没有想象中的小，下面是部分概率：</p><table><thead><tr class="header"><th style="text-align: center;">人数</th><th style="text-align: center;">概率</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">23</td><td style="text-align: center;"><span class="math inline">\(50\%\)</span></td></tr><tr class="even"><td style="text-align: center;">50</td><td style="text-align: center;"><span class="math inline">\(97\%\)</span></td></tr><tr class="odd"><td style="text-align: center;">70</td><td style="text-align: center;"><span class="math inline">\(99.9\%\)</span></td></tr></tbody></table><h3>计算冲突概率</h3><p>我们设 hash 的取值空间为 d，计算次数为 n。 则 hash 不冲突的概率为：</p><p><span class="math display">\[\overline{p}(n,d) = 1 \cdot \left (1 - \frac{1}{d} \right) \cdot \left ( 1- \frac{2}{d}\right) \cdots \left ( 1- \frac{n-1}{d}\right)\]</span></p><p>经过亿点点的数学计算，他可以变为：</p><p><span class="math display">\[\frac{d!}{d^n\left(d-n\right)!}\]</span></p><p>则 hash 冲突概率为：</p><p><span class="math display">\[p(n,d)=1-\frac{d!}{d^n\left(d-n\right)!}\]</span></p><p>但是，这个太丑了，计算也太复杂了，我们换种方法。</p><p>根据泰勒公式：</p><p><span class="math display">\[\exp(x) = \sum_{k=0}^{\infty}\frac{x^k}{k!}=1+x+\frac{x^2}{2}+\frac{x^3}{6}+\frac{x^4}{24}+\cdots\]</span></p><p>当 <span class="math inline">\(x\)</span> 为一个极小的值，那么 <span class="math inline">\(\exp(x)\approx1+x\)</span></p><p>将上面 hash 不冲突的原始公式带入：</p><p><span class="math display">\[\overline{p}(n,d) = 1 \cdot \exp(-\frac{1}{d}) \cdot \exp(-\frac{2}{d}) \cdots \exp(-\frac{n-1}{d})\]</span></p><p>化简得：</p><p><span class="math display">\[\overline{p}(n,d) = \exp(-\frac{n(n-1)}{2d})\]</span></p><p>则 hash 冲突的概率为：</p><p><span class="math display">\[p(n,d) = 1-\exp(-\frac{n(n-1)}{2d})\]</span></p><h3>卡 Hash</h3><p>言归正传，注意这个公式：</p><p><span class="math display">\[p(n,d) = 1-\exp(-\frac{n(n-1)}{2d})\]</span></p><p>我们只要使 d（取值空间）比模数大，并找一个 n（计算次数），使得 <span class="math inline">\(p(n,d)\)</span> 尽量为 1，就完成了。</p><p>例：</p><p>对于字符集为大小写字母及其数字，我们设模数为 <span class="math inline">\(10^9+7\)</span>：</p><p><span class="math inline">\(\log_{62}10^9+7\approx6\)</span></p><p><span class="math inline">\(p(10^6,6^{62})\approx0.9\)</span></p><p>所以共有 <span class="math inline">\(10^6\)</span> 个字符串，每个字符串长度为 6 就是个不错的数据。</p><h2>自然溢出 Hash</h2><p>我们知道，这种 Hash 是形如 <span class="math inline">\(hs = hs \cdot base + s[i]\)</span>，分情况讨论。</p><h3>base 为偶数</h3><p>这种简单，构造两个长度相同且大于64，并只有首字母不同的字符串，形如：</p><p><span class="math inline">\(aaa...a\)</span></p><p><span class="math inline">\(baa...a\)</span></p><h3>base 为奇数</h3><p>定义 <span class="math inline">\(!s_i\)</span> 为 <span class="math inline">\(s_i\)</span> 的倒串,<span class="math inline">\(hash_i\)</span> 为 <span class="math inline">\(s_i\)</span> 的 Hash 值,<span class="math inline">\(!hash_i\)</span> 为 <span class="math inline">\(!s_i\)</span> 的 Hash 值。</p><p>例如： <span class="math inline">\(s_i=abbab\)</span></p><p>则：<span class="math inline">\(!s_i=baaba\)</span></p><p>设 <span class="math inline">\(s_1 = a\)</span></p><p>之后不断构造 <span class="math inline">\(s_i=s_{i-1}+!s_{i-1}\)</span> 就有：</p><p><span class="math display">\[hash_i = hash_{i-1}\cdot base^{2^{i-2}} + !hash_{i-1}\\!hash_{i} = !hash_{i-1}\cdot base^{2^{i-2}}+hash_{i-1}\]</span></p><p>尝试相减：</p><p><span class="math display">\[\begin{align*}&amp;hash_i - !hash_i\\=\ &amp;hash_{i-1}\cdot base^{2^{i-2}} + !hash_{i-1}-(!hash_{i-1}\cdot base^{2^{i-2}}+hash_{i-1})\\=\ &amp;(hash_{i-1}-!hash_{i-1})\cdot (base^{2^{i-2}}-1)\end{align*}\]</span></p><p>发现出现了 <span class="math inline">\(2^i\)</span>，但是原式太复杂，尝试换元：</p><p>设：</p><p><span class="math inline">\(f_i = hash_i - !hash_i\)</span></p><p><span class="math inline">\(g_i = base^{2^{i-2}-1}\)</span></p><p>带回原式：</p><p><span class="math display">\[\begin{align*}f_i &amp;= f_{i-1} \cdot g_i\\&amp;=f_1 \cdot g_1 \cdot g_2 \cdots g_{i-1}\\\end{align*}\]</span></p><p>因为 <span class="math inline">\(base^{2^{i-2}}\)</span> 一定是奇数，所以 <span class="math inline">\(g_i\)</span> 一定是偶数。</p><p>所以：</p><p><span class="math display">\[2^{i-1} | f_i\]</span></p><p>但这样太大了，<span class="math inline">\(i-1\ge 64\)</span> 才能卡掉，继续化简。</p><p><span class="math display">\[g_i = base^{2^{i-2}-1} = (base_{2^{i-2}}-1)\cdot(base^{2^{i-2}}+1)\\\]</span></p><p><span class="math display">\[\begin{align*}\therefore &amp; 2^i | g_i\\&amp;2^2\cdot2^2\cdot2^3\cdots2^{i-1} | f_i\\&amp;2^{i(i-1)/2} | f_i\end{align*}\]</span></p><p>即当 <span class="math inline">\(i=12\)</span> 时就可以使 <span class="math inline">\(2^{64} | hash_i - !hash_i\)</span> 达到要求。</p><p><span class="math inline">\(s_{12}\)</span> 和 <span class="math inline">\(!s_{12}\)</span> 就是我们要的两个字符串。</p><p>参考：</p><p><a href="https://www.cnblogs.com/Hs-black/p/12219270.html">毒瘤养成记1: 如何卡hash</a></p><p><a href="https://www.ruanyifeng.com/blog/2018/09/hash-collision-and-birthday-attack.html">哈希碰撞与生日攻击</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AC 自动机</title>
      <link href="/posts/850042a0/"/>
      <url>/posts/850042a0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>很多人在第一次看到这个东西的时侯是非常兴奋的。不过这个自动机叫作 <code>Automaton</code>，不是 <code>Automation</code>，这里的 <code>AC</code> 也不是 <code>Accepted</code>，而是 <code>Aho–Corasick</code>（Alfred V. Aho, Margaret J. Corasick. 1975）。</p></blockquote><h2>前置</h2><p>Trie （字典树）</p><p>KMP （只要失配指针的思想即可）</p><h2>定义</h2><p>AC 自动机是 <strong>以 Trie (字典树) 的结构为基础</strong>，结合 <strong>KMP (字符串匹配) 的思想</strong> 建立的自动机，用于解决多模式匹配等任务。</p><h2>构建</h2><p>先简单解释一下：</p><p>AC 自动机由两部分组成：</p><ol type="1"><li><p>将模式串构造成一棵普通的 Trie。</p></li><li><p>利用 KMP 思想构造失配指针。</p></li></ol><h3>失配指针</h3><p>同 KMP 一样，AC 自动机同样构造一个 fail 用于失配时的跳转指针。</p><p>但 AC 自动机的 fail 指向当前状态的最长后缀。</p><p>定义如下变量：</p><p>当前节点 <code>u</code>，<code>u</code> 的父亲节点 <code>p</code>，<code>p</code> 和 <code>u</code> 间用一条字符 <code>c</code> 连接。</p><p>字典树的边集 <code>tr</code>。（<span class="math inline">\(tr[u][c]\)</span> 表示节点 <code>u</code> 的 <code>c</code> 出边的点）</p><p>假设所有深度小于 <code>u</code> 的 fail 指针均已求得。</p><ol type="1"><li><p>若 <span class="math inline">\(tr[fail[p]][c]\)</span> 存在，则让 <span class="math inline">\(fail[u]=tr[fail[p]][c]\)</span>。</p></li><li><p>否则，找到 <span class="math inline">\(fail[fail[p]]\)</span>，重复 1 的过程，直到根节点。</p></li><li><p>如果还没有，令 <span class="math inline">\(fial[u]=root\)</span>。（<span class="math inline">\(root\)</span> 表示根节点）</p></li></ol><h3>自动机</h3><p>AC 自动机通过 <strong>一个</strong> BFS 函数实现 fail 和 自动机 的构建。</p><p>定义如下变量：</p><p>字典树的边集 <code>tr</code>。（<span class="math inline">\(tr[u][c]\)</span> 表示节点 <code>u</code> 的 <code>c</code> 出边的点）</p><ol type="1"><li><p>将根节点的所有子节点入队。</p></li><li><p>对于队头 <code>u</code>，遍历字符集，设当前遍历到 <code>i</code>。</p><ol type="1"><li><p>若 <span class="math inline">\(tr[u][i]\)</span> 存在，则将 <span class="math inline">\(fail[tr[u][i]]=tr[fail[u]][i]\)</span>。</p></li><li><p>否则，令 <span class="math inline">\(tr[u][i]=tr[fail[u]][i]\)</span>。</p></li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (nd[<span class="number">0</span>].son[i]) q.<span class="built_in">push</span>(nd[<span class="number">0</span>].son[i]);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (nd[u].son[i])</span><br><span class="line">                nd[nd[u].son[i]].fail = nd[nd[u].fail].son[i], q.<span class="built_in">push</span>(nd[u].son[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nd[u].son[i] = nd[nd[u].fail].son[i];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>匹配</h3><p>遍历文本串 <code>T</code>，设当前点为 <code>u</code>：</p><ol type="1"><li>利用 fail 找到所有匹配的模式串，累加，清零。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; t[i]; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c = t[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            u = nd[u].son[c];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = u; j &amp;&amp; nd[j].e != <span class="number">-1</span>; j = nd[j].fail)</span><br><span class="line">                sum += nd[j].e, nd[j].e = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3>例题</h3><h4><a href="https://www.luogu.com.cn/problem/P3808">P3808 AC 自动机（简单版）</a></h4><p>直接套 AC 自动机。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">int</span> son[<span class="number">30</span>], fail, e;</span><br><span class="line">    &#125; nd[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i]; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!nd[u].son[c]) nd[u].son[c] = ++cnt;</span><br><span class="line">            u = nd[u].son[c];</span><br><span class="line">        &#125;</span><br><span class="line">        nd[u].e++;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (nd[<span class="number">0</span>].son[i]) q.<span class="built_in">push</span>(nd[<span class="number">0</span>].son[i]);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span> (nd[u].son[i])</span><br><span class="line">                    nd[nd[u].son[i]].fail = nd[nd[u].fail].son[i], q.<span class="built_in">push</span>(nd[u].son[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nd[u].son[i] = nd[nd[u].fail].son[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; t[i]; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c = t[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            u = nd[u].son[c];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = u; j &amp;&amp; nd[j].e != <span class="number">-1</span>; j = nd[j].fail)</span><br><span class="line">                sum += nd[j].e, nd[j].e = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ac;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>), ac.<span class="built_in">insert</span>(s);</span><br><span class="line">    ac.<span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ac.<span class="built_in">query</span>(s));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><a href="https://www.luogu.com.cn/problem/P3796">P3796 AC 自动机（简单版 II）</a></h4><p>基本思路一样。</p><p>多记录两个东西：</p><ol type="1"><li><p>每个模式串在字典树中结束的位置</p></li><li><p>每个字典树上的点匹配到模式串的次数</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">156</span>, T = <span class="number">1e6</span> + <span class="number">6</span>, S = N * <span class="number">80</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt, ans[N];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">int</span> son[<span class="number">30</span>], fail, idx, val;</span><br><span class="line">    &#125; nd[S];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(nd, <span class="number">0</span>, <span class="keyword">sizeof</span> nd);</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="built_in">sizeof</span>(ans));</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i]; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!nd[u].son[c]) nd[u].son[c] = ++cnt;</span><br><span class="line">            u = nd[u].son[c];</span><br><span class="line">        &#125;</span><br><span class="line">        nd[u].idx = id;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (nd[<span class="number">0</span>].son[i]) q.<span class="built_in">push</span>(nd[<span class="number">0</span>].son[i]);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span> (nd[u].son[i])</span><br><span class="line">                    nd[nd[u].son[i]].fail = nd[nd[u].fail].son[i], q.<span class="built_in">push</span>(nd[u].son[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nd[u].son[i] = nd[nd[u].fail].son[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; t[i]; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c = t[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            u = nd[u].son[c];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = u; j; j = nd[j].fail) nd[j].val++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++)</span><br><span class="line">            <span class="keyword">if</span> (nd[i].idx) sum = <span class="built_in">max</span>(sum, nd[i].val), ans[nd[i].idx] = nd[i].val;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ac;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N][<span class="number">100</span>], t[T];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i] + <span class="number">1</span>), ac.<span class="built_in">insert</span>(s[i], i);</span><br><span class="line">        ac.<span class="built_in">build</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> x = ac.<span class="built_in">query</span>(t);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> (ac.ans[i] == x) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">        ac.<span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>优化</h2><p>在 AC 自动机中，会一直跳 fail 寻找匹配，但这样效率极低。</p><p>考虑优化：</p><p>先考虑 fail 的特性：一定是一棵树。</p><p>而我们 AC 自动机的匹配就可以转化为在 fail 树上的链求和问题。</p><p>这里提供两种思路。</p><p>例题：<a href="https://www.luogu.com.cn/problem/P5357">P5357 【模板】AC 自动机</a></p><h3>拓扑优化（快）</h3><p>考虑预先记录所有跳的 fail，最后一并求和。</p><p>于是按照 fail 树建图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, S = <span class="number">2e5</span> + <span class="number">5</span>, T = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> s[S], t[T];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>, ans[N], f[N], in[N];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">int</span> son[<span class="number">27</span>], fail, f, ans;</span><br><span class="line">    &#125; nd[N];</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i]; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!nd[u].son[c]) nd[u].son[c] = ++cnt;</span><br><span class="line">            u = nd[u].son[c];</span><br><span class="line">        &#125;</span><br><span class="line">        f[id] = (nd[u].f) ? nd[u].f : nd[u].f = id;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) nd[<span class="number">0</span>].son[i] = <span class="number">1</span>;</span><br><span class="line">        nd[<span class="number">1</span>].fail = <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> fail = nd[u].fail;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> v = nd[u].son[i];</span><br><span class="line">                <span class="keyword">if</span> (!v) &#123;</span><br><span class="line">                    nd[u].son[i] = nd[fail].son[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nd[v].fail = nd[fail].son[i], in[nd[fail].son[i]]++;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">            <span class="keyword">if</span> (!in[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            ans[nd[u].f] = nd[u].ans;</span><br><span class="line">            <span class="type">int</span> fail = nd[u].fail;</span><br><span class="line">            nd[fail].ans += nd[u].ans;</span><br><span class="line">            <span class="keyword">if</span> (!--in[fail]) q.<span class="built_in">push</span>(fail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i]; i++) u = nd[u].son[s[i] - <span class="string">&#x27;a&#x27;</span>], nd[u].ans++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ac;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>), ac.<span class="built_in">insert</span>(s, i);</span><br><span class="line">    ac.<span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t + <span class="number">1</span>);</span><br><span class="line">    ac.<span class="built_in">query</span>(t), ac.<span class="built_in">topsort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ac.ans[ac.f[i]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>子树求和（慢）</h3><p>先子树求和，最后累加。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, S = <span class="number">2e5</span> + <span class="number">5</span>, T = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[S], t[T];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ACM</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">int</span> son[<span class="number">30</span>], val, fail, hd;</span><br><span class="line">        dq idx;</span><br><span class="line">    &#125; nd[S];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> to, nt;</span><br><span class="line">    &#125; e[S];</span><br><span class="line">    <span class="type">int</span> rt, acnt, tot;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = rt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i]; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!nd[u].son[c]) nd[u].son[c] = ++acnt;</span><br><span class="line">            u = nd[u].son[c];</span><br><span class="line">        &#125;</span><br><span class="line">        nd[u].idx.<span class="built_in">push_back</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dq q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (nd[rt].son[i]) q.<span class="built_in">push_back</span>(nd[rt].son[i]);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span> (nd[u].son[i]) &#123;</span><br><span class="line">                    nd[nd[u].son[i]].fail = nd[nd[u].fail].son[i];</span><br><span class="line">                    q.<span class="built_in">push_back</span>(nd[u].son[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    nd[u].son[i] = nd[nd[u].fail].son[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = rt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i]; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">            u = nd[u].son[c], nd[u].val++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123; e[++tot] = &#123;v, nd[u].hd&#125;, nd[u].hd = tot; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nd[x].hd; i; i = e[i].nt) &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].to;</span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">            nd[x].val += nd[v].val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nd[x].idx) cnt[i] += nd[x].val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">failtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= acnt; u++) <span class="built_in">add</span>(nd[u].fail, u);</span><br><span class="line">        <span class="built_in">dfs</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ac;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        ac.<span class="built_in">insert</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">    ac.<span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t + <span class="number">1</span>);</span><br><span class="line">    ac.<span class="built_in">query</span>(t), ac.<span class="built_in">failtr</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>后记</h2><p>这篇文章是近半年未写算法后的第一篇文章，很不容易，希望大家多支持。</p><p>参考 : <a href="https://oi-wiki.org/string/ac-automaton/#kmp-%E8%87%AA%E5%8A%A8%E6%9C%BA">AC 自动机 - OI Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典树</title>
      <link href="/posts/eea60a6a/"/>
      <url>/posts/eea60a6a/</url>
      
        <content type="html"><![CDATA[<h2>定义</h2><p>字典树 ( trie )，将多个字符串进行 <strong>树</strong> 一样的处理，从而快速查找的一种算法。</p><h2>实现</h2><p>如图，我们依次加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ab</span><br><span class="line">aba</span><br><span class="line">ba</span><br><span class="line">caaa</span><br><span class="line">cab</span><br><span class="line">cba</span><br><span class="line">cc</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xglight/photo/main/trie1.png" /></p><p>我们以边代表字母，结点之间的路径就为字符串</p><p>就得到了这棵树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> string </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀函数</title>
      <link href="/posts/23c3ef31/"/>
      <url>/posts/23c3ef31/</url>
      
        <content type="html"><![CDATA[<h2>前置</h2><h3>子串</h3><p>字符串中连续的一段。</p><h3>前缀</h3><p>指从字符串开头到某个位置结束的特殊子串</p><h3>真前缀</h3><p>指从字符串开头到某个位置结束的特殊子串（不包含字符串本身）</p><h3>后缀</h3><p>指从某个位置开始到字符串结尾的特殊子串</p><h3>真后缀</h3><p>指从某个位置开始到字符串结尾的特殊子串（不包含字符串本身）</p><h2>定义</h2><p>对于一个长 <span class="math inline">\(n\)</span> 的字符串 <span class="math inline">\(s\)</span>，我们设 <span class="math inline">\(i\)</span> 位的前缀函数为 <span class="math inline">\(\pi_i\)</span></p><ol type="1"><li><p>若 <span class="math inline">\(s\)</span> 的子串 <span class="math inline">\(0\sim i\)</span> 有一对相等的<strong>真前缀</strong>与<strong>真后缀</strong>，则 <span class="math inline">\(\pi_i\)</span> 为真前缀（真后缀）的长度。</p></li><li><p>若不止一对相等的，令 <span class="math inline">\(\pi_i\)</span> 为最长的长度。</p></li><li><p>若没有，则 <span class="math inline">\(\pi_i=0\)</span></p></li><li><p><span class="math inline">\(\pi_0=0\)</span></p></li></ol><h2>计算方法</h2><h3>朴素（暴力）</h3><p>枚举：<span class="math inline">\(O(n^3)\)</span></p><h3>优化一</h3><p>简单思考一下，<span class="math inline">\(\pi_{i+1}\)</span> 的值至多为 <span class="math inline">\(\pi_i+1\)</span></p><p><span class="math inline">\(O(n^2)\)</span></p><h2>优化二</h2><p>在寻找真前缀与真后缀时，我们会枚举一个长度 <span class="math inline">\(j\)</span></p><p>当匹配失败时，我们希望找到仅次于 <span class="math inline">\(j\)</span> 的长度 <span class="math inline">\(j^{(2)}\)</span>，其中 <span class="math inline">\(j^{(2)}\)</span> 我们希望他满足前缀性质。</p><p>所以，<span class="math inline">\(j^{(n)}=\pi_{j^{n-1}-1}\)</span></p><p><span class="math inline">\(O(n)\)</span></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数论合集</title>
      <link href="/posts/cfd8ddf5/"/>
      <url>/posts/cfd8ddf5/</url>
      
        <content type="html"><![CDATA[<h2>素数（质数）</h2><h3>定义</h3><blockquote><p>只有两个因数的数叫做质因数（1和它本身）</p></blockquote><blockquote><p><span class="math inline">\(1\)</span> 既不是素数也不是合数</p></blockquote><h3>判断素数</h3><h4>朴素算法</h4><p>枚举 <span class="math inline">\(2-(n-1)\)</span>的所有数字，判断其是否能被整除，时间复杂度：<span class="math inline">\(\color{orange}O(n)\)</span></p><p>或者可以优化一下，枚举区间改成 <span class="math inline">\(2-\sqrt{n}\)</span>，时间复杂度：<span class="math inline">\(\color{orange}O(\sqrt{n})\)</span></p><h4>埃式筛法</h4><p>对于多个大数，朴素算法显然慢了</p><p>对于求多个质数，我们可以运用标记思想</p><p>我们知道，对于一个 <span class="math inline">\(x\in Z\)</span>，它的倍数一定是约数</p><p>所以我们可以从小到大的枚举 <span class="math inline">\(n\)</span> 内的质数，标记它的倍数，没被标的即是质数</p><p>时间复杂度：<span class="math inline">\(\color{orange}O(n\, In\, In\,n)\)</span>（<span class="math inline">\(In\, n\)</span>表示<span class="math inline">\(log_en\)</span>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N],ss[N],cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ssai</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">2</span>;i&lt;=x;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i]) ss[++cnt]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ss[cnt]*j&gt;n) <span class="keyword">break</span>;</span><br><span class="line">            f[ss[cnt]*j]=<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">ssai</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ss[i]); </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>欧拉筛法（线性筛法）</h4><p>我们回忆一下埃式筛法，对于一个约数，它可能被多个素数标记，浪费了时间</p><p>那么欧拉筛法就只让一个约数被他最小的质因子标记</p><p>时间复杂度：<span class="math inline">\(\color{orange}O(n)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N],ss[N],cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ssou</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i]) ss[++cnt]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ss[j]*i&gt;n) <span class="keyword">break</span>;</span><br><span class="line">            f[i*ss[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%ss[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">ssou</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ss[i]);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=red>注意，以上两个筛法都是求<span class="math inline">\(\color{red}1-n\)</span>中的素数</font></p><h3>分解质因数</h3><p><sub><sub>这还不简单</sub></sub></p><blockquote><p>算数基本定理（唯一分解定理）:任何一个约数都可以被分解成几个素数相乘的形式</p></blockquote><p>根据这条定理，我们可以采用试除法</p><p>从 <span class="math inline">\(2-\sqrt{n}\)</span> 枚举 <span class="math inline">\(n\)</span> 的质数 ，遇到素数就一直除以它，直到不能整除为止，并记录除的次数</p><p><font color=red>最后若<span class="math inline">\(\color{red}n&gt;0\)</span>，也要算一个素数</font></p><p>时间复杂度：<span class="math inline">\(\color{orange}O(logn)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dpf</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x);i++)</span><br><span class="line">        <span class="keyword">while</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">            x/=i;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>) sum++;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> ans=<span class="built_in">dpf</span>(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>合数</h2><p>合数，通俗理解：不是素数的正整数就是合数（1 除外）</p><h3>定义</h3><blockquote><p>除了 1 和它本身之外还有其他因数的数叫合数</p></blockquote><blockquote><p>1 既不是素数也不是合数</p></blockquote><h3>判断合数</h3><p><sub><sub>应该没有这种题吧</sub></sub></p><p>先用欧拉筛法，加个标记，没被标的即使合数</p><p><sub><sub>这么简单，不用放代码吧</sub></sub></p><h3>求约数个数</h3><blockquote><p>约约数个数定理:对于一个大于 1 的正整数可以 <strong>分解质因数</strong>：</p><p><span class="math inline">\(n=\prod\limits_{i=1}^{k}p_i^{a_i}=p_1^{a_1}*p_2^{a_2}*\dots *p_k^{a_k}\)</span></p><p>则 1 的约数个数为：</p><p><span class="math inline">\(f(n)=\prod\limits_{i=1}^{k}(a_i+1)=(a_1+1)*(a_2+1)*\dots*(a_k+1）\)</span></p></blockquote><p>这里给出证明：</p><blockquote><p>由约数的定义可得：<span class="math inline">\(p_1^{a_1}\)</span>有<span class="math inline">\(p_1^0,p_1^1,p_1^2\dots p_1^{a_1}\)</span>这些约数，共有<span class="math inline">\((a_1+1)\)</span>个</p><p>同理，<span class="math inline">\(p_2^{a_2}\)</span>有<span class="math inline">\((a_2+1)\)</span>个约数，<span class="math inline">\(\dots p_k^{a_k}\)</span>有<span class="math inline">\((a_k+1)\)</span>个约数</p><p><span class="math inline">\(\therefore p_1^{a_1}\)</span>中有<span class="math inline">\((a_1+1)\)</span>个因子，<span class="math inline">\(\dots p_k^{a_k}\)</span>中有<span class="math inline">\((a_k+1)\)</span>个因子</p><p>乘法原理可得：<span class="math inline">\(f_n=(a_1+1)*(a_2+1)*\dots*(a_k+1)\)</span></p></blockquote><p>时间复杂度：<span class="math inline">\(\color{orange}O(\sqrt{n})\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dpf</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>,sum=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x);i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">            x/=i;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        sum*=(cnt<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>) sum*=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> ans=<span class="built_in">dpf</span>(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你要求所有约数,用质因数一个个乘吧</p><p>时间复杂度：<span class="math inline">\(\color{orange}O(n)\)</span></p><h2>公约数&amp;公倍数</h2><h3>公约数</h3><h4>定义</h4><blockquote><p>若 x 同时是 a 和 b 的约数，则称 x 是 a 与 b 的公约数</p></blockquote><h3>公倍数</h3><h4>定义</h4><blockquote><p>若 a 和 b 同时是 x 的约数，则称 x 是 a 与 b 的公倍数</p></blockquote><h3>最大公约数</h3><h4>定义</h4><blockquote><p>若 x 是 a 和 b 的公约数且 x 最大，则称 x 是 a 和 b 的最大公约数</p><p><span class="math inline">\(gcd(a,b)=x\)</span></p></blockquote><h4>求最大公约数</h4><blockquote><p><span class="math inline">\(gcd(a,b)=gcd(b,a\,mod\,b)\)</span></p></blockquote><p>证明：</p><blockquote><p>设 <span class="math inline">\(a=bk+c\)</span>，则 <span class="math inline">\(c=a\, mod\, b\)</span></p><p>设 <span class="math inline">\(d\,|\,a,a\,|\,b\)</span>，则 <span class="math inline">\(c=a-bk,\frac{c}{d}=\frac{a}{d}-\frac{b}{d}k\)</span></p><p>反过来，</p><p>设 <span class="math inline">\(d\,|\,b,d\,|\,(a\,mod\,b)\)</span></p><p>则 <span class="math inline">\(\frac{a\,mod\,b}{d}=\frac{a}{d}-\frac{b}{d}k\)</span></p><p>移项得：<span class="math inline">\(\frac{a\,mod\,b}{d}+\frac{b}{d}k=\frac{a}{d}\)</span></p><p>显然，<span class="math inline">\(\frac{a\,mod\,b}{d}\in Z\)</span></p><p><span class="math inline">\(\therefore \frac{a}{d}\in Z\)</span>，即 <span class="math inline">\(d\,|\,a\)</span></p><p>得证</p></blockquote><p>时间复杂度：<span class="math inline">\(\color{orange}O(logn)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="type">int</span> ans=<span class="built_in">gcd</span>(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>补充</h4><p>若 <span class="math inline">\(\gcd(a,b)=1\)</span>，我们称这两个数 <strong>互质</strong></p><p>即最大的公约数为 1</p><h3>最小公倍数</h3><h4>定义</h4><blockquote><p>若 x 是 a 和 b 的公倍数且 x 最小，则称 x 是 a 和 b 的最小公倍数</p><p><span class="math inline">\(lcm(a,b)=x\)</span></p></blockquote><h4>求最小公倍数</h4><blockquote><p><span class="math inline">\(a*b=\gcd(a,b)*lcm(a,b)\)</span></p></blockquote><p>证明：</p><blockquote><p>设 <span class="math inline">\(a=p_1^{k_{a_1}}p_2^{k_{a_2}}\dots p_s^{k_{a_s}},b=p_1^{k_{b_1}}p_2^{k_{b_2}}\dots p_s^{k_{b_s}}\)</span></p><p>则 <span class="math inline">\(gcd(a,b)=p_1^{min(k_{a_1},k_{b_1})}p_2^{min(k_{a_2},k_{b_2})}\dots p_s^{min(k_{a_s},k_{b_s})}\)</span></p><p><span class="math inline">\(lcm(a,b)=p_1^{max(k_{a_1},k_{b_1})}p_2^{max(k_{a_2},k_{b_2})}\dots p_s^{max(k_{a_s},k_{b_s})}\)</span></p><p><span class="math inline">\(\because k_a+k_b=min(k_a,k_b)+max(k_a,k_b)\)</span></p><p><span class="math inline">\(\therefore a*b=gcd(a,b)*lcm(a,b)\)</span></p></blockquote><p>时间复杂度：<span class="math inline">\(\color{orange}O(logn)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="type">int</span> ans=<span class="built_in">gcd</span>(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a*b/ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>欧拉函数</h2><h3>定义</h3><blockquote><p>欧拉函数，即 <span class="math inline">\(\varphi(n)\)</span>，表示小于等于 n 且与 n 互质数的个数</p><p>即 <span class="math inline">\(\varphi(n)=\sum\limits_{i=1}^n[gcd(i,n)=1]\)</span></p></blockquote><h3>性质</h3><h4>积性函数</h4><h2>逆元</h2>]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/posts/7cab1e06/"/>
      <url>/posts/7cab1e06/</url>
      
        <content type="html"><![CDATA[<h2>定义</h2><p>二叉搜索树是一棵二叉树，具有以下定义：</p><ul><li><p>若二叉搜索树的左子树不为空，则其左子树上所有点的附加权值均小于其根节点的值。</p></li><li><p>若二叉搜索树的右子树不为空，则其右子树上所有点的附加权值均大于其根节点的值。</p></li><li><p>二叉搜索树的左右子树均为二叉搜索树。</p></li></ul><h2>一些操作</h2><p>先看变量：</p><p><span class="math inline">\(lc_x\)</span>：x点的左儿子</p><p><span class="math inline">\(rc_x\)</span>：x点的右二子</p><p><span class="math inline">\(val_x\)</span>：x点的值</p><p><span class="math inline">\(cnt_x\)</span>：x点值的数量</p><p><span class="math inline">\(siz_x\)</span>：x点子树的数量</p><h3>插入</h3><p>向树中插入一个值</p><p>递归插入</p><ol type="1"><li><p>与当前节点比较，若权值小于它，加入左子树，反之加入右子树</p></li><li><p>若当前点权值与插入值一样，当前点 <span class="math inline">\(cnt++\)</span></p></li><li><p>若当前节点为空，将节点设为当前节点</p></li></ol><p>插入时注意更新变量</p><p><font color=red>不要忘记更新父节点的儿子</font></p><h3>删除</h3><p>在树中删除一个值</p><ol type="1"><li><p>先在树中查找该值节点</p></li><li><p>设改点为 <span class="math inline">\(x\)</span>，分类讨论</p><ol type="1"><li><p>若 <span class="math inline">\(cnt_x&gt;1\)</span>，将 <span class="math inline">\(cnt_x--\)</span></p></li><li><p>若 <span class="math inline">\(cnt_x=1\)</span></p><ol type="1"><li><p>若该点是叶子节点（没有儿子），删除该节点</p></li><li><p>若该点只有一个儿子，返回它的儿子</p></li><li><p>若该点有两个儿子，返回左子树的最大值或右子树的最小值</p></li></ol></li></ol></li></ol><h3>查找最大/最小值</h3><p>查最小值一直往左儿子跳</p><p>查最大值一直往右儿子跳</p><h3>查找排名为 k 的元素</h3><p>设当前节点为 <span class="math inline">\(x\)</span>，分类讨论</p><ol type="1"><li><p>若其左子树大小 <span class="math inline">\(\ge k\)</span>，查找其左子树</p></li><li><p>若其左子树大小在 <span class="math inline">\(k-cnt_x到k-1\)</span>中，返回<span class="math inline">\(x\)</span></p></li><li><p>若其左子树大小 <span class="math inline">\(&lt;k-cnt\)</span>，查找其右子树</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>operator浅谈</title>
      <link href="/posts/24055d74/"/>
      <url>/posts/24055d74/</url>
      
        <content type="html"><![CDATA[<h2>前言</h2><p><span class="math inline">\(operator\)</span>，即c++的重载运算符。</p><p>可以理解为定义了一个符号的运算规则，用来更方便处理<u>高精度</u>等特定运算。</p><h2>使用须知</h2><p><span class="math inline">\(=\)</span>赋值运算符、<span class="math inline">\([]\)</span>下标运算符、<span class="math inline">\(()\)</span>函数调用运算符、<span class="math inline">\(-&gt;\)</span>成员访问运算符。</p><p><strong>只能作为类成员重载，不能作为友元函数。</strong></p><p>还有，重载后无优先级，可以打括号。</p><p>Finally，你不应该重载 <span class="math inline">\(\&amp;\&amp;\;\|\|\;\&amp;\)</span> 运算符，他们在程序中有重要的作用。</p><h2>使用</h2><p>你应该把他定义在结构体里，他不会对结构体外的运算符产生影响。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;结构体名&#125; <span class="keyword">operator</span> &#123;运算符&#125;(&#123;运算符&#125;)&#123; </span><br><span class="line">&#123;重载规则&#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h2>例题</h2><p>单讲不好讲，上一道例题：高精度a+b</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">high</span> &#123;</span><br><span class="line">  <span class="type">int</span> len, o[<span class="number">1005</span>];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(o, <span class="number">0</span>, <span class="built_in">sizeof</span>(o));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">in</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">1005</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ch), len = <span class="built_in">strlen</span>(ch);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">      o[len - i] = (ch[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, o[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">high <span class="keyword">operator</span>+(high a, high b) &#123;</span><br><span class="line">  high c;</span><br><span class="line">  c.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">while</span> (c.len &lt;= a.len || c.len &lt;= b.len) &#123;</span><br><span class="line">    c.len++;</span><br><span class="line">    c.o[c.len] += (a.o[c.len] + b.o[c.len]);</span><br><span class="line">    c.o[c.len + <span class="number">1</span>] += (c.o[c.len] / <span class="number">10</span>);</span><br><span class="line">    c.o[c.len] %= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!c.o[c.len] &amp;&amp; c.len &gt; <span class="number">1</span>)</span><br><span class="line">    c.len--;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  high x, y;</span><br><span class="line">  x.<span class="built_in">in</span>(), y.<span class="built_in">in</span>();</span><br><span class="line">  high z = x + y;</span><br><span class="line">  z.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该好理解。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流--Dinic</title>
      <link href="/posts/cd3d697/"/>
      <url>/posts/cd3d697/</url>
      
        <content type="html"><![CDATA[<h2>过程</h2><p>整体来说，<strong>Dinic</strong> 是不断 <strong>BFS 分层</strong> 和 <strong>DFS 增广</strong> 的过程。</p><h3>BFS 分层</h3><p>每个点的 <strong>层数</strong> 即为它到源点的最短距离，源点的 <strong>层数</strong> 为 <span class="math inline">\(0\)</span>。</p><p>通过它，我们可以发现：</p><ol type="1"><li>当汇点没有 <strong>层数</strong> 时，算法结束。</li><li>当每次搜索只搜比当前点 <strong>层数</strong> 多一的点，我们找到的肯定是最短的增广路。</li></ol><h3>DFS 增广</h3><p><span class="math inline">\(S\)</span> 指源点，<span class="math inline">\(T\)</span> 指汇点，<span class="math inline">\(c_i\)</span> 指边 <span class="math inline">\(i\)</span> 的剩余容量。</p><p>运用分层，我们可以轻易的找到最短增广路。</p><p>从起点开始，每次往下进行搜索，只搜比当前 <strong>层数</strong> 多一的点，当搜到 <span class="math inline">\(T\)</span> 点，结束 <strong>DFS</strong> ，继续 <strong>BFS</strong> 分层。</p><h2>优化</h2><h3>多路增广</h3><p>该优化可让你一次搜到多条增广路。</p><p>当你从某个点回退到上一个点时，若该点还有剩余流量，那我们就考虑对其再进行 <strong>DFS</strong>。</p><h3>当前弧优化</h3><p>该优化可帮你避免不必要的搜索。</p><p>我们知道，当一条边剩余容量为 <span class="math inline">\(0\)</span> 时，他就没有用了。</p><p>这时，我们可以考虑避免对这些边的搜索，把头指针指向下一条边就可以了。</p><p>同时，对于一次 <strong>DFS</strong>，它搜过的边不会再搜第二次，我们运用这个更新指针数组。</p><p><font color=red><strong>BFS</strong> 要更新指针数组</font>。</p><p>时间复杂度：<span class="math inline">\(O(n^2m)\)</span>，该复杂度是理论上限，一般会更小。</p><h2>特殊情况</h2><p>这里只给出结论，证明看 <a href="https://oi-wiki.org/graph/flow/max-flow/#%E7%89%B9%E6%AE%8A%E6%83%85%E5%BD%A2%E4%B8%8B%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">OI-Wiki</a>。</p><p>若图中所有边容量为 <span class="math inline">\(1\)</span>，Dinic 的复杂度为 <span class="math inline">\(\textstyle O(m\min\{m^{\frac{1}{2}},n^{\frac{2}{3}}\})\)</span>。</p><p>若在图中所有边容量为 <span class="math inline">\(1\)</span> 的基础上，除源汇点外每个结点 <span class="math inline">\(u\)</span> 都满足出度为 <span class="math inline">\(1\)</span> 或入度为 <span class="math inline">\(1\)</span>，复杂度为 <span class="math inline">\(O(mn^{\frac{1}{2}})\)</span>。</p><h2>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">205</span>, M = <span class="number">5005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> ll LLINF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> v, nt;</span><br><span class="line">        ll c;</span><br><span class="line">    &#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> hd[N], tot = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll c)</span> </span>&#123; e[++tot] = &#123;v, hd[u], c&#125;, hd[u] = tot; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">uadd</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll c)</span> </span>&#123; <span class="built_in">add</span>(u, v, c), <span class="built_in">add</span>(v, u, <span class="number">0</span>); &#125;</span><br><span class="line">&#125; g;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dinic &#123;</span><br><span class="line"><span class="type">int</span> S, T;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> dep[N], cur[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fill</span>(vis, vis + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(S);</span><br><span class="line">    dep[S] = <span class="number">0</span>, vis[S] = <span class="number">1</span>, cur[S] = g.hd[S];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = g.hd[u]; i; i = g.e[i].nt) &#123;</span><br><span class="line">            <span class="type">int</span> v = g.e[i].v;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; g.e[i].c) &#123;</span><br><span class="line">                dep[v] = dep[u] + <span class="number">1</span>, cur[v] = g.hd[v]; <span class="comment">// 注意还原 cur</span></span><br><span class="line">                vis[v] = <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vis[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, ll f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == T || f == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cur[u]; i; i = g.e[i].nt) &#123;</span><br><span class="line">        <span class="type">int</span> v = g.e[i].v;</span><br><span class="line">        cur[u] = i; <span class="comment">// 当前弧优化</span></span><br><span class="line">        <span class="keyword">if</span> (dep[v] == dep[u] + <span class="number">1</span> &amp;&amp; g.e[i].c) &#123;</span><br><span class="line">            ll t = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(f, g.e[i].c));</span><br><span class="line">            <span class="keyword">if</span> (t) &#123;</span><br><span class="line">                g.e[i].c -= t, g.e[i ^ <span class="number">1</span>].c += t;</span><br><span class="line">                res += t, f -= t;</span><br><span class="line">                <span class="keyword">if</span> (!f) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">flow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>()) flow += <span class="built_in">dfs</span>(S, LLINF);</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace Dinic</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; Dinic::S &gt;&gt; Dinic::T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++) &#123;</span><br><span class="line">        ll c;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; c;</span><br><span class="line">        g.<span class="built_in">uadd</span>(u, v, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; Dinic::<span class="built_in">flow</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://oi-wiki.org/graph/flow/max-flow/">oi-wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> network-flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流--ISAP</title>
      <link href="/posts/fc28d770/"/>
      <url>/posts/fc28d770/</url>
      
        <content type="html"><![CDATA[<p>ISAP 和 Dinic 十分相似，应该比较好懂。</p><p>GAP 则是 ISAP 的优化。</p><h2>简介</h2><p>ISAP 算法，也是运用 <strong>BFS 分层</strong> 和 <strong>DFS 搜索</strong>。</p><p>与 Dinic 区别有两点：</p><ol type="1"><li>只用了一次 BFS 分层，后续层数更新随着 DFS 一起</li><li>因为某些原因，DFS 需要反跑（汇点-&gt;源点）</li></ol><h2>过程</h2><p>因为 ISAP 的 DFS 需要反跑，知道大家肯定打不习惯。</p><p>于是，我们可以反跑 BFS 分层，就可以正跑 DFS（反跑时汇点层数为 0）。</p><p>DFS 时，过程与 Dinic 基本相同，这里不详细展开。</p><h3>更新层数</h3><p>设 <span class="math inline">\(i\)</span> 点的层数为 <span class="math inline">\(d_i\)</span>。</p><p>当我们结束了一次 dfs（没有路可走），我们就要更新层数。</p><p>遍历 <span class="math inline">\(i\)</span> 的所有连点，找到连点中最小的层数，记为 <span class="math inline">\(mind\)</span>，则 <span class="math inline">\(d_i=mind+1\)</span>。</p><p>若点 <span class="math inline">\(i\)</span> 没有连点，则 <span class="math inline">\(d_i=n\)</span>。</p><p>当 <span class="math inline">\(d_s\ge n\)</span>，增广路已被搜完，结束循环。</p><h2>优化</h2><h3>当前弧优化</h3><p>详见 <a href="https://xglight.netlify.app/posts/cd3d697/">Dinic</a>。</p><h3>GAP</h3><p>在 ISAP 算法的基础上，我们加一个数组 <span class="math inline">\(num\)</span>，表示层数为 <span class="math inline">\(i\)</span> 的点有多少个。</p><p>更新层数时同时也更新 <span class="math inline">\(num\)</span>。</p><p>若一次更新后，<span class="math inline">\(num_i=0\)</span>，说明图中出现断层，不需要再搜索，直接退出。</p><h2>时间复杂度</h2><p>时间复杂度：<span class="math inline">\(O(n^2m)\)</span>。</p><p>虽然它与 Dinic 有着同样的理论复杂度，但实际上，GAP 在稠密图上更为优秀，Dinic 在稀疏图上更为优秀。</p><p>但是由于 Dinic 实在太好打了，而且网络流的题目一般 <span class="math inline">\(n\le 300\)</span>，所以一般用 Dinic 就行了。</p><h2>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1205</span>, M = <span class="number">120005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> ll LLINF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> v, nt;</span><br><span class="line">        ll c;</span><br><span class="line">    &#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> hd[N], tot = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll c)</span> </span>&#123; e[++tot] = &#123;v, hd[u], c&#125;, hd[u] = tot; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">uadd</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll c)</span> </span>&#123; <span class="built_in">add</span>(u, v, c), <span class="built_in">add</span>(v, u, <span class="number">0</span>); &#125;</span><br><span class="line">&#125; g;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> GAP &#123;</span><br><span class="line"><span class="type">int</span> S, T;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cur[N], dep[N], num[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> prep[N], pree[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(T);</span><br><span class="line"></span><br><span class="line">    dep[T] = <span class="number">0</span>, vis[T] = <span class="number">1</span>, cur[T] = g.hd[T], num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = g.hd[u]; i; i = g.e[i].nt) &#123;</span><br><span class="line">            <span class="type">int</span> v = g.e[i].v;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; g.e[i ^ <span class="number">1</span>].c) &#123;</span><br><span class="line">                cur[v] = g.hd[v];</span><br><span class="line">                dep[v] = dep[u] + <span class="number">1</span>, vis[v] = <span class="number">1</span>, num[dep[v]]++;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">flow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    ll ans = <span class="number">0</span>, sum = LLINF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cur[i] = g.hd[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> u = S;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dep[S] &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u == T) &#123;</span><br><span class="line">            ans += sum;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x = T; x != S; x = prep[x]) &#123;</span><br><span class="line">                <span class="type">int</span> i = pree[x];</span><br><span class="line">                g.e[i].c -= sum, g.e[i ^ <span class="number">1</span>].c += sum;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            u = S, sum = LLINF;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = cur[u]; i; i = g.e[i].nt) &#123;</span><br><span class="line">            <span class="type">int</span> v = g.e[i].v;</span><br><span class="line">            <span class="keyword">if</span> (g.e[i].c &amp;&amp; dep[u] == dep[v] + <span class="number">1</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                prep[v] = u, pree[v] = i;</span><br><span class="line">                sum = <span class="built_in">min</span>(sum, g.e[i].c);</span><br><span class="line">                u = v;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = g.hd[u]; i; i = g.e[i].nt) &#123;</span><br><span class="line">                <span class="type">int</span> v = g.e[i].v;</span><br><span class="line">                <span class="keyword">if</span> (g.e[i].c) cnt = <span class="built_in">min</span>(cnt, dep[v]);</span><br><span class="line">            &#125;</span><br><span class="line">            --num[dep[u]], dep[u] = cnt + <span class="number">1</span>, num[dep[u]]++;</span><br><span class="line">            <span class="keyword">if</span> (num[dep[u]] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            cur[u] = g.hd[u];</span><br><span class="line">            <span class="keyword">if</span> (u != S) u = prep[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace GAP</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; GAP::S &gt;&gt; GAP::T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++) &#123;</span><br><span class="line">        ll c;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; c, g.<span class="built_in">uadd</span>(u, v, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; GAP::<span class="built_in">flow</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://oi-wiki.org//graph/flow/max-flow/">oi-wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> network-flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流--EK</title>
      <link href="/posts/e15a293a/"/>
      <url>/posts/e15a293a/</url>
      
        <content type="html"><![CDATA[<h2>简介</h2><p><strong>EK</strong> 算法，即 <strong>Edmonds-Karp</strong> 动能算法，是求解最大流的基本算法。</p><h2>反向边</h2><p><strong>反向边</strong> 是帮助程序能发现更优解。</p><details class="toggle" ><summary class="toggle-button" style="">例子</summary><div class="toggle-content"><p>例：</p><p>发现了一条 <span class="math inline">\(* \rightarrow A \rightarrow B \rightarrow *\)</span> 的 <strong>增广路</strong>。</p><p>但后面发现分成两条：</p><p><span class="math inline">\(* \rightarrow C \rightarrow B \rightarrow *\)</span></p><p><span class="math inline">\(* \rightarrow A \rightarrow D \rightarrow *\)</span></p><p>这样比原方案更优。</p></div></details><p>所以要建立一条 <strong>反向边</strong>，<span class="math inline">\(B \rightarrow A\)</span>，让流过去的水能够流回来。</p><h2>建立反向边</h2><h3>链式前向星（链表）</h3><p>在添加 <strong>正向边</strong> 时，也把 <strong>反向边</strong> 给添加（容量为0）。</p><p>这样对于第 i 条边的 <strong>反向边</strong> 是 <span class="math inline">\(i\oplus 1\)</span>（编号请从偶数开始存）</p><h3>邻接矩阵</h3><p>易。</p><h2>过程</h2><p>整体来说，<span class="math inline">\(EK\)</span> 就是一个不断 <strong>BFS</strong> 和 <strong>增广</strong> 的过程。</p><p>下文中，<span class="math inline">\(S\)</span> 指源点，<span class="math inline">\(T\)</span> 指汇点，<span class="math inline">\(c_i\)</span> 指边可通过的容量，<span class="math inline">\(l_i\)</span> 指点 <span class="math inline">\(i\)</span> 的流量。</p><h3>BFS</h3><p>每次从源点出发，进行搜索，若寻找到 <span class="math inline">\(T\)</span>，结束 <strong>BFS</strong> 进行增广。</p><p>假设现在我们要从 <span class="math inline">\(x \rightarrow u\)</span>：</p><ol type="1"><li>先判断是否能到达 <span class="math inline">\(u\)</span>，即 <span class="math inline">\(u\)</span> 是第一次到达且边的可通过的容量大于 <span class="math inline">\(0\)</span>。</li><li>更新 <span class="math inline">\(l_u=min(l_x,c_i)\)</span>。</li><li>记录这条边，最后要反跑找到的路径以更新容量，注意，此时不能直接更新流量，因为不确定该增广路的最大可流流量。</li><li>遇到 <span class="math inline">\(T\)</span> 后，跳出 <strong>BFS</strong>，即找到任意一条增广路就跳出。</li></ol><h3>增广</h3><p>反跑增广路。</p><p>此时 <span class="math inline">\(l_t\)</span> 即为该增广路的最大可流流量。</p><p>所以正向边的可通过容量 <span class="math inline">\(-l_t\)</span>，即反向边的可通过容量 <span class="math inline">\(+l_t\)</span>。</p><p>答案显然也 <span class="math inline">\(+l_t\)</span>。</p><p>就这样不断 <strong>BFS</strong> 和 <strong>增广</strong>，直到跑不到 <span class="math inline">\(T\)</span>。</p><p>时间复杂度：<span class="math inline">\(O(nm^2)\)</span>。</p><h2>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, M = <span class="number">2e6</span> + <span class="number">5</span>; <span class="comment">// 点数，边数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> ll LLINF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> v, nt;</span><br><span class="line">        ll c; <span class="comment">// 可通过流量</span></span><br><span class="line">    &#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> hd[N], tot = <span class="number">1</span>; <span class="comment">// 注意从 2 开始对边编号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll c)</span> </span>&#123; e[++tot] = &#123;v, hd[u], c&#125;, hd[u] = tot; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">uadd</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll c)</span> </span>&#123; <span class="built_in">add</span>(u, v, c), <span class="built_in">add</span>(v, u, <span class="number">0</span>); &#125;</span><br><span class="line">&#125; g;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> EK &#123;</span><br><span class="line"><span class="type">int</span> S, T;             <span class="comment">// 源点，汇点</span></span><br><span class="line"><span class="type">int</span> prep[N], pree[N]; <span class="comment">// 前驱点，前驱边</span></span><br><span class="line">ll l[N];</span><br><span class="line"><span class="function">ll <span class="title">flow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ph;</span><br><span class="line">        q.<span class="built_in">push</span>(S);</span><br><span class="line">        l[S] = LLINF;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>(), ph.<span class="built_in">push_back</span>(u);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = g.hd[u]; i; i = g.e[i].nt) &#123;</span><br><span class="line">                <span class="type">int</span> v = g.e[i].v;</span><br><span class="line">                <span class="keyword">if</span> (!l[v] &amp;&amp; g.e[i].c) &#123;</span><br><span class="line">                    prep[v] = u, pree[v] = i;</span><br><span class="line">                    l[v] = <span class="built_in">min</span>(l[u], g.e[i].c);</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l[T]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!l[T]) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u : ph) l[u] = <span class="number">0</span>; <span class="comment">// 重置边的流量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = T; u != S; u = prep[u]) &#123;</span><br><span class="line">            <span class="type">int</span> i = pree[u];</span><br><span class="line">            g.e[i].c -= l[T], g.e[i ^ <span class="number">1</span>].c += l[T];</span><br><span class="line">        &#125;</span><br><span class="line">        res += l[T];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace EK</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; EK::S &gt;&gt; EK::T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v, c; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; c;</span><br><span class="line">        g.<span class="built_in">uadd</span>(u, v, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; EK::<span class="built_in">flow</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://oi-wiki.org//graph/flow/max-flow/">oi-wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> network-flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流--概念篇</title>
      <link href="/posts/7f952e35/"/>
      <url>/posts/7f952e35/</url>
      
        <content type="html"><![CDATA[<h2>网络</h2><p>网络表示一个有向图（可能有环），<span class="math inline">\(G=(V,E)\)</span>。</p><p>每条边 <span class="math inline">\((u,v)\in E\)</span> 都有一个权值 <span class="math inline">\(c(u,v)\)</span>，称之为容量，对于 <span class="math inline">\((u,v)\notin E\)</span>，均有 <span class="math inline">\(c(u,v)=0\)</span>。</p><p>其中有两个点，<span class="math inline">\(s\in V\)</span> 源点（没有入度）和 <span class="math inline">\(t\in V\)</span> 汇点。（没有出度）</p><h2>流</h2><p>设 <span class="math inline">\(f(u,v)\)</span> 定义在二元组 <span class="math inline">\((u\in V,v\in V)\)</span> 上的实数函数且满足：</p><ol type="1"><li>容量限制：对于每条边，流经该边的流量不得超过该边的容量，即 <span class="math inline">\(f(u,v)\le c(u,v)\)</span>。</li><li>斜对称性：每条边的流量与其相反边的流量之和为 <span class="math inline">\(0\)</span>，即 <span class="math inline">\(f(u,v)=-f(v,u)\)</span>。</li><li>流守恒性：从源点流出的流量等于汇点流入的流量，即 <span class="math inline">\(\forall x\in V-{s,t}, {\textstyle \sum_{(u,x)\in E}}f(u,x)={\textstyle \sum_{x,v\in E}}f(x,v)\)</span>。</li></ol><p>那么 <span class="math inline">\(f\)</span> 称为网络 <span class="math inline">\(G\)</span> 的流函数。对于 <span class="math inline">\((u,v)\in E\)</span>，<span class="math inline">\(f(u,v)\)</span>称为边的 <strong>流量</strong>，<span class="math inline">\(c(u,v)-f(u,v)\)</span> 称为边的 <strong>剩余容量</strong>。</p><p>整个网络的流量为：<span class="math inline">\(\sum_{(s,v)\in E}f(s,v)\)</span>，即 <strong>从源点发出的所有流量之和</strong>。</p><p>一般而言也可以把网络流理解为整个图的流量，而这个流量必满足上述三个性质。</p><details class="toggle" ><summary class="toggle-button" style="">流函数的完整定义</summary><div class="toggle-content"><p><span class="math display">\[f(u,v) =   \begin{cases}f(u,v) &amp; (u,v)\in E\\-f(v,u) &amp; (v,u)\in E\\0 &amp; (u,v)\notin E,(v,u)\notin E\end{cases}\]</span></p></div></details><h2>网络流的常见问题</h2><p>网络流问题中常见的有以下三种：最大流，最小割，费用流。</p><h3>最大流</h3><p>我们有一张图，要求从源点流向汇点的最大流量（可以有很多条路到达汇点）。</p><h3>最小费用最大流</h3><p>每条边都有一个费用，代表单位流量流过这条边的开销。我们要在求出最大流的同时，要求花费的费用最小。</p><h3>最小割</h3><p>割其实就是删边的意思，就是割掉 <span class="math inline">\(X\)</span> 条边来让 <span class="math inline">\(S\)</span> 跟 <span class="math inline">\(T\)</span> 不互通。我们要求 <span class="math inline">\(X\)</span> 条边加起来的流量总和最小。</p><h2>残量网络</h2><p>一条边的 <strong>剩余容量</strong> 指条边还可以通过的流量，即 <span class="math inline">\(c(u,v)-f(u,v)\)</span>，在实际应用中，我们也通常只关心剩余容量。</p><p>对于流函数 <span class="math inline">\(f\)</span>，<span class="math inline">\(G_f\)</span> 残量网络是网络 <span class="math inline">\(G\)</span> 中所有结点 <strong>和剩余容量大于 <span class="math inline">\(0\)</span></strong> 的边构成的子图。</p><p>形式化的定义，即 <span class="math inline">\(G_f=(V_f=V,E_f=\left\{(u,v)\in E,c_f(u,v)&gt;0\right\})\)</span>。</p><p>注意，剩余容量大于 <span class="math inline">\(0\)</span> 的边可能不在原图 <span class="math inline">\(G\)</span> 中（根据容量、剩余容量的定义以及流函数的斜对称性得到）。可以理解为，残量网络中包括了那些还剩了流量空间的边构成的图，也包括虚边（即反向边）。</p><h2>增广路</h2><p>在原图 G 中若一条从源点到汇点的路径上所有边的 <strong>剩余容量都大于0</strong> 这条路被称为增广路。</p><p>或者说，在残量网络 <span class="math inline">\(G_f\)</span> 中，一条从源点到汇点的路径被称为增广路。</p><p>参考：<a href="https://oi-wiki.org//graph/flow/max-flow/">OI WIKI</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> network-flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵</title>
      <link href="/posts/7d16c0e9/"/>
      <url>/posts/7d16c0e9/</url>
      
        <content type="html"><![CDATA[<h2>定义</h2><p>矩阵是一个 <span class="math inline">\(n\)</span> 行 <span class="math inline">\(m\)</span> 列的的表格</p><p>也可以看成一个二维数组</p><h2>矩阵乘法</h2><h3>方法</h3><p>设 <span class="math inline">\(A\)</span> 为 <span class="math inline">\(m*d\)</span> 的矩阵，<span class="math inline">\(B\)</span> 为 <span class="math inline">\(d*n\)</span> 的矩阵</p><p><span class="math inline">\(C=A*B\)</span></p><p>则 <span class="math inline">\(C\)</span> 为 <span class="math inline">\(m*n\)</span> 的矩阵</p><p><span class="math inline">\(C_{i,j}=\sum\limits_{k=1}^{d}A_{i,k}*B_{k,j}\)</span></p><p>即：</p><p><span class="math inline">\(\begin{bmatrix}a1&amp;a2\\a3&amp;a4\end{bmatrix}*\begin{bmatrix}  b1&amp;b2\\b3&amp;b4\end{bmatrix}=\begin{bmatrix}c1&amp;c2\\c3&amp;c4\end{bmatrix}\)</span></p><p><span class="math inline">\(c1=a1*b1+a2*b3\)</span></p><p><span class="math inline">\(c2=a1*b2+a2*b4\)</span></p><p><span class="math inline">\(c3=a3*b1+a4*b3\)</span></p><p><span class="math inline">\(c4=a3*b2+a4*b4\)</span></p><p>例：</p><p><span class="math inline">\(\begin{bmatrix}5&amp;5 \\6&amp;7\end{bmatrix}*\begin{bmatrix}3&amp;2 \\7&amp;4\end{bmatrix}=\begin{bmatrix}50&amp;30 \\67&amp;40\end{bmatrix}\)</span></p><p><span class="math inline">\(50=5*3+5*7\)</span></p><p><span class="math inline">\(30=5*2+5*4\)</span></p><p><span class="math inline">\(67=6*3+7*7\)</span></p><p><span class="math inline">\(40=6*2+7*4\)</span></p><h3>定律</h3><p>结合律：<span class="math inline">\((A*B)*C=A*(B*C)\)</span></p><p><font color=red>没有交换律，<span class="math inline">\(\color{red}A*B\neq B*A\)</span>，矩阵内的数也不能随意交换</font></p><h3>矩阵快速幂</h3><p>其实就是快速幂……</p><p>为了方便，可以重载运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="type">int</span> mx[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">in</span><span class="params">(matrix &amp;x)</span></span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x.n,&amp;x.m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=x.n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">1</span>;j&lt;=x.m;j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x.mx[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(matrix x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=x.n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">1</span>;j&lt;=x.m;j++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x.mx[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(matrix &amp;x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">104</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">104</span>;j++) x.mx[i][j]=<span class="number">0</span>;</span><br><span class="line">        x.n=x.m=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">matrix <span class="keyword">operator</span> *(matrix x,matrix y)&#123;</span><br><span class="line">    matrix z;</span><br><span class="line">    z.<span class="built_in">init</span>(z);</span><br><span class="line">    z.n=x.n,z.m=y.m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=z.n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=z.m;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=x.m;k++)&#123;</span><br><span class="line">                z.mx[i][j]+=(x.mx[i][k]*y.mx[k][j])%mod,z.mx[i][j]%=mod;</span><br><span class="line">              &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">matrix <span class="title">fp</span><span class="params">(matrix x,<span class="type">long</span> <span class="type">long</span> p)</span></span>&#123;</span><br><span class="line">    matrix z;</span><br><span class="line">    z.<span class="built_in">init</span>(z);</span><br><span class="line">    z.n=x.n,z.m=x.m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=z.n;i++) z.mx[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p&amp;<span class="number">1</span>) z=z*x;</span><br><span class="line">        x=x*x;</span><br><span class="line">        p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line">matrix a,b,c;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a.<span class="built_in">init</span>(a),b.<span class="built_in">init</span>(b);</span><br><span class="line">    a.<span class="built_in">in</span>(a),b.<span class="built_in">in</span>(b);</span><br><span class="line">    a.<span class="built_in">print</span>(a);</span><br><span class="line">    b.<span class="built_in">print</span>(b);</span><br><span class="line">    c=a*b;</span><br><span class="line">    c.<span class="built_in">print</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>应用</h2><h3>求斐波那契数列的第<span class="math inline">\(n\)</span>项</h3><p>我们都知道：<span class="math inline">\(f_n=f_{n-1}+f_{n-2}\)</span></p><p>但当 <span class="math inline">\(n\)</span> 非常大时，这个会 TLE</p><p>所以我们可以运用矩阵乘法的思想，先上公式</p><p><span class="math inline">\(\begin{bmatrix}f_n&amp;f_{n-1}\end{bmatrix}=\begin{bmatrix}f_{n-1}&amp;f_{n-2}\end{bmatrix}*\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}\)</span></p><p>我们再来推一遍：</p><p><span class="math inline">\(f_n=f_{n-1}+f_{n-2}\\f_{n-1}=f_{n-1}\)</span></p><p>接着，我们把 <span class="math inline">\(A\)</span> 设为 <span class="math inline">\(\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}\)</span></p><p><span class="math inline">\(即A=\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}\)</span></p><p>那不难推出：</p><p><span class="math inline">\(\begin{bmatrix}f_n&amp;f_{n-1}\end{bmatrix}=\begin{bmatrix}f_{n-2}&amp;f_{n-3}\end{bmatrix}*A^2\)</span></p><p>继续往下一直推：</p><p><span class="math inline">\(\begin{bmatrix}f_n&amp;f_{n-1}\end{bmatrix}=\begin{bmatrix}f_2&amp;f_1\end{bmatrix}*A^{n-2}\)</span></p><p>这样，我们就可以用 <span class="math inline">\(O\left(\log n\right)\)</span> 的复杂度求出斐波那契数列的第 n 项</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> nn,mod=<span class="number">10000000007</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n,m;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mx[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">in</span><span class="params">(matrix &amp;x)</span></span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x.n,&amp;x.m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=x.n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">1</span>;j&lt;=x.m;j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x.mx[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(matrix x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=x.n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">1</span>;j&lt;=x.m;j++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x.mx[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(matrix &amp;x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">104</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">104</span>;j++) x.mx[i][j]=<span class="number">0</span>;</span><br><span class="line">        x.n=x.m=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">matrix <span class="keyword">operator</span> *(matrix x,matrix y)&#123;</span><br><span class="line">    matrix z;</span><br><span class="line">    z.<span class="built_in">init</span>(z);</span><br><span class="line">    z.n=x.n,z.m=y.m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=z.n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=z.m;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=x.m;k++)&#123;</span><br><span class="line">                z.mx[i][j]+=(x.mx[i][k]*y.mx[k][j])%mod,z.mx[i][j]%=mod;</span><br><span class="line">              &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">matrix <span class="title">fp</span><span class="params">(matrix x,<span class="type">long</span> <span class="type">long</span> p)</span></span>&#123;</span><br><span class="line">    matrix z;</span><br><span class="line">    z.<span class="built_in">init</span>(z);</span><br><span class="line">    z.n=x.n,z.m=x.m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=z.n;i++) z.mx[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p&amp;<span class="number">1</span>) z=z*x;</span><br><span class="line">        x=x*x;</span><br><span class="line">        p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line">matrix a,f;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;nn);</span><br><span class="line">    f.<span class="built_in">init</span>(f),a.<span class="built_in">init</span>(a);</span><br><span class="line">    f.n=<span class="number">1</span>,f.m=<span class="number">2</span>;</span><br><span class="line">    f.mx[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>,f.mx[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    a.m=a.n=<span class="number">2</span>;</span><br><span class="line">    a.mx[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>,a.mx[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    a.mx[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>,a.mx[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    a=<span class="built_in">fp</span>(a,nn<span class="number">-2</span>);</span><br><span class="line">    f=f*a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f.mx[<span class="number">1</span>][<span class="number">1</span>]%mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>求斐波那契数列前n项的和</h3><p>先来波证明：</p><p>设 <span class="math inline">\(S_n\)</span> 为斐波那契数列前 <span class="math inline">\(n\)</span> 项和</p><p><span class="math inline">\(S_n=f_1+f_2+\dots +f_{n-1}+f_n\)</span></p><p>将右式变一下</p><p><span class="math inline">\(S_n=\textcolor{red}{f_2}+f_1+f_2+\dots +f_{n-1}+f_n-\textcolor{red}{f_2}\)</span></p><p><span class="math inline">\(\because f_n=f_{n-1}+f_{n-2}\)</span></p><p><span class="math inline">\(\therefore S_n=f_3+f_2+f_3+f_4+\dots +f_{n-1}+f_n-f_2\)</span></p><p><span class="math inline">\(\therefore S_n=f_4+f_3+f_4+f_5+\dots +f_{n-1}+f_n-f_2\)</span></p><p>以此类推：</p><p><span class="math inline">\(S_n=f_{n+1}+f_n-f_2\)</span></p><p>即 <span class="math inline">\(S_n=f_{n+1}+f_n-1\)</span></p><p>或 <span class="math inline">\(S_n=f_{n+2}-1\)</span></p><p>不知各位看懂了没？</p><p>得到了最后一条式子，应该都会了吧</p><h3>求斐波那契数列第x项到第y项的和</h3><p>前缀和思想</p><p>求 <span class="math inline">\(S_y\)</span> 与 <span class="math inline">\(S_{x-1}\)</span> 再一减</p><p>完事</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 爬虫获取随机二次元图片</title>
      <link href="/posts/bacd02e2/"/>
      <url>/posts/bacd02e2/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>不想看的可直接到 <code>实践</code> 部分拿源码。</p></div><div class="note info flat"><p>本文将以 Python 3.9 环境下进行爬虫实践。</p></div><p>此文顺便作为 Python 爬虫入门教程，主要介绍 Python 爬虫的原理、使用方法、实践。</p><h2>爬虫简介</h2><p>爬虫（Web Crawler）是一种按照一定的规则，自动地抓取互联网信息的程序或者脚本。它是一种高效的网络数据采集工具，可以用来获取大量的有用信息。</p><h2>前言</h2><p>Python 是一种高级的、跨平台的、解释型的编程语言，它有着丰富的网络爬虫库，可以用来进行网络数据采集，而且便于书写和阅读，十分方便。</p><div class="note info flat"><p>本文将以 Python 3.9 环境下进行爬虫实践。</p></div><h2>前置</h2><h3>Python 3.9 安装</h3><p>此处不再赘述，请自行安装 Python 3.9 环境，可以在网络上搜索相关教程。</p><h3>安装第三方库</h3><p>本文使用到的第三方库有：</p><ul><li>requests：用于发送 HTTP 请求</li><li>BeautifulSoup4：用于解析 HTML 文档</li></ul><p>pip 安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure><h2>爬虫原理</h2><p>爬虫的原理是模拟浏览器行为，向服务器发送 HTTP 请求，获取网页内容，然后分析网页内容，提取有效信息。</p><p>HTTP 请求有多种，常用的有两种 GET 和 POST。</p><ul><li>GET 请求：浏览器地址栏输入网址，按下回车后，浏览器会向服务器发送 GET 请求，获取网页内容。简单来说，<strong>就是获取信息</strong>。</li><li>POST 请求：表单提交，浏览器会向服务器发送 POST 请求，提交表单数据。简单来说，<strong>就是提交信息</strong>。</li></ul><p>本文仅介绍 GET 请求的爬虫实践。</p><h2>入门</h2><h3>requests 库</h3><p>requests 库是 Python 中用于发送 HTTP 请求的库，可以发送 GET 请求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://example.com&#x27;</span></span><br><span class="line"></span><br><span class="line">response = requests.get(url = url) <span class="comment"># 发送 GET 请求</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(response.status_code)  <span class="comment"># 打印响应状态码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(response.text)  <span class="comment"># 打印响应内容</span></span><br></pre></td></tr></table></figure><h4>requests.get() 方法</h4><p><code>requests.get()</code> 方法返回一个 Response 对象，包含了服务器响应的状态码、内容等信息，下面是部分常用参数说明。</p><table><thead><tr class="header"><th style="text-align: center;">参数</th><th style="text-align: center;">接受类型</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">url</td><td style="text-align: center;"><code>str</code></td><td style="text-align: center;">请求的 URL 地址</td></tr><tr class="even"><td style="text-align: center;">headers</td><td style="text-align: center;"><code>dict</code></td><td style="text-align: center;">请求头信息</td></tr><tr class="odd"><td style="text-align: center;">timeout</td><td style="text-align: center;"><code>int</code></td><td style="text-align: center;">超时时间(秒，超时后停止)</td></tr></tbody></table><p><code>headers</code> 参数可以设置请求头信息，就是浏览器的唯一身份标识，比如 User-Agent、Cookie 等，可以通过 <a href="https://tool.ip138.com/useragent/">https://tool.ip138.com/useragent/</a> 获取 <code>User-Agent</code> 值，一般也只需要 <code>User-Agent</code> 即可。</p><p>设置方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;sample user agent&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">&#x27;https://example.com&#x27;</span></span><br><span class="line">response = requests.get(url = url, headers = headers)</span><br></pre></td></tr></table></figure><h4>响应状态码</h4><p>响应状态码（status code）是 HTTP 协议中用于表示请求状态的三位数字代码，常见的有：</p><ul><li>2xx: 成功</li><li>3xx: 重定向</li><li>4xx: 客户端错误</li><li>5xx: 服务器错误</li></ul><h4>响应内容</h4><p>响应内容（response content）是服务器返回给客户端的内容，可以是 HTML 文档、JSON 数据、图片、视频等。</p><p><code>response.text</code> 属性可以获取响应内容的文本形式，<code>response.content</code> 属性可以获取响应内容的字节形式。</p><h3>BeautifulSoup4 库</h3><p>BeautifulSoup4 库是 Python 中用于解析 HTML 文档的库，可以提取 HTML 文档中的有效信息。</p><p>简单示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Example&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;h1&gt;Hello World&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;This is a paragraph.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)  <span class="comment"># 解析 HTML 文档</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.title)  <span class="comment"># 打印 title 标签内容</span></span><br><span class="line"><span class="built_in">print</span>(soup.body)  <span class="comment"># 打印 body 标签内容</span></span><br><span class="line"><span class="built_in">print</span>(soup.body.h1.text)  <span class="comment"># 打印 h1 标签内容</span></span><br></pre></td></tr></table></figure><h4>html 文档结构</h4><p>先介绍一下 html 文档的结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;html&gt;</code> 标签是 HTML 文档的根标签，包含了整个文档的结构。</li><li><code>&lt;head&gt;</code> 标签包含了文档的元信息，比如标题、关键字、描述、作者、脚本等。</li><li><code>&lt;body&gt;</code> 标签包含了文档的主要内容，比如文本、图片、视频、表格等。</li><li><code>&lt;title&gt;</code> 标签包含了文档的标题。</li></ul><p>对于一个 html 元素，比如 <code>&lt;h1&gt;Hello World&lt;/h1&gt;</code>，它的父标签是 <code>&lt;body&gt;</code>，它的兄弟标签是 <code>&lt;p&gt;This is a paragraph.&lt;/p&gt;</code>，他的内容是 “Hello World”。</p><p>一个 html 元素能有一些属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://example.com&quot;</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!-- 超链接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://example.com/image.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Example Image&quot;</span>&gt;</span> <span class="comment">&lt;!-- 图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;example&quot;</span>&gt;</span> <span class="comment">&lt;!-- 输入框 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;example&quot;</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 类名为 &quot;example&quot; 的段落 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- id 为 &quot;example&quot; 的段落 --&gt;</span></span><br></pre></td></tr></table></figure><h4>解析方法</h4><p>下面是一些简单的解析方法：</p><table><thead><tr class="header"><th style="text-align: center;">方法</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>find('tag')</code></td><td style="text-align: center;">查找第一个匹配的标签</td></tr><tr class="even"><td style="text-align: center;"><code>find(name = "example")</code></td><td style="text-align: center;">查找第一个 name 属性值为 “example” 的标签</td></tr><tr class="odd"><td style="text-align: center;"><code>find_all('tag')</code></td><td style="text-align: center;">查找所有匹配的标签</td></tr><tr class="even"><td style="text-align: center;"><code>find_all(name = "example")</code></td><td style="text-align: center;">查找所有 name 属性值为 “example” 的标签</td></tr><tr class="odd"><td style="text-align: center;"><code>find_parent('tag')</code></td><td style="text-align: center;">查找 tag 标签的父标签</td></tr><tr class="even"><td style="text-align: center;"><code>find_next_sibling()</code></td><td style="text-align: center;">查找下一个兄弟标签</td></tr><tr class="odd"><td style="text-align: center;"><code>find_previous_sibling()</code></td><td style="text-align: center;">查找上一个兄弟标签</td></tr></tbody></table><div class="note info flat"><p>在 <code>name = "example"</code> 中，因为 <code>class</code> 是 Python 的关键字，所以用 <code>_class</code> 替代。</p></div><h3>示例</h3><p>下面是一个简单的爬虫示例，爬取 <a href="https://www.python.org">https://www.python.org</a> 首页的标题、链接、描述、图片等信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.python.org&#x27;</span></span><br><span class="line"></span><br><span class="line">response = requests.get(url = url)</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(response.text, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line"></span><br><span class="line">title = soup.find(<span class="string">&#x27;h1&#x27;</span>, class_ = <span class="string">&#x27;page-title&#x27;</span>).text.strip()  <span class="comment"># 标题</span></span><br><span class="line">description = soup.find(<span class="string">&#x27;meta&#x27;</span>, attrs = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;description&#x27;</span>&#125;)[<span class="string">&#x27;content&#x27;</span>]  <span class="comment"># 描述</span></span><br><span class="line">image = soup.find(<span class="string">&#x27;img&#x27;</span>, class_ = <span class="string">&#x27;logo&#x27;</span>)[<span class="string">&#x27;src&#x27;</span>]  <span class="comment"># 图片</span></span><br><span class="line">links = [a[<span class="string">&#x27;href&#x27;</span>] <span class="keyword">for</span> a <span class="keyword">in</span> soup.find_all(<span class="string">&#x27;a&#x27;</span>, class_ = <span class="string">&#x27;headerlink&#x27;</span>)]  <span class="comment"># 链接</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;标题：&#x27;</span>, title)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;描述：&#x27;</span>, description)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;图片：&#x27;</span>, image)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;链接：&#x27;</span>, links)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">标题： Welcome to Python.org</span><br><span class="line">描述： The official home of the Python Programming Language</span><br><span class="line">图片： https://www.python.org/static/img/python-logo@2x.png</span><br><span class="line">链接： [&#x27;https://www.python.org/downloads/&#x27;, &#x27;https://www.python.org/downloads/source/&#x27;, &#x27;https://www.python.org/downloads/windows/&#x27;, &#x27;https://www.python.org/downloads/mac-osx/&#x27;, &#x27;https://www.python.org/downloads/linux/&#x27;, &#x27;https://www.python.org/doc/&#x27;, &#x27;https://www.python.org/doc/essays/&#x27;, &#x27;https://www.python.org/doc/essays/blurb/&#x27;, &#x27;https://www.python.org/doc/essays/ppt/&#x27;, &#x27;https://www.python.org/community/&#x27;, &#x27;https://www.python.org/community/sigs/&#x27;, &#x27;https://www.python.org/community/lists/&#x27;, &#x27;https://www.python.org/community/awards/&#x27;, &#x27;https://www.python.org/psf/&#x27;, &#x27;https://www.python.org/psf/records/&#x27;, &#x27;https://www.python.org/jobs/&#x27;, &#x27;https://www.python.org/events/&#x27;, &#x27;https://www.python.org/events/python-events/&#x27;, &#x27;https://www.python.org/events/python-user-group/&#x27;, &#x27;https://www.python.org/events/python-events/past/&#x27;, &#x27;https://www.python.org/events/python-events/upcoming/&#x27;, &#x27;https://www.python.org/events/python-events/calendar/&#x27;, &#x27;https://www.python.org/events/python-events/python-events-calendar/&#x27;, &#x27;https://www.python.org/events/python-events/python-events-calendar/&#x27;]</span><br></pre></td></tr></table></figure><h2>进阶</h2><p>有时候我们会抱怨，爬虫速度太慢，有没有办法提高爬虫速度，就怪在了 Python 的运行速度上？</p><p>实际上，网络爬虫的速度主要取决于网络的连接速率，对于小项目 Python 的速度是足够的。</p><p>但是网络的连接速率并不是无限的，所以我们需要考虑如何提高爬虫的速度。</p><h3>多线程</h3><p>多线程是提高爬虫速度的一种方法，它可以让多个线程同时运行，同时发送多个网络请求，从而提高爬虫的速度。</p><p>Python 的 <code>threading</code> 库提供了多线程的支持，我们可以用它来实现多线程爬虫。</p><p>这里建议使用线程池，线程池可以管理线程，可以自动分配线程，减少线程创建和销毁的开销。</p><p>需要库：<code>concurrent.futures</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_page</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="comment"># 获取信息</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://example.com/&#x27;</span></span><br><span class="line"></span><br><span class="line">url_list = [url + <span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>)]  <span class="comment"># 构造 URL 列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">20</span>) <span class="keyword">as</span> executor: <span class="comment"># max_workers 线程数</span></span><br><span class="line">    futures = [executor.submit(get_page, url) <span class="keyword">for</span> url <span class="keyword">in</span> url_list] <span class="comment"># 构造线程池</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(futures):</span><br><span class="line">        <span class="keyword">if</span> future.done():</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = future.result() <span class="comment"># 函数返回值</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(e))</span><br></pre></td></tr></table></figure><h3>浏览器指纹</h3><p>对于一些网站会增加一些反爬虫机制，浏览器指纹是一种通过分析浏览器特征来判断其是否为正常浏览器的一种方法。</p><p>通过浏览器指纹我们可以绕开一些反爬虫机制，比如通过浏览器指纹来判断是否为正常浏览器。</p><p>这里使用第三方库 <code>curl_cffi</code> 来获取浏览器指纹。</p><p>pip 安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install curl_cffi</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> curl_cffi <span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://example.com&#x27;</span></span><br><span class="line"></span><br><span class="line">r = requests.get(url = url, impersonate=<span class="string">&quot;chrome101&quot;</span>) <span class="comment"># impersonate 指定浏览器</span></span><br></pre></td></tr></table></figure><h2>实践</h2><p>这里使用随机图片 API 来获取随机二次元图片。</p><p>API 网址大全：<a href="https://blog.jixiaob.cn/?post=93">https://blog.jixiaob.cn/?post=93</a></p><p>这里以 <a href="https://api.lolicon.app/#/setu">https://api.lolicon.app/#/setu</a> 为例。</p><h3>API 介绍</h3><p>API 是 Application Programming Interface 的缩写，它是一些预先定义的函数，通过这些函数，我们可以访问到一些服务或资源。</p><p>一般请求 API 可以添加一些参数。</p><p>例如对于 API : <code>example.com/api?key=value</code>，我们可以添加参数 <code>key=value</code> 来指定请求的条件。</p><p>对于多个参数，我们可以用 <code>&amp;</code> 连接，例如 <code>example.com/api?key1=value1&amp;key2=value2</code>。</p><h3>爬虫实践</h3><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">Lolicon API</button><button type="button" class="tab">Anosu API</button></div><div class="tab-contents"><div class="tab-item-content active"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">headers = &#123;  <span class="comment"># 请求头</span></span><br><span class="line">    <span class="string">&quot;user-agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">json_path = <span class="string">&quot;config.json&quot;</span>  <span class="comment"># 配置文件路径</span></span><br><span class="line">out_path = <span class="string">&quot;graph&quot;</span>  <span class="comment"># 输出文件夹路径</span></span><br><span class="line">max_flow = <span class="number">4</span>  <span class="comment"># 最大线程数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_json</span>():</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(json_path):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(json_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">return</span> json.load(f)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        js = &#123;<span class="string">&quot;number&quot;</span>: <span class="number">0</span>, <span class="string">&quot;graph&quot;</span>: []&#125;</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(json_path, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            json.dump(js, f, indent=<span class="number">4</span>, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> js</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_image</span>(<span class="params"><span class="built_in">id</span>,url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在下载图片：id-&#123;&#125;  url-&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>,url))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: 无法访问图片：id-&#123;&#125;  url-&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>,url))</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        suffix = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> url.endswith(<span class="string">&quot;.png&quot;</span>):</span><br><span class="line">            suffix = <span class="string">&quot;.png&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> url.endswith(<span class="string">&quot;.jpg&quot;</span>):</span><br><span class="line">            suffix = <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> url.endswith(<span class="string">&quot;.jpeg&quot;</span>):</span><br><span class="line">            suffix = <span class="string">&quot;.jpeg&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error: 图片格式不支持：id-&#123;&#125;  url-&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>,url))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;成功下载图片：id-&#123;&#125;  url-&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>,url))</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(out_path, <span class="built_in">str</span>(<span class="built_in">id</span>) + suffix), <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(response.content)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">id</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: 无法下载图片：id-&#123;&#125;  url-&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>,url))</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_url</span>(<span class="params">cnt</span>):</span><br><span class="line">    <span class="keyword">global</span> js</span><br><span class="line">    <span class="built_in">id</span> = cnt</span><br><span class="line">    <span class="comment"># https://api.lolicon.app/#/setu</span></span><br><span class="line">    url = <span class="string">&quot;https://api.lolicon.app/setu/v2?num=20&quot;</span></span><br><span class="line">    r = requests.get(url, headers=headers)  <span class="comment"># 发送请求</span></span><br><span class="line">    data = json.loads(r.text)  <span class="comment"># 解析json数据</span></span><br><span class="line">    data = data[<span class="string">&quot;data&quot;</span>]</span><br><span class="line">    url_list = []</span><br><span class="line">    image_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        image_url = i[<span class="string">&quot;urls&quot;</span>][<span class="string">&quot;original&quot;</span>]</span><br><span class="line">        f = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> js[<span class="string">&quot;graph&quot;</span>]:</span><br><span class="line">            <span class="keyword">if</span> j[<span class="string">&quot;url&quot;</span>] == image_url:</span><br><span class="line">                f = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> f == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="built_in">id</span>+=<span class="number">1</span></span><br><span class="line">        url_list.append((<span class="built_in">id</span>,image_url))</span><br><span class="line">        image_list.append(i)</span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=max_flow) <span class="keyword">as</span> executor:</span><br><span class="line">        futures = [executor.submit(get_image, <span class="built_in">id</span>, image_url) <span class="keyword">for</span> <span class="built_in">id</span>,image_url <span class="keyword">in</span> url_list]</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(futures):</span><br><span class="line">            <span class="keyword">if</span> future.done():</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    result = future.result()</span><br><span class="line">                    <span class="keyword">if</span> result == -<span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    js[<span class="string">&quot;number&quot;</span>] = <span class="built_in">max</span>(js[<span class="string">&quot;number&quot;</span>], result)</span><br><span class="line">                    js[<span class="string">&quot;graph&quot;</span>].append(image_list[result-cnt-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(e))</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(json_path, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            json.dump(js, f, indent=<span class="number">4</span>, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(out_path):</span><br><span class="line">    os.mkdir(out_path)</span><br><span class="line"></span><br><span class="line">js = load_json()</span><br><span class="line"></span><br><span class="line">cnt = js[<span class="string">&quot;number&quot;</span>]</span><br><span class="line"></span><br><span class="line">get_url(cnt)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下载完成&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">headers = &#123;  <span class="comment"># 请求头</span></span><br><span class="line">    <span class="string">&quot;user-agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">json_path = <span class="string">&quot;config.json&quot;</span>  <span class="comment"># 配置文件路径</span></span><br><span class="line">out_path = <span class="string">&quot;graph&quot;</span>  <span class="comment"># 输出文件夹路径</span></span><br><span class="line">max_flow = <span class="number">4</span>  <span class="comment"># 最大线程数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_json</span>():</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(json_path):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(json_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">return</span> json.load(f)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        js = &#123;<span class="string">&quot;number&quot;</span>: <span class="number">0</span>, <span class="string">&quot;graph&quot;</span>: []&#125;</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(json_path, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            json.dump(js, f, indent=<span class="number">4</span>, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> js</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_image</span>(<span class="params"><span class="built_in">id</span>,url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正在下载图片：id-&#123;&#125;  url-&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>,url))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: 无法访问图片：id-&#123;&#125;  url-&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>,url))</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        suffix = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> url.endswith(<span class="string">&quot;.png&quot;</span>):</span><br><span class="line">            suffix = <span class="string">&quot;.png&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> url.endswith(<span class="string">&quot;.jpg&quot;</span>):</span><br><span class="line">            suffix = <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> url.endswith(<span class="string">&quot;.jpeg&quot;</span>):</span><br><span class="line">            suffix = <span class="string">&quot;.jpeg&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error: 图片格式不支持：id-&#123;&#125;  url-&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>,url))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;成功下载图片：id-&#123;&#125;  url-&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>,url))</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(out_path, <span class="built_in">str</span>(<span class="built_in">id</span>) + suffix), <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(response.content)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">id</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Error: 无法下载图片：id-&#123;&#125;  url-&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">id</span>,url))</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_url</span>(<span class="params">cnt</span>):</span><br><span class="line">    <span class="keyword">global</span> js</span><br><span class="line">    <span class="built_in">id</span> = cnt</span><br><span class="line">    <span class="comment"># https://docs.anosu.top/</span></span><br><span class="line">    url = <span class="string">&quot;https://image.anosu.top/pixiv/json?num=10&amp;r18=0&quot;</span></span><br><span class="line">    r = requests.get(url, headers=headers)  <span class="comment"># 发送请求</span></span><br><span class="line">    data = json.loads(r.text)  <span class="comment"># 解析json数据</span></span><br><span class="line">    url_list = []</span><br><span class="line">    image_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        image_url = i[<span class="string">&quot;url&quot;</span>]</span><br><span class="line">        f = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> js[<span class="string">&quot;graph&quot;</span>]:</span><br><span class="line">            <span class="keyword">if</span> j[<span class="string">&quot;url&quot;</span>] == image_url:</span><br><span class="line">                f = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> f == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="built_in">id</span>+=<span class="number">1</span></span><br><span class="line">        url_list.append((<span class="built_in">id</span>,image_url))</span><br><span class="line">        image_list.append(i)</span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=max_flow) <span class="keyword">as</span> executor:</span><br><span class="line">        futures = [executor.submit(get_image, <span class="built_in">id</span>, image_url) <span class="keyword">for</span> <span class="built_in">id</span>,image_url <span class="keyword">in</span> url_list]</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(futures):</span><br><span class="line">            <span class="keyword">if</span> future.done():</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    result = future.result()</span><br><span class="line">                    <span class="keyword">if</span> result == -<span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    js[<span class="string">&quot;number&quot;</span>] = <span class="built_in">max</span>(js[<span class="string">&quot;number&quot;</span>], result)</span><br><span class="line">                    js[<span class="string">&quot;graph&quot;</span>].append(image_list[result-cnt-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(e))</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(json_path, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            json.dump(js, f, indent=<span class="number">4</span>, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(out_path):</span><br><span class="line">    os.mkdir(out_path)</span><br><span class="line"></span><br><span class="line">js = load_json()</span><br><span class="line"></span><br><span class="line">cnt = js[<span class="string">&quot;number&quot;</span>]</span><br><span class="line"></span><br><span class="line">get_url(cnt)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;下载完成&quot;</span>)</span><br></pre></td></tr></table></figure></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
