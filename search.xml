<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2025.10.29-NOIP</title>
      <link href="/posts/d98fae2/"/>
      <url>/posts/d98fae2/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="fe94a0d8c1a7911d1bf880e6abb357c7e04a46b84e5ff2eee0aa91ebaa8dadd5">93024cf999deb8d8b2919f7e109263d4fa4f22b5a6d5f2a46597c1ea59cef215f2fb6074b217f6d1d837246605c722979219760661120bad378ee841db1d6ece06b715dc2ec3e418211e4ac040af43a52585d4be41aad0352b96f107ff167c660c7473800697740c5f8d4f36c0a7797358ec23557d0a4551a246fad8ba24a2d60a6c6db4949ea496d54435c59b5667e1765c2b4f2609eaad0a02ae00fbf44cc8bbe682507298e6fa7f33ea286aea7273f04d390170745b943ee40ddbbfa46acd1522920d7ba3ef2390f777a724b88cd9dd0186372461b04c5a340733e0ee48a682d6a151beb0c7aa776de6fe86d1ba589dfb7b0a70bad0a6245955f94b5fc397525e1f60b0b14d2449133c01cc16394b052434bc36bb90c2b01ac0d2b9d2d6c7217962339d18164e84f656cc8f5c2f63d4dbb50b40fe43bd1ff1c5a6c8be7fdee906e039689ac7197fb53844896ec4bfa31227a3efd28165f16f4780ceb3dd21ba73af4e032bfcf83c3590ba48cb00005830f8a35c29538ce4ce0a9f074e77b096f1404503a210ddde5855eeff8ebd886daa558c4e83be9de27c5fe0bcd6fc074e18076dc0fd619ff9402257b152138b2c0afebc4937bbc9e991b265ea3ae9b54d62d886984b4ee01adc2537abedbd723d1d4245e1b7de334d90eed4b486fa6663e0c1ff803a1a2fd8f234ef6bd1b4491605c6cb09879da207e9d9a3b957538428f41e30e9e902035cc0d858fe147a5d889506e4f65d96daebcddd80fa24ea5bf1dd3ae6d27b71033411a64dfe3e59a7edb56dce23f8ede608d075900a1fef6f4d1080aa21bb2f911c9f66edc149956569427bb092e0a57a30007f52b7d9146a1b5ef430bd128c2e0129ae074c2d9b96546b5fd57a8b69992f6da4eb0ace29f23a719284537165d35ad7022d1ee121e5a3cb0161edf9ef943b04c283788e7574c7b627d54b4c966bf3ca7e8d3faf178e9ef8a98ad69d1dd8b8793276f60f4c7dab3dfcb45cad9e6f74f26e7fb4b4e81c5a055469cb3f0d943704f9578714655134ca992a18cbf2bff7d13b37434a82a5349a8aef7a7135c71af4a3d0b714a1a766a2e522af67fa0203f08c3dd424e70fbccf9e5de37b8f754dd26679a3608208571844e3be8be547bd9599fbe20a6acb4b43f95bb6ed8f89babc8ec03e791f324831a76779e102578ef4df7d5935887445967ccd7ad97603794821ec78f3c1a53eaf5311ffef3a196777e0ba3c1c689669fd8b36301ea50321e57c323e90579f412223fac9edbda88b56c0038fc78f1928ea5e2dbba323687bd3740ebf42a38d8c66412b535a6bd2639eac4b448e22b01f9b4fa471ab40d2ea9dec9cf0db219dd82b4bdcfce403fedc19f9c75399f3cbe26d616b5d2cadc9074f67cfd078c29ff71f13c688785076fc13928b4bcd352f1b9b99f43a66aaa5a09a6a39092abd7f1676ffe78e54202a3ce67aae85f3e9a4a8b27c924abeb6cbdf9b1dac6ba591ec8b2f1b3f595d37e0825e270b5df78d1970017e3e2dbac7d94997dac12555877862c7a16c92d50360a1d570b8116e4191868b7bbd875b4f889cae12db9d509a45b2cb6d3f64ba7e0eb8796f237f76f305cc6d0b7b03908f0340cfbab6aa03f6598c4ca8da879772e6da26d8b18bfec008ba28763bf78be80a37a5ecb5ebc7725255af239f08323b55a995b13faba1e0c7bf49fc09aff89f0181a9de4d2a08ad5eae3b5c495a00f086299a2723b697ace2a62527a58a17f9e50577bffd58d6100eee22330b2c4d4f763d68eef8bd57975294f93b2b37bef6c95fb5c1f1d2d3d3352e90c7ee6d019e040b1f5f9246adaf3c7948a546c083fa7602e45eced1988b84bba839bdc1bcf70fd36b6c47cbdb7a88caa1e45ee7838088e7694884013b9cd240bf2332e88a79f8e8809cb893231da453873722d7e946b556003517f8f3580da6e311d1f09ef5499b3ffd6b54cfcabdb4b79f5b414a222509996c1120663b3a9ae49500ef9046f4ffb912348f225cbae10fb6e3b2e4a76f7327006bdcf2e9818cac3b41451f99c2fa034c64cd48e583427596e7d83569e8b46fef8a65c427dd3a1885e89f831f9fe9ef2ef89902ba912951699ef2b296a7cd0454c2cc226022dafa47c4f965c560a8c122f391785808a454a535218f3c310cf98af1399daaaa13ae858a9221f23d2afa9171ce2860a7dd5cdbd7a6d0101406a978a1e71964bb6b8834b77bf0ce3e478255dd31e4cff34b254b08c41d2f5d60087ae733b57841e0d5c04587d40f140076991963e35305d6820d36f67371d258fe98ccbde6a3d212123043a9003fdcc42d8255fa109a7ee2113ff60f7d34e492cb80f1ad236be55e57d2b148d5e549725b72c85416ba5d97282bed6ab97bdd8f249a6676172eaec0024fdd108cf7c8355383c45a82ddd1764d2fe59c22c3979e4aaaef46c824795659c057c2d4e41669868c91be434ab9725241a5d189e06b26a823be4ee673b4c9d2540a6eb790dcecd310bcec050945cb68a197f96b4ab6df271cb4a4469f38eceb46effce333a6e0ef17aec7c41b4e990112d77cdc343f2f0164ab0a4ba455562af824aa5ae0c1d78e457868037db2cc9794682034fec1d77bf030b3c6731a69af46f9c581e7bf6ee7af4646a99c6c017bc9a369fd89f97aef2ef24a8af88253163fa28436b356dd5fa8f9697c1e189f79ce30d4662f301f05c121f0dad0a678773b44e659257564ae7541c2b45901c8fafec337f66b797fc2972eebbeddccb3f418646fa05d7e5e106b32727c2b44bc502a21a02ae8a065b5e25a6d7bfc92906a628fb5b191dc9115fb2efca87a500c7f148d84469f87a81a840000b15ecfd0babba6bdc76ad9f31aa978665cb2cab250161a46828accbb24552784baccd126dafc4dcdd88bd02a5bd0187445a738f2bc39f661a9b768a119feac0d20ed7bb164032f839a64068b1dd6ea90e64bcff322a52b444d53f64d33a376fe1303736c487c176aaabbdd5e1ce856d6ff046f32a6430a180715536c08f67f89c9f50db09627feb181e4d5c3c492a6a5486fa688c0807ab25428fcf943f3afbf78808f4357284809665b43c0b7e6ef220855ca8d7b6f357120ecfad93dad1a73811a8a01c2f66af643cd793c628212659c8d16269135ad46a0e1d8368716252eaeaf350a4ff19c338439b9479cf49f1bfddf24c50c2068f0460ff4ca851571058e36c40ab324f837a1de33e706eca9762c851e2a13c440d6e19076ae6afa4bf997ee27fc337c00dc6b04616a63bc3870f4550d86f024958626c93607fcf74431d36c4abc3a7ce92130349aad5dd70e6353622f46bf9f26a1470af8a0bb97c490fbbed91446463e3dc4883ad7a96eebce90a88b6a0fe09e6cb2a99633ebd567ac33f2d3c81eadfd9412aa800f52d90538ef093179afcb37886a844922b34ddf62eee2625095e2ab7925904e2c49bdaf21dc62622dc3a26a3d0cef4c219ed7139548dc23bcc67c66163f911049d4c6353d1e85046f203f3855594dbc296dbefdee6bd835f6447592206e02c2f9b5c53e68640d5dbfdeda8b76f2ba6f2b5fb4030e8856c1be9e37be7bd884048d9f8278762801066d05a4c9904973ab0a61beef9458df2ac9bb4dfbf8d13e6face16dbdeff8632a9435674ee89198c544f49c8a61fe84cfeb3981ed43707de6b8b64ce838cab2ccac33389500e6b02fef64d534e7e8162eb963a5c5ea6c636eb40b2494bff7e27a23f920f1a134877db6a77720fccc8309047825b8a4c26dbe9d546b7c29016302979cc16bbc320ab7b8bd2ceb71e34b18</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> school </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025.10.28-NOIP</title>
      <link href="/posts/c6c42947/"/>
      <url>/posts/c6c42947/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="dec0042d1f56cfa55af20cf344cf904f22961e78ae583d7b8292730f79facf47">93024cf999deb8d8b2919f7e109263d43aacb93126eeadb1d972d22e8288c18d69f7655a7188b53a112604ace5a033b742b1c431e404f4cf710d5d1a1e6ed002736b292260860974a002ad0b193f3b4b155bba22c79570884a02df86937a901c78d4377ea05682e55c57c4b18d82b3ef5bd813e25c31efd4361fd0ce9563bd96556a387090e95e1032d4942bdb28a4333c04602840d13f9445615f00dff6b50331d0b95a1b2312fe6a919c05a519b42cdbff18237b1300241b4bc9799827af1918b0d911125c0548229d08c133a7ba79f94983bb13e6b01d82c4132e6cb716a6254d7641772f65831c9eb0919ae3f9376a060de19af1ef42d1f0b2c5a8e39f14f5fd53d9f59c243eef15325585e819f76482362753663045633345e16b2fff88b290e90da17934a3052865ee5ecb705767e2ec77ee564ca6cc45244e76b188500859c40d2ee7d90a6aa226f42c580e77ae8b65b333c392e0382f9e3646416fa8e866333c9de00b5792b8b26fb6f83cad7435e0462f5b6bae1138467df9c775b31d543dc85a14130940b6d054eef3e1d0f001028f8acd030b5265dd76216eedd00102a6b071f0e3f9d0415d8554544b28c99553af5063dbd0363d445cdcd7f4dbbbab8fdeff7ff1d1c7de6338f11c5807bbf9e68816fcdd657b1ad878e786efcd3b08108366968dbdfeca2c474fa5f69c52e58b6031b4d8915fce1a940b58c3e52138325184ca82fd3e40ae65dc2b0ec9fcdbf8aae1e45e05bc9b36b1a4141dbc0e00513c399a2356e8c433c0eb7ffd300323b7cc2d7469ae6e32a1857c06c9614eba4a8f06999cd3ccfc6a165854be184b31f1215e6b291d58fd6f9dba37407eb46efd2547999446e348b18906d16bd3f30f6a3a77311abe5cc9293b42e3e73c52600f062e5024ba1999e89f18a71b05b03897716d338ab01751338441337fd8a99f2872c796378cb951e89417e00e77cc1d1d4693208720d0b6aa151dc7e21f73eb4bd4ca55e05aac9f0eb44b87be54d786f596d71307d043a8a8115d68523698b700f6525e82512da2ff1b82a8d722563ca84e3b104329826cc4fd09599908f02b67cdd8007ed675f205581416d9d82fc35b9a57e5eb9e293d76d88508e932ab399f1c836e23bdf4a90546cf9cccd4d7ef2e85ec11474a6c63ed6771d105d50118492e54c5040e540cbc61694d921bb1ecb8a1d06f1b2d33bb8d8a6c8884f379f798ddf024cf984aa56f58e94b80130d899bf1a7928027b8bce64c0797caaad617d2d4328b2e210cb76787b03fb120b0e6c8ef380ebbec85c9e88b0ffd19b35a7ab8b421e81c580b72682eba24f015f99179cba91e934378c5eda86921a6c349adb88f4826336c51d5fceb5409e0b4fdb0707bd9d769d2ffc0631b9a5ab560e4781a852711137c7c8568019e6a609e6ebb2239b22fb1cff23574fb5b29029f0c3788a3c4860c39d8a4dd30dc4c883b03decfa66b03aff331120469dbec8c9d1867c850ec27e75cec23587c168afb12dc12eed7a47e8b9f7f5dbb53f4fa7bb0369f40efcc25518abaad52ad3f04dbc49e3f053793fea55830a1fe6a48c256d99278f8e6baeb876f8d2db93a967480655eea96754e5b745ec114542152c41395999826484ccf45b485273b20decbfb4c90c8427abc726aa4c58f52f1b85f082384d45da029140f8c063c19b4284eeedc0902814a8573ac1046244502812f62f5c95cc5e88d89538eacfae2aeeae1b26a898c604d3f57109d81e10635ae1304e63b1a604f29f6f5880655eefe36816d447b14e4bcc86c7273315f906d7e4c7bddbbd7b0485fed56d777495cfe92294be956be6431c36fa0b38262223227cb0d5e3353063e1bd7a13cf4abe574ea8e1390f738d67a1f980d3af7fd53dd67850c95d7caa4e1ee8f6241dcc3bae7922d7650cad53b59e1dcb76bbb78c0c0541c865a2994104b4911b5652dc3483b5d47a520dd2edfd4419ba7e730efa6620dd806eea621098cdcfb3312f276caec92fc0b264851fb201e6bcc5ca42ba3ecaa8d7f61dee2c5d851e712a9efb471fc97d1b18e48bf01033834d9fd373889661afd53ef8238e81ca0547160e5a0b18419a2f52daa9ba6562fdbe3267a4d3f73248c27905e09dd7edaff4d858fa6bc675d91be1603750aaab523dc3a0908ef799edf6efe88b95d292bdb9c915549723a292cdef5188fed6e0ad53156cbbfefcdbbc789c2809b87b04dc86aac9dbec963ebcadadaed3e09e5141399a2ec030224ed43a634f120f69816b41b07f05087c135160e4774184b19f9118954b35e986e3bdf7b5b3c1fca03f355561831e30947265ece07bf0a6224bc7ba5d3f684af6637eaea71282b672746d646d1c2352711a710dde8288037a8c080091c76794d20727e98329075eea538473d02e5341aab334dcefbbd7bc47f84f71ec51db0aa34225c24dff0991c92e7cc3fb3186b75ed2f6d0b5d6096873409b0306244e16f46d008e4a565ecb39518dbb2b8b4cf33f1071c246dd60bc84aa19d4949068ca5956dda60a2c8aa46b17aacabc979c45c8dd0fce259a54a863b18871a9d0695311e5a7b95481fc27eda97965db1ada782090b2b581ac63ef777ec560d7ada15c4e7c2208996c520352515852c2f7835ade210df8fee249abddfd6582fe462341c227cd54310cdeab15a457e1b8b4d1b347c4f1e272a1663219c7c3ec9d0387a68b1deb4e4f3a07a46f1ac1c295a18a04ee70f77118d6419fc97bb197420d10e36cb1430305e3206b20c2ec76fa74a367db9cff3631a17e221f1d5be6acf8238b39e93785cb2f7bf61173b8fe4a528cc8243676f63db202475f28643a40da9a241b6eda9fd58b390a53a20ca1ecdb20dbfea5b5bd3e12d297e1ad833abf2ff6c1341d765c620f64d30a9c27c0ff7cf403d9cdb2c554e56dbaaf811070a1aef3d36dd2bb3fe1e1f0f5bc1c5fff8d65ff02c431a34bf659c195c8d0160aeeaa64ee0d2af2fddadf44e192b2d98867f01482900b3b9c86b05baa4ca2f3e2abb48ec69056433a747a33545ba7259d438ea8d8d68e5e8c5711d0597b6e531dd70934b350dbd1217b65f7e8248531d5b15636614748312bc0f9e741d2a25bc8afe52f6805b7a7e220ea52c94b3d51d8486eeafe9a80b426c304b139c3e2e9cd35dcdaa81d056dab4f78cfef736a68b363e8814a8b8d400096296cc9ab0658fb7b6bdbaa3c54cb2e0a06ee7319af37994264296141136fbabe33389f83568f5c11b6fd83da62a560af61f5d3fc745b1e92387fb772c2e1705c6d9f75e232297e2f8854f31872ecdedb9d8da5fc6e3f3dee301411aea557793fa58268988b8655aa96aa2057e40032f9aad07bcb137db29d944303a4a286251528abdd8fb16fa6c085f104c6503e84d70ea3cd436f376a46950e173de6a848e9baaebb9ec29f3cd89a37535a059f9dfc1c0088626123a94c5b74f65cbd1aa9cdb34b32d9109c6365ebaa63aac5daf4077164ed0cb6fd52980afcc15f2fedad2fcb150a9b6407937c0a6e2af374d8ac9c33248a7c95bc89dddaf3f72c9505a96e3d1e88a185ba78612f361f6eef462355165d85f7d32e3f7496d80ae4df3622b1b9fa3f9533c297319bcfeade54d61edb259f3e4b49739c5d2d48f8e41d342c892019267e40e996acc7a4968e74f6b1932a4040e53d4274d3b38d31b0605a55ff925f290981cb591b8e849f7d48bc9bf16640267d5158fcf754e3ac562a16e346b118d12bd507da84c81f8d0ac47697846041453801521d7a4520cd450e4a035688195e54f59d3fd9aad1aae62cfd937540226bc0fa6321a18a0b29c6fda895f80b1e9a3d338905e785dea9a5e2cb901afc0d50d8ec51df6c0b15eb13b51e33cb0415a6f2147a0418b62b2e63221018ed6034e60d6d6b131b8614b6e9a0e6d710c5417b136f452c967a0cb8b258c48e11866d3bc81df686c4cc598e76184057281d0b0745470d8881658a5a4c817c8da8d84133d6aee8aa51e4b128e7b1b4a9a015f7df4400c65e580d9ba80eb7a691ff7ca4bfbc25cb901ad51ed859d5176507645e1bfc894562c75090c8cb18f9d053aa343b1f3e769a50ed0c13c3dce262cc746e8064968e482a97cc856acbb9959ce1de7cfc58e16c86a1c86664aee50f14088a5025bfdeedc020b5edd6eb912a20f527b8781834c67042bc453049613dd4edd195ce626d03147eb84feab3cb1ff883cd8aca55523f5d7398fe5b20296bc19a52a2282d8c5b8b389f070a3102e65a46bb63305fd78aaee979d82d99bb1403c5448f97a359c8e29643d0f69abe91d7d8a2aee7caeaf32f5c40a5279dc23ebb999ac77e6980f88c5ce6770308ebf0999fb311498473638f55d4d13b90d13e1d9ef1a73f1e598ee85ede3628a3ff93e617875ddebe2d93adbd88e90d3cda7da2df45cb2427d62befaa9b9134d32fe51084725c014769305353525007083101fd642619f79d402eefbb64707658e68d12be32bbce5e304fa3a1940cdf21806bf9a9a4adfa154ff67ef6626da324a71cc28a37a3fe610992840a56766c61f65f91f6734103882362bda52bb1be97b72a1d5b85a7c0401462b8e7ab7fc406a6ad2cf08758db52796b6b03501ff9332d24d048b3ecba59316009e8f063fd9c3558c22a75823375e6fff44829e2cd11d77bcb23700b087a57fd7a75942e8d2df2fb6626e9c52e46a8f3ad7916edaf90110cfbb32687f2fde6aaf78a9be4f0af9ebfab2c1b46d4f424acd8b941dc46ab604d2bf400b6e87fdae7d43a1fb37ab0f767fb6bcaf11d073a75a485b0701d14cc2394796aacaae88c816a8725b0a52e3297aea737bf36310495b98e9c8a3f223336b6171351f0cbb185c9eab05a05c289bbf5d370d9736b82571e4e5701f4499344521d7c641c7020faaa32f0bf4e00c44db67129b16b54bb884fa24161af9ddb09899b0153482f4bddb432249e1878dd56d3299a5fa2bef0aac2a1493f7e6863f6443b8da146e3e1584d029413b2f4b136eda931106edad1b6621f5c7cd75ae30f3a1d6eb8fce5aba4273e80446ddd27a9f54de01816b0d966286e8899ed8fad678cce27c1cbfb8b6d1248ba0890b405983f29673dc57ff1a9d1387a38b2bad1735c05aa6a96bb6f2615e9dd2a83682c7fb8f872953f7323845d7140b098cbce79bd1397443f490ee62be57e0046f11e1db6a09a31d6c993d2844ea6879d7480795d5fa205d89ab82a0b6f86cb40d375000e581e1ffeb5f56a5a735905566bd6b9d1a4696b902eb74dff920171c2d4d2821129dd7c2f10dd48e21e8658ec3e0bbb0e97e9c88d9aabf03aa816efb539063690e594eaffdcc9a6d4f990b1cd734c6443028e59a13a7f78304e16022f13bdb6db32749b9117e93991e49b453bb1d24d156c04031e92c60e9ed4d2a5cb310b9537d89db690191aa9c9b52903cf8e51300c59a4e81b1e4176fc9f33b724af9588082f391fa92ca94ca9eafeaaf39f56b0783f22be6d248373e63ef55f0a29116d6d93a5b8c0ffbe4ae2164fa80618fbbac6b4b37a4fb36903c0e728eb6ccce38efc0f0df667b4fb3be60c607b72a8ac1d4001a421008f94bec4f9df880355a0b84af5c3e83116553fae0f11b67e5e98cc1c7815ef1b8604a7a01a7730e28b1df30fec7b1602092bd1136b6126a7c91677bf8eeeea65da81b9fb485c299fe732ab99e824ac11a8b88d29554a7370520be3a76035e54481360b70b5fede13aa5196dc82ab63153b578967d5940bcc980d2ea5fe78bfaa14e0d0cd672946bddc85ca458a019e5d725d89633b55905ddf7bf31da953e5a41c60f03d6b7b985f3c085525e8b004f8fd91fef7b47836dd8c0c9463f39b0eb6f685a36629b52e015e36eca7f1b08770c97c25eaa9bcf919e2bfbaeca7e1d49616b2f958a1287a05ea7a4bca54d5861695d8f76a7e06e4b5265a4d284c88cfef7e1786c0b80a707724bb5dd25c8632950396882fef0a5d6a81ea568fe73115c91b756fb4e1eb2cdaf7e15a395158561f8aef3f9737ee3709f33c7c68bd5dd76e68e618f470eb1cdcd65a4af41210afdb40666412afa5ea4e65146d1d6e84467a4556cbfb25db800d07b9cb1f5eaba121ab4f06a2d4c752e60c59a445fe2c4ba5209b1d50806fb2e626d0ca2a3032078ee2b6701413dd56c80d59beddd3778a77a5fba97d31298fbdf51b7d2eb5d16995700c1bf3866f180f397fd420a89b47ea2e12bc0fd52a9c9dd48a9818799400216101bb92e0eead69d5006ebf2697ee90448b312fcac5203a49b44214e25e31dc15fa67125ab329acb036df4b6a8e8f069190c8aaf4c18626c202871bf65ca1aafa3799a5efecde7187c0ffe06002e027423a2b6d4ab1a0ccf60a5135fea82126d7058dfd4850e69f030d44839</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> school </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC 429 总结</title>
      <link href="/posts/5c4fe895/"/>
      <url>/posts/5c4fe895/</url>
      
        <content type="html"><![CDATA[<p><sub><sub>我也不知道为什么没有 428。</sub></sub></p><h2>A,B,C</h2><p>简单题</p><h2>D</h2><p>一眼前缀和二分。</p><p><sub><sub>但是赛时二分就没有一发过的，还要调很久。</sub></sub></p><h2>E</h2><p>一眼宽搜，维护每个点到安全/危险点的最大值，次大值。</p><h2>F</h2><p>略微思考，发现是线段树维护矩阵。</p><p>但是赛时线段树打挂了。</p><h2>G</h2>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> atcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 2135</title>
      <link href="/posts/2d1c6871/"/>
      <url>/posts/2d1c6871/</url>
      
        <content type="html"><![CDATA[<p>赛后 VP Div.1，感觉还行。</p><h2>A</h2><p>一个挺容易想的 DP，维护每中数字的位置，多了就删前面的。</p><h2>B</h2><p>交互题。</p><p>按照一贯思路，先考虑极端情况。把机器人移动到右上角，即往右移动 <span class="math inline">\(2e9\)</span>，再往上移动 <span class="math inline">\(2e9\)</span>。</p><p>此时绝对值可以去掉，设距离为 <span class="math inline">\(dis\)</span>，即：</p><p><span class="math display">\[dis = x+2e9+y+2e9 - \max\{x_i+y_i\}\]</span></p><p>再把机器人移动到右下角：</p><p><span class="math display">\[dis = x+2e9-(y-2e9)+\min\{y_i-x_i\}\]</span></p><h2>C</h2><p>赛时挺快想到思路，但没调出来。</p><p>树一定可以随便涂色。</p><p>考虑奇环，一定只能全为 <span class="math inline">\(0\)</span>，偶环上所有数一定要一样。</p><p>因此先把所有奇环找出来，填数，再跑边 <strong>双连通分量</strong>，填偶环上的数。</p><p>最后的 <span class="math inline">\(-1\)</span> 一定有 <span class="math inline">\(V\)</span> 种填法。</p><h2>D1</h2><p>还是交互，但赛时没时间想了。</p><p>一样考虑极端情况，先问 <span class="math inline">\(10^5\)</span> 个 <span class="math inline">\(1\)</span>。</p><p>设答案为 <span class="math inline">\(l_1\)</span>，容易发现此时能求出 <span class="math inline">\(W\)</span> 的范围：</p><p><span class="math display">\[W\in \left[\left \lceil \dfrac{10^5}{l_1}\right \rceil,\left \lceil \dfrac{10^5}{l_1-1}\right \rceil-1\right]\]</span></p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>因为 <span class="math inline">\(l_1 = \left \lceil \dfrac{10^5}{W}\right \rceil\)</span>，所以 <span class="math inline">\(l_1-1 &lt; \dfrac{10^5}{W} \le l_1\)</span>。</p><p>推得：<span class="math inline">\(W(l_1-1)&lt;10^5\le Wl_1\)</span>，两边分别变形即可。</p></div></details><p>我们记 <span class="math inline">\(W\in[L,R]\)</span>，可以证明 <span class="math inline">\(2L &gt; R\)</span>。</p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>首先肯定有 <span class="math inline">\(\left \lceil \dfrac{W}{L} \right \rceil  = \left \lceil \dfrac{R}{L} \right \rceil\)</span>。</p><p>假设 <span class="math inline">\(2L=R\)</span> 时，<span class="math inline">\(\left \lceil \dfrac{W}{2L} \right \rceil = \left \lceil \dfrac{\frac{W}{2}}{L} \right \rceil = \left \lceil \dfrac{\left \lceil\frac{W}{2} \right \rceil}{L} \right \rceil \neq \left \lceil \dfrac{W}{L} \right \rceil\)</span>，不成立。</p><p>因此 <span class="math inline">\(2L &gt; R\)</span>。</p></div></details><p>考虑神奇构造：<span class="math inline">\(\{L,\ 1,\ L,\ 2,\ L,\ 3,\ \cdots,\ L,\ R-L\}\)</span>。</p><p>序列每组形如 <span class="math inline">\((L,i)\)</span>，若 <span class="math inline">\(W\in[L,L+i-1]\)</span>，则造成 <span class="math inline">\(2\)</span> 的贡献，否则为 <span class="math inline">\(1\)</span>。</p><p>所以 <span class="math inline">\(l_2 = (W-L) + 2(R-W)\)</span>，即 <span class="math inline">\(W = 2R - L - l_2\)</span>。</p><h2>D2</h2><p>延续 D1 的思考，考虑如何缩小查询的大小。</p><p>将第一次查询换为填入 <span class="math inline">\(N\)</span> 个 <span class="math inline">\(B\)</span>。</p><p>若回答 <span class="math inline">\(l_1 = 0\)</span>，说明 <span class="math inline">\(W &lt; B\)</span>，容易发现 <span class="math inline">\(\left \lceil \dfrac{m}{1} \right \rceil，\left \lceil \dfrac{m}{2} \right \rceil，\cdots，\left \lceil \dfrac{m}{\sqrt{m}} \right \rceil\)</span> 这 <span class="math inline">\(\sqrt{m}\)</span> 个数互不相同。</p><p>因此询问 <span class="math inline">\(B^2\)</span> 个 <span class="math inline">\(1\)</span> 即可。</p><p>若回答 <span class="math inline">\(l_1 \neq 0\)</span>，同 D1 一样，我们也可以求出 <span class="math inline">\(W\)</span> 的范围。</p><p><span class="math display">\[W\in\left[\left\lceil\frac{C}{A_1}\right\rceil\cdot B,\min\left\{10^5,\left\lfloor\frac{C - 1}{A_1 - 1} + 1\right\rfloor\cdot B - 1\right\}\right]\]</span></p><p>证明与 D1 类似，不再展开。</p><p>这种方式的询问次数为 <span class="math inline">\(\min\{C+B^2,C+2(R-L)\}\)</span>，写一个暴力找出合适的 <span class="math inline">\(N\)</span> 与 <span class="math inline">\(B\)</span> 即可。</p><p>接下来步骤同 D1。</p><h2>E1/E2</h2><h2>F</h2><p>不知道为什么，总感觉 CF 的最后一题没有倒数几题难。</p><p>先考虑每个点的 <span class="math inline">\(f_u\)</span> 会是什么样子。</p><p>定义 <span class="math inline">\(X\)</span> 是 <strong>能级数</strong> 当且仅当以下两个条件其一成立时：</p><ul><li><span class="math inline">\(X=x\)</span>。</li><li><span class="math inline">\(X=x^{X_1X_2X_3\cdots X_n}\)</span>，其中 <span class="math inline">\(X_i\)</span> 也是 <strong>能级数</strong>，并且 <span class="math inline">\(n\)</span> 是一个常数。</li></ul><p><span class="math inline">\(f_u\)</span> 就形如 <strong>能级数</strong>。</p><p>考虑比较 <strong>能级数</strong> <span class="math inline">\(X = x^{X_1X_2X_3\cdots X_n}\)</span> 和 <span class="math inline">\(Y = x^{Y_1Y_2Y_3\cdots Y_m}\)</span> 的大小。</p><p>将指数从大到小排序，按照类似字典序比较即可。</p><blockquote><p>证明略，本人数学不好。</p></blockquote><p>接下来我们可以发现一个事实，一个父亲的 <span class="math inline">\(f\)</span> 一定大于它的儿子的 <span class="math inline">\(f\)</span>。</p><p>所以我们按照拓扑从叶子开始计算每个点的 <span class="math inline">\(f\)</span>，维护一个堆，每次拿出一个最小的 <span class="math inline">\(f\)</span> 更新。</p><p>用 vector 暴力维护 <span class="math inline">\(f\)</span> 即可（排序，插入）。</p>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自然数的 k 次幂求和</title>
      <link href="/posts/31a2dedc/"/>
      <url>/posts/31a2dedc/</url>
      
        <content type="html"><![CDATA[<h2>简介</h2><p>自然数的 <span class="math inline">\(k\)</span> 次幂求和，顾名思义，即求：</p><p><span class="math display">\[S_k(n) = \sum_{i=1}^{n} i^k\]</span></p><h2>待定系数法</h2><p>我们观察几组式子：</p><p><span class="math display">\[\begin{align*}S_1(n) &amp;= \frac{n(n+1)}{2} \\ S_2(n) &amp;= \frac{n(n+1)(2n+1)}{6}\\ S_3(n) &amp;= \frac{n^2(n+1)^2}{4} \\ S_4(n) &amp;= \frac{n(n+1)(2n+1)(3n^2+3n-1)}{30} \\ \end{align*}\]</span></p><p>总结规律，我们可以大胆猜想，<span class="math inline">\(S_k(n)\)</span> 的求和公式应该是一个 <span class="math inline">\(k+1\)</span> 次多项式。</p><p>所以可以直接列出 <span class="math inline">\(k+1\)</span> 个方程，解线性方程组。</p><p>证明在下一节给出。</p><h2>差分法</h2><p>可以得到： <span class="math display">\[S_k(n) = \frac{1}{k+1} \left[ (n+1)^{k+1} - 1 - \sum_{j=0}^{k-1} \binom{k+1}{j} S_j(n) \right]\]</span></p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>考虑相邻整数的 <span class="math inline">\(k+1\)</span> 次幂差：</p><p><span class="math display">\[(m+1)^{k+1} - m^{k+1} = \sum_{j=0}^k \binom{k+1}{j} m^j\]</span></p><p>对 <span class="math inline">\(m\)</span> 进行求和：</p><p><span class="math display">\[\sum_{m=1}^n[(m+1)^{k+1} - m^{k+1}] = \sum_{m=1}^n \sum_{j=0}^k \binom{k+1}{j} m^j\]</span></p><p>左边易得：</p><p><span class="math display">\[(n+1)^{k+1} - 1\]</span></p><p>右边变换：</p><p><span class="math display">\[\begin{align*}&amp;\sum_{m=1}^n \sum_{j=0}^k \binom{k+1}{j} m^j \\=&amp;\sum_{j=0}^k\binom{k+1}{j}\sum_{m=1}^nm^j\\=&amp; \sum_{j=0}^{k} \binom{k+1}{j} S_j(n)\end{align*}\]</span></p><p>因此得到恒等式：</p><p><span class="math display">\[\sum_{j=0}^{k} \binom{k+1}{j} S_j(n) = (n+1)^{k+1} - 1\]</span></p><p>分离 <span class="math inline">\(S_k\)</span>：</p><p><span class="math display">\[\begin{align*}\binom{k+1}{k} S_k(n) + \sum_{j=0}^{k-1} \binom{k+1}{j} S_j(n) &amp;= (n+1)^{k+1} - 1\\(k+1) S_k(n) &amp;= (n+1)^{k+1} - 1 - \sum_{j=0}^{k-1} \binom{k+1}{j} S_j(n)\end{align*}\]</span></p><p>因此：</p><p><span class="math display">\[S_k(n) = \frac{1}{k+1} \left[ (n+1)^{k+1} - 1 - \sum_{j=0}^{k-1} \binom{k+1}{j} S_j(n) \right]\]</span></p></div></details><p>这样我们不仅得到了一条递推式，还证明了 <span class="math inline">\(S_k(n)\)</span> 的求和式是一个 <span class="math inline">\(k+1\)</span> 次多项式。</p><p>直接递推，复杂度 <span class="math inline">\(k^2\)</span>。</p><p>还可以用分治 FFT，复杂度 <span class="math inline">\(O(k\log^2 k)\)</span></p><h2>拉格朗日插值</h2><p>我们知道 <span class="math inline">\(S_k(n)\)</span> 的求和式是一个 <span class="math inline">\(k+1\)</span> 次多项式，当然可以用 <span class="math inline">\(k+2\)</span> 个点进行插值。</p><p>取 <span class="math inline">\((0,S_k(0)), (1,S_k(1)), \cdots, (n,S_k(k+1))\)</span> 作为 <span class="math inline">\(k+2\)</span> 个点，得：</p><p><span class="math display">\[S_k(n) = \sum_{i=0}^{k+1}S_k(i)\prod_{i\neq j}\frac{n-j}{i-j}\]</span></p><p>暴力是 <span class="math inline">\(k^2\)</span> 的，考虑优化。</p><p>分别考虑积的分子与分母。</p><p>对于分母，考虑 <span class="math inline">\(i\)</span> 已确定：</p><p><span class="math display">\[\begin{align*}&amp;\frac{1}{\prod_{i\neq j}(i-j)} \\=&amp;\frac{1}{i(i-1)(i-2)\cdots1\times(-1)\cdots(k+2-i-1)(k+2-i)} \\=&amp;(-1)^{k+2-i}\frac{1}{i!(k+2-i)!}\end{align*}\]</span></p><p>预处理阶乘与逆元即可。</p><p>对于分子:</p><p><span class="math display">\[\begin{align*}&amp;\prod_{i\neq j}(n-j)\\=&amp;n(n-1)\cdots\{n-(i-1)\}\{n-(i+1)\}\cdots\{n-(k+2)\}\\=&amp;\left\{\prod_{j=1}^{i-1}(n-j)\right\}\left\{\prod_{j=i+1}^{k+2}(n-j)\right\}\end{align*}\]</span></p><p>维护 <span class="math inline">\(n-j\)</span> 的前缀积和后缀积即可。</p><p>复杂度 <span class="math inline">\(O(k\log V)\)</span>，<span class="math inline">\(\log V\)</span> 是逆元复杂度，也可以 <span class="math inline">\(O(n)\)</span> 预处理优化。</p><h2>伯努利数</h2><p>有公式：</p><p><span class="math display">\[S_k(n) = \frac{1}{k+1}\sum_{i=0}^k\binom{k+1}{i}B_in^{k+1-i}\]</span></p><p>其中 <span class="math inline">\(B_i\)</span> 是伯努利数，定义为：</p><p><span class="math display">\[B_n = \begin{cases}1 &amp; n=0 \\-\frac{1}{2} &amp; n=1\\-\sum_{k=0}^{n-1}\binom{n}{k}B_k\frac{1}{n-k} &amp; n\equiv 0 \pmod 2\  \text{且}\ n&gt;1\\0 &amp; \text{otherwise}\end{cases}\]</span></p><blockquote><p>作者太菜了不会证明，可以参考 <a href="https://oi-wiki.org/math/combinatorics/bernoulli/">OI-Wiki</a></p></blockquote><h2>第一类 Stirling 数</h2><p>这次我们对 <span class="math inline">\(S_k(n)\)</span> 多加一个 <span class="math inline">\(0\)</span>，即：</p><p><span class="math display">\[S_k(n) = \sum_{i=0}^k i^k\]</span></p><p>根据第一类 Stirling 数定义：</p><p><span class="math display">\[\binom{n}{k} = \frac{\prod_{i=n-k+1}^n i}{k!} = \frac{1}{k!}\left[\sum_{i=0}^k(-1)^{i+k}{k\brack i} n^i\right]\]</span></p><p>变形得：</p><p><span class="math display">\[n^k ={\sum_{i=0}^{k-1}(-1)^{i+k}{k\brack i}n^i}-k! \binom{n}{k}\]</span></p><p>累加求和：</p><p><span class="math display">\[\begin{align*}S_k(n) &amp;= \sum_{j=0}^n\left[k!\binom{j}{k} - \sum_{i=0}^{k-1}(-1)^{i+k}{k\brack i} j^i\right]\\&amp;=k!\sum_{j=0}^n\binom{j}{k} - \sum_{i=0}^{k-1}(-1)^{i+k}{k\brack i}\sum_{j=0}^n j^i\end{align*}\]</span></p><p>上指标求和：</p><p><span class="math display">\[S_n(k) = \frac{\prod_{i=n-k+1}^{n+1} i}{k+1}-\sum_{i=0}^{k-1}(-1)^{i+k}{k\brack i}S_i(n)\]</span></p><p>预处理 <span class="math inline">\(O(k^2)\)</span>，询问 <span class="math inline">\(O(k^2)\)</span>。</p><p>但是不用除法。</p><h2>第二类 Stirling 数</h2><p>考虑这样一个式子：</p><p><span class="math display">\[ i^k = \sum\limits_{j=0}^k \begin{Bmatrix}k\\j\end{Bmatrix}\dbinom{i}{j}j!\]</span></p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p><span class="math inline">\(i^k\)</span> 可以看成将 <span class="math inline">\(k\)</span> 个互不相同的球放进 <span class="math inline">\(i\)</span> 个互不相同的盒子里。</p><p>那么枚举现在有 <span class="math inline">\(j\)</span> 个非空的盒子，自然乘上 <span class="math inline">\(\begin{Bmatrix}k\\j\end{Bmatrix}\dbinom{i}{j}\)</span>，因为这样是无序的，所以乘上 <span class="math inline">\(j!\)</span> 才是有序的。</p></div></details><p>考虑求 <span class="math inline">\(S_k(n)=\sum_{i=1}^n i^k\)</span>，即为：</p><p><span class="math display">\[\begin{align*}&amp;\sum_{i=1}^n \sum\limits_{j=0}^k \begin{Bmatrix}k\\j\end{Bmatrix}\dbinom{i}{j}j!\\=&amp;\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\sum\limits_{i=1}^n\dbinom{i}{j} \\=&amp;\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}j!\binom{n+1}{j+1}\\=&amp;\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}\dfrac{(n+1)!}{(j+1)(n-j)!}\\=&amp;\sum_{j=0}^k\begin{Bmatrix}k\\j\end{Bmatrix}\dfrac{\prod_{i=n-j+1}^{n+1}i}{(j+1)}\end{align*}\]</span></p><p>预处理斯特林数，还要注意 <span class="math inline">\(j+1\)</span> 在 <span class="math inline">\(P\)</span> 下不一定存在逆元，但分子的某个数一定可以整除它。</p><p>预处理 <span class="math inline">\(O(k^2)\)</span>，询问 <span class="math inline">\(O(k)\)</span>。</p><p>也不用除法。</p>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025.10.22-A</title>
      <link href="/posts/67529007/"/>
      <url>/posts/67529007/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a1f482d654b867fc6554187b41dbc84f15e96f90c5fc333d267008d02a4772e4">93024cf999deb8d8b2919f7e109263d436f7768a67e3b41578a0afeefd292b2dcabffd9739f059a2eaa848e67bc2889b57bfb598838a4c2cbce13f193ad9658485b0ade317e39803c6adfa9faf0bb122f3a1e263204a24e236fd8d13e2a5bbd2f7b3ec86f006a093f42b62517007f99cf14c87c45ae705bc88d3c79bcba14b9f3c8bf7d2baa2ea19996962d56ba9f5a785050b019b588616880e56edddbd7946c24c1b0ce965d81b2b28ee2b829db32831e690a46edb44a6d240c2cfd8665ed855b3ef4f024399100a528e612e5ea70f55c1ef4cb1912b612cb787143029019d079f6531fc244bac38eededc5433459cdf3396d42f7a4fe0adabe710ad903bc468806d7ec77ac7b068c08b45f130ba938e6f9e29423ee5244e749971735f9c4b791030f630bcc5ff4bffe558041e724a2893da21d92522ad58c6e44c3ebc6c73472cfdc98862a400da84c9ca0ef8eb5172afcc92fdf4e21db221992200b4b5024aae44135f6fb14e894a446ae933a593aac06c8e6ea1a653fffe58a08ebba6b61b5ebaa34632af51c7d954e44b132fa21d3d79ec1360909bd61f625ed41c4d1cc43e5b8dcb8f4cdbee76e7d44075ad44fff4257321c176f16f9161a97d80d3b71aebf1c512442976706f881666996991bbf55cc9586f46e7ee86dfec06fa80493707d0cc2b684569e13bb0b6831e73cf3e01a0a9c620929117328684ccc21fb8e58af2ed3c663bed22b1239052aebc904c1ae437aaecb7cf503fbf315a26568f47de536de6a220faec26f16eaf1a45c531d7c5d8469186e16082ce8120bef5ea7acce465d53088fe6ca9a86f0dfb5da4c228dc669b8216f266136a438264b05ff6eb248081f94d9042e9cb9c948d7b5e64ea507921514b4b730a99a97eee56fe90df3086aca51e7eb7d6e1d13b6062c23cd62debe8e2bf452d60fcf6cd6bd1389c443b94d1ac0a44821a634ebb900c35c55be29c788a76b75734ed5230f0330b91810bff81624a86e7e066b73339fb6a2c25ad7ea13b416edf1ce7637b190437ecdcc416d946d085775e37dd59e2c8226332ada621a65d68a3070a7e4fd13065b1bebe59fb4bd1cedb3ae47fc438b64ed6535a0e0c06880b8179aa776c6fe198324961b15f9903a57d3663c1c1f57d659abbee40d0a7b0729b43dcad34237d3a7172a39b48e32e1bb1732e492921221855acd1d870b349df497eb866539772c5f2d7c465c786c72a0ebd8dfdcf8a032b5ca6aa152978d23b72bed2fc7e712276cf9c3150f44c20d5d9cf2eeac5a0b0bcd1ca8d56682828c0affbf18e67c5b3c6fd4c14403629955b7b500d532ef0bdf2c5c19f3ab5408279a77cc25fea196438cbfbc740fb14b100a25963d04794b6dec12c23ab2ac54c0ebb6f6eb04a07b90f89075a3a19a03630c29877c503c6af49c3c278ca57e85cdb4cf69442bbb9182062703c239f774c6f8ec249ca9ea5a1e641f24073a159926c193a565673d62b8d20c3f06ecb74aec4e822f9a8780700a101d97fb6c145e9c0595fb8f8a8795a17cb540867e80447b490afa984b9a5bb6b4948945da8f90750573ed8c70b036007a93fbb890360cf2f73b9e0f87e233f56cc90b681043cc82a63dfc5ee3caada7863138fda2f0abadd4c3bb747541cd767f54db8636eaa0bb2ac57aff0d21932364016d6e352b0a7cda09e0578691abc2e6ea5e5f0d2196ce0bc73ddca3aae816bbaedfc5428870dc2dc37edede063a4e862b8297bb86763179e8142167312c67520a5fdbbdfc74e649c054deb74954350571e978670d10eaf7cc7fbb8c744c3d376bb524f0892475b2fba75a912600252455c2bd209f986d38ed2be3097584d94e8462952e2f362b16392a37d1327ffa300f18bec23ba9ef2ece63a848fe70539e8bb4fc7d43e23b6ec4855a77c5fd19f4278bdf4153a91da72b18bf57d2d2f885255f31ef4e9a3b6939c4c4cfa505dc82e99e26a91160d8420400d6bc157a60a389384c8dc07e26c297f466cfc98caf8041495bcb5d9544bcd315f8644dcbcb418842b853d2ac48fe0c71ce0ab2fafb9dd9944f751839713816fca99304dcc6791f034b7960dcc8148e81dcb97fa6f86e0af89f701b02092b37bac791ef36e19980fd62846009dca99345a8d6e953b8799c892e9ea399b1d52add9213f90f1060fdb6730247b76b81cae42405da93a489f19dc267c5a640b73d782c647a9fdae70f5361d2d6f88a7c14411e36df877e44bd7d91343c04a8f3a26cbed58faa4073f7c37ad4acb3d5f73f8fbd7a3f89f7f6ab8cf61756218669ecc66d71f9ef95e9bd6962dd2569c504d3cec0116e71c2c757714037fa18e7de4a7cbfc8fb6e03abff90f356bd63ff3dc8e369dcebfb24e68d9a9f6730cf7001a4d8c56d5fcfa659a63d6964fe22c1530a7494431aa35b9813689a25397c2dcb54c3866231eccbdf675e0e7f7d847f8a79fd641b82cc0ba5e3e71a17e89b3fcbb250fb42495c92bf8ef8a960dda55a38e80c538d34c1dcc52aea7674dbdc845df9af0fcd73f52c0e563d6ac63ebd1389105d6f8d6a1458a61cc0fa871211a582ef229a8adb3665c359d5b0c385e412e2c494cbc1e4be85841aa29b4ec01bb9ad666d00b014ec7a76a52dc47554692d6659cf970cca9a416be66760cfc908d58e284fc7e53d3034a108da4865b989dd213460c698ac0fa6cad85163ebbfc722d04b26d40a097e8cbe7b22bb11345345dc47155fd7be87d43fe220cf20152e40b2bea822daa8ec3ca22f6bd4063ca016bc89967be8abc71504997f592d9f574be31173acde8e87b18e0543cbdb6af95124116de51fa7626b8ca4d70a2aa4dcc53f155c35e07830d874534878f0fd6562bde56db8258de432da69c2f763b927c78308162b32e5c92aa6dd59f34015ec4938f4dd5eb06d68f7dd93a416b23e2568ed35d78f76a773da225e8392d67d1d631cae2ce02c4e63ea862c6dd975e33388e7159bc4de662d35a323f6df95b7d9bc4a78bec4dc92b5187989bf78c0efa25439fcc1401c84de6d67c7b9692151b0b2058f2dba56ba2142d38b7ea2503ec9a92795c1c7f485397fe430f919327ad5d5454fed3c85b68500a2aeb0b26a454824091713c7ed7c7c8d53176bdec818f1f8d2a1278f7d7df59f7144b0b3cf746660f9774c8e81248fbfc780b8de1ec81804d82cd76760829adcae7d015b5cbc52188496539f8a29cef2b54fc79fad88b4a36c19b0e579595bbaf0111bf5d7a785aad153f2c1508677d16ee5af819cbcf21f3d7c0efd46b8733e712ed2942b90d919ce15cf843fade7e9c0300b9fca07ec9fc2a32aeb911e65a5ae7395b75a3bb59a8a3dc2cd3185d639ee6e34e7e8cf85cf5ec5757cb4d6b8c29ce3673ceeed29ebb6f52b74582b1c789118bb84d936327f43e36ad5eb8a587445ca46325bc03f919771727f70e2a3bd55fa0f2b18c2694cb18fa27257ab144d4e14520ef35613b9e81828d8683415724784282b557aa70b709042b32ce275adf7b19a9074f9b968a1b3272c53716496b273a3827eef3fdfc0f2415ecc0fe6043fb33873ce88bcb2ec50b94f6b7fb6f5c625b2a03d83c5ec6dfc38593c8d0e60757c2283f6d22bb1b34e059051972111d3e9f2cd6555e596de1bbb6b27721aa745481af533ef0a6c48079b4fa8f5633070e284067d13411fb182070fe4484cf36ffdd228af657203a86920b413a85576550bd04f1988c3eb7eb9ac2d849393f45ed611a9b0f6e2d56f07ec77c2a94557e7e3bb32af27e09ae39daafca984f5a396e11a94d5fd8c4214ee8d66d2aacf7336aedfe436e3c88803f2c29f68da1aae487d68dcc43c46777993fde1a429469bd0fa9c3bf060e092a4fa5f25c3b29d3eb5b21596287574d714b479c256824f42152c8d5cd0ce836fb0997a6a18a0f52fb357c45bbf1765ef18a1bb2b5938dc65cab51cf523ac5c9b0a4eca1c17b5b98fce0633594bee248d045632b61459d7e09cf55cea9e67f3555a7c957ac43fc5c9cf9ec839a1b87146fd27beee118014884cec51e172a15e9afb890fd3804fe8d4fa802eb04045b456220d7e6a7e950aa3f9cff942aaa975c90ba8213e65a2e3b5549fdf29c8014ae7a873a89ad12f0cc6d1a8873a570df5cf8d50b3de0486064a352fe50af6fedf937ae10bd13c6333cded5bb207c3ac395240c80ba53d9aac70faf487fbdfd7123eba4a87737a5038bfa6846ecdabb20dbe6bf6b7bc3804fae272771c9ac0f9f08f10aeaf118f3687c3b1be1cabca1253d8f82437a70dfa27715cc372504fd186cfe81eaaa771aba7ae225d2ef8bffb200c2c62bb8b7c2b672272fd10e8bd54ff1f4b292fc342ad9097b545be7956522fa270eb86555c3ccf6997b75693c7e548a3ffb3ee5fa3c1f1eb03142469f1e0d4dab36f13917bbf79cfa7b2b2e8c27e69b41434debd99e8100f16c81742c56e90b4532e73ea692714b50efabf0a363c90e9d7fa86e39eddfe265336cccfb18acd04f6a6317a8be50c261a6935312d75eb89cd0b9678cfab632335cd9911ba54ba193fba806b7dfd96580bffd5fa779420cbbd66079ebf3f97aa8bfee667d876b463707f170e2bd3b42927d4eed1ccf02a372d35a1f8aff98f1ff5f4a8de9de8b99841fb7e3e078e61d8e902ce37e37a21d10ac57c92ab07db5030ecefa2638cd2c7a8fd4bf41c146fa2651421ee830c49e5e1bb3db809f717a295078fb2cefbc223893ddc6501113647656e8a3baefe284571cbf2bac5fd733ad365f0ec90f0da5c9b4c1e7e7750c62e8673b7a792fdb6c9360d3257e5ae0c86dac00201d35227f25a63c8875ea7c0a853135a88545a29edcc7a320cf7d8cfcae4db98be4c6b9714bea1094ac6bd5cc734d5549cdb602ef839c820b1c5bd1c64f7874c1d26cac80b64c18d33ccc189327c78a08e537a5f5d59b7b5e661c2120decd1fa53bf1d67f0f06726de06ca67092c4e493f2bb4ee7ec8f0891d33afdeb16927cc39916d8aca288f89f29fd29dcdb347c0a9fa65c11e5f1dfaec828662402a6b30e8d49abec6dc72f8406b508b6b7de96ea914b14823b3f90e3726e0ec8c73d428e8204c9997b07407df8e5466c914339c18129e0af29c3ee83bd03fcde3165a720a5bca52067bc14564a764d45c4e1c296eb71311b7c89646776116951ebe9c4a91954047b196ad820e25b614a79a0a8e56f58e0d7f42d4b4c09c3c7b4b8b732a215ce5c8ac17d7ca01e0ec4fb9305e28beb55788c63c81eead0322c829513a5097ef24c4b869199f19d32af2e8286938b8b946f446ab5dd9600e473c6e6949904043a7e0d8e4701bd72e8ff7cdbb278fa89a21ec86dd3ba79ac6d8a7f39be326c0c2287f55204bfb519bff8aeab4c06421ef21e6699064452df94ac3a651595928b576b1c4e4e715ce7c4aaa906bca49c0e6851ca1be45851bbf507de1dca2ebaad6e76cf66f207468eb6459a9713bbb718bd9db7e078afd6e6ee077b92b4a8725419d96d391efec984d0198cf886dfa6ad5c3395551df06ccadd927838</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> school </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++11 的多线程</title>
      <link href="/posts/151b1912/"/>
      <url>/posts/151b1912/</url>
      
        <content type="html"><![CDATA[<h2>多线程编程</h2><p>多线程编程，并发编程的一种，即在同一个进程中执行多个线程，每个线程都有独立的栈、指令计数器，但共享同一个内存空间（堆、全局变量等），可以让程序在多核 CPU 上并行执行，从而更快更高效喵！。</p><p>但是由于缺少系统的保护机制，多线程编程容易出现数据竞争和死锁等问题。</p><h2>C++11 中的多线程</h2><div class="note info flat"><p>编译器版本：Clang 21.1.1</p></div><div class="note info flat"><p>C++ 标准：C++11</p></div><p>多线程在 C++11 被引入，其工具集在 C++11 已经比较完善，主要分为五个板块：</p><ol type="1"><li>线程管理：<code>thread</code></li><li>互斥锁：<code>mutex</code></li><li>线程同步：<code>condition_variable</code></li><li>原子操作：<code>atomic</code></li><li>异步操作：<code>future</code> 和 <code>async</code></li></ol><h2>thread 线程类</h2><p><code>std::thread</code> 单个执行线程的类，用于创建和管理线程。</p><p><strong>构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::thread t1; <span class="comment">//  默认构造函数，默认不执行</span></span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(func, arg1, arg2)</span></span>; <span class="comment">//  构造函数，传入函数和参数，执行线程</span></span><br></pre></td></tr></table></figure><p><strong>成员函数</strong></p><ul><li><code>join()</code>：等待线程执行结束，阻塞当前线程，直到线程执行结束。</li><li><code>detach()</code>：将线程与 <code>thread</code> 对象分离，允许线程独立执行（守护线程）。</li><li><code>joinable</code>：检查线程是否可被 <code>join()</code>，即在运行且未被分离。</li><li><code>get_id()</code> ：获取线程的唯一标识符。</li><li><code>hardware_concurrency()</code>：静态函数，返回系统硬件支持的并发线程数。</li></ul><h2>mutex 互斥锁类</h2><p><code>std::mutex</code> 保护共享数据，防止多个线程同时访问导致数据竞争。</p><h3>std::mutex</h3><p>最基本的互斥锁，不可递归锁定。</p><p><strong>成员函数</strong></p><ul><li><code>lock()</code>：获取互斥锁，如果互斥锁已经被其他线程锁定，则阻塞当前线程，直到互斥锁被释放。</li><li><code>try_lock()</code>：尝试获取互斥锁，如果互斥锁已经被其他线程锁定，则立即返回 <code>false</code>，否则获取锁并返回 <code>true</code>。</li><li><code>unlock()</code>：释放互斥锁。</li></ul><h3>std::recursive_mutex</h3><p>允许同一线程多次锁定同一个互斥锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::recursive_mutex rec_mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursive_function</span><span class="params">(<span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lock</span><span class="params">(rec_mtx)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (depth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">recursive_function</span>(depth - <span class="number">1</span>); <span class="comment">// 可以递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>std::timed_mutex</h3><p>带超时功能的互斥锁。</p><p><strong>成员函数</strong></p><ul><li><code>try_lock_for(const chrono::duration&lt;Rep, Period&gt;&amp; timeout_duration)</code>：尝试获取互斥锁，如果互斥锁已经被其他线程锁定，则在指定时间内阻塞当前线程，直到互斥锁被释放或超时，成功获取锁返回 <code>true</code>，超时返回 <code>false</code>。</li><li><code>try_lock_until(const chrono::time_point&lt;chrono::system_clock, chrono::duration&lt;Rep, Period&gt;&gt;&amp; timeout_time)</code>：尝试获取互斥锁，如果互斥锁已经被其他线程锁定，则在时间点之前阻塞当前线程，直到互斥锁被释放或超时，成功获取锁返回 <code>true</code>，超时返回 <code>false</code>。</li></ul><h3>std::lock_guard</h3><p>RAII 风格的锁管理器，构造时锁定，析构时自动解锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 代码块 </span></span><br><span class="line">&#125;<span class="comment">// 自动解锁</span></span><br></pre></td></tr></table></figure><h3>std::unique_lock</h3><p>更灵活的锁管理器，可以选择手动锁定和解锁，也可以选择超时时间。</p><p><strong>成员函数</strong></p><ul><li><code>lock()</code>：手动锁定互斥锁。</li><li><code>try_lock()</code>：尝试手动锁定互斥锁，如果互斥锁已经被其他线程锁定，则立即返回 <code>false</code>，否则获取锁并返回 <code>true</code>。</li><li><code>unlock()</code>：手动解锁互斥锁。</li><li><code>release()</code>：释放所有权，不解锁。</li><li><code>defer_lock</code>：创建但不锁定互斥锁。</li><li><code>adopt_lock</code>：接管已加锁的互斥量，避免重复加锁。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx1, mtx2;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1, std::defer_lock)</span></span>; <span class="comment">// 创建，但不锁定</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2, std::defer_lock)</span></span>; <span class="comment">// 创建，但不锁定</span></span><br><span class="line">    lock<span class="number">1.l</span>ock(); <span class="comment">// 手动锁定 mtx1</span></span><br><span class="line">    lock<span class="number">2.l</span>ock(); <span class="comment">// 手动锁定 mtx2</span></span><br><span class="line">    <span class="comment">// 也可使用 std::lock(lock1, lock2) 一次性锁定</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">    lock<span class="number">1.</span><span class="built_in">unlock</span>(); <span class="comment">// 手动解锁 mtx1</span></span><br><span class="line">&#125; <span class="comment">// 自动解锁 mtx2</span></span><br></pre></td></tr></table></figure><h2>condition_variable 条件变量类</h2><ul><li>允许一个或多个线程等待某个条件成立。</li><li>其他线程可以通过 <code>notify_one()</code> 或 <code>notify_all()</code> 来唤醒等待的线程。</li><li>等待线程会自动释放锁，进入阻塞状态，直到被唤醒并重新获得锁。</li></ul><p><strong>成员函数</strong></p><ul><li><code>wait(lock)</code>：使当前线程阻塞，直到被通知。</li><li><code>wait(lock,pred)</code>：使当前线程阻塞，直到被通知且 <code>pred()</code> 返回 <code>true</code>。</li><li><code>notify_one()</code>：通知一个等待线程。</li><li><code>notify_all()</code>：通知所有等待线程。</li><li><code>wait_for()</code>：等待指定时间，直到被通知且条件满足或者超时，条件满足返回 <code>true</code>，超时返回 <code>false</code>。</li><li><code>wait_until()</code>：等待到指定时间点，直到被通知且条件满足或者超时，条件满足返回 <code>true</code>，超时返回 <code>false</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知消费者</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, []&#123; <span class="keyword">return</span> !q.<span class="built_in">empty</span>(); &#125;); <span class="comment">// 等待队列非空</span></span><br><span class="line">        <span class="type">int</span> val = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumed: &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>atomic 原子操作类</h2><p>用于在多线程环境中执行无锁的原子操作，从而避免数据竞争并提升性能。</p><p><strong>构造函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">flag</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">void</span>*&gt; <span class="title">ptr</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>成员函数</strong></p><ul><li><code>load()</code>：获取原子变量的值。</li><li><code>store()</code>：设置原子变量的值。</li><li><code>fetch_add()</code>：将原子变量的值加上指定值，并返回原值。</li><li><code>fetch_sub()</code>：将原子变量的值减去指定值，并返回原值。</li><li><code>exchange()</code>：交换值并返回原值。</li><li><code>compare_exchange_strong(expected, desired)</code>：如果当前值等于 <code>expected</code>，则将原子变量的值设置为 <code>desired</code>，并返回 <code>true</code>；否则，返回 <code>false</code>。</li><li><code>compare_exchange_weak(expected, desired)</code>：基本同 <code>compare_exchange_strong</code>。</li></ul><details class="toggle" ><summary class="toggle-button" style="">`strong` 和 `weak` 的区别</summary><div class="toggle-content"><div class="note warning flat"><p>某些平台的硬件指令（如 ARM）在实现 CAS 时可能会偶尔失败，即使值匹配。</p></div><p><code>compare_exchange_strong</code> 不允许虚假失败；但 <code>compare_exchange_weak</code> 允许，即值相同也可能失败，但同时性能更高。</p><p>所以 <code>compare_exchange_strong</code> 比较适合用于确保原子操作的成功，而 <code>compare_exchange_weak</code> 适合用于提升性能（在循环中使用）。</p></div></details><p><strong>内存序</strong></p><p>在多线程程序中，编译器和 CPU 为了优化性能，可能会对指令进行重排，这意味着你写在前面的代码，可能在执行时被放到后面，或者被其他线程看到的顺序不同。</p><p>内存序（memoryorder）就是用来控制这种重排行为的机制，确保线程之间的操作顺序符合预期。</p><table><thead><tr class="header"><th style="text-align: center;">内存序</th><th style="text-align: center;">同步相关</th><th style="text-align: center;">重拍相关</th><th style="text-align: center;">应用场景</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>memory_order_relaxed</code></td><td style="text-align: center;">不同步</td><td style="text-align: center;">允许重排</td><td style="text-align: center;">高性能计数器、无依赖场景</td></tr><tr class="even"><td style="text-align: center;"><code>memory_order_acquire</code></td><td style="text-align: center;">同步之前写入</td><td style="text-align: center;">禁止后面的重排到前面</td><td style="text-align: center;">读取标志位后读取数据</td></tr><tr class="odd"><td style="text-align: center;"><code>memory_order_release</code></td><td style="text-align: center;">同步之后读取</td><td style="text-align: center;">禁止前面的重排到后面</td><td style="text-align: center;">写入数据后设置标志位</td></tr><tr class="even"><td style="text-align: center;"><code>memory_order_acq_rel</code></td><td style="text-align: center;">同步前后</td><td style="text-align: center;">双向禁止重排</td><td style="text-align: center;">读写结合的同步点</td></tr><tr class="odd"><td style="text-align: center;"><code>memory_order_seq_cst</code></td><td style="text-align: center;">同步所有线程</td><td style="text-align: center;">全局顺序一致</td><td style="text-align: center;">默认，最安全但性能差</td></tr></tbody></table><h2>async 异步操作类</h2><p>标准库引入了一整套用于 <strong>异步操作</strong> 的类和机制，使得多线程编程更加现代化和易用。</p><h3>std::async</h3><p>异步执行函数，返回 <code>std::future</code>。</p><p><strong>构造函数</strong></p><ul><li><code>std::launch::async</code>：立即在新线程中执行。</li><li><code>std::launch::deferred</code>：延迟执行，直到 <code>std::future::get()</code> 被调用。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;T&gt; f = std::<span class="built_in">async</span>(std::launch::deferred, func, arg1, arg2);</span><br><span class="line"></span><br><span class="line">f.<span class="built_in">get</span>(); <span class="comment">// 阻塞，直到结果可用</span></span><br></pre></td></tr></table></figure><h3>std::future</h3><p>提供对异步操作结果的访问，表示一个尚未完成的异步操作的结果。</p><p><strong>成员函数</strong></p><ul><li><code>get()</code>：等待异步操作完成，并返回结果。</li><li><code>wait()</code>：等待异步操作完成。</li><li><code>wait_for()</code>：等待指定时间，直到异步操作完成或超时。</li><li><code>valid()</code>：检查异步操作是否有效。</li><li><code>get_future()</code>：从 <code>promise</code> 或 <code>packaged_task</code> 获取 <code>std::future</code> 对象。</li></ul><h3>std::promise</h3><p>存储值或异常，供 <code>std::future</code> 读取。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt; prom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">perform_calculation</span>();</span><br><span class="line">        prom.<span class="built_in">set_value</span>(result); <span class="comment">// 设置结果</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        prom.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>()); <span class="comment">// 设置异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::promise&lt;<span class="type">int</span>&gt; prom;</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>(); <span class="comment">// 获取 future</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(producer, std::ref(prom))</span></span>;</span><br><span class="line"></span><br><span class="line">fut.<span class="built_in">get</span>(); <span class="comment">// 阻塞直到结果可用</span></span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><h3>std::packaged_task</h3><p>将可调用对象包装为异步任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(compute)</span></span>;</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; fut = task.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在单独线程中执行</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(std::move(task), <span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> result = fut.<span class="built_in">get</span>();</span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><h2>实用函数</h2><ul><li><code>sleep_for()</code>：使当前线程睡眠指定时间。</li><li><code>sleep_until()</code>：使当前线程睡眠到指定时间点。</li><li><code>yield()</code>：让出当前线程的执行权。</li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025.10.14-A</title>
      <link href="/posts/716a435b/"/>
      <url>/posts/716a435b/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="bece7e15bf17339368061e7d9051e99987da8ad659bc92efe9c375cb31092658">93024cf999deb8d8b2919f7e109263d4d6dbe796c1247aec9fe10e82328d6a454f6cf42448d739612e082de9cd02819c836dc28e0e700ac8e34c451c05d201ca2cddc39cf5e37821ad0cc45fe7895e16073899e13291d8640b9960897e17d713c0915a2f9e2d1c1aea437d605b783de82cbef197d197f7d659b8d64aa30f67d49d73792042df59a88026292d95c73fa26d58f3657433324dfc7c56e8f678ef647a81f7c9a884f8348f2b761d47adc7c9a5a0181f2ba1df73f6b82a8d95a9b4fce1f02e0e6d1400f825139d77729077a3aca08f2bbdd0717d376fe380075ae8eafb69bec43eddff5565a330ba2688f5287674d96ffb2b84637c40a9852cd317becbd43a960b5e66f907c2af2faa47eb018e5af2bc5a42ae779efe40ca366661393f4c96fe0025d6cce0a6995e9c8824ef78120143fe88f3e596bc1501e7ee1cc1ada1068617b22aac31f805bd9f265345cf836f86ce2df66746a846f883190a26fc01d6642aae0e397beba959eade650c789d1ddc8048ec25eb84fe44ada3d84611393e2f0d37ddd3b4242a4c09b52195bedffa814dd75fdb126b3fe559d88a9599ffb81da7753c67f0071bfda9506d5f7773e4439936446f20365abeaadd108d41a07e2f8b10804f87eade30f10a6b2995a93c511b62208e00455a11dfba30bf39b92761a18aad20394eb1cf932071de4f94a3e5f2c065f728cadf34bc81925a1caa0716b4a9529e0b5915294746faffd41cd61a012099d2901b42c6595ec83fdf54a18eacf5922c87578567e742098594765d685731513bc0cb4e24f0f055b4e757b3f136c5651925f09464fce1ff84064862e32ad56cb6d36727e2251db865f06524163b33facfb61180cdc9415330c6f7066a69785ef3e2f81f2a4417232cc860097b0ffa430963f501166c759e447502fc98b3c6aa42fe7f509a5e79f0d95ae73da3bedcb14bd51610b28d206de6b8d0e11975a11c6e4d2d668c08962f0c7f811292cb8eaa8bd5fdd57139e97dc9c3221ac21ec06fa21eac23caac1fcb8b9203ba8bc50b93a427e4f89f935f095cc8e15cebcdc716ed7c163965204b1e598b0fb559be339247723d3b69c56bd7bb5fce17c3384a1c3d8e7cbcaa6f532fed109d06ab05301a3cf073f0539d7b8759ba0db25a2abc5fcd1ddc5f21e787ebf7cc2ec58c2ed51c9b86ac4a60b89552b48783a6cd9fd674282dcf7b9587d3b65afedad5dc50dc38d6771535fe2285cfcdeea6dcfeb5ce2b933c7034998c77bf8f0fc1a4864bb5021c1849cc68dc7d6b841233be91fecdbfbaf4d2ac11922737313c8455eb04d8cc49ac177d2473fc593bb041bd69c3852e037501de1f1410f3d96638e5f9d6da85f46d0577bfd7bd1f442be1d10570851bda1288ad07b6292d49eae7c2206b6d4088d6d23ea8d457f9cc363b02f3567c53da106b274d95348c17a4526d8a42cc85faf047d32e42b90249e1f95da6a76a6d311ca5e32557feeba94aaba4dfaea0742feb27d2bf923e35e6a4f27efc0e2b8dafd9bfea7272f55d8f0872f4d2677b4b6b75a697e292961d0efee2ca55001ded71c26cdcd9cffb9a18d933e52203663a055f309c2920010f8177a65f61c39e929531fa119999e6c39211998e459518253d559ce7d86350b37b6fa113c6d8dd6b00f3a26ebc2b27e0bb1eeed662d6ebe4c2d94285c67fa51360814217001d2c1e8e36861550c48accf3b64341e0b22d7db045b49a3cd0aafa2069e29af5c8b33c56e9b24a61969ea17c6b279664159e96c7140d8c9b588cf54dcd13ff1ebc8caa85b4a8171ed5930d9a201f15d1cca58a10980beb74a69529d5b5851f344c38b95d7645dcc2d4ec4a885834200a55ecd1f81fba1cc6b069b9802e426788642cfe7e182e93f581b60c1e70762126de926610838fd99439559869576815d62d1c889dfc25d1dacdeece8b7a83f2cd29cc79efbb229e7b1be2fe1fb036bf92b657d077159d05036c48dc99b6740b52b17521dbe57ace73966cf6c76d359226d972e15de803704a252568c918edc2f045643c3cf86e6d09dfdb86caf83c7accd72f50cfe316f620c5573d4c8db27ef6aad3b3476febd1235f964da187718ebe55a70b9d077a22d2b5a1c7ea744fe7c72c0c24a10798aeebfdadfd8b8868d347b2bf85cbff4aab44e011f12da221d7ac906ea10613403721d468c8aa6e6264f87a29420e6fabab1638208568813afd95e4b1a587c95d78327ff3876c4f85d2c37703ba994ce2645b97a7e80438eacb122dadd08664413c5a89b44973abb4c33db9a5fcb9f064045b47ad19bc5e5d9208e71580b85b0e332c55a522576a12e019568c0988e681a05aa452cc29276cb52f0135f6716af1c46decea1c1d6caf6444984ca8f8bcf02ddabb4bb48ea468c29b5c6e80a344caecccdc890aa9b1b6c6e1786089a07d0a4d0f46d0b12ebd176e1a5ba4b8f48aa0ea87595880c503cd84cdbe3b189725508cc22bfa3125f1ededf49465543a648891c86e3c665145b9ad7cf83d1054833ff164ad8cb44257fd1b763de69c77cb10f311569d97c22e2f1b1c535ff90079bde74a6313a2e5fad315e13d2d5a87ec6aeac57cc238666b1ca9c23a0de6f41004960b6d3be1a5a5590bb9b33b029b24f83c1d110ee2a6b1c20fbc32d29049130899e39ab6354f5cedc47cd77a4a02a9e5edfa330734dfc7505016c12d8cdc6b07d03eb8468387c18ecf35c0596bb8fdda0c8b67cd7af4f3326e8860f13752b4bda267b7d8d58121e13476ca8e02115080415bb2ed8f8b520f75dee83ae7f78b1005106d077f1d627b67524a59f54fd651b8ceb6b57448667625f75dd8d6197c17f863fd7b2a38a9708465c9cf665684d5e998e6a6e166ad78bbb17b4d0d0c1f41d9a758c822fc804044143a23368b577e2f638ae01b197ab386ad224c74ca777b134416c67fbd34c136b2042e995118b736ee62b5a08edfcc19697d22470ed9900bb4dd87336eb457822042f5836424fb4d95a23d85d6a265cbf4237476628913bc1e36de692ef03f0664979bf0e769e5f8be506f551dc2e77c226eda62c2b6a65c52f7f8dcf99fc768537805c74be94116f8ee3900c74d2719b59ee6c77e0c73682700f9e9bdf58195a3ffbe6586d5d5042ddde58bc3210d2b15fb6d591be03867b5c4dff7ee3d9362b5fce85dee6310599aa5d30f27057d36819edaf3d28a35ee9b4e1eda0c2793b6c76a4d64462494c2922d1dd081b83ddfbd5712854dc14bd71897fd52feb875715dd1c432848ab32bcba570c07deb6cf147015159241d884dc4eb3a53220940ad97f3338b730d2b3320cf7f83d1678fec796a28bf827a2dd1eadf8a140676e288a555ddbb5fb1a0e7f7585d079cb787800c8bd1e73608ecc7e7bc06d9a1720a5372be7d5d6b166df92685378f76cbbca2ad4deb4831d022f5674eac4921a67870db6feaf2c780088a4a9774264c44c7cd758292f70453e1889a5405aab5ff4e62bc4fc5dfcf678dd95e32fe441d1bd361558fb590dffbbdfb41f824b589b43ba6ad3704d5fab251fbe26380cf5cb3594fa0f459a4ecab6b7ba4fc317342c82d61a28625050a2949277ee602dd40fb643a2aff45412941d4666d054b5aea533f960bc1844556096c1b4508591f11c162c8c53a42bf8cf4d452cd9d18c064a8293959481a229d595608dfb3f929ba2cf865a9a51bc42c833ef0f7201fcb2a702141c72ec92cccdc2a171a1af3553df47e6f7aa2bc2bf46b1cbad937be6d8a625fc2364250fe905d2b93496eca1fea0f4f29850a2e874c8e9ee0ee940eb74c7d5f1629ccc2aa1bf4dc18802bee71570a5d1325dcfdd157dca88b576fb6222c02ccbb30192c84e323bab3a38eecc60dcf6b5ccd839e440ddeada329635ac15436760395adce0a5dc6f2188f2a504c2aa65d4967405b7a2dbd9044c073ed84cfad18895ef6572305b41854b19443606ebec6ab9cf5ee033661fdcbeccfd3ce4290352be60f58d2c8481d71093ce28ac4d7bfd9babfcf096ecf86e73c39b25d6e01091aecd4da9f4b1ccd78e9e22cee80e080467ed1f684a037774388f4f365aabea6657e24e343ecac738d8d5d5bde7c917f7bbf15e562b6bce6eea0f76018edc862fd87869d9476b2ab2513babe46dbd713bcad2aa7d6e0d40a577cf1ccb04494306e57cd2d97b2c683506643f6d7acd9d0f8f655756128ba941aacdf0734a900778e0c3573ec5c0181965b39133a3b542da1828fdcd1187a6215d38dae82cbe37b546b5f8fd0dadd3b409e641402cc52f66cf8117781f83d5e7b901c7724f4116d4e2860dcb884e850beb8dd8aa0f7013bf2a9a2933e74edf37a740327f282e52acab362d8535251482f8ab982acc8a306c2649123f20f299ddb12cfc0d221e48442b075b79f02c62c40378cee677552c5b8ba4fb84d11c30102cfab9cfa9c3966221685da0653812696f39b8bc6fa5296677348d73ff7aaf24171d0a509f7af286ecc50aabbe65133e8551fdd24d333c60a2d0abe76af05fc5fb0220e225712d760a8b2629647babd9678e6fe4b77f96b43aa13f65e52a10707c32e46b920c06a4ebbdc6660c36d9588a57a448562ca842047a88df79ad4978482fed9a46bd7853c1d8864e79b44ac683fa797db1d6fb5afb015866e2c27d86bb86cdcaa1080297ded56f9029164d9947b890dce50bd2182a9a6f848fafc0f4257511f1ee8254eef23a34b86047c65e6fbc58245a0b604022bd828fe766774257e8750bc4539a9bb317fd7b080f7957167aa7090e1c27ae3f76c1c904323568563c96d5f8deabcbc632f715756645cc2f08485b869a649189870f39da520d4809e507b35cccbbcd0c6a2b1bcfa4240111b58a4e798242f372081043265702c20c1a7f90dbca65c441fb628f7e6d2e61f6e881ad0202464181d47cb3306e1df0a0f5a1459d81501aae01de0f25f0f234858826fafadd459a044229a782b16150f714e55a5d0de9e15f8e3a130c452538ecd4633f040353943736cbbdae822eed661d758ace40351410d6891cad01049fcd7c9e3e064bd13aa002d366d7accc3c0f371159a218ffaa0df09db076a9940ce0e54f8a33341b0a0fbcd3e1a555e6ea45dfbde3620bf6d1b2e6d7868b8a1d858b9026f3ff528b47b4b1f19efef4860c682b06eafc805d32102e8dfbdd5b1310b0b86a88ec58eb2c704b6fcb26c70335cf062f70175dc732ecd85cf40504d1d88c0822eba46f8378c69c7e423459d2824c04b00bf73d0ed7aeda295818cd9b69ef4f9a76c7d29ce1aec6364d37e10e3c6b87ff2950343ef8ead298a439bba2edda06a358f0abe88abb117fc2ae78ce1287482394fb31128d5665680b08d7473d9b8855b2de4420576a77179bc909c762ca1451efc2ea82ce44de9b8b7b0f896635213341c4702a8249ed1eb7e7d9e7d723b8a57de32fed37eed833eccffc13d53234f0e31f933dd9db58e2827f56313bc71a8d5dec48fe8d56df6aa0b7c8372ae39e85c15c7574d4395bc527cde533f7605ac9995ffdbbcb0731ef8349b9fcbf4dc8efeee692e8848319c49a6f5a3d2d62b23e81ab334f03191b40106e90ade2aa4f3ce1c3bbd8239fade591902b82d269662680fd55498fcaa91d969212d760050c609267ed95e775ec14bd188d50db1299aed198b541f3152324d64f2a6e4ba8c13b8c3ce577b6810390fc74f76ff44b33bc5afdd6a7914c8ae11f5f9e20ec7b31b5375cb9977f1236617cc6df30785f4ad61f83d3f2ec263ae080cfb88fde49c6b8d5933a9ae0bc5e8bd9207645c64cfdf8b4616a0e323464a76a2e0bfe02d2d1e50cda6b5f941231bbd4a036a26e0aca947f067f3d715968f799451118d36adab7d18cb21d7fe45052471009be5cbff22baf9b45086b86c338da19d5240d4f23b6909d91c8b92fe1591ec07b301a859d01f5c06d541fc955ee132ad817bada5bf3d77411cb1134e7e34013369999544817e8dd7468db88639a835cc2658afc428f73c10573c4e36f49f9dc217dd2ee87b4b12b4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> school </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC 427 总结</title>
      <link href="/posts/49c5faa7/"/>
      <url>/posts/49c5faa7/</url>
      
        <content type="html"><![CDATA[<h2>A</h2><p>简单题。</p><h2>B</h2><p>简单题。</p><h2>C</h2><p>简单题，可以枚举二分图的左部点。</p><h2>D</h2><p>简单题，DFS 即可。</p><h2>E</h2><p>赛时考虑移动 <span class="math inline">\(T\)</span>，但死活调不出来。</p><p>赛后用 bitset 存整个图，一遍过，而且打的飞快。</p><h2>F</h2><p>双端搜索，用 <span class="math inline">\(f\)</span> 存前 <span class="math inline">\(\frac{n}{2}\)</span> 个数可能的子集和，<span class="math inline">\(g\)</span> 存后 <span class="math inline">\(\frac{n}{2}\)</span> 个数可能的子集和。</p><p>不过要分别记两个，中间不能同时选。</p><p>排序后二分计算，不过可以用 <code>equal_range</code>。</p><h2>G</h2><p>赛时没想到。</p><p>记 <span class="math inline">\(t_P(T)\)</span> 表示初始心情为 <span class="math inline">\(T\)</span>，按顺序收到 <span class="math inline">\(P\)</span> 礼物后的最终心情。</p><p>定义一个 <strong>好的</strong> 序列 <span class="math inline">\(P_1, P_2, \cdots, P_n\)</span>，当且仅当 <span class="math inline">\(\forall i \in [1, n),P_i + A \le P_{i+1}\)</span>。</p><p>对于一个 <strong>好的</strong> 序列，一定存在一个整数 <span class="math inline">\(x\)</span> 使得：</p><ul><li><span class="math inline">\(\forall i \in [1,x)\)</span>，收到礼物 <span class="math inline">\(P_i\)</span> 一定 <strong>失望</strong>。</li><li><span class="math inline">\(\forall i \in [x, n)\)</span>，收到礼物 <span class="math inline">\(P_i\)</span> 一定 <strong>高兴</strong>。</li></ul><p>对于两个序列 <span class="math inline">\(P,Q\)</span>，若 <span class="math inline">\(t_P(T) = t_Q(T)\)</span>，则称两个序列是等价的，不难证明两个等价序列的长度一定相等。</p>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> atcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL</title>
      <link href="/posts/3006dc10/"/>
      <url>/posts/3006dc10/</url>
      
        <content type="html"><![CDATA[<h2>简介</h2><p>C++ 标准模板库（Standard Template Library，STL）是一套功能强大的 C++ 模板类和函数的集合，它提供了一系列通用的、可复用的算法和数据结构。</p><p>STL 分为多个组件，包括容器（Containers）、迭代器（Iterators）、算法（Algorithms）、函数对象（Function Objects）和适配器（Adapters）等。</p><p>使用 STL 的好处:</p><ul><li>代码复用：STL 提供了大量的通用数据结构和算法，可以减少重复编写代码的工作。</li><li>性能优化：STL 中的算法和数据结构都经过了优化，以提供最佳的性能。</li><li>泛型编程：使用模板，STL 支持泛型编程，使得算法和数据结构可以适用于任何数据类型。</li><li>易于维护：STL 的设计使得代码更加模块化，易于阅读和维护。</li></ul><h2>容器</h2><h3>vector</h3><p>vector 是 STL 中的动态数组容器，定义在 <code>&lt;vector&gt;</code> 头文件中。</p><p>特性：</p><ul><li>随机访问：支持随机访问，可以快速访问任意位置的元素。</li><li>动态数组：可以动态扩容，可以根据需要增加或减少元素。</li><li>连续存储：支持连续内存存储，便于与 C 风格数组交互。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;        <span class="comment">// 空 vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;    <span class="comment">// 10 个默认值为 0 的 vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 10 个值为 1 的 vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(v2)</span></span>;   <span class="comment">// 拷贝 vector v2</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(v<span class="number">2.</span>begin(), v<span class="number">2.</span>end())</span></span>; <span class="comment">// 利用范围构造函数</span></span><br></pre></td></tr></table></figure><p>注：vector 的构造函数默认为空。</p><p><strong>成员函数</strong></p><div class="tabs"><div class="nav-tabs no-default"></div><div class="tab-contents"></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="note warning flat"><p>请注意区分 <strong>容量</strong> 和 <strong>大小</strong> 的概念，vector 实际占用的内存空间相当于容量。</p></div><ul><li>容量：指的是 vector 预留的内存空间大小，可以动态增加或减少。</li><li>大小：指的是 vector 中实际存储的元素个数。</li></ul><p><strong>释放 vector 内存</strong></p><ol type="1"><li><code>vector&lt;T&gt;().swap(v)</code>。</li><li><code>v.clear(), v.shrink_to_fit()</code>。</li></ol><h3>deque</h3><p>deque 是 STL 中的双端队列容器，定义在 <code>&lt;deque&gt;</code> 头文件中。</p><p>特性：</p><ul><li>支持 <strong>两端</strong> 高效插入和删除。</li><li>随机访问常数较大。</li></ul><p><strong>成员函数</strong></p><div class="tabs"><div class="nav-tabs no-default"></div><div class="tab-contents"></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2>迭代器</h2><h2>算法</h2><h2>函数对象（functional）</h2><h3>函数对象</h3><table><thead><tr class="header"><th style="text-align: center;">类名</th><th style="text-align: center;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>plus&lt;T&gt;</code></td><td style="text-align: center;">加法</td></tr><tr class="even"><td style="text-align: center;"><code>multiplies&lt;T&gt;</code></td><td style="text-align: center;">乘法</td></tr><tr class="odd"><td style="text-align: center;"><code>divides&lt;T&gt;</code></td><td style="text-align: center;">除法</td></tr><tr class="even"><td style="text-align: center;"><code>modulus&lt;T&gt;</code></td><td style="text-align: center;">模运算</td></tr><tr class="odd"><td style="text-align: center;"><code>negate&lt;T&gt;</code></td><td style="text-align: center;">取负</td></tr><tr class="even"><td style="text-align: center;"><code>equal_to&lt;T&gt;</code></td><td style="text-align: center;">等于</td></tr><tr class="odd"><td style="text-align: center;"><code>not_equal_to&lt;T&gt;</code></td><td style="text-align: center;">不等于</td></tr><tr class="even"><td style="text-align: center;"><code>greater&lt;T&gt;</code></td><td style="text-align: center;">大于</td></tr><tr class="odd"><td style="text-align: center;"><code>less&lt;T&gt;</code></td><td style="text-align: center;">小于</td></tr><tr class="even"><td style="text-align: center;"><code>greater_equal&lt;T&gt;</code></td><td style="text-align: center;">大于等于</td></tr><tr class="odd"><td style="text-align: center;"><code>less_equal&lt;T&gt;</code></td><td style="text-align: center;">小于等于</td></tr></tbody></table><p>还有一些，可以自行查阅头文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> c = std::<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;()(a, b); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 降序排序</span></span><br></pre></td></tr></table></figure><h3>function</h3><p>一个 <strong>通用函数包装器</strong>，可以保存函数指针、lambda、函数对象、成员函数指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; f = add; <span class="comment">// 保存函数指针</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; endl;         <span class="comment">// 输出 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>bind</h3><p>一个 <strong>参数绑定器</strong>，可以将参数绑定到函数上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123; <span class="keyword">return</span> a+b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">bind</span>(add, <span class="number">10</span>, placeholders::_1); <span class="comment">// 固定 a=10, b 为参数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(<span class="number">5</span>) &lt;&lt; endl;                     <span class="comment">// 输出 15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>哈希函数</h3><p><code>std::hash&lt;T&gt;</code> 可以获取对象的哈希值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string,<span class="type">int</span>,hash&lt;string&gt;&gt; mp;</span><br></pre></td></tr></table></figure><h2>适配器</h2>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 库 chrono</title>
      <link href="/posts/7b504e68/"/>
      <url>/posts/7b504e68/</url>
      
        <content type="html"><![CDATA[<p>C++11 引入的 <code>chrono</code> 库，用于处理时间、计时和时间点，主要提供三类核心概念。</p><h3>duration（持续时间）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::chrono::duration&lt;Rep, Period&gt;</span><br></pre></td></tr></table></figure><p><code>Rep</code> 表示持续时间的类型，<code>Period</code> 表示时间单位。</p><p>常用别名:</p><ul><li><code>std::chrono::seconds</code> 秒</li><li><code>std::chrono::milliseconds</code> 毫秒</li><li><code>std::chrono::microseconds</code> 微秒</li><li><code>std::chrono::nanoseconds</code> 纳秒</li><li><code>std::chrono::minutes</code> 分钟</li><li><code>std::chrono::hours</code> 小时</li></ul><h3>time_point（时间点）</h3><p>表示某个具体时刻。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::chrono::time_point&lt;Clock, Duration&gt;</span><br></pre></td></tr></table></figure><p><code>Clock</code> 表示时钟类型，<code>Duration</code> 表示时间间隔类型。</p><h3>clock（时钟）</h3><p>提供获取当前时间的函数。</p><ul><li><code>steady_clock</code> 单调递增，不受系统时间调整影响，适合计时。</li><li><code>system_clock</code> 系统时间，可转换为日历时间。</li><li><code>high_resolution_clock</code> 高精度计时。</li></ul><h3>使用</h3><p><strong>获取当前时间点</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br></pre></td></tr></table></figure><p><strong>计时</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="comment">// 代码片段</span></span><br><span class="line"><span class="keyword">auto</span> end = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> duration = <span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Time used: &quot;</span> &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p><strong>返回 <code>epoch</code> 到当前时间点的偏移量，并把这个时间间隔以整数形式表示</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrono::steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>(); <span class="comment">// 常用于初始化随机数种子</span></span><br></pre></td></tr></table></figure><p>不同 <code>Clock</code> 类型的 <code>spoch</code> 不一样：</p><ul><li><code>steady_clock</code> 的 <code>spoch</code> 通常为 <strong>系统启动时间</strong>。</li><li><code>system_clock</code> 的 <code>spoch</code> 通常为 <strong>1970-01-01 00:00:00 UTC</strong> 。</li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 中的 Lambda</title>
      <link href="/posts/eeb037c6/"/>
      <url>/posts/eeb037c6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 中的随机化</title>
      <link href="/posts/ced3a8ad/"/>
      <url>/posts/ced3a8ad/</url>
      
        <content type="html"><![CDATA[<p>mt19937 是 C++11 引入的伪随机数生成器，使用 <strong>梅森旋转</strong>（Mersenne Twister）算法。</p><p>相较于 <code>rand</code> 它的周期更长（<span class="math inline">\(2^19937 -1\)</span>），生成的随机数更加均匀，速度更快，<strong>但仍然是可预测的</strong>。</p><h3>定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::mt19937 <span class="title">rng</span><span class="params">(seed)</span></span>; <span class="comment">// 这里 seed 为任意整数</span></span><br><span class="line"><span class="function">std::mt19937 <span class="title">rng</span><span class="params">(std::chrono::steady_clock::now().time_since_epoch().count())</span></span>; <span class="comment">// 一般用当前时间作为种子</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::mt19937_64 <span class="title">rng</span><span class="params">(seed)</span></span>; <span class="comment">// 64 位版本</span></span><br></pre></td></tr></table></figure><p>调用 <code>rng()</code> 即可生成在 <span class="math inline">\([0, 2^32 - 1]\)</span> 范围内的随机数，<span class="math inline">\(64\)</span> 位版本的 <code>rng()</code> 则在 <span class="math inline">\([0, 2^64 - 1]\)</span> 范围内。</p><p>一些成员函数：</p><ul><li><code>.seed(unsigned)</code> 重新设置种子。</li><li><code>.discard(n)</code> 跳过 <span class="math inline">\(n\)</span> 个结果。</li><li><code>.min()</code> 和 <code>.max()</code> 返回随机数的最小值和最大值。</li></ul><h3>random_device</h3><p>如果不想使用伪随机，可以使用 <code>std::random_device</code> 来获取硬件随机数。</p><div class="note warning flat"><p>C++ 标准规定 <code>std::random_device</code> 可以退化为伪随机数</p></div><p>但一般来说，在 Windows，Linux，macOS 上，<code>std::random_device</code> 都是硬件随机数生成器。</p><p>可以通过其成员函数 <code>.entropy()</code> 来获取硬件随机数生成器的熵，如果大于 <span class="math inline">\(0\)</span>，一般都是真随机数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::random_device rd;</span><br><span class="line"><span class="function">std::mt19937 <span class="title">rng</span><span class="params">(rd())</span></span>; <span class="comment">// 用硬件随机数生成器初始化 mt19937</span></span><br></pre></td></tr></table></figure><p>请不要滥用 <code>std::random_device</code>：</p><ol type="1"><li>它的速度更慢。</li><li>有研究指出，在熵池耗尽后，<code>std::random_device</code> 可能退化为伪随机数，并且性能急剧下降。</li></ol><p>关于 <strong>熵</strong> 的更多内容，读者可以查阅更多资料。</p><h3>均匀分布</h3><p>mt19937 还提供了 <strong>分布类</strong>，用于生成一定范围内均匀分布的随机数。</p><p><strong>均匀分布整数</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">dist</span><span class="params">(a, b)</span></span>; <span class="comment">// [a, b] 范围内均匀分布整数</span></span><br><span class="line"><span class="type">int</span> x = <span class="built_in">dist</span>(rng);</span><br></pre></td></tr></table></figure><p><strong>均匀分布浮点数</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">dist</span><span class="params">(a, b)</span></span>; <span class="comment">// [a, b] 范围内均匀分布浮点数</span></span><br><span class="line"><span class="type">double</span> x = <span class="built_in">dist</span>(rng);</span><br></pre></td></tr></table></figure><p><strong>正态分布</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::normal_distribution&lt;<span class="type">double</span>&gt; <span class="title">dist</span><span class="params">(mean, stddev)</span></span>; <span class="comment">// 正态分布，mean 为均值，stddev 为标准差</span></span><br><span class="line"><span class="type">double</span> x = <span class="built_in">dist</span>(rng);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025.10.10-A</title>
      <link href="/posts/7663eb87/"/>
      <url>/posts/7663eb87/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="5c692f22b4c38982a94584fd569357d8b700fa9b63730787088a56622edbd854">93024cf999deb8d8b2919f7e109263d436f7768a67e3b41578a0afeefd292b2d4999fc90f8999d6616be736d318b4686c019a080f804dc58f7f397fdc0e0aed4859adc7170991ee7d6ab2abf9f680a77d18728f5d743cbe3c1f19f805b99f8f33434949cdaa14bdc0eff774a5dac66dacbb2a06185373e71d4bafc33751a44439a2314186e85f523aea94e7035e39553745aaa25ba82881030bf79ddb084dfa57d342cbeb1af99637a787a02dddd9c3948b2fae9767174fa139bfe96361c92674eb7be550a2b78854cf202803fd2b702cb8769425adc04a3f3fdaf9087c8f0d0414a99bbc664dd70c6dab46d35ebfbb8814a3b7e551cbc10940214350b0e35cfa791087719ed29fb3207ce1b0a59fe21956e27551669b842142afc33c14af8ce9397ed6fa5c9b11c1ecd97b88e88912ac8bc0135cd250a70a06ceec9f504873eb344ac0e8a4a7345ce553ac1456917f7aaa50904b001179f46c9e8946874af08d33b3766566c568340e2d4bf7eeb89857ad02b1f05b69b0ecf953ef498b88095348915830d35b81eb774fea783b52f9557875ad76317f013225e85f538318127c5c5b81e26b3a3a9f74bf321f1690985c1d97d5c80d995380c2b17e455cb4277e87ebe70d5bf14959ebde14683854881037f36ccecace3fae159c354a978d17ba6b4c7032d87a8a59be1151bb916138a16dbffea2cf2b2e14a89a8bfbd69da6f3ac11b7186e8c199bb46407eedad4bf4aa6b532c8e816909e416ced093d61c4384236b3cd07d1a82680da30b0ed585f402a532a16cf7b7ec9a6bed91eef2b930544cb86a8fae9e653140ffc1464d307a47fa44293c339c87b1012766bf90ecb4caa17e0d1d7b9f89341ec29fd49cbf740c8f3c8d0eef2d75fe412fd29a9a2b6908214c978731347642970a29848a6dfda3411354ad7151dcf845da6bf1ebcb7d3f8d9e4b436ba919f45b2ce328a76a39afe31fb0a0ef4be41b63e1b279ba01cb17296bfc33f6941deaffac8e20870bd6fc32ddae0e1dc86833bd42d429b8fa6d9e6572a26f819d31aed1cc480bc883beab9adb13a942304f4ed03105e65a2347073c068dfb13c1e0b5d4bd6490ca6f6cc6a68f14f224cfbfb576fb883b7908121666ef98e6dfa277ea783ef79a8c151d457ce416b70dc15341cee326b6f4e12a2af2c6a382ce0b80f77e01c0490d496cb8c87e334a5867d3d16a68a69d5e6ea8d4e9e88fd3abfa1253b422b3f550a1e3cb3bca8373728b7c1f5d13c82de8c5cc42991ab37dd6fb5ab24765782c2113644910adf9f725adb1462d65f4ea66505e6e49d27148fb639af3f52202e5b535b41abacba5ced7c8aec0b749b6618376fcd1bec36232b4c2abe3da766d17b4029fbf6d0cef77eb1fd77d245addac40156c2b47511683bcfbca48f9c41aa1c92abaa5bc9d12766217e0c8eb87f6a7238c7d0b274daaf8755da0897671f5845a094717882381bf62d1a5b4ed1934533686514af7b6caa841de0d6d01df726ed6b0ae1b95f94860b6329660a4a65056bbed507edf67f2907176c68e3ef3514c4b5216426adbbf89376979458daa1f592da4bed09a06bca21f7834480a680af57fb9aed269c7ba44b4aac701210e620944b31de08ead73d3284248f4e4dfbef8c3854c5dcab256d287dcc25954982b41bd987125c3e831fa7c10480d8b3f7f89a4ac25a47bc29ca7814438d5dadaef93856b74467044e178d945f9b5614034e1da0a4ef27bf12a627d64c43e286798974ceabf14dac77c195b6682562626251f9b22962e1d6a7aa6e9a99070774f66bf0e5c954a43b185e00c12ab75d6ff05a09934b748b61afbee25efd3ebabdc32bf6107f25091223ad75721030ab574d05bacea74366955cfbc9bb2f19ab27255c7ce740c897b75ecdec079cca7b9e924cf1f16e459d221a024517ced832c294e9cdd0d83ec3a4ef224d2f34e7fbd228350beb7708c6398db26ddfd723e41bf6cb7014ad2d39ed3b8482e2bc85d35cd1d13bcd6348295467d7553766af496243d5d820aee083b60d7a4c09574cdba29075f879c88ec82d739a09c936659dd7e8439f4dae74a1260f3d99009a4758df4e6a1007889c93227c02266dd9b61cb80429364543fc8333f9939a9d69a0f4b06d87b16b2abea95d4ba052ab807681fce86c0e0306d93682204473f961f24626e97c59da458cafaa307f22041d4a267dc2dbfbdd658ca9d671fd7dfcd8a60a354942c3db8666ae9eaca3d7872c129cff59b1c8c8845fd2a94cb71e89761047e84442ae8e10dd33cdc98d3c588f514e8b6ce339e75d5961762984494c315d02d2e1b627e182700488b3e3427edbccc3b1aa9cd44ffe0e569864c0f46712003da9b6ecf5d70422f1bb68e87c7c47009eed43ac07e7f668e6da2b9b70cf679efd9bab54a9d5f446d3305e8f274207ad98bf8fb6652c212629fd834fa174f10410830802d11596d3affb5825cd9ff4b691fdb07edeb43fdde3bf50794bafc996128e5eba6f5077a1a7c3809ee5299efc2e32047c7f7affbf28ac15719bca02238ce4678bf2913badd5700585b413d505e8914880ff3a2b207c36566988f231e8d46cd26f5e104b3581bdbbe757f54a6c934fcd2bf8f2ed34c0370c1818d8d3cd770a1bf7be25cd5cdd1d9138c2371fc937295a8d816e263219faa265b430435dd043e75efe4fa4a948005d0b46e57f432c4017944b4559f74da2c3923f043256bf4e63f012770647d6b2edb94e9355777c5cb2bf2ff1abda821c88fd783ab54421e225d0f0eedf5d1c48522cab1b3b3c11db1f5f1c88ac7cb6f2bb1590f47b08e1f2bd21c45723c1023036cf06be329c7224158a06e15e845c1ee6664c176fe3fa2bce5ac76e97bb72a3bca57eb849dd87352b899453db9584289658650903403fc10406f7512d419b3298afc0657448187527df33307bc32a000550dbc9e5fbe1552e6bdb7a56e0dac8366f0282d8a2d0c9c1c3f037033934560e6d2134a463719a0439ecea3fbef3847ed3d244e71e6cc10b2bbeef8c329f37a518b7e3dfbce7f786d2b6ee85de7544472f966f4cfc293271fbe0238a1f3ceefbd9e8837f777e2f4f6adb6d307832bdd243a20d01275407ed9fe435399fafb83f25714855fcf50a696eaa31431f03f637c526c499cb6f01f4e487cc277cf7ec2e215729b93167e6467d53dd1622ff0f58957519966aed274c7b603ae877594b61ef947132f1886abe811372d93bdff33b01ec83bceb64e4d57c4f213f4eb385631f13e5c1dd2b10e2bf7aa433113ebf6f67c06298c894da489cf8d2a68a6dc35d33a2d8dfa37fffb4d2753e07929adf107fa01e028afd19e52ba9f7981686459f3b9a70c866fbf0e751df6bf5c66c56fad18d7b03a9229edd43c201c5fa2a378025027505e1f300c42f6dbca1607b294a9fdcb192ee3277581e671b3316151a3ba1a736c9cdef75fd3b3c0007e2ccde12eb926e16f74b968358f47b0f02d6f258fc57fc1f86508dc3a382741240aec571dfeac169d8071986e95826f99a943d8c171cc6209d6480236f61cd72d054facad1254312de958942d5af31dc4e0391b2e8304576f4bbf49359003aa5d56118b53396cf77ba14a804c88cc8f6260876cf59db1fcce7bd9988897fe6b136da8a7bda1b2a7ab978c674e7bd4a9b79bc7a0e1f63805d00e668dc699db60934cc3033e708727e70538f4a71630fc9230ffa3019894d663727f4d5bb2eff3d7d7bccf97c57a9baa8b6b6eab0e083317c477b9bd51572a0eda49404f5df73dba51a4c1d044a00d29f82e1a585fb8dd8f059187f674110f3af195617e5a824b80c64b4674d71a6e9a67c6cb01add010534d384dc750eb2c98d1777090e8df691fc2781a3022608cae98a3aeb39e204d6d8e20a8d54d2ea884cf1c979c6b42169d2df009c0d762efb3122ac3ce801b02686a056447ab5671fbd0e1c02b6d423f4fd8335570cb604d5c7fc0e40082597db09f37874ce41de98b8191734fe0a715a6598c10b715f0a9d194dcc9361d703befa50ee773a6a2fe50df91ad6fe1ee04f5c48b3b59a5c7c6420b5ed874567c1763b5a185528bb87c1afe53cadfebe855887d2291a807ffaff8b39fb3c5555946a6dc750f01bbbde65693da87c7d3eb1bd6faf1608d1d914ff3c1630ed41157f3c361585c9898520988a7e4a33bfff67fe34cea8d8ef5554b8670006954632aad934bf486d1f4975291ddd78144eb598b9bb411850c6830259cd67363669daa3d93d2423fed673bde2fedea1ca2d9a693faf9b4eb0f16792623d8710242823fd858d2022ad9244ee2570ce3044ddb0dbb99f63eb59037f3bb211891e9b086c68771905940368b86f1fca1830f7833eb089f93287709dc2a6b03e801653e2668ae722dd972bbac72b13485232fd08b1b3765c1b9b58454b9ad84bce4a6ccfa0a5da61696314c29f6f8064ef9cc5ff96b2c764428534a0b0cd2b113904a2cb270712d5254d35b5e93af800a917d689b7c7ab29403eb26c6c79c527f640c9e53e5d0d5046278cf1f23c9fe9244416d8c7648e7897faa65a161d6c37c67f6efbee645798988efbad4388eddb7567f39491bb64e6994c15717a9a598343379c6573ce16d3f55a8fb59c2e668228516358d88d37a813f9d2c681c800d39c2707496d4fe026a3d7f3f998ed6f435fcadf998142c31656d50aca2af90bebefe43543ad1968228b7fc25f6f3358f71e91db0aefbb0535dfafde2b43ec12ddb80c39d5d72091391efa837863dabb9df5dccfdfe40df7fa7ffdb8104efe1a6caa92570a4e721b337c0e751337a49003708ac9e55763910ce8fd93355260feaca98bf725436329c7e6416b103a28540401975ad0a1061ca2e800b4b29d1aa24f370b208e724ba43cca5bdc0e72db9d79cfcb8710dfa35cae44313cfdd353bd4e216a7cef57c0475c28b6e9097bf997c8c918bcc9ef2913445e667b9ba97c822d4c7ed97764dadcb103b9ab786647bcb679e188956ab4d475fdab678e2bd13215fa1b56f7d9f9263517dcbff955f6100b9ba754eb13af9703f8c0a9a7959be8a1cef52d770530c65d1eb9a85a039508f415b5600bb0b05c9fe556ad81ba7fb5f1b13c8d3e1b56f679a5c9d89284d2fc397e412f370039aded673e7eb665e18686065b4df6607ff5f05500641e3745880f141496ab3a777f8cedbf14f56a5a943f9810ebb816add3439338efb814657132e66dd416bb58b2ce7d1202c666c57c65ee163a4ff085f5351364d36c5703d8d0fd1d6cfb18591f38da846c3aa0632696b96c68af9532adedeaf81edf107d22932359cc6c7c90feecbc2139804eeb80a05bcaab1bd97eb3abc62c2f3ceeb8d9026c6b49a74f7ee19a3636e7dd7f652a5c05ef5822e90179800d25c3007ef7fb66e1a80813f20cb5fd71c91c96a4f8d7c046f94735aed2408a526e0d1bddddd87df434d3f35b370cd06e2ae765d69cd3a9b6d93eb1b89c0dec50049a6654c35d8d2051fab353d6733b8447ad9c684625810ab9916da0ea3dc81660aeca64aeedcd4b878d86dbd9ec299a067d24e8fb511e3d7ab778d307d9753678599c0ad4075d402a48ee160644d15fec6159ee5e52774f885152c690c97ba97a91871c7965dcb61baa32fe8262a5e08ca1510b702307d77b91676034739674f083b92c3428e2519039f2c02dd4cdab57366bf5ad81ea9d6e02f5046c61477d87696c968cc0bf294ad677fa7d823d61518f2eeaef850a27f8d668b006ffaf553512e30b0080aef120aa8dce59bb29d9d9df3fb970a6247455f1394a90ec0245412bbedf1815f417eec7ba0decf1ab12d29185f158b785b5fb22983ea6e0f14b34a23d44c3bf4eb4daeee735d94e446879895dbb7049e50a63ca2d2c551176c182438426d81df89c27e2e2de017c27439535e6641560ba99eae89f07fd2d661ea154f09e816b79c833c4306f01108093f81b110f60f08322534030b458a9b6b9e1b33086970f4656d007341d35dfc636fa31e43fce54ae81304555c0c76894be8e53001e643132819181123fe7387b597fe8092ab6ff915bd850c70db74f5dea8d00b32067d19ca02289572dafb32060a634f63851eccd50ccb6328b98f6460ad3954d41a1d6943c2ceef72c4addb225d2f098c8a2fd3bc3a4e98aa4c41b76b05cbf0509424d501ceb953ebd21b158b3b1bb978f4650214469d3b2537df1a809733b32d3d25197483642b62e771015f870b1f855d8fad976949b40c8c539e4ffeb5d4c187e49ff1f729ff5e84f741eb6c6c11249568013020f7238783b3d4f50d7dabce919eac9c131d8adb85cd5489f811118bc7eb431ac3977b5dccb58e5215d333403d6c23bc0e28cce2768028d30591f424cd53a949a9bc6c953f5a0d1caa6a4e3b3592040922f5b3fdb07dca01c814b9b5ec5eb086b629c08f366d6050c417857f9b369d3f662c2ed318228b4910c6c67d569d82ba56323d4d70d8c8dfe1e8e075d93d15d500521a0665e29914deabf45d226a555bb3c38dd05e47ec46ff56487928d46bf2190cc6102b1f2638ea9074b263bc354620e69dfde80d30fcd23bb0ea17d19c645fd13482484ece55c576dc13f4fb63fdbf261eb65c7737c3932c03d6ab05dc6597f9a369c7bfa4fa96026d6084f9859c63a32e679935af49e12d69c8accd9bf5e5427f5ff99489dbaf98db4c328d4bc08666455c04265f7792d1133b864877e98f8b5638a654011c1c4f4795ed2b5d3b3c22d767c01727594979bc650696753f4b6973301b939ee2703789bf1176ad764a9be45e69c542fbf983bc3705e22c912861ef0571c5661167c9b44eb0a13a4feecbd28098ad830b07f91ea30a66f7522f369b6fcc94363012329e7458c4e8c6d34cf63d7cf0e79e93a3dc67f9d612b24e0d4f66f7d42b58772f24c4bac64c82b9569e602d120718af47e0c191b34dfb91fb654b443e10e3edef9b26f0f48ce28138c9608049efbedd560c1b334cbd9522440da357c7f78270d14b0cf4358c73413b81808dfa696843be3380f81fbcacad56c7a8f71185c3baa8f195fcb8ff61c4b5f3b05f6e4c0feeb0e1b75a02204d9392a6a100cf2969afc2cfbf38b74a533da0fa79eeeb73cf51f94dcec130e5255098106302e4b2ec31bd1338844d618e31b9e89f720e4adfc7612d6d2a5ae7a6da8a81c3e4d72926a012702f701ee39c9a8f0810d59e155017ce3cbf0f1c30289eaef22056f33abdce7f62c90feed9f32caffcf45a486ef01a1a78f338c7a5c8fdaf08ecb79558a5a6a1cb6c5f5e30e08161ec96a964c39b373a058b2366bcdfa0e108144f269582e56b98e8e0bd4f6f16fd8fa1225891343933d1aef14e5ef3a7ab2d3c1bbeb9132aff0259638964e971631650c2872af6663af9d833a8bc2654781feb5894fb8969cff58f236e7c1f34d68ebf2380a07ef592275543fa573ee9203a26d9746f96c484f91ba9d89eca39706e038da6ea869c7f2ae6442a7af929df2be0295bda52e607de79cc11f740e15cd41957bafc1526345dbc133828fcdba940e28921fe2584dcbf8ec94929c00b891346fc25fe7473aae36c1309b0c973938b00061de9e51800a91df1093cb90fee88b3e2c7ff2d5e3f26454d011325361856c36debe54f89e719df51ad24285edfb168d3f5b17ddbbbd4f6e3f7a2020f4e7673dc52d9e0ac54759857802b369bb75589043a923c2cf925d6b70c91b9889beacbc631f25a3827a0910ab0c8f3e80f0615d3b5684a54629d924f9b0b58017c25598e641cb56608d75f46c5f933ee8a31e726ca71053a4e7a1ae0d7525ca2d1e2f67dbd5ef5a3518ce96d03273306cae365cc22fb0582790526e4c09f5ebbd2c4588f83bef39e45cd43781acd294ea8dc1bc612e302c78c48f9e0d03a80680038f0e05dda012966cb367280e1b520d48c1e6e9ef9b6d4e8087c953bee9ead8f645453ed7d1a3133217f86c506b3fcbd4df48c1bdd5fc4fa488079c3312df5e6a0fca8a01015c181b75d7f9d597665debd9a1bb6b3b206f224dd2631c804308683533584c62af25c497bc74a4b0951899c809f2d2e80c933389913e52e2142c2d446992082767efe9f43e85acdd6b69b40b61755d4ce4389848eba6db5d8eaf8a42a09f24bb874437d4f75d6e336ebad1c0376b91c2a73af4c817e84cb4e7ff3bb5fcaebe468b6ce280e1b643df6e0f3a6c8a376ec0590f9566be580ccb39c03169a31c65f0bc17194fdbe4f9863132d87d472fc9c5effdbf32d760591363d48fdbb653ec85d39eac58198beece86caa2af99b972e06d2d5fb4d898f7af5aaa01935bb286b77d25ac819ba54b3437872bd6ef2b99109945d94dff5d06ee3247e1d152752116b4be46f04063f22dccbfccb3024c189475e548cdefe2e77adc68ac178e8239575d3ad1af47ea7170a1a32660ef16fb6d5c92be34123184fd8be355e4cb3f1c0211aa6e47a6ebbc092fe3f8980af47a8148f2d2e8601341282f3ab88ebc0c21cf7138468023987acbb4a88853b2a79e5cb85267bd0819dafddd106e7c397e99a40ba0b1d60f6f3970ba38729b9d3e5b6356e600a404f414d7cf36378039e93e2d78804922c8861decfae2ef858edff12f7ae89e680855e4c2531ffe52aa5b615bac7bb8eaca20e1c0ad04bf08aad3fbb87b6ffe0d25e9014e3de907ec2293ac462ac39881469fdfa795b8881fc6f5cc41084e4eb854ea64b371c138a873103825a783e4bc05dabae803930896dcd954e0c42dcb10a3e0f98c36e988ee5f249b75ce021878cc80e33fd09a6ab19fd7a0c1ca5804cf8c9d017340b8ea3708e98ea9e14a7543e33a67e8585e4623bcc078ef2cb0cca22f7dba91c3ae20008f30777c85dc6ba43fd70ce098f32288808cbff0dcfe862be40dc80de4b15afd7158807c695a11c75492d5289956ba09a79d235313af100284439d7af47734099559c892d2654bb4e99063e0bcbf88b93ca42cdddf86868160a7ee611ddc164d288ec706a26f4f4338e630f5f517eb68af739b98e318e0eb1abf83610a5ee8538c9d29be226073e312f15614caa919a4df01c188e6cb93dc19391691e2bd53dfafb49d499e8d5e95b4a31f7dfa5f9bc798104328678fac5f07a12c7c2a50a8f01bf193c719a77b5d22e4022a8f2a9ed12b7c7eab361ff7dccc0c48b0ce9127019b7745518f6740116ceb4d53530f85edff5867937520900a640fecb0538d32149a2ca8625df443334f80c5c93b0a1b056085c6eff5141353f1f84b7b7a3a0b143637e082925d0b912bbfae3999c04426a686563fb79cef723b21b50fbc00a5e5c6a42e17985cbdc6906629949a57983841b49a1bcf50d6e6d9cdc098f7447cfa0c90d3d11d20244a44eb7f33ff06d188d5281945dd87202637363dedeae80ff84734d5dc5bf5865b15e668bfb98da7a53c6025ed7a9e4792397d07b9dcf6ff8cf444cbf8f65e804eed707c5c2ef7f136c6ddf5baba7dfb5b0dd550e3edd2acbe7e051165fbfb11fba0876baa5dcefaddaea89f13d5fd7b0a15ef7715e3daa4cfcfac3219ebe9d55bf85d62c24773062af6b6192c28a12b4a35081848dc7f8694da047e6a778f7ff18fa7da8be7d16c151987673d94115f5891f53a93c887d9c3c6977187881b6e18e1b6b5a5b8e4989181631482f77a5ade4e005849294cd0c1663e20708097d2603c14997220c6fcf306a734c5a63495e55dc61c9f5f99d09aa6a49fd4fd1b840ca33deffa9c36abed6715288e641d8bed4c1acbcb7547e167e25c959582a8cc83a6392f900de97142efc1c1bc259e142ee1d8b2c850d12d940add9c18fbdaacc084001ff7a4a4156b00a00fdd5089df331318c879abf5f963229fd9670d4036f3b59d577cef11f952453e3bc6f756dcdb87cd16bba1f1696dfefc20d6c61df2ed4df0687e9f22f12bd27c8812e8008dbe44177aeb550a4cb7ed6d502bd6e39070b328a0cbbda644c32ce8c2347e156e16700d3474cb3d231390cfdcacfd86e132845f3c9c9c3a84a4d016265bdbe18ac92c63328b8842c885a7d102931cb3f3c2a273c026ba940b8622c3fefa3f37e94f2e5df7a5f5ae77f0e16404d413797438dcfcaa73874313b78d2d10874f0421a671e169251aacd7003f938e1a14e8e771f59ebd8bec115435f56237f021a9b8039f2bab9cc6c1e3a80b21ea1fcdac8d3b1ab2c480a7687c895728611cfb543807c9e7dd36ad514c79e93cf9e63857db2551417c8afcb9abd8753fb54b06e9da1f5acc97fee09505bc216115ee48abe3bd051c294f6e8a816394180a8295db58d8a1879de15f574e94d44cf7e14c47b5e26feee5891d32d629381e8fd3de0735553f47a2ec20b5c74e9df81bf5b9caf5e1c03a19e1311c665dcbfbb0784431d2451426aa729f14f9f91bd8e6b2a3a93bdd81898b63c16fc25e1370cfa038c0af1f47ae114339055fba8c10f5f98b70ecf7ba55f0d45aafb1f1368f0559376392f5c2281ebd5e1781302ab438e964580dcaecfba442754f4339535d6db937e525cb8bb4b4871fcde2693f68aa19a1dffbbab3bf2cc8eb87b8ae4ee3fbd656730f25b220f71587f0c2611bc81d41dff8921b454a4b3f9028229c6100b0768da7cc124411999d93d7202c8b736d5e98116b028c7a3877a81cd0239a3a82fd60d4a2ede08e34993376cbc4b125197d7d6b3ce933d57576082e70c6785de28b03a7752db00e765872146d5126f45349619077cfa151b4d6a28562ee6fb01304710ff49f1cb8eed0627dd4074ce611503d8dbefff7ecf2a5027cc0e3bbfc0a8aa1012a64c1796b837965e2d65f5f0459711fff140a24883203732ece793dbdf22daf6ae98131c100b2600f017d5540f481badb97280f88a1319212c1bfa5f7f3b7c5138c8a7b0188ddcd7f3214c83e1006baafc6c333b528094e419442b80147329a62a9b6ef09e58e41c8bb185290deeb5e3fe83eb42bdbb8d9c7175bb79bb7a577eac85921b25cf4e7ef100880e5a0cdf4b0013a80af7609a6dc5a2bb0f139b053f944747ff3ac39d0767ba76c6664c57b3d360693b30ddd2c4f57aa1c4cd08251b0627ce84d965b3d379363074256e681ecdd19aa9acf7e33f49caaee249cfa99e1c9b7d9d5f5612f543518600e2b4896bd33909a3cdf0dd9ffeab6645d4438046dba07ea6ded71c67c665e9f3bddac4a32afbff531a1d1bb9f37e0b689ccfaf0c7442c8f96fa146dea36043a88d428d5ec3e86e7027b99fa0971eab00d9819b3730d827a2df5ff8e8afb1e61f161d2962e9c3af4fd5457eca0d77a85ef91b92311edc940af93104597ea8c85b0f463b245017655914c5ff3eb0e99d6904fef804a55a26520aa20172f0a019aa951408105ebf71cb0d4e6b790647461a98a7a38652d32ac10574e12d2264c2ba6d72cb227cd773205eff168e3f78881a8abbd908c846a7a864511dfa25427a657657b469ac1e01e1daafe2887f0c7dfdaf29ff15a178b8131608617d11a14d8ec2d5b539800a6a55c9cb00601bb73b15abb7c4ff65183479bd3cfbb6c278587d344a09d5de93f251ce8074a05497719d0aba9e597eb412d67c66b2fb326aefdb474bc17183497bf827af2a286c9b82e78ee1ca2f1359f6b99c3b36eb8cfd33cb1b03fe31271d7c29dc5751b1c6d1f5584c46734cb57f6f5cc68a72d844b1e76ca977fec3beb262702fb184d9e66a9a1f1a695cac238bc5968dd70911fb6c65e3c82ab7e5e16ef60c8d378cc61133d89c6ef8a790f901c724cf6e70ba6d2d9a375326591aa44afe31e9d7b8d942f4c4a6d76437ad2415d72dce24efab54772ca048a034c18bfd3d9e93901d8e4c0a876538876a2c510abfd9a7c2c3fbd84d52ebd141d21dec406e6bd1e30983b6b03fecbb769179285298e6135b566c20270f5eba20c5616062a8d921ce4861ba13606a987f4ece464e5e783f672768c1f70d34843c48d87ff8855b0ef2ce128e02d816f69c5412f574ad51ca92562d10ef8aee36c607491add3f8bb715a22a4a711781c22f18b5a3d2428b3648214f1f2b01b26fa81cb35c4bd119df789911fa9d7826ff7876d8a9147e6fc97ea137013d5c4686cd8e16b7410f6a513b818d0cadc87a088c6a547e8db2bf76055da29985281cbe50548cb5a3fdeb25eed3defad42856c2f36b19eff2fb893a9c79030b95e34dfb143775d0314dae1f3088be70cc5990bdaeb6eb64df6a0db8113efeb258ecf25a42041e25b3b252715a6b9a667339da8bfb6c9296b622350f146115d104900db51d1db27b970348e0e37c12ea176979093d5633f4d965201e5d6e3c152b48b44b1b79b26f838d2c28a2fe665259e196d98a93b95451cd4667c354a317b1e4dd00</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> school </tag>
            
            <tag> dp </tag>
            
            <tag> trie </tag>
            
            <tag> manacher </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF 2152</title>
      <link href="/posts/e5225a54/"/>
      <url>/posts/e5225a54/</url>
      
        <content type="html"><![CDATA[<h2>A</h2><p>简单题，大胆猜结论，答案为不同的数字个数乘二减一。</p><p>但是赛时离散化忘记指定特值。</p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>把目标数组去重后降序排列，令其为数组 <span class="math inline">\(a\)</span>，长度为 <span class="math inline">\(m\)</span>，对于 <span class="math inline">\(i = 1,2,\dots,m-1\)</span>，执行以下操作：</p><ol type="1"><li>增加 <span class="math inline">\(a_i - a_{i+1}\)</span>。</li><li>对于所有 <span class="math inline">\(a_j \neq a_i \text{且} j &gt; i\)</span>，清空。</li></ol><p>最后增加 <span class="math inline">\(a_m\)</span>。</p></div></details><h2>B</h2><p>简单题，博弈论。</p><p>最优情况一定是 Krug 被逼到了边缘，所以 Doran 也要走到边缘。</p><p>根据 Krug 和 Doran 的相对位置取 MAX 即可。</p><h2>C</h2><p>难度不大。</p><p>考虑一个数列如果不全是 <span class="math inline">\(0/1\)</span> 交替的，那么每次操作一定会有两个相邻的 <span class="math inline">\(0/1\)</span>。</p><p>如果全是 <span class="math inline">\(0/1\)</span> 交替的，只存在一次操作没有相邻的 <span class="math inline">\(0/1\)</span>，即答案会多 <span class="math inline">\(1\)</span>。</p><p>前缀和预处理即可。</p><h2>D</h2><p>赛时卡题了，观察结论题。</p><p>首先不看增加的操作，将一个数清到 <span class="math inline">\(1\)</span> 需要 <span class="math inline">\(\log_2 a_i\)</span> 次。</p><p>对一个偶数加 <span class="math inline">\(1\)</span> 没有用，立马除就可以。</p><p>如果一个数在不断除 <span class="math inline">\(2\)</span> 的时候，出现了不为 <span class="math inline">\(1\)</span> 的奇数，然后对这个数执行 <span class="math inline">\(+1\)</span>，那么怎么除都不行，所以贡献会多 <span class="math inline">\(1\)</span>。</p><p>所以除了 <span class="math inline">\(2\)</span> 的幂外，其它数贡献都会多 <span class="math inline">\(1\)</span>。</p><p>但是，还有一类特例，对于 <span class="math inline">\(2^k + 1~(k\in \mathbb{Z}^+)\)</span>，如果先除贡献就不会多，先加贡献就会多 <span class="math inline">\(1\)</span>，先手最多除一半的数，所以贡献会多一半。</p><h2>E</h2><p>赛时没做出来，构造题还是做少了。</p><p>看到构造想到询问特例，于是先询问所有点。</p><p>然后每次询问除了已经回答过的点。</p><p>如果某次回答长度大于等于 <span class="math inline">\(n+1\)</span>，直接输出。</p><p>否则，从每次询问向前面询问的点连边，跑 DAG 上 DP 即可。</p><h2>F</h2><p>思考题。</p><p>转换条件，满足 <span class="math inline">\(\max\{x,y,z\} - \min\{x,y,z\} &gt; z\)</span>，贪心的想，相当于满足 <span class="math inline">\(a_{i+2} - a_i &gt; z\)</span>。</p><p>所以我们可以选区间开头的两个点，<span class="math inline">\(l\)</span> 和 <span class="math inline">\(l+1\)</span>，两个点不断向后跳满足条件的点。</p><p>我们就看成后面的点向前面的点连边，树上倍增优化即可。</p><p>但是两个点可能会调到重复的点，即两点的 <span class="math inline">\(lca\)</span>，此时显然要从 <span class="math inline">\(lca\)</span> 和 <span class="math inline">\(lca+1\)</span> 重新开始跳。</p><p>于是再维护另一个倍增，表示跳到重复的点。</p><p>查询时先跳第二个倍增，如果区间还有剩余再跳第一个。</p>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 奇技淫巧</title>
      <link href="/posts/78aab76b/"/>
      <url>/posts/78aab76b/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>编译器版本： gcc 15.2.0</p></div><div class="note info flat"><p>C++ 标准： c++14</p></div><h2>前言</h2><p>本文介绍了 C++ 中一些有趣/神奇的函数，虽然不一定用的到就是了。</p><p>STL，lambda，随机化，chrono 均有另开文章。</p><h2>__builtin</h2><p>以 <code>__builtin</code> 开头的函数均为编译器内置函数，效率极高。</p><p><strong>位操作</strong></p><ul><li><code>__builtin_clz</code> 计算前导 <span class="math inline">\(0\)</span> 个数（<span class="math inline">\(32\)</span> 位），<span class="math inline">\(0\)</span> 是未定义行为。</li><li><code>__builtin_ctz</code> 计算尾随 <span class="math inline">\(0\)</span> 个数（<span class="math inline">\(32\)</span> 位），<span class="math inline">\(0\)</span> 是未定义行为。</li><li><code>__builtin_popcount</code> 计算 <span class="math inline">\(1\)</span> 的个数（<span class="math inline">\(32\)</span> 位）。</li><li><code>__builtin_parity</code> <span class="math inline">\(1\)</span> 的个数为奇数则返回 <span class="math inline">\(1\)</span>，偶数则返回 <span class="math inline">\(0\)</span>。</li></ul><p>上面函数结尾加 <code>ll</code> 即 <span class="math inline">\(64\)</span> 位版本，例如 <code>__builtin_clzll</code>。</p><p><strong>内存操作</strong></p><ul><li><code>__builtin_expect(expr, value)</code> 告诉编译器 <code>expr</code> 最可能为 <code>value</code>，用于分支预测。</li><li><code>__builtin_prefetch(addr, rw, locality)</code> 提前加载内存到缓存，<code>rw</code> 为 <span class="math inline">\(0\)</span> 表示读，为 <span class="math inline">\(1\)</span> 表示写；<code>locality</code> 为缓存层级。</li><li><code>__builtin_memcpy</code> 同 <code>memcpy</code> 函数。</li><li><code>__builtin_memset</code> 同 <code>memset</code> 函数。</li><li><code>__builtin_memmove</code> 同 <code>memmove</code> 函数。</li></ul><p><strong>数学</strong></p><ul><li><code>__builtin_abs</code> 绝对值。</li><li><code>__builtin_sqrt</code> 平方根。</li><li><code>__builtin_add_overflow</code>,<code>__builtin_mul_overflow</code> 等，检查溢出，返回 <code>bool</code>。</li></ul><h2>强制内联</h2><p><code>__attribute__((always_inline))</code> 不管优化级别，都尽量内联。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> __attribute__((always_inline)) <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>分支预测</h2><p>C++14 只有上文的 <code>__builtin_expect</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect(x &gt; <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">  <span class="comment">// x &gt; 0 更可能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++20 新增了 <code>[[likely]]</code> 和 <code>[[unlikely]]</code>，用于分支预测。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>) [[likely]] &#123;</span><br><span class="line">    <span class="comment">// 这里分支更可能被执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> [[unlikely]] &#123;</span><br><span class="line">    <span class="comment">// 不常执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>constexpr</h2><p><code>constexpr</code> 在 C++11 引入，表示一个变量为常量表达式，<strong>必须</strong> 在编译期求值。</p><p>相较于 <code>const</code> 的仅保证只读，不保证编译期计算，它的速度会更快。</p><h2>algorithm</h2><p>这个库东西很多，这里只列举好用但大家不一定都知道的。</p><h3>排列</h3><ul><li><code>partial_sort(first,middle,last)</code> 只排序前几项，即保证 <span class="math inline">\([first,middle)\)</span> 是最小且有序的，复杂度 <span class="math inline">\(O(n\log k)\)</span>。</li><li><code>nth_element(first, nth, last)</code> 找到第 <span class="math inline">\(n\)</span> 小的元素，保证小于等于 <span class="math inline">\(nth\)</span> 的元素都在 <span class="math inline">\(nth\)</span> 的左边，大于等于 <span class="math inline">\(nth\)</span> 的元素都在 <span class="math inline">\(nth\)</span> 的右边，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>is_sorted(first,last)</code> 判断是否有序，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>next_permutation(first,last)</code> 产生下一个字典序排列，复杂度 <span class="math inline">\(O(n)\)</span>。（CSP-S 2025 初赛）</li><li><code>prev_permutation(first,last)</code> 产生上一个字典序排列，复杂度 <span class="math inline">\(O(n)\)</span>。（CSP-S 2025 初赛）</li></ul><h3>查找</h3><ul><li><code>find(first, last, value)</code> 返回指向第一个等于 <code>value</code> 的元素的迭代器，如果找不到，返回 <code>last</code>，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>find_if(first, last, pred)</code> 返回指向第一个满足 <code>pred</code> 的元素的迭代器，如果找不到，返回 <code>last</code>，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>count(first, last, value)</code> 返回 <code>value</code> 在区间 <span class="math inline">\([first, last)\)</span> 中出现的次数，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>count_if(first, last, pred)</code> 返回 <code>pred</code> 判定为真的元素在区间 <span class="math inline">\([first, last)\)</span> 中出现的次数，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>binary_search(first, last, value)</code> 判断 <code>value</code> 是否在区间 <span class="math inline">\([first, last)\)</span> 中，复杂度 <span class="math inline">\(O(log n)\)</span>（<mark class="hl-label red">必须有序</mark>）。</li><li><code>equal_range(first, last, value)</code> 返回一个 <code>pair</code> 表示一个区间 <span class="math inline">\([lower_bound, upper_bound)\)</span> 满足区间内的元素等于 <code>value</code>，复杂度 <span class="math inline">\(O(log n)\)</span>（<mark class="hl-label red">必须有序</mark>）。</li><li><code>minmax(a,b)</code> 返回一个 <code>pair</code> 表示 <code>a</code> 和 <code>b</code> 的最小值和最大值。</li><li><code>minmax_element(first, last)</code> 返回一个 <code>pair</code> 表示区间 <span class="math inline">\([first, last)\)</span> 中的最小值和最大值，复杂度 <span class="math inline">\(O(n)\)</span>。</li></ul><h3>修改</h3><ul><li><code>copy(first,last,out)</code> <strong>复制</strong> 元素到另一个容器，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>move(first,last,out)</code> <strong>移动</strong> 元素到另一个容器，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>fill(first,last,value)</code> 用指定值填充区间，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>rotate(first, middle, last)</code> 将区间 <span class="math inline">\([first,last)\)</span> 变为 <span class="math inline">\([middle, last) + [first, middle)\)</span>，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>replace(first, last, old_value, new_value)</code> 用 <code>new_value</code> 替换 <code>old_value</code>，复杂度 <span class="math inline">\(O(n)\)</span>。</li></ul><h3>随机化</h3><ul><li><code>shuffle(first, last, rng)</code> 将区间 <span class="math inline">\([first,last)\)</span> 随机化，复杂度 <span class="math inline">\(O(n)\)</span>（请不要再用 <code>random_shuffle</code>）。</li></ul><h2>numeric</h2><p>这个库提供了一些数值计算的函数。</p><ul><li><code>accumulate(first, last, init)</code> 累加区间 <span class="math inline">\([first,last)\)</span>，<code>init</code> 为初始值，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>inner_product(first1, last1, first2, init)</code> 计算两个区间 <span class="math inline">\([first1,last1)\)</span> 和 <span class="math inline">\([first2,last2)\)</span> 的内积，<code>init</code> 为初始值，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>partial_sum(first, last, out)</code> 计算区间 <span class="math inline">\([first,last)\)</span> 的前缀和，结果存入 <code>out</code>，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>adjacent_difference(first, last, out)</code> 计算区间 <span class="math inline">\([first,last)\)</span> 的相邻差，结果存入 <code>out</code>，复杂度 <span class="math inline">\(O(n)\)</span>。</li><li><code>iota(first, last, value)</code> 用 <code>value</code> 填充区间 <span class="math inline">\([first,last)\)</span>，复杂度 <span class="math inline">\(O(n)\)</span>。</li></ul><h2>initializer_list</h2><p>C++11 引入的一种新的数据结构，支持用大括号初始化列表，注意定义后不能修改。</p><p>常与 STL 容器一起使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; l = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::<span class="built_in">max</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><p>或者用于循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>iterator</h2><p>C++11 引入的一些迭代器相关的函数。</p><ul><li><code>distance(first, last)</code> 返回迭代器之间的距离，复杂度 <span class="math inline">\(O(1)\)</span>。</li><li><code>advance(it, n)</code> <strong>移动</strong> 迭代器 <code>it</code> 指向的位置 <code>n</code> 步，复杂度 <strong>依赖迭代器类型</strong>。</li><li><code>next(it, n)</code> <strong>返回</strong> 迭代器 <code>it</code> 指向的位置 <code>n</code> 步后的迭代器，复杂度 <strong>依赖迭代器类型</strong>。</li><li><code>prev(it, n)</code> <strong>返回</strong> 迭代器 <code>it</code> 指向的位置 <code>n</code> 步前的迭代器，复杂度 <strong>依赖迭代器类型</strong>。</li></ul><p>时间复杂度：</p><ul><li>对于 <code>vector</code>，<code>deque</code> 和 <code>array</code> 等，支持 <strong>直接跳跃</strong>，复杂度 <span class="math inline">\(O(1)\)</span>。</li><li>对于 <code>list</code>，<code>map</code> 和 <code>set</code> 等，时间复杂度 <span class="math inline">\(O(n)\)</span>。</li><li>对于单向迭代器，例如 <code>forward_list</code>，<code>istream_iterator</code> 等，时间复杂度 <span class="math inline">\(O(n)\)</span>，且只支持单向移动。</li></ul><h2>nullptr</h2><p>C++11 引入的 <code>nullptr</code> 关键字，用于表示空指针。</p><p>主要区别于 <code>NULL</code>，因为 <code>NULL</code> 被实现为 <code>#define NULL 0</code>。</p><h2>decltype</h2><p>C++11 引入的 <code>decltype</code> 关键字，用于获取表达式的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decltype(expression) var;</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> y = <span class="number">2.5</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) a = x; <span class="comment">// int</span></span><br><span class="line"><span class="keyword">decltype</span>(y) b = y; <span class="comment">// double</span></span><br><span class="line"><span class="keyword">decltype</span>(x+y) c = x+y; <span class="comment">// double, because (x+y) is a double expression</span></span><br></pre></td></tr></table></figure><h2>auto</h2><p>C++11 引入的 <code>auto</code> 关键字，用于自动推导类型。</p><h3>类型推导</h3><div class="note warning flat"><p>必须初始化，否则无法推导类型。</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">10</span>; <span class="comment">// int</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2.5</span>; <span class="comment">// double</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="string">&quot;hello&quot;</span>; <span class="comment">// const char*</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p>注意默认去掉引用和 const。</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> c = a;        <span class="comment">// int</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;a;       <span class="comment">// int*</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;b;       <span class="comment">// const int*</span></span><br><span class="line"><span class="keyword">auto</span>&amp; f = a;       <span class="comment">// int&amp;，引用类型必须显示加 &amp;  </span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b; <span class="comment">// 返回值类型自动推导</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>循环</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : v) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : v) &#123; <span class="comment">// 如果要修改元素</span></span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>结构化绑定</h3><p>C++17 引入，但 C++14 可用，应该会报 warning。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> [x, y] = <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; mp = &#123;&#123;<span class="string">&quot;a&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [key, value] : mp) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>if / switch 初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(key); it != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>C++20</h3><p>模板参数中使用 auto：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">auto</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; N &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>&lt;<span class="number">42</span>&gt;();  <span class="comment">// N 被推导为 int</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025.10.8-A</title>
      <link href="/posts/4791dc7/"/>
      <url>/posts/4791dc7/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="6840ab164d716b2ab0474f519b7cc9406ed5cb88a1b12a39abb022c2939efa5b">93024cf999deb8d8b2919f7e109263d436f7768a67e3b41578a0afeefd292b2d6d5ddece01699d8f2cc04bccc4405b947a3fe5037bbcf5d47d5d5ad930b4c7b9ab9f5f3238dd5d9a4aceac8cd69ee0c215b9f27f78b0855917c24355aaec56e5b845932cf02de320468e98d727a4cb63092dae35430e3acf77d7bfed27e543578f37f6bb3d64e7c66f3506bbf2b6c265de9662030fe50805ab561444180ea5ad7a824c55e4a83dc107219baf57abb6d10e474ddec526ef5842d4c6bde6d9179d8da847f513069a9f4fab06d04a2c2d5d3c66877815116cebd1d82817f0b3eecefb87aa899039db9828a9b492976cec01527832224b8f3beeac886c98bf2c5a26668e1769419c16e29a29afebd3968609d233041f96f01a4d353ed720a82c42cb80cd3981a4ad6c06549f1253107a94d72b5b56f0db26fa4b15b5c0a1b7366f47e28eae47aac342f1e5cba30d6800d6a40801265497629d6a2019a6fd22e3f8067ad118ed9a63f289bd9dabf81f93303367c4c1e324e0312f649bad35104a55d0d2317474b848efd3059b96be7e5f36fd2243679aa06b02695bdae683aaa6d2e64db25936100324ec463ef96210dc6807f0218e33aa344830050d7ec54ca9ebe0cf46906a8e1bb6136169b9f9086d22b4cf4b20865bc673128b2910f8ddb03df213b7ddc7dc8e5e6460a682dfb01d37825664c8f49e26c6a22a301eb8658c354d98f216b571952b606ea6d400a7f66f2f543ade1f80e73f34c5baa64b2d9565632df9430d7ae897d90d395d94899000a0b6a6980c577b2011a9952bfbe95abe90f56732028116ac58f56c1e5fa2d6a37021d3518fbf55ce791c73b2b7c3f0f6b8dbb8aa08cc7a1a311bbaaeca547c4f01de1fe3e9add146f82f6f24cb1d6bf3b2b93915b08438e25187154dfeef118779ccf3522099a86ac92f921e60ee6c5d944f07c0aaeb8006abe1a7b1dd0fde5fe83100a6758169d4f504b92ed74a4d908af75e6de7b9d7892c9067c9e4438a1c6546ecf4dc4d58be96f42666b6bf95b0ede5e888f6ed7537988e08c0c4e562db58f4c383be1b6a01eb71b005b5c913e3ae2d595c712a020c2728194173da8c5e454e28f89f1c7425d72af8e884800938fa4c51b4e52aa954f2ddddc5e51bc36fb973b013f44d106ea184cac03f652396e0b9a6d8bd400671454921c712f98fce2a1f61ade72199412355208b0ad88bfa7756d47a4056d17d750724f8337aecf2de7196a8ea3dd2bd6241da4b1e7a1204e8107387728f55c80cb06fa199257680b1949751236d2904ad867f7f51dd6fd19aedb24efd9647570d249bc3a799faa5404b30de57ce7e38a73498e26cca573bd88a3270117fb6531fd16c7ff00b18e0886f13a22a0b5d61cc8fa81cae0628f73debbc04c43ee969b4a9ff455dba8e368b23dea987743b092e6a2b9688d3df05d1207e77eefb9bb8767caa06362dff6c27762ae4e670312c224db0ecf22ee94dde0c5bf85afafdd6231c5d42eacd75392c0838f3a245303a9d7020c127fe9b3ad42b4490f958e5310fe9c2592303b25f41073b48484f352c1b5dc66593af217fab5836d52ca640b5486778ddba515511a500d614303c3872847f7c30a5397e8d86f881b66261ced8dfe614dd814fe7bbaba062efc3d4c61c38e7d117cf986e67bc7974fb703539746c425e2304d1722fdf123f16f8e6c44a8627681f1c7cc7b593e35c48f4645c1be6768044aebe62d40b1ae1c79d6ee5c8573cc9ea2efc598b7bdb43d5011224a7827506983182900a561b28e4a0ad9631987d3dcbcb07595854052cdbd0bcc4f5eba0ae53ec9b31f309076efa8e2ef422c85b2bf667f5cb7fd57ca4bf83305605f277ba7b1d966902ad1bfcd12210a70f7c5eec05c778f58ba7c9deed9168ba338859c608e648e50800dad9508b23a0fc9b809a8715970ca638467e9198a7adca289c4fdba0e3f4608745a9cca4a7815620b467ac63cdbda1e056185cbc54524fca34ab999febe69d189fcc493b38c15377728d6f5ed647735776b6df358556058216d4af92c7092e1809ce8c2745d9a45e8b348ce10e7e7acb2f8178817d3a6e00f03c9bbf720754c22de123b3a8a268cb6d1065c9f2922c932e52e476a1ba68ac0473a64447d55eb78f486fde1c7c0f39594ac263df11994480ccbb8f56dbbf04a9376472f6f58f1cc8a8657e253a52fd5de10e0bba9aa9e7b69b1da3ffcc2d13ed9336a129fc8ebdfdeb11fa0b0f368d9b7d91cde570d3a08e181f52ea121441c0329cf23e2745d45025e345b4bb90e0ab6477fd381cf3c7aa185176352241acbe3ec34fe0776c19b9e585770a92e942f2ef5624fabccfcefb6bf6243c7d21e1f5a5f9586bc03c87320a7c886ff5cc737b2ff138042319b9a76a34783fe10e4487e38310142d9c35af7540f8691f084c08202bc5c3c44ac9fb805a7790f5ba2ea83fe685a1c9386211c025e2de7f7064a027456a519fa62e4dd6902106436e41329af134cfe1d47f169aaf6b3f26912fd8867863be0359a7b7bc4be0e85fe644f15bcf418ed934e241497dff0b28f04a0c648d22ab2ab005f5b888308fc1d1d7579698ec8afd10a5895c353ed45c198fa73f73df7f9de7ec7d158e64a989e0a75566cc71cf2d26713b7fb9c745f7d6d702a7100d8e4a9a4b2af210d26a59e5d4ccd4bb694ea74a182a53839d0887bccd8d1161b9129dbc87c11496aa2c712f51be7ca4d459ce128e28505c7e577dc4db1045b670bdffcfa14cfd5fed55e4189bd4713fd26ff0f7bf74aa7b18491bdb3fff12d2ebec6c8211ff3e755b8c7be07e843e55531c78cf4a6932c6fbe9656560ad02eac3035ef52d5401f542b9bafb8741da2492279945a46e76bf4bd8765bc55d975b6ec9fdc6d96b7e5048cbf47debccc0304b6a71d575f6eb12c7a5db18cdb6e8ff2137d40a65c6be1480832a0cdeafa208dc48e91482df1ec7a032e2532ac6b492c03f9d126d5c1021520379aa0698b463340a9da00032d8afe7cec825b5a37f2c4fcc3fd0f1cf313c00942b5a96c8a9373a6dc43e1ab1992853f4237a8776664aa14ea8fa62a52637889bff2a47eedf908c31e02007b71f71e10f96cd3cab8a537bd6e8c2969ab158dadbc2b565ab2270a07003828862aab5b06226e3ddbe4ba2d45becf7032c567a76c608c6df9d90499051c1a6793ae48efb30c2ff2b1932f4fb3fbb5f9346b196f6fa5cf74d166910b38ad38bc5a55638cddda4dd4e356cc0dfa39c4ef32bfb6c6cf8dbb6b3b222228ddb9c908183030b1e7b108fc8d5b866235be1944230a5527e13f4ff10bebaca5e0f427ec5e9edb3a05f3eefbe9518a95334325e409c5738c8a10ba3188985cb0b4cca81308b90c5f1aa31daf96980cf734ab831aafc166e71939c07f96849cc8cf370dea6c6f5c801147113c93c42ae3f26ba10e54611ab09272dc6c94daf5f16e237535b0c5229e977980e3bf33062d95736dda47e3649d341d146fe18f32dcadda393e90b989a44ff9973095fe1f1664a3632ab161c912ef7fe87d2f7087e4cad591a366c193280d69aea2f0586b579ce0c04d64e968bbf495e93b10ef782a71f8f30bcf7ec4e39bae6cd044db77559f131ad91bc5fdfabeacdcc2d977a6dc5c3be19571f7c5ea4dc1c3422041d0f12c897a0adcbed2f453da1200418b06621866ad1ca09f283b8dd6919f9adae758718a260f946cec5b1bb827b1814de8975aacff327a891841a248ba3248227291b3e0079bc67320843fb54f2e64079c1f444e771e3bbab5b253773aba8560af78837c2f6ca412ab83c00de2ed1d884d5a63d1cab6e4da920ef31cf4e5695f212ad2733a684183ea0cdb0316c262d93647d03a2063ab0929bec44e09d25062582e399ddce6a160c1892a49c88ba85be960fd5b8840806adf64e74bd03b4c619fdb6637ae17be25a35b49aa0328630a7b6f32e5f6fc2ab92651af85fd20a1bd4463d7cced4cfbbd39fe4d154c4cc870c0b2a5756cf4d0c70a61398e79b118ea7c28b2e10f90572c61a0c547d41ba6f8085f382799a2aaab23cd8782cc6bd63330b9777a10cf89702eeb5b1685498fb6ec530599aab8c4ae49f9fe152060572a4071bb1619e277d4bd871d39ff8449e4f1615f4d84ffe773cf1981c91da2eaa1820e71de2ae3d0713e9a02a04d4bed4d16e3a41441141c889d46ef3db61772e576b7777d9c85e2f596fcce181ee2f3bde7b1163a471f2dc4926c0e26c7f65079065c5ae95478be12557d42a5d4c4cdf81587590f06bb765867914a24a72d75a75eb37611660f0706e680a65d7940bbe8bd6187093b24f2b8a9ec7ff570bbf96a073d5c264c95736d8a41c2fb654c1a21e74edeab6b13ba87eae6ad8d894710569c178fc21a31807fe9eb9d8ee8427951ccdc2efc9baaec8b1830339c529f91c5f13bd1d41f8898132148fa598054b64e165b0d5481a682ca98e0e7c5fb3dbacb120615a1286ca164b8e1f9c59592ecf4ba74b2a9615d8181e8a3c0b30d1270783e2da6a1a7adb9fb7c17d53a58d6f99553fe692cd416cddc6409e391865f2449602e2bbef35db7957efa6523c3d7f82c1fbaaeb8b39b600d4519d3e6d0727fad8089c4128b0758258c0cbab41c9ee375e339e2179b9068f172dcc3bbb30e3ed295823c3bee8153e6082731e09dcfe7c368ee0e0c04a387f8628866f23508e164a78d6ccfb5ba65f2b3d5987d137cb106018d25ded64c340c3d5995ba385171f635cc060ae6386d34e26eb3cb3f2ae2d56dc72b35332d0b73aff05eb36da4ce0a2483c307a296093a53b290373d4f7649dce4b364714c533fb151ad538f0c5102640219cc6a16f0261b222ffd9f8aee8f5f109800a0592cc924fbf7a3996b23604fa1d16fb0dee</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> school </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025.10.7-NOIP</title>
      <link href="/posts/25373191/"/>
      <url>/posts/25373191/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="f1b882435f86db8fbcbfda042724273de975bd115e2174a1774c7aed6b4874c6">93024cf999deb8d8b2919f7e109263d412754b53667526e793dc67267e2d6266d79ba8c61f62ab2dd142a6a62265aa43e2e075283f78c2c579e1aa0c37f65c5ea3aee0ebc8487a9498f0b42890ac07503b1be67fc0482f8d56d3dd1c93e545561ee9086807dd53b13629d3ea11fd9dc2d8b33215199acf07f6f3a55ba29277661a71145ef6063e6e398902e578c6a43843861154915a20b7b2dcf536ce3a2d1aa2766e83cb46c6ded31485b7156dce62abdcd8f0de1851d282050b22c9c6e0e4a5afd9591c3006f082fdcf220d9cfc0f5ba747a9765fe2b5ec72b809ef6530ad7582da55ae24160b45ce2d7cee571b98082b6b75dcc5a5dae438e5e0fcc2a9bf59408f53a458feb8a38f277399a74dcf229c9171fcb0756225a199d76d7dcabd14addd155d825da9735d9081b4cc26af01de957035c60053d6e6962b3e954b956dbaf366ec582dc4af9a7f25b39e51f6ac64553a4a690025087bb9c40a4e4ae7d22db9021b015dd7bbb744f11512b940ba9eaaf60667ca1b4dee768087f903a5153c66f55187f2888a5e4bc6eabdb1d42e40058ac86d6c4f8db4c9ec28f4cb99871f10c6a9e3e2c2a5e11257873624d352da2dd754df15e3cef1a6dc42f4d48a006880c8ca7abd28e8e13956ce73de319a85039be316c16ca35c78b0683fba1608e52f4cd4865114c3e3d402f5e26ca183c075f0f0191dc939235fb3c30e4c92d75ac9a46aced0b17ed03c0ca67875ed5da0114d7d5d1d00f2dd62e33344d08efe43f26533058e53cd7559e4f08f294599af7f7a716190c76fd778ab919e9cceb854b768d18123b39aed7e0c8e6f7d23caa1225040b85b8c5ad2b778913ddb7d4d6bf3305fd0b25fc15e2d08ae0b722c11332d4a54252d77f91b42abbcb3529bec2ace834827f70c2b8a63506161ca386450627ebc5b3141f6e93eefc9af254d9f692e02cf4f834faeffd579396e4957586d1f71457956afe6a061b67baea613f62d9423d8d7257ff23a62139112d3624dc45a3043f385a98e718b965a719cd5f257f3afc07ccf896b86fabe0e8bf2cfeb5de0ac0ffc9b04c806aeb76b144e0bd101fa847282b405abb847c6972e9901aefe695c9bbee2406c3f74ed019ade29eb1eef899ca6424f1d0cc6695f36a861e64d9ebc320e3b6c3885c76a0b66cbf8e65fe73a16d10237b604f33758bed12f8f90afccc73db33c0e5f9e231fdb5fbe9ebb51ef46ce230a8fbc1dd91127c989113fe6680b2c593cd5b03b5cb5333efdd68caf7995fa969c0869dab401e7aa2aca7588405fdbc628353e30c160cb8f49c6c2f257654d3162ce2a29f6cdb807b825d0b8c7feb5bc48f2cc68fe477998692665264dc91a1b200efd0979440a84d87e6e0f9cb872961da4cf2c537e34d52180a2bb4bfc5d1b3bf9c9d45652a3b23110d6ca87f27cf776004e73ed03bda6d1f390b069b09157bd6a182af1fc9d132a059b0d49db206add5a562c9e8392fb7afc4729b5b06218f13d4ac3a49df73ace64cca1201b1ebfcd1428d00627cf8a585c33988bc98a803e7bdf6bcc774d37290af26ed8eca0997755dd6ec91842229e7b16ed6776fae51167f388a06f4b4cfd753406d2519988963a0f204a0108b57212255dc2241606821764074d7a6907388bbccce3f90530150044cbbc2dffbd2c00849af1237809a8ed577a3a4e3a5ed502d0281e909f21ee2fb05dc63f2ea33ab8a8a3f271a2385ff55809e022629bcafbaf899e699eb4b9183a173008fff25d7d3fb8fec2763ab10da7068e72ce999c23b909b9250baff18ba85e095dbabd1f0a54b90ec5dc5f4947bec1809fc0ce36ce69541cc4ec0a7ac81111da487ad1ed5c6647ef7630f547cfe393992a17d50bb420b13ebafbe3d7e4221a48dac81973f394265db5247b8cbc564b51791227433735369a4c64d0ec4d72b1bf1faabe0cb7c45a5521215a740c96e17efe299ea4e0106ac6e001e5683dd2206066eb87d552099a0ae2764ebe6e8c66a3ac4d9e57c704391442c4cc294ea7391e7616772c05245a2d6eaedf418088db1f626b24c75373aaf919c91264872f6ef1db7e50d8ae3bbb5c1d799dd2882da8987c7acd5e66b8ea3594139374306f0c9344b9786a887f83fd015ab4d87df80bba53176f75901080a90e74212cf8293f5ee4bceba76d498a4940f457bdb4caf543821369c1258f17f487555fc2c2d84279baf6a924e3a676bc0a5479b30ea0d49d5249d4ff66600fc26c9a754cfe9a4e07f6664bbfb36b9c19fdbc64942f2e86aea33ece608b3e9e933446f50d9d41a2b83df3adf5adbb646c1218c5d597a3be6c159aa7f029a51c0dee1ac141b62b7682ddffdf07a940468cf234c24df3374267d97b916eff25b89cb681b90b2b41d98a8bbc76f0b8dc0ad8c74086d7cdc632513591cac411d5dda634576f5ea5ad96317333d374ca8652ce38778555e219c1e93fb8e2600a10b1d24888ce3b4403ebf92eec0b1f413d18291cdfc8908ded3e47acf6aedf46d07768a466be0567362360e48c53270981808fb6057fce8ea46665f14ab1aeb3b114a8cf6cf6286cb3fe49818b08c7b0597e6088f43ed9fdf5356f3dcfebe76506ed4f204e438fdfb5f612869da80f3cd7f0a8497a995aea6d9ac609e7fc348a02bbedccdc98383349378cfbd6985f0a24122d53a69e0c493a08f2db2183dbbf93b4e1d1efa02ada53ac161f5ce98e9b6ec267eb73bbe3fee94ab494c407332d5551fc7ecf3746983b95576de3ca31c80b476d2681abf2e483295550e30ebe1cec9ecfc8fc912c1b9038b1df13d6a8c256f181ee78df3e23fb603b83a4460512048305baaff2eec586ac4da62a7772101d198caa457af3bff21e2e8c41b5cedbf9c4785e46200f9db56bcfcaa9cfd507030ead453b524730650fc038617cd4a4c1c0890ea7a4359dcd08c874a8f336cdf767878903fcc1984ab2fd11fdaf13e7cb537eeae6be61c0e17489fc88d4c56190ef005f5fc6feda200f390df0c1659f31eae74b14fed63258a6da070070ed8cdee64cf9b3f57280399c37dba7304d171d4620e6df30d3af9783cb79a5e7c00dcac396a156a27b7562048cb4bc8acb3c0aaa9cc48f86feae4013b8546e94021f7c1bf866f6a36e47ef5df91aed2e1f4386834d05172e8e38ca46b1d54d1a62f502559e9158d95df5cccdd8015abce743a606ff67876c14598e39720efdd3bb1c4efe38f1fdce306a0ecf1daea403298a7b57b8d4945dad94cb7ef250c3f3443e11da506af45e2fe37a9068aa69954fe08dc32bf43a162070b975d221672ee179594fc01edd965b5785b57c8d9a598e0fada8a3f9c6bbb77eb4f183f0d17e46ea0ee9f2d896f2b09776ec89668673402cb8b91c6a1e8f38ca8b1b7b3342139263140660c0c5df171b383e2ffd9f4cd601a4b20df8b0732376fd920955c08224f948289e39f690c5d8cc07eaa0d2905804b5df64d55f70cfb4c34c9514d00c26798d15c0cf60cec78e3e1a4b8259d669c6175f7decd687f573e83507d0c067781721198d305eef2621355572ca48635b22b8a6625bd049c02f119a2e9f7ec793d3291631140c144b22a7e8c6b1b5f369052300e6e7cd20eacf7213687c352bcd403f60f065e0a855a50343233db8f200e9880e371df761a2b18ac31d30141495eb92f04ba9945feb07a7c6a5a2f86c76eba513f6fc7632eeb70fa1da5b472e94b9408d6df43f6770eb6101f83828d5ec90c55dec7da9ecc167c8bfc3e31139db7f023509e766c333cb43dfeb7d13597be72e0ec49956bc0034bd1045364149c88f29a6b40d007002af1c64167b62c0eba69076cac5cae169185fabf0b133d19d62f6eeb75f607458ec506e21105735fa4be84dba1294b6d4358f5942080ab9ddef516bbbcb7eb05ecf1360e3e5574855ec66d518d7da56b3179acef8564301174e12178aebad8f3c56f7f170cfae956eca0208344cf2455c38091e10ce77bea0027cc27f4a3ce741726ae60cc2f0fe5c0d117981c7e01e8710fd8584288c5313c9c0b90a58b00fbaaa8cfa9f72dec6e8222134120214c2a4c63fb51628a7c2c64e53c91b9fa9abb9747384205d0b2c6dd14fa29a44541792fa89799afa9605bac876c801bdb142f2e7e42d03eccadc48cce6f63b4cd49e81779439b81cf54f191cad783464f83282928c4a07208fb9eb2903e871c5da06d174bc297aff5341301222618e7d54c6b499ae589c9a7e8add6fcaf0c957a57897a2398f26d6336003d728891ca1dc1c4c82f04eede3d178fbb66f3d8db66a5ed46250e4548999e909212ea692ba1ddb78ac482d2d6072d71af4bc89f452985ed0ced7f7436ed5d4dcc14cf352cd1e5b4f6acd7e85f40529b49a91d778d87e976fbfeffda2c9eb28fa27a9cf74b943d4365b90584ade680fcfb9dd27b95a7a7e2b62158ab6ee11fcf92c0eefab60b1b72f7afd7878c3c7261b780996d504579e18392d17f6a3600d33e623ba344439eace1c521187b65f52a240b1895d969a8b480267e17ad263e4b529fd489e79c67ec675ea1eb0baf62ebc929e369647e22b52462a08126ac08390de0583a37bd318ff90d412ebc1d207bb3ec42f35c06f531a05cf2690baf930ee5fd438ae7c9ccdda352264f6afa81af78d71cbb937e7223813c551d30d969331ecea9ccaf12d4f88fb19056435ffea926e272c5813b6ade739088db845129c4596b4a1ffe10fdfb96832f40883a816eaa7dcaa717e298179a942f1723e5dd20fa680d9e0ececd68db38f12b0cd0f969ddd789e9807188c5549f743c06bc355bf82bc3ba8dd3fec4144b005404beb06ba73b009fd1547816d06411ab8ddc3578c821a4018286d6fa939e1e13ed74c955f0178087aaa8a12da5b049244353294988ccf13e41d8aaedd142aaf73f79cb427af4ed20237ed1d3512a2ec15d55e411e406b6cfff087c8b1cf1e3856e4468601912cac35988002bca3c525f987db8fa63b2a7bb693f7771c43a02e31284f768768328c1ddc63ac94bfea202878e5a90525434e163ab9b2b7512c3a8a8460c41906c4aa6f6475fb8c4ea25821e3b0c195171a53491aaa37ccc719bbb026e0a29b3f933c54c8942439674329512118169d7b3f8593135f37e06202be8cde1d1cf313cb32ed76ba6f3662d40e5c85cf28361f93a6a5d35a4a108dd8bbbf662c0fa52a04e3e856008072d3bf02fbb499c3fc654ae909e4a6943c47ede02c1314b0ec563f7abc0bea655023445b8848f8172b39887974108c531beadab689f6cd88253a8dceb77f8f07eb19a7302b9247822cc2367e7b6ec10154905d67445882cec729c727482439da2d8a06f40f887271cc72bd4ed1cffea6a95393bd81c7a9ebbec59f7f4eba0b2b8114cf30b76ef670f5327448a1366887522674e6b66049f73f5585605704b5382a356e72577878ec918d8441f2acc93ffb68d777e80af7a1ede0d2bbcc6f7c0aa00581d6d6672f5c6397df2198b89fd71df2459cedd0fa8c3b6e155f38b9f2975cedf8cc2854c840a0da19f57eab5cd359d3072b40e560822824cfce1ec72c23c4f08bdbff545f50fe719d337760eddf1e039991af09e9f571277800dd19131cbc939d8ef23ad72374f47d63cce99983e030b5b6af95673aa11eeba07213ec2ba621efc77a92e8d0e8e846cb0dcfaa590dbba9eea72a441ce00465d5d543625d7ca0d0442027e3af33700a176f062dc02a6c8c3d4ecb8feb51c863cf081a04959cf2282c58485d4f7b3d24057b5fd32c235ea98911fdeccd0f25f34e9d9669e0c7412da3661dcbf385e786713cac9809fe7a805230c9943f95</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> school </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提供给 Duel 的 Rating 计算方案</title>
      <link href="/posts/486bb1c0/"/>
      <url>/posts/486bb1c0/</url>
      
        <content type="html"><![CDATA[<p>本方案基于加权 Elo 模型，并结合团队表现系数，客观反映选手实力。</p><h2>比赛模型转换</h2><p>难度权重设为：</p><p><span class="math display">\[W_t=\frac{D_t}{100}\quad(D_t\in\{100,200,\dots,1000\})\]</span></p><h2>队伍评级与期望胜率</h2><ol type="1"><li>队伍平均评级 记 R 为选手的评级。 <span class="math display">\[R_A = \frac{1}{n}\sum_{i=1}^n R_{A,i},\quadR_B = \frac{1}{m}\sum_{j=1}^m R_{B,j}\]</span><br />其中 <span class="math inline">\(n,m\)</span> 分别为 A、B 队参赛人数。</li><li>期望胜率 <span class="math display">\[E_A = \frac{1}{1 + 10^{(R_B - R_A)/400}},\quadE_B = 1 - E_A\]</span><br />若 A 队首解题目得 <span class="math inline">\(r_t=1\)</span>，B 队则得 <span class="math inline">\(r_t=0\)</span>；都未解或同时解则 <span class="math inline">\(r_t=0.5\)</span> 。</li></ol><h2>表现系数 <span class="math inline">\(f(P)\)</span></h2><ol type="1"><li>表现指标 <span class="math display">\[P_A = \frac{\text{A队实际得分}}{\text{理论最高分 }(100+200+\dots+1000)},\quadP_B = \frac{\text{B队实际得分}}{\text{理论最高分}}\]</span></li><li>映射函数 <span class="math display">\[f(P) = \alpha + (1-\alpha)\,P,\quad \alpha = 0.5\]</span><br /><span class="math inline">\(\alpha\)</span> 为保底系数，此处为 <span class="math inline">\(0.5\)</span>。</li></ol><h2>个人 Rating 更新公式</h2><p>对于第 <span class="math inline">\(t\)</span> 道题，第 <span class="math inline">\(i\)</span> 位选手的增量为 <span class="math display">\[\Delta R_{i,t} = f(P_{\text{其队}})\;\times\;K \times W_t \times (r_t - E_A)\]</span></p><ul><li><span class="math inline">\(K\)</span>：基础调整系数，此处为 <span class="math inline">\(K=32\)</span>。</li><li><span class="math inline">\(W_t\)</span>：题目难度权重</li><li><span class="math inline">\(r_t - E_A\)</span>：胜负偏差（胜为正、负为负）</li><li><span class="math inline">\(f(P)\)</span>：表现系数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025.10.5-A</title>
      <link href="/posts/ca18e94/"/>
      <url>/posts/ca18e94/</url>
      
        <content type="html"><![CDATA[<h2>T1 misspelling</h2><p><a href="https://www.luogu.com.cn/problem/P9522">[JOISC 2022] 错误拼写</a></p><p>先刻画题目，<span class="math inline">\(T_u \le T_v,u&lt;v\)</span> 相当于 <span class="math inline">\(S_{[u,v]}\)</span> 全部相等或 <span class="math inline">\(\forall k\in [i,p),S_i = S_k \text{且} S_i &gt; S_p\)</span>。</p><p><span class="math inline">\(u&gt;v\)</span> 同理。</p><p>这样我们就从后向前转移 DP <span class="math inline">\(f_{i,j}\)</span>，表示已经处理完 <span class="math inline">\([i+1,n]\)</span>，其中 <span class="math inline">\(s_i = j\)</span> 的方案数。</p><p>假设枚举一个 <span class="math inline">\(i&#39; &gt; i\)</span> 进行转移，表示 <span class="math inline">\([i,i&#39;-1]\)</span> 全部相等，<span class="math inline">\(s_i&#39; \neq s_i\)</span>，如果存在 <span class="math inline">\(i \le u &lt; i&#39; \le v\)</span>：</p><ul><li>当 <span class="math inline">\(T_u \le T_v\)</span> 时，<span class="math inline">\(\forall i&#39; \in (u,v]\)</span>，一定要有 <span class="math inline">\(j &gt; j&#39;\)</span></li><li>当 <span class="math inline">\(T_u &gt; T_v\)</span> 时，类似</li></ul><p>也就是说，假设固定 <span class="math inline">\(i&#39;\)</span>，在 <span class="math inline">\(i\)</span> 不断前移中，必然有一个位置让 <span class="math inline">\(i&#39;\)</span> 不能产生 <span class="math inline">\(j &gt; j&#39;\)</span> 的贡献，也必然有一个位置让 <span class="math inline">\(i&#39;\)</span> 不能产生 <span class="math inline">\(j &lt; j&#39;\)</span> 的贡献。</p><p>设 <span class="math inline">\(g_j\)</span> 表示 <span class="math inline">\(f_{i+1} \sim f_n\)</span> 的 <span class="math inline">\(j\)</span> 的贡献。</p><p>现在枚举到 <span class="math inline">\(i\)</span>，只考虑和 <span class="math inline">\(i\)</span> 有关的贡献（<span class="math inline">\(i=u&lt;v\)</span>）：</p><ul><li>若有 <span class="math inline">\(T_u \le T_v\)</span>，<span class="math inline">\(\forall i&#39; \in (u,v]\)</span>，且仍产生 <span class="math inline">\(j &lt; j&#39;\)</span>，删去该贡献，即 <span class="math inline">\(h_j\)</span> 减去 <span class="math inline">\(\sum_{j &lt; j&#39;} f_{i&#39;,j&#39;}\)</span>。</li><li>若有 <span class="math inline">\(T_v \le T_u\)</span>，同理。</li></ul><p>更新完后更新 <span class="math inline">\(f_{i,j} = h_j + 1\)</span>，<span class="math inline">\(1\)</span> 表示全部相同的情况。</p><p>再更新 <span class="math inline">\(f_i\)</span> 对 <span class="math inline">\(h\)</span> 的贡献，即 <span class="math inline">\(h_j\)</span> 加上 <span class="math inline">\(\sum_{j \neq j&#39;} f_{i,j&#39;}\)</span>。</p><p>可以用链表维护仍然存在的贡献。</p><h2>T2 ski 2</h2><p><a href="https://www.luogu.com.cn/problem/P10432">[JOIST 2024] 滑雪 2 / Ski 2</a></p><p>性质观察题，DP 解决。</p><p><strong>结论一：</strong> 贪心的思考，一定是选高度最低的点建造酒店，如果1高度相同，就选建造设施最便宜的点，</p><p><strong>结论二：</strong> 如果要提升发高度，最多只会提升至另一个点高度 <span class="math inline">\(+1\)</span>。</p><p><strong>结论三：</strong> 如果一个点建造了连接设施，那它就一定不会升高。</p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>若现在有 <span class="math inline">\(H_x &lt; H_y\)</span>，现在将 <span class="math inline">\(x\)</span> 提升到 <span class="math inline">\(H_y+1\)</span>，并且向 <span class="math inline">\(y\)</span> 连边。</p><p>若 <span class="math inline">\(C_y \le C_x\)</span>，则 <span class="math inline">\(x\)</span> 连向 <span class="math inline">\(y\)</span> 一定优，还可以将本来连向 <span class="math inline">\(x\)</span> 的点改连向 <span class="math inline">\(y\)</span>。</p><p>若 <span class="math inline">\(C_y &gt; C_x\)</span>，就可以放弃提升，将 <span class="math inline">\(y\)</span> 连向 <span class="math inline">\(x\)</span>，将本来连向 <span class="math inline">\(x\)</span> 的点改连向 <span class="math inline">\(y\)</span>，也一定更优。</p></div></details><p>所以，考虑 <span class="math inline">\(f_{i,j,k}\)</span>，表示当前在高度 <span class="math inline">\(i\)</span>，该高度上一共有 <span class="math inline">\(j\)</span> 个可用的接口，有 <span class="math inline">\(k\)</span> 个节点现在高度为 <span class="math inline">\(i\)</span>，且准备抬升到 <span class="math inline">\(i+1\)</span>。</p><ol type="1"><li>可以新建一个链接设施，<span class="math inline">\(f_{i,j+1,k} = f_{i,j,k} + minc_i\)</span>，其中 <span class="math inline">\(minc_i\)</span> 指在高度 <span class="math inline">\(i\)</span> 新建接口的最小花费。</li><li>可以向 <span class="math inline">\(i+1\)</span> 转移，设高度 <span class="math inline">\(i\)</span> 原本有 <span class="math inline">\(cnt_i\)</span> 个节点，<span class="math inline">\(f_{i+1,j,max\{0,k+cnt_{i+1} - j\}} = f_{i,j,k} + K\cdot k \cdot (H_{i+1} - H_{i})\)</span>。因为 <strong>结论三</strong>，所以新的 <span class="math inline">\(k\)</span> 有 <span class="math inline">\(j\)</span> 个节点一定不会再升高。</li></ol><p>我们发现这样时间复杂度是 <span class="math inline">\(O(n^2\max H)\)</span>。</p><p>考虑将 <span class="math inline">\(H\)</span> 离散化，注意不止要加入 <span class="math inline">\(H_i\)</span>，还有所有可能经过升高到达的高度。</p><p>时间复杂度 <span class="math inline">\(O(n^3)\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC 426 总结</title>
      <link href="/posts/856ffa39/"/>
      <url>/posts/856ffa39/</url>
      
        <content type="html"><![CDATA[<h2>A</h2><p>简单题</p><h2>B</h2><p>简单题</p><h2>C</h2><p>也是简单题，但是 <span class="math inline">\(1e6\)</span> 让我在赛时差点打了线段树。</p><p>用 <code>map</code> 即可解决，<span class="math inline">\(O(n\log n)\)</span>。</p><h2>D</h2><p>贪心，每次选择最长的一段 <span class="math inline">\(1/0\)</span>，直接模拟。</p><p>赛时想了好久，快结束时才想出来。</p><h2>E</h2><p>比较简单的代数题，两点距离显然是一个二次函数，求导求最值即可。</p><p>注意分类讨论，两人都在走和一人停一人走的情况。</p><p>用向量实现可以简化码量。</p><h2>F</h2><p>原题。</p><p>考虑到每种商品只会小于 <span class="math inline">\(0\)</span> 一次，可以先记录每种商品是否售罄，再去掉该次购买售罄的情况，直接线段树上二分暴力修改即可。</p><h2>G</h2>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> atcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP-S 2025 初赛题目解析</title>
      <link href="/posts/f1d582a1/"/>
      <url>/posts/f1d582a1/</url>
      
        <content type="html"><![CDATA[<h2>单项选择</h2><h3>T1</h3><p>有 <span class="math inline">\(5\)</span> 个红色球和 <span class="math inline">\(5\)</span> 个蓝色球，它们除了颜色之外完全相同。将这 <span class="math inline">\(10\)</span> 个球排成一排，要求任意两个蓝色球都不能相邻，有多少种不同的排列方法？</p><ul><li>A. 25</li><li>B. 30</li><li>C. 6</li><li>D. 120</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>C</p><p>将 <span class="math inline">\(5\)</span> 个红色球排成一排，共有 <span class="math inline">\(6\)</span> 个空隙（<code>_R_R_R_R_R_</code>）。</p><p>将 <span class="math inline">\(5\)</span> 个蓝色球，放在 <span class="math inline">\(6\)</span> 个空中，共 <span class="math inline">\(\binom{6}{5} = 6\)</span></p></div></details><h3>T2</h3><p>在 KMP 算法中，对于模式串 <span class="math inline">\(P = \text{abacaba}\)</span>，其 <code>next</code> 数组（ <span class="math inline">\(next[i]\)</span> 定义为模式串 <span class="math inline">\(P[0\dots i]\)</span> 最长公共前后缀的长度，且数组下标从 <span class="math inline">\(0\)</span> 开始）的值是什么？</p><ul><li>A. {0,0,1,0,1,2,3}</li><li>B. {0,1,2,3,4,5,6}</li><li>C. {0,0,1,1,2,2,3}</li><li>D. {0,0,0,0,1,2,3}</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>A</p><p>模拟即可。</p></div></details><h3>T3</h3><p>对一个大小为 <span class="math inline">\(16\)</span>（下标 <span class="math inline">\(0 \sim 15\)</span>）的数组上构建满线段树。查询区间 <span class="math inline">\([3,11]\)</span> 时，最少需要访问多少个树结点（包括路径上的父结点和完全包含在查询区间内的结点）？</p><ul><li>A. 7</li><li>B. 8</li><li>C. 9</li><li>D. 10</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>B</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    graph TD;    A[0,15] --&gt; B[0,7];    A --&gt; C[8,15];    B --&gt; D[0,3];    B --&gt; E[4,7];    C --&gt; F[8,11];    C --&gt; G[12,15];    D --&gt; H[0,1];    D --&gt; I[2,3];    I --&gt; J[2];    I --&gt; K[3];    style A fill:red;    style B fill:red;    style C fill:red;    style D fill:red;    style E fill:red;    style F fill:red;    style I fill:red;    style K fill:red;  </pre></div></div></details><h3>T4</h3><p>将字符串 <code>cat</code>, <code>car</code>, <code>cart</code>, <code>case</code>, <code>dog</code>, <code>do</code> 插入一个空的 Trie 树（前缀树）中。构建完成的 Trie 树（包括根结点）共有多少个结点？</p><ul><li>A. 8</li><li>B. 9</li><li>C. 10</li><li>D. 11</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>D</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    graph TD;    rt[root] --&gt; c0[c];    c0 --&gt; a1[a];    a1 --&gt; t2[t];    a1 --&gt; r2[r];    r2 --&gt; t3[t];    a1 --&gt; s2[s];    s2 --&gt; e3[e];    rt --&gt; d0[d];    d0 --&gt; o1[o];    o1 --&gt; g2[g];  </pre></div></div></details><h3>T5</h3><p>对于一个包含 <span class="math inline">\(n\)</span> 个顶点和 <span class="math inline">\(m\)</span> 条边的有向无环图（DAG），其拓扑排序的结果有多少种可能？</p><ul><li>A. 只有 <span class="math inline">\(1\)</span> 种</li><li>B. 最多 <span class="math inline">\(n\)</span> 种</li><li>C. 等于 <span class="math inline">\(n-m\)</span> 种</li><li>D. 以上都不对</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>D</p><p>拓扑排序的数量取决于图的具体结构，没有一个简单的公式可以计算。</p><p>如，没有边为 <span class="math inline">\(n!\)</span> 种，是链则只有 <span class="math inline">\(1\)</span> 种。</p></div></details><h3>T6</h3><p>在一个大小为 <span class="math inline">\(13\)</span> 的哈希表中，使用闭散列法的线性探查来解决冲突。哈希函数为 <span class="math inline">\(H(key)=key \mod 13\)</span>。依次插入关键字 <code>18</code>, <code>26</code>, <code>35</code>, <code>9</code>, <code>68</code>, <code>74</code>。插入 <code>74</code> 后，它最终被放置在哪个索引位置？</p><ul><li>A. 5</li><li>B. 7</li><li>C. 9</li><li>D. 11</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>D</p><ol type="1"><li><span class="math inline">\(18 \mod 13 = 5\)</span></li><li><span class="math inline">\(26 \mod 13 = 0\)</span></li><li><span class="math inline">\(35 \mod 13 = 9\)</span></li><li><span class="math inline">\(9 \mod 13 = 9\)</span>，<span class="math inline">\(9\)</span> 冲突，放在第 <span class="math inline">\(10\)</span> 个位置</li><li><span class="math inline">\(68 \mod 13 = 3\)</span></li><li><span class="math inline">\(74 \mod 13 = 9\)</span>，<span class="math inline">\(9,10\)</span> 冲突，放在第 <span class="math inline">\(11\)</span> 个位置</li></ol></div></details><h3>T7</h3><p>一个包含 <span class="math inline">\(8\)</span> 个顶点的完全图（顶点的编号为 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(8\)</span>），任意两点之间的边权重等于两顶点编号的差的绝对值。例如，顶点 <span class="math inline">\(3\)</span> 和 <span class="math inline">\(7\)</span> 之间的边权重为 <span class="math inline">\(|7 − 3| = 4\)</span>。该图的最小生成树的总权重是多少？</p><ul><li>A. 7</li><li>B. 8</li><li>C. 9</li><li>D. 10</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>A</p><p>用 Kruskal 算法求解：</p><p>边权最小分别为 <span class="math inline">\(1\rightarrow 2=1,2\rightarrow3=1,3\rightarrow4=1,4\rightarrow5=1,5\rightarrow6=1,6\rightarrow7=1\)</span>。</p><p>总权重为 <span class="math inline">\(7\)</span>。</p></div></details><h3>T8</h3><p>如果一棵二叉搜索树的后序遍历序列是 <code>2, 5, 4, 8, 12, 10, 6</code>，那么该树的前序遍历序列是什么？</p><ul><li>A. 6, 4, 2, 5, 10, 8, 12</li><li>B. 6, 4, 5, 2, 10, 12, 8</li><li>C. 2, 4, 5, 6, 8, 10, 12</li><li>D. 12, 8, 10, 5, 2, 4, 6</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>A</p><p>后序遍历 <code>2, 5, 4, 8, 12, 10, 6</code>，根是最后一个元素 <span class="math inline">\(6\)</span>。</p><p>二叉搜索树保证：左子树 &lt; 根 &lt; 右子树，所以左子树节点 <code>2, 5, 4</code>，右子树 <code>8, 12, 10</code>。</p><p>再结合后序遍历，可得：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>    graph TD;    rt[6] --&gt; A[4];    rt --&gt; B[10];    A --&gt; C[2];    A --&gt; D[5];    B --&gt; E[8];    B --&gt; F[12];  </pre></div><p>即，前序遍历 <code>6, 4, 2, 5, 10, 8, 12</code>。</p></div></details><h3>T9</h3><p>一个 0-1 背包问题，背包容量为 <span class="math inline">\(20\)</span>。现有 <span class="math inline">\(5\)</span> 个物品，其重量和价值分别为 <code>7，5，4，3，6</code> 和 <code>15，12，9，7，13</code>。装入背包的物品能获得的最大总价值是多少？</p><ul><li>A. 43</li><li>B. 41</li><li>C. 45</li><li>D. 44</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>D</p><p>发现重量小的，价值也小，可以直接枚举。</p><ol type="1"><li><code>2, 3, 4, 5</code>，价值 <span class="math inline">\(41\)</span>。</li><li><code>1, 2, 3, 4</code>，价值 <span class="math inline">\(43\)</span>。</li><li><code>1, 3, 4, 5</code>，价值 <span class="math inline">\(44\)</span>。</li></ol></div></details><h3>T10</h3><p>在一棵以结点 <span class="math inline">\(1\)</span> 为根的树中，结点 <span class="math inline">\(12\)</span> 和结点 <span class="math inline">\(18\)</span> 的最近公共祖先 (LCA) 是结点 <span class="math inline">\(4\)</span>。那么下列哪个结点的 LCA 组合是不可能出现的？</p><ul><li>A. LCA(12, 4) = 4</li><li>B. LCA(18, 4) = 4</li><li>C. LCA(12, 18, 4) = 4</li><li>D. LCA(12, 1) = 4</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>D</p><p><span class="math inline">\(1\)</span> 是根节点，<span class="math inline">\(1\)</span> 与任何节点的 LCA 都是 <span class="math inline">\(1\)</span>。</p></div></details><h3>T11</h3><p>递归关系式 <span class="math inline">\(T(n) = 2T(\frac{n}{2}) + O(n^2)\)</span> 描述了某个分治算法的时间复杂度。请问该算法的时间复杂度是多少？</p><ul><li>A. <span class="math inline">\(O(n)\)</span></li><li>B. <span class="math inline">\(O(n\log n)\)</span></li><li>C. <span class="math inline">\(O(n^2)\)</span></li><li>D. <span class="math inline">\(O(n^2 \log n)\)</span></li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>C</p><p>主定理： <span class="math inline">\(\log_b a = \log_2 2 = 1\)</span>，<span class="math inline">\(2 &gt; 1\)</span>，因此为 <span class="math inline">\(O(n^2)\)</span>。</p></div></details><h3>T12</h3><p>在一个初始为空的最小堆（min-heap）中，依次插入元素 <code>20, 12, 15, 8, 10, 5</code>。然后连续执行两次“删除最小值”（delete-min）操作。请问此时堆顶元素是什么？</p><ul><li>A. 10</li><li>B. 12</li><li>C. 15</li><li>D. 20</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>A</p><p>即第三小的值。</p></div></details><h3>T13</h3><p><span class="math inline">\(1\)</span> 到 <span class="math inline">\(1000\)</span> 之间，不能被 <span class="math inline">\(2\)</span>、<span class="math inline">\(3\)</span>、<span class="math inline">\(5\)</span> 中任意一个数整除的整数有多少个？</p><ul><li>A. 266</li><li>B. 267</li><li>C. 333</li><li>D. 734</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>A</p><p>容斥原理。</p><ol type="1"><li>能被 <span class="math inline">\(2,3,5\)</span> 整除的数：<ul><li><span class="math inline">\(2\)</span>：<span class="math inline">\(\lfloor 1000/2 \rfloor = 500\)</span></li><li><span class="math inline">\(3\)</span>：<span class="math inline">\(\lfloor 1000/3 \rfloor = 333\)</span></li><li><span class="math inline">\(5\)</span>：<span class="math inline">\(\lfloor 1000/5 \rfloor = 200\)</span></li></ul></li><li>能被两两相乘整除的数：<ul><li><span class="math inline">\(2\times 3 = 6\)</span>: <span class="math inline">\(\lfloor 1000/6 \rfloor = 166\)</span></li><li><span class="math inline">\(2\times 5 = 10\)</span>: <span class="math inline">\(\lfloor 1000/10 \rfloor = 100\)</span></li><li><span class="math inline">\(3\times 5 = 15\)</span>: <span class="math inline">\(\lfloor 1000/15 \rfloor = 66\)</span></li></ul></li><li>能被 <span class="math inline">\(3\)</span> 个数整除的数：<ul><li><span class="math inline">\(2\times 3\times 5 = 30\)</span>: <span class="math inline">\(\lfloor 1000/30 \rfloor = 33\)</span></li></ul></li></ol><p>总答案即为 <span class="math inline">\(1000 - (500+333+200 - 166-100-66+33) = 266\)</span>。</p></div></details><h3>T14</h3><p>斐波那契数列的定义为 <span class="math inline">\(F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)\)</span>。使用朴素递归方法计算 <span class="math inline">\(F(n)\)</span> 的时间复杂度是指数级的。而使用动态规划（或迭代）方法的时间复杂度是线性的。造成这种巨大差异的根本原因是？</p><ul><li>A. 递归函数调用栈开销过大</li><li>B. 操作系统对递归深度有限制</li><li>C. 朴素递归中存在大量的重叠子问题未被重复利用</li><li>D. 动态规划使用了更少的数据存储空间</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>C</p><p>显然，朴素递归中存在大量的重叠子问题未被重复利用，这也是动态规划的优势所在。</p></div></details><h3>T15</h3><p>有 <span class="math inline">\(5\)</span> 个独立的、不可抢占的任务 <code>A1, A2, A3, A4, A5</code> 需要在一台机器上执行（从时间 <span class="math inline">\(0\)</span> 开始执行），每个任务都有对应的处理时长和截止时刻，按顺序分别为 <code>3, 4, 2, 5, 1</code> 和 <code>5, 10, 3, 15, 11</code>。如果某一个任务超时，相应的惩罚等于其处理时长。为了最小化总惩罚，应该优先执行哪个任务？</p><ul><li>A. 处理时间最短的任务 <code>A5</code></li><li>B. 截止时间最早的任务 <code>A3</code></li><li>C. 处理时间最长的任务 <code>A4</code></li><li>D. 任意一个任务都可以</li></ul><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>B</p><p>贪心模拟即可。</p></div></details><h2>程序阅读</h2><h3>T16</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">bool</span> flag[<span class="number">27</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> p[<span class="number">27</span>];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == n + <span class="number">1</span>) &#123;</span><br><span class="line">++ans;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (flag[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (k &gt; <span class="number">1</span> &amp;&amp; i == p[k - <span class="number">1</span>] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">p[k] = i;</span><br><span class="line">flag[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs</span>(k + <span class="number">1</span>);</span><br><span class="line">flag[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断题</strong></p><ol type="1"><li>当输入的 <span class="math inline">\(n=3\)</span> 的时候，程序输出的答案为 <span class="math inline">\(3\)</span>。</li><li>在 <code>dfs</code> 函数运行过程中，<span class="math inline">\(k\)</span> 的取值会满足 <span class="math inline">\(1 \le k \le n+1\)</span>。</li><li>删除第 <span class="math inline">\(19\)</span> 行的 <code>flag[i]=false;</code>，对答案不会产生影响。</li></ol><p><strong>选择题</strong></p><ol type="1"><li>当输入的 <span class="math inline">\(n=4\)</span> 的时候, 程序输出的答案为？<ul><li>A. 11</li><li>B. 12</li><li>C. 24</li><li>D. 9</li></ul></li><li>如果因为某些问题，导致程序运行第 <span class="math inline">\(25\)</span> 行的 <code>dfs</code> 函数之前，数组 <code>p</code> 的初值并不全为 <span class="math inline">\(0\)</span>，则对程序的影响是？<ul><li>A. 输出的答案比原答案要小</li><li>B. 无法确定输出的答案</li><li>C. 程序可能陷入死循环</li><li>D. 没有影响</li></ul></li><li>假如删去第 <span class="math inline">\(14\)</span> 行的 <code>if(flag[i]) continue;</code>，输入 <span class="math inline">\(3\)</span>，得到的输出答案是？<ul><li>A. 27</li><li>B. 3</li><li>C. 16</li><li>D. 12</li></ul></li></ol><details class="toggle" ><summary class="toggle-button" style="">解析</summary><div class="toggle-content"><p>程序为求解 <span class="math inline">\(p_i +1 \neq p_{i+1}\)</span> 的长度为 <span class="math inline">\(n\)</span> 的 <strong>排列</strong> <span class="math inline">\(p\)</span> 的方案数。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>TTFADC</p><p><strong>判断题</strong></p><ol type="1"><li>手动模拟，得出答案为 <span class="math inline">\(3\)</span>。</li><li>显然，第 <span class="math inline">\(25\)</span> 行，<span class="math inline">\(k\)</span> 初值为 <span class="math inline">\(1\)</span>；第 <span class="math inline">\(9 \sim 12\)</span> 行，<span class="math inline">\(k = n+1\)</span> 就会返回。</li><li>显然，未清空标记，方案数会减少。</li></ol><p><strong>选择题</strong></p><ol type="1"><li>手动模拟。</li><li>不会影响，因为在计算 <span class="math inline">\(p_i\)</span> 时，<span class="math inline">\(p_{i-1}\)</span> <strong>一定</strong> 被重新赋值完。</li><li>删去，则去掉了 <strong>排列</strong> 的限制，还是手动模拟。</li></ol></div></details><h3>T17</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">int</span> cnt_broken = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt_check = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;now check:%d\n&quot;</span>, h);</span><br><span class="line">    ++cnt_check;</span><br><span class="line">    <span class="keyword">if</span> (cnt_broken == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You have no egg!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h &gt;= k) &#123;</span><br><span class="line">        ++cnt_broken;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">assert_ans</span><span class="params">(<span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == k) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You are Right using %d checks\n&quot;</span>, cnt_check);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Wrong answer!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">guess1</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(i)) &#123;</span><br><span class="line">            <span class="built_in">assert_ans</span>(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">guess2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (w = <span class="number">1</span>; w * (w + <span class="number">1</span>) / <span class="number">2</span> &lt; n; ++w)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ti = w, nh = w;; --ti, nh += ti, nh = std::<span class="built_in">min</span>(nh, n)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(nh)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = nh - ti + <span class="number">1</span>; j &lt; nh; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(j)) &#123;</span><br><span class="line">                    <span class="built_in">assert_ans</span>(j);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">assert_ans</span>(nh);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">guess1</span>(n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">guess2</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：下述的 “猜测数” 为调用 <code>check</code> 函数的次数（即 <code>cnt_check</code> 的值）；“猜测正确” 的含义为 <code>assert_ans</code> 函数 <code>return true</code>（执行第 <span class="math inline">\(25\)</span> 行所在分支）的情况；所有输入保证 <span class="math inline">\(1 \le k \le n\)</span>。</p><p><strong>判断题</strong></p><ol type="1"><li>当输入为 <code>6 5 1</code> 时，猜测次数为 <span class="math inline">\(5\)</span>；当输入为 <code>6 5 2</code> 时，猜测次数为 <span class="math inline">\(3\)</span>。</li><li>不管输入的 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(k\)</span> 具体为多少，<span class="math inline">\(t=2\)</span> 时的猜测数总是小于等于 <span class="math inline">\(t=1\)</span> 时的猜测数。</li><li>不管 <span class="math inline">\(t=1\)</span> 或 <span class="math inline">\(t=2\)</span>，程序都一定会猜到正确结果。</li></ol><p><strong>选择题</strong></p><ol type="1"><li>函数 <code>guess1</code> 在运行过程中，<code>cnt_broken</code> 的值最多为？<ul><li>A. 0</li><li>B. 1</li><li>C. 2</li><li>D. n</li></ul></li><li>函数 <code>guess2</code> 在运行过程中，最多使用的猜测次数的量级为？<ul><li>A. <span class="math inline">\(O(n)\)</span></li><li>B. <span class="math inline">\(O(n^2)\)</span></li><li>C. <span class="math inline">\(O(\sqrt{n})\)</span></li><li>D. <span class="math inline">\(O(\log n)\)</span></li></ul></li><li>当输入的 <span class="math inline">\(n=100\)</span> 时，代码中 <span class="math inline">\(t=1\)</span> 和 <span class="math inline">\(t=2\)</span> 分别需要的猜测次数最多分别为？<ul><li>A. 100,14</li><li>B. 100,13</li><li>C. 99,14</li><li>D. 99,13</li></ul></li></ol><details class="toggle" ><summary class="toggle-button" style="">解析</summary><div class="toggle-content"><p><sub><sub>今年最奇怪的题目</sub></sub></p><p>由 <code>egg</code>，<code>cnt_broken</code> 可以得出（？），我们假设这样一个情景：</p><p>现在你有两个一样的鸡蛋，你可以进行一种操作：</p><ul><li>把鸡蛋从一个高度 <span class="math inline">\(h\)</span> 扔下来，观察它有没有摔碎。如果鸡蛋碎了，这个鸡蛋就不能再用了，你需要用另一个鸡蛋继续尝试，如果两个都碎了（<code>You have no egg!</code>），则游戏结束。</li></ul><p>现在，你想知道会让鸡蛋摔碎的最小高度（<code>guess1</code>），和知道前者的最小操作次数（<code>guess2</code>）。</p><p><strong>guess1</strong></p><p><code>guess1</code> 函数比较好懂，就是枚举所有可能的高度，这样会一定会摔碎 <span class="math inline">\(1\)</span> 个鸡蛋。</p><p><strong>guess2</strong></p><p><code>guess2</code> 函数略复杂，它将高度分为了几个区间，我们以 <span class="math inline">\(n = 15\)</span> 为例，化为了 <span class="math inline">\([1,5],[6,9],[10,12],[13,14],[15,15]\)</span> 五段，它们的长度依次递减，分别为 <span class="math inline">\(5,4,3,2,1\)</span>。</p><p>对于每段区间，我们先尝试它的右端点，如果没摔碎说明高度足够，就尝试下一个区间。</p><p>如果摔碎了，因为只剩一个鸡蛋，只能模仿 <code>guess1</code> 从小到大依次尝试，求出最终答案。</p><p>这样摔碎鸡蛋的数量一定是 <span class="math inline">\(1\)</span> 或 <span class="math inline">\(2\)</span>。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>TFTBCA</p><p><strong>判断题</strong></p><ol type="1"><li>手动模拟，得出答案为 <span class="math inline">\(5\)</span>。</li><li>不一定，如果鸡蛋在很低的高度就碎了，<code>guess2</code> 需要额外尝试区间的右端点，多一次猜测。</li><li>显然正确。</li></ol><p><strong>选择题</strong></p><ol type="1"><li>显然为 <span class="math inline">\(1\)</span>。</li><li>猜测次数的最大值 <span class="math inline">\(m\)</span>，要满足 <span class="math inline">\(\frac{m(m-1)}{2} \ge n\)</span>，解二次不等式得 <span class="math inline">\(m\)</span> 的最小值为 <span class="math inline">\(\left\lceil\frac{1+\sqrt{1+8n}}{2}\right\rceil\)</span>，量级估算为 <span class="math inline">\(\sqrt{2n} \approx \sqrt{n}\)</span>。</li><li>手动模拟。</li></ol></div></details><h3>T18</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; k, p;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mpow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; k; k = k &gt;&gt; <span class="number">1</span>, x = x * x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; ans1, ans2;</span><br><span class="line"><span class="type">int</span> cnt1, cnt2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; ans, <span class="type">int</span>&amp; cnt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(ans, cnt, l + <span class="number">1</span>, r, v + k[l] * <span class="built_in">mpow</span>(i, p[l]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; cntans1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    k.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    p.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k[i], &amp;p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(ans1, cnt1, <span class="number">1</span>, n &gt;&gt; <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(ans2, cnt2, (n &gt;&gt; <span class="number">1</span>) + <span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">    std::<span class="built_in">sort</span>(ans<span class="number">1.</span><span class="built_in">begin</span>(), ans<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> newcnt1 = <span class="number">1</span>;</span><br><span class="line">    cntans<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; cnt1; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans1[i] == ans1[newcnt1 - <span class="number">1</span>]) &#123;</span><br><span class="line">            ++cntans1[newcnt1 - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans1[newcnt1++] = ans1[i];</span><br><span class="line">            cntans<span class="number">1.</span><span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt1 = newcnt1;</span><br><span class="line">    std::<span class="built_in">sort</span>(ans<span class="number">2.</span><span class="built_in">begin</span>(), ans<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> las = <span class="number">0</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cnt2 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (; las &lt; cnt1 &amp;&amp; ans1[las] + ans2[i] &lt; <span class="number">0</span>; ++las)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">if</span> (las &lt; cnt1 &amp;&amp; ans1[las] + ans2[i] == <span class="number">0</span>)</span><br><span class="line">            ans += cntans1[las];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断题</strong></p><ol type="1"><li>删除第 <span class="math inline">\(51\)</span> 行的 <code>std::sort(ans2.begin(), ans2.end());</code> 后，代码输出的结果不会受到影响。</li><li>假设计算过程中不发生溢出，函数 <code>mpow(x, k)</code> 的功能是求出 <span class="math inline">\(x^k\)</span>。</li><li>代码中第 <span class="math inline">\(39\)</span> 行到第 <span class="math inline">\(50\)</span> 行的目的是为了将 <code>ans1</code> 数组进行“去重”操作。</li></ol><p><strong>选择题</strong></p><ol type="1"><li>当输入为 <code>3 15 1 2 -1 2 1 2</code> 时，输出结果为？<ul><li>A. 4</li><li>B. 8</li><li>C. 0</li><li>D. 10</li></ul></li><li>记程序结束前 <code>p</code> 数组元素的最大值为 <span class="math inline">\(P\)</span>，则该代码的时间复杂度是？<ul><li>A. <span class="math inline">\(O(n)\)</span></li><li>B. <span class="math inline">\(O(m^n \log m^n)\)</span></li><li>C. <span class="math inline">\(O(m^\frac{n}{2} \log m^\frac{n}{2})\)</span></li><li>D. <span class="math inline">\(O(m^\frac{n}{2} (\log m^\frac{n}{2} + \log P))\)</span></li></ul></li><li>本题所求出的是？<ul><li>A. 满足 <span class="math inline">\(a,b,c \in [1,m]\)</span> 的整数方程 <span class="math inline">\(a^3+b^3=c^3\)</span> 的解的数量</li><li>B. 满足 <span class="math inline">\(a,b,c \in [1,m]\)</span> 的整数方程 <span class="math inline">\(a^2+b^2=c^2\)</span> 的解的数量</li><li>C. 满足 <span class="math inline">\(x_i \in [0,m]\)</span> 的整数方程 <span class="math inline">\(\sum_{i=1}^n k_i \cdot x_i^{p_i} = 0\)</span> 的解的数量</li><li>D. 满足 <span class="math inline">\(x_i \in [1,m]\)</span> 的整数方程 <span class="math inline">\(\sum_{i=1}^n k_i \cdot x_i^{p_i} = 0\)</span> 的解的数量</li></ul></li></ol><details class="toggle" ><summary class="toggle-button" style="">解析</summary><div class="toggle-content"><p>先看选择题第三问，首先排除 <code>A,B</code> 选项，根本没有出现输入的量。</p><p>观察第 <span class="math inline">\(24\)</span> 行，枚举从 <span class="math inline">\(1\)</span> 开始，故程序含义为：</p><ul><li>满足 <span class="math inline">\(x_i \in [1,m]\)</span> 的整数方程 <span class="math inline">\(\sum_{i=1}^n k_i \cdot x_i^{p_i} = 0\)</span> 的解的数量。</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>FTTBDD</p><p><strong>判断题</strong></p><ol type="1"><li><span class="math inline">\(52\)</span> 到 <span class="math inline">\(59\)</span> 行是双指针计算答案，不排序显然会影响结果。</li><li>快速幂。</li><li>显然。</li></ol><p><strong>选择题</strong></p><ol type="1"><li>结合程序意义，即求 <span class="math inline">\(x_1^2+x_3^2=x_2^2，x_i \in [1,15]\)</span> 的方案数，可以手动枚举计算，也容易联想到就是求边长在 <span class="math inline">\(15\)</span> 以内的直角三角形的数量。</li></ol></div></details><h2>完善程序</h2><h3>T19 特殊最短路</h3><p>给定一个含 <span class="math inline">\(N\)</span> 个点、<span class="math inline">\(M\)</span> 条边的带权无向图，边权非负。起点为 <span class="math inline">\(S\)</span>，终点为 <span class="math inline">\(T\)</span>。对于一条 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 的路径，可以在整条路径中，至多选择一条边作为“免费边”：当第一次经过这条被选中的边时，费用视为 <span class="math inline">\(0\)</span>；如果之后再次经过该边，则仍按其原始权重计费。点和边均允许重复经过。求从 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 的最小总费用。</p><p>以下代码求解了上述问题。试补全程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> INF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="type">int</span> to;</span><br><span class="line"><span class="type">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dist;</span><br><span class="line"><span class="type">int</span> u;</span><br><span class="line"><span class="type">int</span> used_freebie;<span class="comment">//0 for not used, 1 for used</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> State &amp;other) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> dist &gt; other.dist;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m, s, t;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;Edge&gt;&gt; <span class="built_in">adj</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">adj[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">adj[v].<span class="built_in">push_back</span>(&#123;u, w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">d</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">2</span>, INF));</span><br><span class="line">priority_queue&lt;State, vector&lt;State&gt;, greater&lt;State&gt;&gt; pq;</span><br><span class="line"></span><br><span class="line">d[s][<span class="number">0</span>]= <span class="number">0</span>;</span><br><span class="line">pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s,   ①  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">State current =pq.<span class="built_in">top</span>();</span><br><span class="line">pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dist = current.dist;</span><br><span class="line"><span class="type">int</span> u= current.u;</span><br><span class="line"><span class="type">int</span> used = current.used_freebie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dist &gt;   ②  )&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;edge : adj[u]) &#123;</span><br><span class="line"><span class="type">int</span> v = edge.to;</span><br><span class="line"><span class="type">int</span> w = edge.weight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(d[u][used] + w &lt;   ③  )&#123;</span><br><span class="line">   ③  = d[u][used] + w;</span><br><span class="line">pq.<span class="built_in">push</span>(&#123;  ③  , v , used&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(used == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(  ④   &lt; d[v][<span class="number">1</span>])&#123;</span><br><span class="line">d[v][<span class="number">1</span>] =   ④  ;</span><br><span class="line">pq.<span class="built_in">push</span>(&#123;d[v][<span class="number">1</span>], v, <span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt;   ⑤   &lt;&lt;  endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li>① 处应填：<ul><li>A. 0</li><li>B. 1</li><li>C. -1</li><li>D. false</li></ul></li><li>② 处应填：<ul><li>A. d[u][!used]</li><li>B. d[u][used]</li><li>C. d[t][used]</li><li>D. INF</li></ul></li><li>③ 处应填：<ul><li>A. d[v][1]</li><li>B. d[v][used]</li><li>C. d[u][used]</li><li>D. d[v][0]</li></ul></li><li>④ 处应填：<ul><li>A. d[v][0]</li><li>B. d[v][1]</li><li>C. d[u][0]</li><li>D. d[u][1]</li></ul></li><li>⑤ 处应填：<ul><li>A. d[t][1]</li><li>B. d[t][0]</li><li>C. min(d[t][0], d[t][1])</li><li>D. d[t][0]+d[t][1]</li></ul></li></ol><h3>T20 最优测试</h3><p>工厂打算通过客户反馈来间接测试生产线，从而找到存在缺陷的生产线。工厂有 <span class="math inline">\(n\)</span> 条生产线（编号 <span class="math inline">\(0\sim n−1\)</span>），已知其中恰有一条生产线存在缺陷。每一轮测试为，从若干生产线的产品取样混合成一个批次发给客户。若该批次中包含缺陷生产线的产品，客户将要求退货（结果记为 <span class="math inline">\(1\)</span>），否则正常收货（记为 <span class="math inline">\(0\)</span>）。受售后压力限制，在所有发货批次中，最多只能有 <span class="math inline">\(k\)</span> 次退货（即结果为 <span class="math inline">\(1\)</span> 的次数 <span class="math inline">\(\le k\)</span>）。工厂的目标是，设计最少的间接测试轮数 <span class="math inline">\(w\)</span>（发货总批次），保证根据客户收货或退货的反馈结果，唯一确定存在缺陷的生产线。</p><p>以下程序实现了工厂的目标，包含两部分：</p><ol type="1"><li>确定 <span class="math inline">\(w\)</span> 的最小值，并设计最优测试方案；</li><li>根据测试结果推断存在缺陷的生产线。该程序确定 <span class="math inline">\(w\)</span> 最小值的方法为：由于不同的生产线故障时，测试应当返回不同的结果，因此 <span class="math inline">\(w\)</span> 轮测试的可能结果数不应少于生产线数量。</li></ol><p><code>test_subset()</code> 函数为抽象测试接口，输入所有批次的方案并返回一个二进制编码；该编码表示为每批次的检测结果（即最低位是第 <span class="math inline">\(1\)</span> 批次、最高位是第 <span class="math inline">\(w\)</span> 批次）；其实现在此处未给出。</p><p>试补全程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">comb</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; w) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= i; ++t) &#123;</span><br><span class="line">        res = res * (w - t + <span class="number">1</span>) / t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算长度为 w、1 的个数 ≤k 的码字总数 </span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">count_patterns</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="built_in">min</span>(w, k); ++t) &#123;</span><br><span class="line">        total += <span class="built_in">comb</span>(w, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象测试接口 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test_subset</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; plan)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="comment">// === 第 1 步：求最小 w === </span></span><br><span class="line">    <span class="type">int</span> w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (  ① ) &#123; </span><br><span class="line">        ++w;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; w &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// === 第 2 步：生成测试方案 === </span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">code</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(w, <span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ones = <span class="number">0</span>; ones &lt;= k &amp;&amp; idx &lt; n; ++ones) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bits</span><span class="params">(w, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">fill</span>(bits.<span class="built_in">begin</span>(), bits.<span class="built_in">begin</span>() + ones, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt; w; ++b) &#123;</span><br><span class="line">                code[idx][b] = bits[b];</span><br><span class="line">            &#125;</span><br><span class="line">            ++idx;</span><br><span class="line">            <span class="keyword">if</span> (idx &gt;= n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ( std::  ② );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">plan</span>(w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; w; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (  ③ ) &#123; </span><br><span class="line">                plan[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// === 第 3 步：调用测试接口 === </span></span><br><span class="line">    <span class="type">int</span> signature = <span class="built_in">test_subset</span>(plan);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// === 第 4 步：结果解码 === </span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sig_bits</span><span class="params">(w, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; w; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (  ④ ) &#123; </span><br><span class="line">            sig_bits[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (  ⑤ ) <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">solve</span>(n, k);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol type="1"><li>① 处应填：<ul><li>A. (1&lt;&lt;w)&lt;n</li><li>B. count_patterns(w,k) &lt; n</li><li>C. count_patterns(k,w) &lt; n</li><li>D. comb(w,k) &lt; n</li></ul></li><li>② 处应填：<ul><li>A. next_permutation(bits.begin(), bits.end())</li><li>B. prev_permutation(bits.begin(), bits.end())</li><li>C. next_permutation(bits.begin(), bits.begin()+ones)</li><li>D. prev_permutation(bits.begin(), bits.begin()+ones)</li></ul></li><li>③ 处应填：<ul><li>A. (j&gt;&gt;i) &amp; 1</li><li>B. (i&gt;&gt;j) &amp; 1</li><li>C. code[i][j] == 1</li><li>D. code[j][i] == 1</li></ul></li><li>④ 处应填：<ul><li>A. (signature &gt;&gt; i) &amp; 1</li><li>B. (signature &gt;&gt; i) ^ 1</li><li>C. signature | (1&lt;&lt;i)</li><li>D. (signature &gt;&gt; i) | 1</li></ul></li><li>⑤ 处应填：<ul><li>A. is_permutation(code[j].begin(), code[j].end(), sig_bits.begin())</li><li>B. code[j] == sig_bits</li><li>C. plan[j] == sig_bits</li><li>D. code[j][i] == sig_bits[i]</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> csp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流--最小费用最大流</title>
      <link href="/posts/5aab9e40/"/>
      <url>/posts/5aab9e40/</url>
      
        <content type="html"><![CDATA[<h2>介绍</h2><p>最小费用最大流，简称 <strong>费用流</strong>。</p><p>与 <strong>最大流</strong> 不同的是，每条边还有一个 <strong>费用</strong> <span class="math inline">\(c\)</span>，这条边每流过一个单位流量，就需要付出 <span class="math inline">\(c\)</span> 的费用。</p><p>在保证最大流的 <strong>前提</strong> 下，还要让总费用最小。</p><h2>算法</h2><p>费用流，常用的为 SSP（Successive Shortest Path）算法。</p><div class="note warning flat"><p>此算法不能处理带负环的情况，需使用消圈法。</p></div><p>它是一个贪心的算法，思路是每次寻找单位费用最小的增广路进行增广，直到图上不存在增广路为止。</p><h3>证明</h3><p>我们考虑使用数学归纳法和反证法来证明 SSP 算法的正确性。</p><p>设流量为 <span class="math inline">\(i\)</span> 的时候最小费用为 <span class="math inline">\(f_i\)</span>。我们假设最初的网络上 <strong>没有负圈</strong>，这种情况下 <span class="math inline">\(f_0=0\)</span>。</p><p>假设用 SSP 算法求出的 <span class="math inline">\(f_i\)</span> 是最小费用，我们在 <span class="math inline">\(f_i\)</span> 的基础上，找到一条最短的增广路，从而求出 <span class="math inline">\(f_{i+1}\)</span>。这时 <span class="math inline">\(f_{i+1}-f_i\)</span> 是这条最短增广路的长度。</p><p>假设存在更小的 <span class="math inline">\(f_{i+1}\)</span>，设它为 <span class="math inline">\(f_{i+1}&#39;\)</span>。因为 <span class="math inline">\(f_{i+1}-f_i\)</span> 已经是最短增广路了，所以 <span class="math inline">\(f&#39;_{i+1}-f_i\)</span> 一定对应一个经过 <strong>至少一个负圈</strong> 的增广路。</p><p>这时候矛盾就出现了：既然存在一条经过至少一个负圈的增广路，那么 <span class="math inline">\(f_i\)</span> 就不是最小费用了。因为只要给这个负圈添加流量，就可以在不增加 <span class="math inline">\(s\)</span> 流出的流量的前提下，使 <span class="math inline">\(f_i\)</span> 对应的费用更小。</p><p>综上，SSP 算法可以正确求出无负圈网络的最小费用最大流。</p><blockquote><p>证明过程摘自 <a href="https://oi-wiki.org/graph/flow/min-cost/#%E8%AF%81%E6%98%8E">OI-Wiki：SSP 算法</a></p></blockquote><h3>复杂度分析</h3><p>如果使用 spfa 求解最短路，每次找增广路的时间复杂度为 <span class="math inline">\(O(nm)\)</span>。设该网络的最大流为 <span class="math inline">\(f\)</span>，则最坏时间复杂度为 <span class="math inline">\(O(nmf)\)</span>。事实上，SSP 算法是 <strong>伪多项式时间</strong>。</p><h2>实现</h2><p>Dinic + spfa:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>, M = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> ll inf = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">graph</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> v, nt;</span><br><span class="line">        ll c, w;</span><br><span class="line">    &#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> hd[N], tot = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll c, ll w)</span> </span>&#123;</span><br><span class="line">        e[++tot].v = v, e[tot].nt = hd[u], e[tot].c = c, e[tot].w = w, hd[u] = tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">uadd</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll c, ll w)</span> </span>&#123; <span class="built_in">add</span>(u, v, c, w), <span class="built_in">add</span>(v, u, <span class="number">0</span>, -w); &#125;</span><br><span class="line">&#125; g;</span><br><span class="line"><span class="type">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">namespace</span> SSAP &#123;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> cur[N];</span><br><span class="line">ll dis[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dis[i] = inf, vis[i] = <span class="literal">false</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>, vis[s] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = g.hd[u]; i; i = g.e[i].nt) &#123;</span><br><span class="line">            <span class="type">int</span> v = g.e[i].v;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + g.e[i].w &amp;&amp; g.e[i].c) &#123;</span><br><span class="line">                dis[v] = dis[u] + g.e[i].w;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v]) q.<span class="built_in">push</span>(v), vis[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t] != inf;</span><br><span class="line">&#125;</span><br><span class="line">ll mincost;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, ll f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t || f == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;i = cur[u]; i; i = g.e[i].nt) &#123;</span><br><span class="line">        <span class="type">int</span> v = g.e[i].v;</span><br><span class="line">        cur[u] = i;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v] &amp;&amp; dis[v] == dis[u] + g.e[i].w &amp;&amp; g.e[i].c) &#123;</span><br><span class="line">            ll t = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(f, g.e[i].c));</span><br><span class="line">            <span class="keyword">if</span> (t) &#123;</span><br><span class="line">                g.e[i].c -= t, g.e[i ^ <span class="number">1</span>].c += t;</span><br><span class="line">                mincost += g.e[i].w * t;</span><br><span class="line">                sum += t, f -= t;</span><br><span class="line">                <span class="keyword">if</span> (f == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">flow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>, flow;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">spfa</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cur[i] = g.hd[i], vis[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> ((flow = <span class="built_in">dfs</span>(s, inf))) &#123;</span><br><span class="line">            ans += flow;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) vis[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace SSAP</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        ll c, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; c &gt;&gt; w;</span><br><span class="line">        g.<span class="built_in">uadd</span>(u, v, c, w);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = SSAP::<span class="built_in">flow</span>();</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; SSAP::mincost &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> network-flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Multiple Choice Test P</title>
      <link href="/posts/e1da9495/"/>
      <url>/posts/e1da9495/</url>
      
        <content type="html"><![CDATA[<h2>一句话题意</h2><p>给你 <span class="math inline">\(n\)</span> 组向量，从每组中选出一个向量，使被选出的向量的总和到远点的距离最大，<span class="math inline">\(2\le n \le 2\times 10^5\)</span>。</p><h2>前置</h2><ol type="1"><li>凸包</li><li>闵可夫斯基和</li></ol><h2>解法</h2><p>结论：所有被选出的向量一定在凸包上。</p><blockquote><p>简单证明：</p><p>与原点距离最大的点即为 <strong>欧几里得距离</strong> 的平方：<span class="math inline">\(f(p) = x_p^2+y_p^2\)</span>。</p><p>显然在凸包上时，距离最大。</p></blockquote><p>我们就可以对每个向量集合求出凸包，然后每次用 <strong>闵可夫斯基和</strong> 求出凸包的和。</p><p>最后遍历凸包上的点，求出最大的距离。</p><p>时间复杂度：<span class="math inline">\(O(n\log n)\)</span>，其中 <span class="math inline">\(n\)</span> 是向量个数。</p><h2>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">short</span> <span class="type">int</span> <span class="title">sgn</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> (<span class="built_in">abs</span>(x) == <span class="number">0</span>) ? <span class="number">0</span> : ((x &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">-1</span>); &#125; <span class="comment">// 判断符号</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    db ang;  <span class="comment">// 极角，用 atan2 计算</span></span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="type">const</span> Point b) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;x + b.x, y + b.y&#125;; &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="type">const</span> Point b) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;x - b.x, y - b.y&#125;; &#125;</span><br><span class="line">    ll <span class="keyword">operator</span>*(<span class="type">const</span> Point b) <span class="type">const</span> &#123; <span class="keyword">return</span> x * b.y - y * b.x; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Point b) <span class="type">const</span> &#123; <span class="keyword">return</span> (x == b.x) ? (y &lt; b.y) : (x &lt; b.x); &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Point b) <span class="type">const</span> &#123; <span class="keyword">return</span> (y == b.y) ? (x &lt; b.x) : (y &gt; b.y); &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Cross</span><span class="params">(Point a)</span> </span>&#123; <span class="keyword">return</span> x * a.y - y * a.x; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; x = y = <span class="number">0</span>; &#125;</span><br><span class="line">&#125; sum; <span class="comment">// 点</span></span><br><span class="line">vector&lt;Point&gt; v;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Convex</span> &#123;</span><br><span class="line">    vector&lt;Point&gt; p;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Andrew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        p.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = v.<span class="built_in">size</span>(), cnt = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt &gt; <span class="number">1</span> &amp;&amp; ((p[cnt - <span class="number">1</span>] - p[cnt - <span class="number">2</span>]) * (v[i] - p[cnt - <span class="number">1</span>])) &lt;= <span class="number">0</span>)</span><br><span class="line">                p.<span class="built_in">pop_back</span>(), cnt--;</span><br><span class="line">            p.<span class="built_in">push_back</span>(v[i]), cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> basic = cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (cnt &gt; basic &amp;&amp; <span class="built_in">sgn</span>(((p[cnt - <span class="number">1</span>] - p[cnt - <span class="number">2</span>]) * (v[i] - p[cnt - <span class="number">1</span>]))) &lt;= <span class="number">0</span>)</span><br><span class="line">                p.<span class="built_in">pop_back</span>(), cnt--;</span><br><span class="line">            p.<span class="built_in">push_back</span>(v[i]), cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">1</span>) p.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125; <span class="comment">// Andrew 算法实现凸包</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mincowsky</span><span class="params">(Convex coh)</span> </span>&#123;</span><br><span class="line">        Point minp&#123;inf, inf&#125;;</span><br><span class="line">        <span class="type">int</span> minid = <span class="number">0</span>, n = coh.p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (minp &gt; coh.p[i]) minid = i + <span class="number">1</span>, minp = coh.p[i];</span><br><span class="line"></span><br><span class="line">        sum.x += minp.x, sum.y += minp.y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = minid - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="type">int</span> x = (coh.p[j - <span class="number">1</span>].x - coh.p[j].x), y = (coh.p[j - <span class="number">1</span>].y - coh.p[j].y);</span><br><span class="line">            p.<span class="built_in">push_back</span>(Point&#123;x, y, <span class="built_in">atan2</span>(y, x)&#125;);</span><br><span class="line">        &#125; <span class="comment">// 上凸包</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x = (coh.p[n - <span class="number">1</span>].x - coh.p[<span class="number">0</span>].x), y = (coh.p[n - <span class="number">1</span>].y - coh.p[<span class="number">0</span>].y);</span><br><span class="line">            p.<span class="built_in">push_back</span>(Point&#123;x, y, <span class="built_in">atan2</span>(y, x)&#125;);</span><br><span class="line">        &#125; <span class="comment">// 连接点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= minid; j--) &#123;</span><br><span class="line">            <span class="type">int</span> x = (coh.p[j - <span class="number">1</span>].x - coh.p[j].x), y = (coh.p[j - <span class="number">1</span>].y - coh.p[j].y);</span><br><span class="line">            p.<span class="built_in">push_back</span>(Point&#123;x, y, <span class="built_in">atan2</span>(y, x)&#125;);</span><br><span class="line">        &#125; <span class="comment">// 下凸包</span></span><br><span class="line">    &#125; <span class="comment">// 闵可夫斯基和</span></span><br><span class="line"></span><br><span class="line">&#125; coh, maxcoh; <span class="comment">// 凸包</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>,t; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">        v.<span class="built_in">resize</span>(t);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; t; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;v[j].x, &amp;v[j].y);</span><br><span class="line">        coh.<span class="built_in">Andrew</span>();</span><br><span class="line">        maxcoh.<span class="built_in">mincowsky</span>(coh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(maxcoh.p.<span class="built_in">begin</span>(), maxcoh.p.<span class="built_in">end</span>(), [](Point a, Point b) &#123; <span class="keyword">return</span> a.ang &gt; b.ang; &#125;); <span class="comment">// 最后按极角排序</span></span><br><span class="line"></span><br><span class="line">    ans = sum.x * sum.x + sum.y * sum.y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : maxcoh.p) &#123;</span><br><span class="line">        sum.x += p.x, sum.y += p.y;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, (sum.x * sum.x + sum.y * sum.y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>炽声音节旋题解</title>
      <link href="/posts/c1988da5/"/>
      <url>/posts/c1988da5/</url>
      
        <content type="html"><![CDATA[<h2>前置</h2><ul><li>模拟</li></ul><h2>解法</h2><p>为了方便描述每个音节的长度，我们定义一个 <strong>最小单位时间</strong>，<strong>四分音符</strong> 长 <span class="math inline">\(96\)</span> 的单位时间。</p><blockquote><p>为什么是 <span class="math inline">\(96\)</span> ？</p><p><sub><sub>大部分电脑音游用的 96。</sub></sub></p><p><span class="math inline">\(96 = 2^5 \times 3\)</span>，可以整除本题所有的 <strong>音符时长</strong>。</p></blockquote><h3>记录</h3><p>我们将每个音符记为多个事件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">    ll t;     <span class="comment">// 时间点</span></span><br><span class="line">    <span class="type">int</span> type; <span class="comment">// 0 为 Hold 起始，1 为 Hold 结束，2 为 Tap</span></span><br><span class="line">    <span class="type">int</span> btn;  <span class="comment">// 按键编号 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以将每一时刻的事件存在一起，方便处理。</p><blockquote><p>注：C++ 中 <code>stoi</code> 函数可以将 <code>string</code> 直接转为数字。</p></blockquote><h3>多押无理</h3><blockquote><p>在任意时刻，按下的按键不能大于 2。</p><p>按下的按键包括：</p><ol type="1"><li><p>Tap 和 Hold 的开始。</p></li><li><p>已按下的 Hold（包括刚好结束）。</p></li></ol></blockquote><p>直接开 <code>bool</code> 储存每一按键当前是否按下，再结合当前时刻的按键数累加判断。</p><h3>嵌套无理</h3><blockquote><p>在任意时刻，同一个按键不能按下两次。</p><p>按下的按键同上。</p></blockquote><p>同上，判断 <code>bool</code> 中当前按键是否按下，再结合当前时刻的按键判断。</p><p>每次记得更新 <code>bool</code> 中的状态。</p><p>上述两个无理只要有 <strong>其中之一</strong>，就为 <code>No</code>。</p><p>时间复杂度：<span class="math inline">\(O(T(n log n + n))\)</span>，<span class="math inline">\(n\)</span> 为事件总数。</p><h2>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Event</span> &#123;</span><br><span class="line">    <span class="built_in">Event</span>(ll t, <span class="type">int</span> type, <span class="type">int</span> btn) :</span><br><span class="line">        <span class="built_in">t</span>(t), <span class="built_in">type</span>(type), <span class="built_in">btn</span>(btn) &#123;&#125;</span><br><span class="line">    ll t;     <span class="comment">// 时间点</span></span><br><span class="line">    <span class="type">int</span> type; <span class="comment">// 0 为 Hold 起始，1 为 Hold 结束，2 为 Tap</span></span><br><span class="line">    <span class="type">int</span> btn;  <span class="comment">// 按键编号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BASE = <span class="number">96</span>; <span class="comment">// 一拍占用的最小单位时间</span></span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string t, line;</span><br><span class="line">vector&lt;Event&gt; events;            <span class="comment">// 时间</span></span><br><span class="line">vector&lt;string&gt; notes;            <span class="comment">// 每个音符</span></span><br><span class="line">map&lt;ll, vector&lt;Event&gt;&gt; timeline; <span class="comment">// 每个时刻的事件</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hold;    <span class="comment">// 当前按下的按键</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="built_in">getline</span>(cin, t);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        events.<span class="built_in">clear</span>(), <span class="built_in">getline</span>(cin, t);</span><br><span class="line">        ll now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">getline</span>(cin, line);</span><br><span class="line">            <span class="type">int</span> pos = line.<span class="built_in">find</span>(<span class="string">&#x27;&#125;&#x27;</span>); <span class="comment">// 结束位置</span></span><br><span class="line">            <span class="type">int</span> value = <span class="built_in">stoi</span>(line.<span class="built_in">substr</span>(<span class="number">1</span>, pos - <span class="number">1</span>));</span><br><span class="line">            ll unit = BASE * <span class="number">4</span> / value; <span class="comment">// 计算单位时间</span></span><br><span class="line">            string body = line.<span class="built_in">substr</span>(pos + <span class="number">2</span>), tmp;</span><br><span class="line">            notes.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> ch : body)</span><br><span class="line">                <span class="keyword">if</span> (ch == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">                    notes.<span class="built_in">push_back</span>(tmp), tmp.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    tmp += ch;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; notes.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                ll time = now + i * unit; <span class="comment">// 按键时间</span></span><br><span class="line">                <span class="keyword">if</span> (notes[i].<span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="function">stringstream <span class="title">ss</span><span class="params">(notes[i])</span></span>;</span><br><span class="line">                string token;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, token, <span class="string">&#x27;/&#x27;</span>)) &#123; <span class="comment">// 以 &#x27;/&#x27; 分割音符</span></span><br><span class="line">                    <span class="keyword">if</span> (token.<span class="built_in">find</span>(<span class="string">&#x27;h&#x27;</span>) == string::npos) &#123;</span><br><span class="line">                        <span class="type">int</span> btn = <span class="built_in">stoi</span>(token);</span><br><span class="line">                        events.<span class="built_in">push_back</span>(<span class="built_in">Event</span>(time, <span class="number">2</span>, btn));</span><br><span class="line">                    &#125; <span class="comment">// Tap</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">int</span> btn = <span class="built_in">stoi</span>(token.<span class="built_in">substr</span>(<span class="number">0</span>, token.<span class="built_in">find</span>(<span class="string">&#x27;h&#x27;</span>)));</span><br><span class="line">                        <span class="type">int</span> l = token.<span class="built_in">find</span>(<span class="string">&#x27;[&#x27;</span>), m = token.<span class="built_in">find</span>(<span class="string">&#x27;:&#x27;</span>), r = token.<span class="built_in">find</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">                        <span class="type">int</span> value = <span class="built_in">stoi</span>(token.<span class="built_in">substr</span>(l + <span class="number">1</span>, m - l - <span class="number">1</span>));</span><br><span class="line">                        <span class="type">int</span> cnt = <span class="built_in">stoi</span>(token.<span class="built_in">substr</span>(m + <span class="number">1</span>, r - m - <span class="number">1</span>));</span><br><span class="line">                        ll duration = (BASE * <span class="number">4</span> / value) * cnt;           <span class="comment">// Hold 持续时间</span></span><br><span class="line">                        events.<span class="built_in">push_back</span>(<span class="built_in">Event</span>(time, <span class="number">0</span>, btn));            <span class="comment">// Hold 起始</span></span><br><span class="line">                        events.<span class="built_in">push_back</span>(<span class="built_in">Event</span>(time + duration, <span class="number">1</span>, btn)); <span class="comment">// Hold 结束</span></span><br><span class="line">                    &#125; <span class="comment">// Hold</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            now += unit * notes.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timeline.<span class="built_in">clear</span>(), hold.<span class="built_in">clear</span>();                                                <span class="comment">// 记得初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [t, type, btn] : events) timeline[t].<span class="built_in">push_back</span>(<span class="built_in">Event</span>(t, type, btn)); <span class="comment">// 储存每个时刻的事件</span></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [t, event] : timeline) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : hold)</span><br><span class="line">                <span class="keyword">if</span> (v &gt; <span class="number">0</span>) sum++; <span class="comment">// 统计当前按下的按键数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> e : event)</span><br><span class="line">                <span class="keyword">if</span> (e.type == <span class="number">2</span> || e.type == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (hold[e.btn] &gt; <span class="number">0</span>) flag = <span class="literal">true</span>; <span class="comment">// 重复按下</span></span><br><span class="line">                    sum++;                            <span class="comment">// 按下按键</span></span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="number">2</span>) flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> e : event) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.type == <span class="number">0</span>)</span><br><span class="line">                    hold[e.btn]++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e.type == <span class="number">1</span>)</span><br><span class="line">                    hold[e.btn]--;</span><br><span class="line">            &#125; <span class="comment">// 更新按键状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; (flag ? <span class="string">&quot;No&quot;</span> : <span class="string">&quot;Yes&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> simulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025.2.5-A</title>
      <link href="/posts/39f57f6b/"/>
      <url>/posts/39f57f6b/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="8d46329b0dd17813355bf42d5ed443ed52613342587beec6102ab38b507f9ee5">93024cf999deb8d8b2919f7e109263d4872d78f951621408c757971c9e670596d61f9856b4466a8b341035d04ecc7143b1c10f189912ac2afc56c4f05e9375d9b3028bbb66e3653c828e12db114e47e41c84f9f088ca350a3eebcb27f0667097056370fb368338a94523aa5d1b6929723cb5df68208de559ed9ea87d147abe7e8778f65f0ed38307e63d2d6815ea553e07713ddc18865c95d4983472f42e0a5ece5c240240ccf9b68a010dec0db10435a5567a326df6b2b16d65689939bb28a435b6081b15c57d9b21818db8a2456c55a000440cc19cb9cbe806c0938f994495f558c950c2bc85e956d04e6b4d564a955637898de9bcef65ab8e9ad8c6b199d19e1a03a5d077cfaf12101f18fbd1a95f4f1c7cf8498fc81da5a1fcf0bec747ed6e9f9533b9cbf4c1a496a959e131a71feccc5b4798b01d28c0dcf7d6a1a74ff839c7a7137fec79fe65d2521538e13fa1948372f17a825ac00cc6c8121adf92f5a03ef679ef1cd532f968236633bc6aab8ade735ecfa28d5436fd1e7d08b124532304c88012a79e39510b2529c444855354640fab43d9f245893e921591e77d191b771752a106d1b57e764798628a9dda99728a6094d4ca90d6d8f3336bcfae85</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> school </tag>
            
            <tag> dp </tag>
            
            <tag> network-flow </tag>
            
            <tag> constructive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025 洛谷冬日绘板脚本</title>
      <link href="/posts/6e35af4a/"/>
      <url>/posts/6e35af4a/</url>
      
        <content type="html"><![CDATA[<h2>关于冬日绘板</h2><p>绘板地址: <a href="https://paintboard.ayakacraft.com/">https://paintboard.ayakacraft.com/</a></p><p>Api 文档: <a href="https://www.luogu.com/article/57b4jd3c">https://www.luogu.com/article/57b4jd3c</a></p><p>官方介绍：<a href="https://www.luogu.com.cn/article/7yfdaqak">https://www.luogu.com.cn/article/7yfdaqak</a></p><p>冬日绘板是进行网络画布像素争夺的一项活动，在 OI 圈中有一定的知名度。这类活动据传起源于 2017 年愚人节的 Reddit 平台开展的类似活动，时长 72 小时，而当时绘画的冷却时间则为 5 分钟。洛谷平台于 2021 年元旦、2022 年元旦也发布了类似的活动，由于活动在冬日举行，故定名为冬日绘板。</p><h2>脚本</h2><p><img src="https://img.shields.io/badge/Python-3.10.11-blue" /> <img src="https://img.shields.io/badge/C++-Clang_19.1.4-blue" /> <img src="https://img.shields.io/github/license/xglight/XG-LSPaintBoard" alt="GitHub License" /> <img src="https://img.shields.io/github/downloads/xglight/XG-LSPaintBoard/latest/total" alt="GitHub Downloads (all assets, latest release)" /> <img src="https://img.shields.io/github/stars/xglight/XG-LSPaintBoard" alt="GitHub Repo stars" /></p><p>采用 C++ 后端与 Python 网络交互，Socket 通信。</p><p>实测效率极优。</p><p>在 Github 上开源：</p><p><a href="https://github.com/xglight/XG-LSPaintBoard">https://github.com/xglight/XG-LSPaintBoard</a></p><p>脚本测试服务器：</p><p><a href="https://github.com/xglight/LSPaintBoard-Fake-Server">https://github.com/xglight/LSPaintBoard-Fake-Server</a></p><p>欢迎 Issues。</p><p>也欢迎 token，可以通过 Email、QQ 或 Luogu 联系我。</p>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024NOIP游记</title>
      <link href="/posts/cfc318c/"/>
      <url>/posts/cfc318c/</url>
      
        <content type="html"><![CDATA[<h2>Day 1</h2><p>今天是 NOIP，<sub><sub>又能逃课出去了</sub></sub>。</p><p>进入赛场，先开 T1，很快想出了贪心，但对拍比较久，打了 40 min。</p><p>T2 开始，先是推结论，发现推不出来，进而想到 DP，但最后一个大样例一直过不去，赛场上灵光炸现，想出来了。</p><p>一看时间还剩 90 min，开始写 T3 暴力，不过到结束还是没写出来。</p><p>成绩：100+100+0+0=200</p><h2>总结</h2><p>这次打的比较稳健，但速度还是太慢，希望明年能有所进步。</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> noip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024CSP游记</title>
      <link href="/posts/167da4e1/"/>
      <url>/posts/167da4e1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>坐标： gd-zs</p></blockquote><h2>Day0</h2><p>明天就要打 CSP 了，当天晚上把算法都看了一遍。</p><h2>Day1</h2><h3>J</h3><p>7:30 就到了考场，等了好久。</p><p>T1,T2 30 分钟就做完了，T3 调试加对拍花了大概 40 分钟，开始想 T4。</p><p>先打了一个暴力模拟，感觉没什么问题，然后开始优化，过了大样例。</p><p>不过没想到 DP 有点可惜。</p><h3>S</h3><p>中午睡了 1 小时。</p><p>打开 T1,30 分钟就打完了。</p><p>T2 直接用了二分+树状数组，对拍花了 1.5 小时。</p><p>T3 不太会，只打了 30 到 50 pts 的 DP。</p><p>T4 似乎暴力有 35 pts，我考场上没打。</p><h2>总结</h2><p>这次发挥还算稳定，希望今年分数线不高。</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 的 mathjax 渲染</title>
      <link href="/posts/4e95c1db/"/>
      <url>/posts/4e95c1db/</url>
      
        <content type="html"><![CDATA[<h2>前言</h2><p>本来 mathjax 的渲染一直用的十分顺手，直到有一天，我打了一个超级复杂的公式，发现渲染出来的效果不太好，于是我开始了寻找解决方案。</p><p>比如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> x<span class="built_in">_</span>0 <span class="built_in">&amp;</span> x<span class="built_in">_</span>0<span class="built_in">^</span>2 <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> x<span class="built_in">_</span>0<span class="built_in">^</span>n <span class="keyword">\\</span></span><br><span class="line">1 <span class="built_in">&amp;</span> x<span class="built_in">_</span>1 <span class="built_in">&amp;</span> x<span class="built_in">_</span>1<span class="built_in">^</span>2 <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> x<span class="built_in">_</span>1<span class="built_in">^</span>n <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\ddots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="keyword">\\</span></span><br><span class="line">    1 <span class="built_in">&amp;</span> x<span class="built_in">_</span>n <span class="built_in">&amp;</span> x<span class="built_in">_</span>n<span class="built_in">^</span>2 <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> x<span class="built_in">_</span>n<span class="built_in">^</span>n  </span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">a<span class="built_in">_</span>0 <span class="keyword">\\</span> a<span class="built_in">_</span>1 <span class="keyword">\\</span> <span class="keyword">\vdots</span> <span class="keyword">\\</span> a<span class="built_in">_</span>n</span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line">=</span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">y<span class="built_in">_</span>0 <span class="keyword">\\</span> y<span class="built_in">_</span>1 <span class="keyword">\\</span> <span class="keyword">\vdots</span> <span class="keyword">\\</span> y<span class="built_in">_</span>n</span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure><h2>分析问题</h2><p>hexo 常用的渲染插件为 <code>hexo-renderer-marked</code>，原理是将公式块渲染为一个元素，然后用 <code>MathJax</code> 进行渲染。</p><p>但插件会优先转义 Markdown 语法，当语法冲突时，会导致公式无法正常渲染。</p><h2>解决方案</h2><p>换渲染插件，使用 <code>hexo-renderer-pandoc</code>。</p><div class="note warning flat"><p>如果你有下载过任何其他的渲染插件，请务必卸载，否则可能会导致渲染问题。</p></div><div class="note info flat"><p>需要本机下载 Pandoc 并配置环境变量。</p></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure><p>还要在 hexo 配置文件 <code>_config.yml</code> 中添加以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pandoc:</span></span><br><span class="line">  <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;-f&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;commonmark_x&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;-t&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;html&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;--mathjax&#x27;</span></span><br><span class="line">  <span class="attr">extensions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;-implicit_figures&#x27;</span></span><br></pre></td></tr></table></figure><h2>Github Action 自动部署</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- name: 安装 Pandoc</span><br><span class="line">  run: |</span><br><span class="line">    wget https://github.com/jgm/pandoc/releases/download/2.10.1/pandoc-2.10.1-1-amd64.deb</span><br><span class="line">    sudo dpkg -i pandoc-2.10.1-1-amd64.deb</span><br></pre></td></tr></table></figure><h2>Mathjax 版本</h2><p>可以自己改 CDN，具体在 <strong>主题配置文件</strong> 配置项 <code>CDN</code> 处。（一般在文件末尾）</p><p>找到 <code>option</code> 中的 <code>mathjax</code> 项，去掉注释，后面加上 <code>CDN</code> 链接。</p><table><thead><tr class="header"><th style="text-align: left;">文件名</th><th style="text-align: left;">输入格式支持</th><th style="text-align: left;">输出格式</th><th style="text-align: left;">含可访问性扩展 (assistive / complexity / explorer)</th><th style="text-align: left;">是否含 Speech Rule Engine</th><th style="text-align: left;">文件大小 (约)</th><th style="text-align: left;">推荐用途</th><th style="text-align: left;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><strong>tex-chtml.js</strong></td><td style="text-align: left;">TeX</td><td style="text-align: left;">CHTML</td><td style="text-align: left;">❌ 无</td><td style="text-align: left;">❌ 无</td><td style="text-align: left;">~300KB</td><td style="text-align: left;">一般网页、轻量渲染</td><td style="text-align: left;">最轻版本，只支持 TeX→CHTML</td></tr><tr class="even"><td style="text-align: left;"><strong>tex-svg.js</strong></td><td style="text-align: left;">TeX</td><td style="text-align: left;">SVG</td><td style="text-align: left;">❌ 无</td><td style="text-align: left;">❌ 无</td><td style="text-align: left;">~350KB</td><td style="text-align: left;">需要高质量矢量公式</td><td style="text-align: left;">输出为 SVG，适合打印或 PDF</td></tr><tr class="odd"><td style="text-align: left;"><strong>tex-mml-chtml.js</strong></td><td style="text-align: left;">TeX + MathML</td><td style="text-align: left;">CHTML</td><td style="text-align: left;">✅ 有</td><td style="text-align: left;">✅ 有</td><td style="text-align: left;">~450KB</td><td style="text-align: left;">✅ 最完整常用版本</td><td style="text-align: left;">官方推荐版，支持屏幕阅读器</td></tr><tr class="even"><td style="text-align: left;"><strong>tex-mml-svg.js</strong></td><td style="text-align: left;">TeX + MathML</td><td style="text-align: left;">SVG</td><td style="text-align: left;">✅ 有</td><td style="text-align: left;">✅ 有</td><td style="text-align: left;">~500KB</td><td style="text-align: left;">可访问 + 高质量公式</td><td style="text-align: left;">含语音朗读与 Explorer</td></tr><tr class="odd"><td style="text-align: left;"><strong>mml-chtml.js</strong></td><td style="text-align: left;">MathML</td><td style="text-align: left;">CHTML</td><td style="text-align: left;">⚠️ 部分</td><td style="text-align: left;">❌ 无</td><td style="text-align: left;">~250KB</td><td style="text-align: left;">原生 MathML 网站</td><td style="text-align: left;">无 TeX 支持</td></tr><tr class="even"><td style="text-align: left;"><strong>mml-svg.js</strong></td><td style="text-align: left;">MathML</td><td style="text-align: left;">SVG</td><td style="text-align: left;">⚠️ 部分</td><td style="text-align: left;">❌ 无</td><td style="text-align: left;">~280KB</td><td style="text-align: left;">MathML + SVG 输出</td><td style="text-align: left;">纯 MathML 渲染</td></tr><tr class="odd"><td style="text-align: left;"><strong>tex-mml-chtml-full.js</strong></td><td style="text-align: left;">TeX + MathML + AsciiMath</td><td style="text-align: left;">CHTML</td><td style="text-align: left;">✅ 有</td><td style="text-align: left;">✅ 有</td><td style="text-align: left;">~900KB–1MB</td><td style="text-align: left;">🧩 全功能版（全家桶）</td><td style="text-align: left;">包含所有输入 / 输出 / 辅助模块</td></tr><tr class="even"><td style="text-align: left;"><strong>tex-mml-svg-full.js</strong></td><td style="text-align: left;">TeX + MathML + AsciiMath</td><td style="text-align: left;">SVG</td><td style="text-align: left;">✅ 有</td><td style="text-align: left;">✅ 有</td><td style="text-align: left;">~1.1MB</td><td style="text-align: left;">大型项目、演示系统</td><td style="text-align: left;">所有模块 + SVG 输出</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022 CSP-S 初赛部分解析</title>
      <link href="/posts/92783d13/"/>
      <url>/posts/92783d13/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考：<a href="https://blog.csdn.net/lq1990717/article/details/141991949">https://blog.csdn.net/lq1990717/article/details/141991949</a></p></blockquote><h2>单项选择题</h2><h3>2</h3><p>你同时用 time 命令和秒表为某个程序在单核 CPU 的运行计时。假如 time 命令的输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real 0m30.721s</span><br><span class="line">user 0m24.579s</span><br><span class="line">sys  0m6.123s</span><br></pre></td></tr></table></figure><p>以下最接近秒表计时时长为：</p><p>A. 30s</p><p>B. 24s</p><p>C. 18s</p><p>D. 6s</p><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>A。</p><p>real： 总的运行时间，从命令开始执行到结束的时间，包括等待CPU时间和其他进程时间。</p><p>user： 用户CPU时间，即在用户态下花费的时间，不包括用于内核操作的时间。</p><p>sys：系统CPU时间，即在内核态下花费的时间，比如执行系统调用所花费的时间。</p><p>秒表计时的时长接近于程序运行的总时间，即real后面显示的时间。</p></div></details><h3>10</h3><p>共有 8 人选修了程序设计课程，期末大作业要求由 2 人组成的团队完成。假设不区分每个团队内 2 人的角色和作用，请问共有多少种可能的组队方案。</p><p>A. 28</p><p>B. 32</p><p>C. 56</p><p>D. 64</p><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>A。</p><p>题目问的是组队的方案，<strong>并没有要求组成 4 队</strong>。8人中选出 2 人组队，选出的 2 人不区分角色作用，也就是选出的 2 人没有顺序，是组合。因此该问题就是求 8 个不同元素中选出 2 个元素的组合数，为 <span class="math inline">\(C_{8}^{2}\)</span>。</p></div></details><h2>阅读程序</h2><h3>22</h3><p>判断：这是一个不稳定的排序算法。</p><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>错。</p><p>程序为 <strong>基数排序</strong>。</p></div></details><h3>32</h3><p>当输入为 <code>100 7</code> 时，输出为：</p><p>A. 1400</p><p>B. 1401</p><p>C. 417</p><p>D. 400</p><details class="toggle" ><summary class="toggle-button" style="">答案</summary><div class="toggle-content"><p>B。</p><p>程序给出十进制数 <span class="math inline">\(n\)</span>，将 <span class="math inline">\(n\)</span> 在 <span class="math inline">\(k\)</span> 进制下进行数位分离，但是每分离出一位后，该数值的符号取反（比较特殊的进制转换）。</p><p>这里说一下 <span class="math inline">\(-a \% b\)</span> 的值。</p><p>设 <span class="math inline">\(a = q*b+r\)</span>，则 <span class="math inline">\(a \% b = r\)</span>。</p><p>当 <span class="math inline">\(a&lt;0\)</span> 时，仍然满足 <span class="math inline">\(a = q*b+r\)</span>。</p><p>例：</p><p>输入： <code>-255 8</code>。</p><table><thead><tr class="header"><th style="text-align: center;">除法式</th><th style="text-align: center;">商</th><th style="text-align: center;">余数</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(-255/8\)</span></td><td style="text-align: center;"><span class="math inline">\(-32\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><span class="math inline">\(-32*8+1 = -255\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(32/8\)</span></td><td style="text-align: center;"><span class="math inline">\(4\)</span></td><td style="text-align: center;"><span class="math inline">\(0\)</span></td><td style="text-align: center;"><span class="math inline">\(4*8+0 = 32\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(-4/8\)</span></td><td style="text-align: center;"><span class="math inline">\(-1\)</span></td><td style="text-align: center;"><span class="math inline">\(4\)</span></td><td style="text-align: center;"><span class="math inline">\(-1*8+4 = -4\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(1/8\)</span></td><td style="text-align: center;"><span class="math inline">\(0\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><span class="math inline">\(0*8+1=1\)</span></td></tr></tbody></table><p>因此结果为 <code>1401</code>。</p></div></details>]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> csp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更新日志</title>
      <link href="/posts/5a717bf0/"/>
      <url>/posts/5a717bf0/</url>
      
        <content type="html"><![CDATA[<div class="timeline "><div class='timeline-item headline'>        <div class='timeline-item-title'>          <div class='item-circle'><p>2025</p></div>        </div>      </div></div><div class="timeline "><div class='timeline-item headline'>        <div class='timeline-item-title'>          <div class='item-circle'><p>2024</p></div>        </div>      </div></div>]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>On the mathematics behind rolling hashes and anti-hash tests</title>
      <link href="/posts/96efb74b/"/>
      <url>/posts/96efb74b/</url>
      
        <content type="html"><![CDATA[<p>This blog assumes the reader is familiar with the basic concept of rolling hashes. There are some math-heavy parts, but one can get most of the ideas without understanding every detail.</p><p>The main focus of this blog is on how to choose the rolling-hash parameters to avoid getting hacked and on how to hack codes with poorly chosen parameters.</p><h2>Designing hard-to-hack rolling hashes</h2><h3>Recap on rolling hashes and collisions</h3><p>Recall that a rolling hash has two parameters <span class="math inline">\((p,a)\)</span> where <span class="math inline">\(p\)</span> is the modulo and <span class="math inline">\(0\le a &lt; p\)</span> the base. (We’ll see that <span class="math inline">\(p\)</span> should be a big prime and <span class="math inline">\(a\)</span> larger than the size of alphabet.) The hash value of a string <span class="math inline">\(S = s_0 \cdots s_{n-1}\)</span> is given by:</p><p><span class="math display">\[h(S) = (\sum^{n-1}_{i=0} a^{n-i-1} s_i) \mod P\]</span></p><p>For now, lets consider the simple problem of: given two strings <span class="math inline">\(S,T\)</span> of equal length, decide whether they’re equal by comparing their hash values <span class="math inline">\(h(S), h(T)\)</span>. Our algorithm declares <span class="math inline">\(S\)</span> and <span class="math inline">\(T\)</span> to be equal if <span class="math inline">\(h(S) = h(T)\)</span>. Most rolling hash solutions are built on multiple calls to this subproblem or rely on the correctness of such calls.</p><p>Let’s call two strings <span class="math inline">\(S, T\)</span> of equal length with <span class="math inline">\(S \neq T\)</span> and <span class="math inline">\(h(S) = h(T)\)</span> an equal-length collision. We want to avoid equal-length collisions, as they cause our algorithm to incorrectly assesses <span class="math inline">\(S\)</span> and <span class="math inline">\(T\)</span> as equal. (Note that our algorithms never incorrectly assesses strings a different.) For fixed parameters and reasonably small length, there are many more strings than possible hash values, so there always are equal-length collisions. Hence you might think that, for any rolling hash, there are inputs for which it is guaranteed to fail.</p><p>Luckily, randomization comes to the rescue. Our algorithm does not have to fix <span class="math inline">\((p, a)\)</span>, it can randomly pick then according to some scheme instead. <span class="math inline">\(A\)</span> scheme is reliable if we can prove that for arbitrary two string <span class="math inline">\(S, T\)</span>, <span class="math inline">\(S\neq T\)</span> the scheme picks <span class="math inline">\((p, a)\)</span> such that <span class="math inline">\(h(S) \neq h(T)\)</span> with high probability. Note that the probability space only includes the random choices done inside the scheme; the input <span class="math inline">\((S, T)\)</span> is arbitrary, fixed and not necessarily random. (If you think of the input coming from a hack, then this means that no matter what the input is, our solution will not fail with high probability.)</p><p>I’ll show you two reliable schemes. (Note that just because a scheme is reliable does not mean that your implementation is good. Some care has to be taken with the random number generator that is used.)</p><h3>Randomizing base</h3><blockquote><p>This part is based on a <a href="https://rng-58.blogspot.com/2017/02/hashing-and-probability-of-collision.html">blog</a> by <a href="https://codeforces.com/profile/rng_58"><font color = "red">rng_58</font></a>. His post covers a more general hashing problem and is worth checking out.</p></blockquote><p>This scheme uses <span class="math inline">\(a\)</span> fixed <strong>prime</strong> <span class="math inline">\(p\)</span> (i.e. <span class="math inline">\(10^9 + 7\)</span> or <span class="math inline">\(4\cdot 10^9 + 7\)</span>) and picks <span class="math inline">\(a\)</span> uniformly at random from <span class="math inline">\([0,p-1]\)</span>. Let <span class="math inline">\(A\)</span> be a random variable for the choice of <span class="math inline">\(a\)</span>.</p><p>To prove that this scheme is good, consider two strings <span class="math inline">\((S, T)\)</span> of equal length and do some calculations：</p><p><span class="math display">\[\begin{aligned}h(S)&amp;=h(T)\\(\sum_{i=0}^{n-1} A^{n-i-1} S_i) \mod p &amp; = (\sum_{i=0}^{n-1} A^{n-i-1} T_i) \mod p\end{aligned}\]</span></p><p>Therefore,we have:</p><p><span class="math display">\[\sum_{i=0}^{n-1} A^{n-i-1} S_i \equiv \sum_{i=0}^{n-1} A^{n-i-1} T_i \pmod p\\\]</span></p><p>Let us let <span class="math inline">\(P(A)\)</span> denote a polynomial in <span class="math inline">\(A\)</span> of degree <span class="math inline">\(\le n-1\)</span>:</p><p><span class="math display">\[P(A) = \sum_{i=0}^{n-1} A^{n-i-1}(S_i-T_i) \equiv 0 \pmod p\]</span></p><p><span class="math inline">\(P\)</span> is non-zero as <span class="math inline">\(S \neq T\)</span>. The calculations show that <span class="math inline">\(h(S) = h(T)\)</span> if and only if <span class="math inline">\(A\)</span> is a root of <span class="math inline">\(P(A)\)</span>.</p><p>As <span class="math inline">\(p\)</span> is prime and we are doing computations <span class="math inline">\(\mod p\)</span>, we are working in a field. Over a field, any polynomial of degree <span class="math inline">\(\le n - 1\)</span> has at most <span class="math inline">\(n-1\)</span> roots. Hence there are at most <span class="math inline">\(n - 1\)</span> choices of a that lead to <span class="math inline">\(h(S) = h(T)\)</span>. Therefore：</p><p><span class="math display">\[Pr[h(S)=h(T)]=Pr[P(A)=0] \le \frac{n-1} {p}\]</span></p><p>So for any two strings <span class="math inline">\((S, T)\)</span> of equal length, the probability that they form an equal-length collision is at most . This is around <span class="math inline">\(10^{-4}\)</span> for <span class="math inline">\(n = 10^5, p = 10^9 + 7\)</span>. Picking larger primes such as <span class="math inline">\(2^{31} - 1\)</span> or <span class="math inline">\(4\cdot 10^9 + 7\)</span> can improve this a bit, but one needs more care with overflows.</p><h3>Tightness of bound</h3><p>For now, this part only applies to primes with smooth <span class="math inline">\(p - 1\)</span>, so it doesn’t work for <span class="math inline">\(p = 10^9 + 7\)</span> for example. It would be interesting to find a construction that is computable and works in the general case.</p><p>The bound <span class="math inline">\(\frac{p-1} {p}\)</span> for this scheme is actually tight if <span class="math inline">\(n-1|p-1\)</span>. Consider <span class="math inline">\(S=ba...a\)</span> and <span class="math inline">\(T=aa...b\)</span> with <span class="math inline">\(P(A)=A^{n-1}-1\)</span>.</p><p>As <span class="math inline">\(p\)</span> is prime,<span class="math inline">\(\frac{\mathbb{Z} } {p\mathbb{Z} }\)</span> is cyclic of order <span class="math inline">\(p - 1\)</span>, hence there is a subgroup <span class="math inline">\(G \subseteq \frac{\mathbb{Z} } {p\mathbb{Z} }\)</span> of order <span class="math inline">\(n - 1\)</span>. Any <span class="math inline">\(g\subseteq G\)</span> then satisfies <span class="math inline">\(g^{n - 1} = 1\)</span>, so <span class="math inline">\(P(A)\)</span> has <span class="math inline">\(n - 1\)</span> distinct roots.</p><h3>Randomizing modulo</h3><p>This scheme fixes a base <span class="math inline">\(a \le |\sum|\)</span> and a bound <span class="math inline">\(N &gt; a\)</span> and picks a <strong>prime</strong> p uniformly at random from <span class="math inline">\([N, 2N - 1]\)</span>.</p><p>To prove that this scheme is good, again, consider two strings <span class="math inline">\((S, T)\)</span> of equal length and do some calculations:</p><p><span class="math display">\[\begin{aligned}h(S)&amp;=h(T)\\(\sum_{i=0}^{n-1} a^{n-i-1} S_i) \mod p &amp; = (\sum_{i=0}^{n-1} a^{n-i-1} T_i) \mod p\end{aligned}\]</span></p><p>Therefore,we have:</p><p><span class="math display">\[\sum_{i=0}^{n-1} a^{n-i-1} S_i \equiv \sum_{i=0}^{n-1} a^{n-i-1} T_i \pmod p\\\]</span></p><p>So:</p><p><span class="math display">\[X = \sum_{i=0}^{n-1}a^{n-i-1}(S_i-T_i) \equiv 0 \pmod p\]</span></p><p>As <span class="math inline">\(X \equiv 0 \pmod p,p|X\)</span>.As we chose a large enough, <span class="math inline">\(X \neq 0\)</span>. Moreover <span class="math inline">\(|X| &lt; a^n\)</span>. An upper bound for the number of distinct prime divisors of <span class="math inline">\(X\)</span> in <span class="math inline">\([N, 2N - 1]\)</span> is given by <span class="math inline">\(\log_N (|X|) = \frac{n\ln (a)} {\ln N}\)</span>. By the prime density theorem, there are around <span class="math inline">\(\frac{X} {\ln{N} }\)</span> primes in <span class="math inline">\([N, 2N - 1]\)</span>. Therefore:</p><p><span class="math display">\[Pr[h(S)=h(T)] = Pr[p|X] \le \sim \frac{n\ln(a)} {N}\]</span></p><p>Note that this bound is slightly worse than the one for randomizing the base. It is around <span class="math inline">\(3\cdot 10{-4}\)</span> for <span class="math inline">\(n = 10^5, a = 26, N = 10^9\)</span>.</p><h3>How to randomize properly</h3><p>The following are good ways of initializing your random number generator.</p><ul><li><p>high precision time.</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrono::<span class="built_in">duration_cast</span>&lt;chrono::nanoseconds&gt;(chrono::high_resolution_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">chrono::<span class="built_in">duration_cast</span>&lt;chrono::nanoseconds&gt;(chrono::steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br></pre></td></tr></table></figure><blockquote><p>Either of the two should be fine. (In theory, <code>high_resolution_clock</code> should be better, but it somehow has lower precision than <code>steady_clock</code> on codeforces??)</p></blockquote></li><li><p>processor cycle counter</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_ia32_rdtsc();</span><br></pre></td></tr></table></figure></li><li><p>some heap address converted to an integer</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">uintptr_t</span>) <span class="built_in">make_unique</span>&lt;<span class="type">char</span>&gt;().<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure></li><li><p>processor randomness (needs either pragma or asm) (Thanks <a href="https://codeforces.com/profile/halyavin"><font color = "red">halyavin</font></a> for <a href="https://codeforces.com/blog/entry/60442?#comment-443083">suggesting</a> this.)</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pragma version</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC target (<span class="string">&quot;rdrnd&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">rdrand32</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> ret;</span><br><span class="line">    <span class="built_in">assert</span>(__builtin_ia32_rdrand32_step (&amp;ret));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// asm version</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> ret;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;rdrand %0&quot;</span> :<span class="string">&quot;=a&quot;</span>(ret) ::<span class="string">&quot;cc&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>If you use a C++11-style rng (you should), you can use a combination of the above:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seed_seq seq&#123;</span><br><span class="line">    (<span class="type">uint64_t</span>) chrono::<span class="built_in">duration_cast</span>&lt;chrono::nanoseconds&gt;(chrono::high_resolution_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>(),</span><br><span class="line">    (<span class="type">uint64_t</span>) __builtin_ia32_rdtsc(),</span><br><span class="line">    (<span class="type">uint64_t</span>) (<span class="type">uintptr_t</span>) <span class="built_in">make_unique</span>&lt;<span class="type">char</span>&gt;().<span class="built_in">get</span>()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">mt19937 <span class="title">rng</span><span class="params">(seq)</span></span>;</span><br><span class="line"><span class="type">int</span> base = <span class="built_in">uniform_int_distribution</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, p<span class="number">-1</span>)(rng);</span><br></pre></td></tr></table></figure><p>Note that this does internally discard the upper 32 bits from the arguments and that this doesn’t really matter, as the lower bits are harder to predict (especially in the first case with chrono.).</p><p><strong>See the section on ‘Abusing bad randomization’ for some bad examples.</strong></p><h3>Extension to multiple hashes</h3><p>We can use multiple hashes (Even with the same scheme and same fixed parameters) and the hashes are independent so long as the random samples are independent. If the single hashes each fail with probability at most <span class="math inline">\(a_1,\cdots, a_k\)</span>, the probability that all hashes fail is at most <span class="math inline">\(\prod_{i=1}^k a_i\)</span>.</p><p>For example, if we use two hashes with <span class="math inline">\(p = 10^9 + 7\)</span> and randomized base, the probability of a collision is at most <span class="math inline">\(10^{ - 8}\)</span>; for four hashes it is at most <span class="math inline">\(10 ^{- 16}\)</span>. Here the constants from slightly larger primes are more significant, for <span class="math inline">\(p = 2^{31} - 1\)</span> the probabilities are around <span class="math inline">\(2.1\cdot 10^{ - 9}\)</span> and <span class="math inline">\(4.7\cdot 10^{ - 18}\)</span>.</p><h3>Larger modulo</h3><p>Using larger (i.e. 60 bit) primes would make collision less likely and not suffer from the accumulated factors of <span class="math inline">\(n\)</span> in the error bounds. However, the computation of the rolling hash gets slower and more difficult, as there is no <code>__int128</code> on codeforces.</p><p>One exception to this is the Mersenne prime <span class="math inline">\(p = 2^{61} - 1\)</span>; we can reduce <span class="math inline">\(\mod p\)</span> by using bitshifts instead. (Thanks <a href="https://codeforces.com/profile/dmkz"><font color = "blue">dmkz</font></a> for suggesting this.) The following code computes <span class="math inline">\(a\cdot b \mod p\)</span> without <code>__int128</code> and is only around <span class="math inline">\(5\%\)</span> slower than a <span class="math inline">\(30\)</span> bit hash with modulo.</p><p>For the argument, the condition <span class="math inline">\(0\le a,b &lt; mod\)</span> should hold.The return value then also satisfies this.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">uint64_t</span> mod = (<span class="number">1ull</span>&lt;&lt;<span class="number">61</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">modmul</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> l1 = (<span class="type">uint32_t</span>)a, h1 = a&gt;&gt;<span class="number">32</span>, l2 = (<span class="type">uint32_t</span>)b, h2 = b&gt;&gt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">uint64_t</span> l = l1*l2, m = l1*h2 + l2*h1, h = h1*h2;</span><br><span class="line">    <span class="type">uint64_t</span> ret = (l&amp;mod) + (l&gt;&gt;<span class="number">61</span>) + (h &lt;&lt; <span class="number">3</span>) + (m &gt;&gt; <span class="number">29</span>) + (m &lt;&lt; <span class="number">35</span> &gt;&gt; <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    ret = (ret &amp; mod) + (ret&gt;&gt;<span class="number">61</span>);</span><br><span class="line">    ret = (ret &amp; mod) + (ret&gt;&gt;<span class="number">61</span>);</span><br><span class="line">    <span class="keyword">return</span> ret<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A smaller factor can be gained by using unsigned types and <span class="math inline">\(p=4\cdot 10^9 + 7\)</span>.</p><p>Note that <span class="math inline">\(p=2^{64}\)</span>(overflow of unsigned long long) is not prime and can be hacked regardless of randomization (see below).</p><h3>Extension to multiple comparisons</h3><p>Usually, rolling hashes are used in more than a single comparison. If we rely on m comparison and the probability that a single comparison fails is <span class="math inline">\(p\)</span> then the probability that any of the fail is at most <span class="math inline">\(m\cdot p\)</span> by a union bound. Note that when <span class="math inline">\(m = 10^5\)</span>, we need at least two or three hashes for this to be small.</p><p>One has to be quite careful when estimating the number comparison we need to succeed. If we sort the hashes or put them into a set, we need to have pair-wise distinct hashes, so for <span class="math inline">\(n\)</span> string a total of <span class="math inline">\(\binom{n} {2}\)</span> comparisons have to succeed. If <span class="math inline">\(n = 3\cdot 10^5\)</span>, <span class="math inline">\(m 4.5\cdot 10^9\)</span>, so we need three or four hashes (or only two if we use <span class="math inline">\(p = 2^{61} - 1\)</span>).</p><h3>Extension to strings of different length</h3><p>If we deal with strings of different length, we can avoid comparing them by storing the length along the hash. This is not necessarily however, if we assume that <strong>no character hashes to</strong> <span class="math inline">\(0\)</span>. In that case, we can simple imagine we prepend the shorter strings with null-bytes to get strings of equal length without changing the hash values. Then the theory above applies just fine. (If some character (i.e. <code>a</code>) hashes to <span class="math inline">\(0\)</span>, we might produce strings that look the same but aren’t the same in the prepending process (i.e. <code>a</code> and <code>aa</code>).)</p><h2>Computing anti-hash tests</h2><p>This section cover some technique that take advantage of common mistakes in rolling hash implementations and can mainly be used for hacking other solutions. Here’s a table with a short summary of the methods.</p><table><thead><tr class="header"><th style="text-align: center;"><strong>Name</strong></th><th style="text-align: center;"><strong>Use case</strong></th><th style="text-align: center;"><strong>Run time</strong></th><th style="text-align: center;"><strong>String lenth</strong></th><th style="text-align: center;"><strong>Notes</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Thue-Morse</td><td style="text-align: center;">Hash with overflow</td><td style="text-align: center;"><span class="math inline">\(O(1)\)</span></td><td style="text-align: center;"><span class="math inline">\(2^{10}\)</span></td><td style="text-align: center;">Works for all bases simultaneously.</td></tr><tr class="even"><td style="text-align: center;">Birthday</td><td style="text-align: center;">Small modulo</td><td style="text-align: center;"><span class="math inline">\(O(\sqrt{p}\log p)\)</span></td><td style="text-align: center;">$\approx 2 \log_{</td><td style="text-align: center;">\sum</td></tr><tr class="odd"><td style="text-align: center;">Tree</td><td style="text-align: center;">Large modulo</td><td style="text-align: center;"><span class="math inline">\(O(2^{\sqrt{p\lg p} } )\)</span></td><td style="text-align: center;"><span class="math inline">\(O(2^{\sqrt{p\lg p}}+1)\)</span></td><td style="text-align: center;">faster; longer strings</td></tr><tr class="even"><td style="text-align: center;">Multi-tree</td><td style="text-align: center;">Large modulo</td><td style="text-align: center;">$O((2^{\sqrt{2\lg m p} }+\log_{</td><td style="text-align: center;">\sum</td><td style="text-align: center;">}m)\cdot m\log m)$</td></tr><tr class="odd"><td style="text-align: center;">Lattice reduction</td><td style="text-align: center;">Medium-large alphabet, Multiple hashes</td><td style="text-align: center;"><span class="math inline">\(O(length^3)\)</span></td><td style="text-align: center;">$\approx \sum<span data-i="0">_</span>^{n-1}\log_{</td><td style="text-align: center;">\sum</td></tr><tr class="even"><td style="text-align: center;">Composition</td><td style="text-align: center;">Multiple hashes</td><td style="text-align: center;">Sum of single runtimes</td><td style="text-align: center;">Product of single string lengths</td><td style="text-align: center;">Combines two attacks.</td></tr></tbody></table><h3>Single hashes</h3><h4>Thue–Morse sequence: Hashing with unsigned overflow (<span class="math inline">\(p = 2^{64}\)</span>, <span class="math inline">\(q\)</span> arbitrary)</h4><p>One anti-hash test that works for any base is the Thue–Morse sequence, generated by the following code.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Q = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1</span> &lt;&lt; Q;</span><br><span class="line"><span class="function">std::string <span class="title">S</span><span class="params">(N, <span class="string">&#x27; &#x27;</span>)</span>, <span class="title">T</span><span class="params">(N, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    S[i] = <span class="string">&#x27;A&#x27;</span> + __builtin_popcount(i) % <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    T[i] = <span class="string">&#x27;B&#x27;</span> - __builtin_popcount(i) % <span class="number">2</span>; </span><br></pre></td></tr></table></figure><p><span class="math inline">\(S\)</span>, <span class="math inline">\(T\)</span> form an equal-length collision, regardless of the chosen base.</p><p>See this <a href="https://codeforces.com/blog/entry/4898">blog</a> for a detailed discussion. Note that the bound on the linked blog can be improved slightly, as <span class="math inline">\(X^2 - 1\)</span> is always divisible by <span class="math inline">\(8\)</span> for odd <span class="math inline">\(X\)</span>. (So we can use <span class="math inline">\(Q = 10\)</span> instead of <span class="math inline">\(Q = 11\)</span>.)</p><h4>Birthday-attack: Hashing with 32-bit prime and fixed base (<span class="math inline">\(p &lt; 2^{32}\)</span> fixed, <span class="math inline">\(q\)</span> fixed)</h4><p>Hashes with a single small prime can be attacked via the birthday paradox. Fix a length <span class="math inline">\(l\)</span> and the size of alphabet <span class="math inline">\(d\)</span>, and pick <span class="math inline">\(k\)</span> strings of length <span class="math inline">\(l\)</span> uniformly at random. If <span class="math inline">\(l\)</span> is not to small, the resulting hash values will approximately be uniformly distributed. By the birthday paradox, the probability that all of our picked strings hash to different values is:</p><p><span class="math display">\[\sum_{i=0}^{k-1}(1-\frac{i} {d} ) &lt; \sum_{i=0}^{k-1}(e^{-\frac{i} {d} } ) =e^{-\frac{k(k-1)} {2d} } &lt; e^{-\ln 2} = \frac{1} {2}\]</span></p><p>Hence with probability <span class="math inline">\(&gt; \frac{1} {2}\)</span> we found two strings hashing to the same value. By repeating this, we can find an equal-length collision with high probability in <span class="math inline">\(O(\sqrt{p} )\)</span>. In practice, the resulting strings can be quite small (<span class="math inline">\(length  \approx  6\)</span> and <span class="math inline">\(d=62\)</span> for <span class="math inline">\(p = 10^9 + 7\)</span>, not sure how to upper-bound this.).</p><p>More generally, we can compute <span class="math inline">\(m\)</span> strings with equal hash value in <span class="math inline">\(O(m\cdot p^{1-\frac{1} {m} } )\)</span> using the same technique with <span class="math inline">\(r = m \cdot p^{1-\frac{1} {m} }\)</span>.</p><h4>Tree-attack: Hashing with larger prime and fixed base (<span class="math inline">\(p\)</span> fixed, <span class="math inline">\(q\)</span> fixed)</h4><blockquote><p>Thanks <a href="https://codeforces.com/profile/Kaban-5"><font color="red">Kaban-5</font></a> and <a href="https://codeforces.com/profile/pavel.savchenkov"><font color="red">pavel.savchenkov</font></a> for the <a href="https://codeforces.com/blog/entry/17507?locale=ru#comment-223614">link</a> to some Russian comments describing this idea.</p></blockquote><p>For large primes, the birthday-attack is to slow. Recall that for two strings <span class="math inline">\((S, T)\)</span> of equal length:</p><p><span class="math display">\[h(S)=h(T)\]</span></p><p><span class="math display">\[\sum_{i=0}^{n-1}a^{n-i-1}(S_i-T_i) \equiv 0 \pmod{p}\]</span></p><p>we set <span class="math inline">\(\alpha_i = S_i - T_i\)</span> satisfies <span class="math inline">\(-|\sum| \le \alpha_i \le |\sum|\)</span>.The tree-attack tries to find <span class="math inline">\(\alpha_i \in\{-1,0,1\}\)</span> such that:</p><p><span class="math display">\[\sum_{i=0}^{n-1} (a_{n-i-1} \mod p) \cdot \alpha_i = 0\]</span></p><p>The attack maintains clusters <span class="math inline">\(C_1, ..., C_k\)</span> of coefficients. The <strong>sum</strong> <span class="math inline">\(S(C)\)</span> of a cluster <span class="math inline">\(C\)</span> is given by:</p><p><span class="math display">\[S(C) = \sum_{i\in C} (a_{n-i-1} \mod p) \cdot \alpha_i\]</span></p><p>We can merge two clusters <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> to a cluster <span class="math inline">\(C_3\)</span> of sum <span class="math inline">\(S(C_1) - S(C_2)\)</span> by multiplying all the <span class="math inline">\(\alpha_i\)</span> from <span class="math inline">\(C_2\)</span> with $ - 1$ and joining the set of coefficients of <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span>. This operation can be implemented in constant time by storing the clusters as binary trees where each node stores its sum; the merge operation then adds a new node for <span class="math inline">\(C_3\)</span> with children <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> and sum <span class="math inline">\(S(C_1) - S(C_2)\)</span>. To ensure that the <span class="math inline">\(S(C_3) \ge 0\)</span>, swap <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> if necessary. The values of the <span class="math inline">\(\alpha_i\)</span> are not explicitly stored, but they can be recomputed in the end by traversing the tree.</p><p>Initially, we start with <span class="math inline">\(n = 2k\)</span> and each <span class="math inline">\(\alpha_i=1\)</span> in its own cluster. In a phase, we first sort the clusters by their sum and then merge adjacent pairs of clusters. If we encounter a cluster of sum <span class="math inline">\(0\)</span> at any point, we finish by setting all <span class="math inline">\(\alpha_j\)</span> not in that cluster to <span class="math inline">\(0\)</span>. If we haven’t finished after <span class="math inline">\(k\)</span> phases, try again with a bigger value of <span class="math inline">\(k\)</span>.</p><p>For which values of <span class="math inline">\(k\)</span> can we expect this to work? If we assume that the sums are initially uniformly distributed in <span class="math inline">\([0,p-1]\)</span>, the maximum sum should decrease by a factor <span class="math inline">\(\sim 2^{k-i}\)</span> in phase <span class="math inline">\(i\)</span>. After <span class="math inline">\(k\)</span> phases, the maximum sum is around <span class="math inline">\(\frac{p} {2^{\binom{k} {2} } }\)</span>, so <span class="math inline">\(k\approx \sqrt{2\lg p}+1\)</span> works. This produces strings of length <span class="math inline">\(n=2^{\sqrt{2\lg p}+1}\)</span> in <span class="math inline">\(O(n)\)</span> time. (A more formal analysis can be found in the paper ‘<a href="ftp://ftp.inf.ethz.ch/pub/crypto/publications/FlaPrz05.pdf">Solving Medium-Density Subset Sum Problems in Expected Polynomial Time</a>’, section 2.2. The problem and algorithms in the paper are slightly different, but the approach similar.)</p><h5>Multi-tree-attack</h5><p>While the tree-attacks runs really fast, the resulting strings can get a little long. (<span class="math inline">\(n = 2048\)</span> for <span class="math inline">\(p = 2^{61} - 1\)</span>.) We can spend more runtime to search for a shorter collision by storing the smallest m sums we can get in each cluster. (The single-tree-attack just uses <span class="math inline">\(m = 1\)</span>.) Merging two clusters can be done in <span class="math inline">\(O(m\log m)\)</span> with a min-heap and a <span class="math inline">\(2m\)</span>-pointer walk. In order to get to m strings ASAP, we allow all values <span class="math inline">\(\alpha_i\in[-|\sum|,|\sum|]\)</span> and exclude the trivial case where all <span class="math inline">\(\alpha_i\)</span> are zero.</p><p>Analysing the expected value of <span class="math inline">\(k\)</span> for this to work is quite difficult. Under the optimistic assumption that we reach m sums per node after <span class="math inline">\(\log_{\left |\sum \right |} m\)</span> steps, that the sums decrease as in the single tree attack and that we can expected a collision when they get smaller than <span class="math inline">\(m^2\)</span> by the birthday-paradox, we get <span class="math inline">\(k = \sqrt{2\frac{\lg p} {\lg m} }+\log_{|\sum|} m\)</span>. (A more realistic bound would be <span class="math inline">\(k=\frac{\lg p} {\lg m}+log_{|\sum|}m\)</span>, which might be gotten by accounting for the birthday-paradox in the bound proven in the paper ‘<a href="https://www.semanticscholar.org/paper/On-Random-High-Density-Subset-Sums-Lyubashevsky/08d901a94599ab95b1138f0ee68c5d0cda31bd68?p2df">On Random High Density Subset Sums</a>’, Theorem 3.1.)</p><p>In practice, we can use <span class="math inline">\(m \approx 10^5\)</span> to find a collision of length <span class="math inline">\(128\)</span> for <span class="math inline">\(|\sum|=2\)</span>, <span class="math inline">\(p = 2^{61} - 1\)</span> in around 0.4 seconds.</p><h4>Lattice-reduction attack: Single or multiple hashes over not-to-small alphabet</h4><blockquote><p>Thanks to <a href="https://codeforces.com/profile/hellman_"><font color="orange">hellman_</font></a> for mentioning this, check out his write-up on this topic here. There’s also a write-up by someone else <a href="https://galhacktictrendsetters.wordpress.com/2017/09/05/tokyo-westerns-ctf-2017-palindromes-pairs-challenge-phase/">here</a>.</p></blockquote><p>As in the tree attack, we’re looking for <span class="math inline">\(\alpha_i\in[-|\sum|,|\sum|]\)</span> such that:</p><p><span class="math display">\[\sum_{i=0}^{n-1} (a_{n-i-1} \mod p) \cdot \alpha_i = 0\]</span></p><p>The set:</p><p><span class="math display">\[{\alpha_0,\cdots,a_{n-1},\beta} | \beta \equiv \sum_{i=0}^{n-1} (a_{n-i-1} \mod p)\cdot \alpha_i\]</span></p><p>forms a lattice (A free <span class="math inline">\(\mathbb{Z}\)</span>-module embedded in a subspace of <span class="math inline">\(\mathbb{R}^n\)</span>.) We’re looking for an element in the lattice such that <span class="math inline">\(\beta = 0\)</span> and <span class="math inline">\(|\alpha_i| \le |\sum|\)</span>. We can penalize non-zero values of <span class="math inline">\(\beta\)</span> by considering:</p><p><span class="math display">\[\beta = 10^5((\sum_{i=0}^{n-1} (a_{n-i-1} \mod p)\cdot \alpha_i)) \mod p\]</span></p><p>instead, then we seek to minimize <span class="math inline">\(\max\{|\alpha_0|,\cdots,|a_{n-1}|,|\beta|\}\)</span>. Unfortunately, this optimization problem is quite hard, so we try to minimize:</p><p><span class="math display">\[\alpha_0^2 + \cdots + \alpha_{n-1}^2 + \beta^2\]</span></p><p>instead. The resulting problem is still hard, possibly NP-complete, but there are some good approximation algorithms available.</p><p>Similar to a vector space, we can define a basis in a lattice. For our case, a basis is given by:</p><p><span class="math display">\[\{e_\beta+10^5(a_{n-i-1} \mod p)e_{a_i} | 0\le i &lt; n\} \cup \{p\cdot 10^5e_\beta\}\]</span></p><p>A lattice reduction algorithm takes this basis and transforms it (by invertible matrices with determinant <span class="math inline">\(\pm\)</span>) into another basis with approximately shortest vectors. Implementing them is quite hard (and suffers from precision errors or bignum slowdown), so I decided to use the builtin implementation in sage.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Anti-rolling-hash test generation by lattice reduction</span></span><br><span class="line"><span class="string">original code by Hellman_, modified by dacin21</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">anti_hash</span>(<span class="params">PAs, string_length, sigma, block_size = <span class="number">0</span>, MULTIPLIER = <span class="number">100000</span>, sigma_base = <span class="built_in">ord</span>(<span class="params"><span class="string">&#x27;a&#x27;</span></span>)</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(PAs)</span><br><span class="line">    N = string_length</span><br><span class="line">    As = [a <span class="keyword">for</span> p, a <span class="keyword">in</span> PAs]</span><br><span class="line">    Ps = [p <span class="keyword">for</span> p, a <span class="keyword">in</span> PAs]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;polynomial hash modulo &lt;n&gt; primes&quot;&quot;&quot;</span></span><br><span class="line">        v = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            v = [(x * q + <span class="built_in">ord</span>(c))%p <span class="keyword">for</span> x, q, p <span class="keyword">in</span> <span class="built_in">zip</span>(v, As, Ps)]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tuple</span>(v % p <span class="keyword">for</span> v, p <span class="keyword">in</span> <span class="built_in">zip</span>(v, Ps))</span><br><span class="line"></span><br><span class="line">    mv = matrix(ZZ, N, N)</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> xrange(N):</span><br><span class="line">        <span class="keyword">for</span> x, q, p <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(n), As, Ps):</span><br><span class="line">            mv[y,x] = <span class="built_in">pow</span>(q, N-y-<span class="number">1</span>, p);</span><br><span class="line"></span><br><span class="line">    m = matrix(ZZ, N + n, N + n)</span><br><span class="line">    <span class="comment"># submatrix with terms</span></span><br><span class="line">    m.set_block(<span class="number">0</span>, <span class="number">0</span>, MULTIPLIER * mv)</span><br><span class="line">    <span class="comment"># modulo reductions</span></span><br><span class="line">    m.set_block(N, <span class="number">0</span>, MULTIPLIER * diagonal_matrix(Ps))</span><br><span class="line">    <span class="comment"># term coefficients</span></span><br><span class="line">    m.set_block(<span class="number">0</span>, n, identity_matrix(N))</span><br><span class="line">    <span class="comment"># 4th submatrix is zero</span></span><br><span class="line"></span><br><span class="line">    m_reduced = m.LLL()</span><br><span class="line">    <span class="keyword">if</span> block_size &gt; <span class="number">0</span>:</span><br><span class="line">        m_reduced = m_reduced.BKZ(block_size = block_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> m_reduced:</span><br><span class="line">        <span class="built_in">print</span> row[:n], <span class="built_in">min</span>(row[n:]), <span class="string">&quot;~&quot;</span>, <span class="built_in">max</span>(row[n:])</span><br><span class="line">        delta = <span class="built_in">max</span>(<span class="built_in">abs</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> row[n:])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">set</span>(row[:n]) == &#123;<span class="number">0</span>&#125; <span class="keyword">and</span> delta &lt; sigma:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;Found collision!&quot;</span></span><br><span class="line">            s = [<span class="literal">None</span>] * N</span><br><span class="line">            t = [<span class="literal">None</span>] * N</span><br><span class="line">            <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(row[n:]):</span><br><span class="line">                a = sigma_base</span><br><span class="line">                b = a + <span class="built_in">abs</span>(v)</span><br><span class="line">                <span class="keyword">if</span> v &gt; <span class="number">0</span>:</span><br><span class="line">                    a, b = b, a</span><br><span class="line">                s[i] = a</span><br><span class="line">                t[i] = b</span><br><span class="line">            s = <span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, s))</span><br><span class="line">            t = <span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, t))</span><br><span class="line">            <span class="built_in">print</span> s + <span class="string">&quot; &quot;</span> + t</span><br><span class="line">            <span class="comment"># print h(s)</span></span><br><span class="line">            <span class="comment"># print h(t)</span></span><br><span class="line">            <span class="keyword">assert</span> h(s) == h(t)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;Failed to find collision, try a larger string_length&quot;</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;For lengths &gt; 30, setting block_size to 10 or 15 is recommended&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;hash.in&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> infile:</span><br><span class="line">        n, k, sigma = <span class="built_in">map</span>(<span class="built_in">int</span>, infile.readline().strip().split())</span><br><span class="line">        PAs = [<span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, infile.readline().strip().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        anti_hash(PAs, k, sigma)</span><br></pre></td></tr></table></figure><p>Input is taken from a file named <code>hash.in</code> in the format. To use the BKZ algorithm, set the <code>block_size</code> argument.</p><p>Input format:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n length sigma</span><br><span class="line">p_1 a_1</span><br><span class="line">...</span><br><span class="line">p_n a_n</span><br></pre></td></tr></table></figure><p>Sage offers two algorithms: LLL and BKZ, the former is faster but produces worse approximations, especially for longer strings. Analyzing them is difficult, so I experimented a bit by fixing <span class="math inline">\(|\sum|=26\)</span>, <span class="math inline">\(p = 2^{61} - 1\)</span> and fixing <span class="math inline">\(a_1,\cdots ,a_n\)</span> randomly and searching for a short anti-hash test with both algorithms. The results turned out really well.</p><p>LLL algorithm:</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n\)</span></th><th style="text-align: center;">minimal length</th><th style="text-align: center;">time spent (seconds)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">12</td><td style="text-align: center;">0.02</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">23</td><td style="text-align: center;">0.04</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">34</td><td style="text-align: center;">0.08</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">48</td><td style="text-align: center;">0.18</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">60</td><td style="text-align: center;">0.34</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">77</td><td style="text-align: center;">0.75</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">301</td><td style="text-align: center;">5.14</td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: center;"><span class="math inline">\(&gt; 1500\)</span></td><td style="text-align: center;"><span class="math inline">\(&gt; 990\)</span></td></tr></tbody></table><p>for <span class="math inline">\(n = 8\)</span> the algorithm couldn’t find a collision of length <span class="math inline">\(\le 1500\)</span>.</p><p>BKZ algorithm with <code>block_size = 10</code>:</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n\)</span></th><th style="text-align: center;">minimal length</th><th style="text-align: center;">time spent (seconds)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">12</td><td style="text-align: center;">0.02</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">23</td><td style="text-align: center;">0.04</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">33</td><td style="text-align: center;">0.09</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">45</td><td style="text-align: center;">0.21</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">57</td><td style="text-align: center;">0.58</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">72</td><td style="text-align: center;">1.12</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">88</td><td style="text-align: center;">2.59</td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: center;">108</td><td style="text-align: center;">5.33</td></tr></tbody></table><p>BKZ algorithm with <code>block_size = 15</code>:</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n\)</span></th><th style="text-align: center;">minimal length</th><th style="text-align: center;">time spent (seconds)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">12</td><td style="text-align: center;">0.02</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">23</td><td style="text-align: center;">0.04</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">33</td><td style="text-align: center;">0.09</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">45</td><td style="text-align: center;">0.21</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">57</td><td style="text-align: center;">0.52</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">70</td><td style="text-align: center;">1.24</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">85</td><td style="text-align: center;">2.41</td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: center;">102</td><td style="text-align: center;">5.20</td></tr></tbody></table><p>BKZ algorithm with <code>block_size = 25</code>:</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n\)</span></th><th style="text-align: center;">minimal length</th><th style="text-align: center;">time spent (seconds)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">12</td><td style="text-align: center;">0.02</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">23</td><td style="text-align: center;">0.04</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">33</td><td style="text-align: center;">0.10</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">46</td><td style="text-align: center;">0.58</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">57</td><td style="text-align: center;">1.14</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">70</td><td style="text-align: center;">3.67</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">84</td><td style="text-align: center;">6.96</td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: center;">96</td><td style="text-align: center;">26.70</td></tr></tbody></table><p>Note that this attack does not work well for small (i.e binary) alphabets when <span class="math inline">\(n &gt; 1\)</span> and that the characters have to <strong>hash to consecutive</strong> values, so this has to be the first attack if used in a composition attack.</p><h3>Composition-attack: Multiple hashes</h3><blockquote><p>Credit for this part goes to <a href="https://codeforces.com/profile/ifsmirnov"><font color="red">ifsmirnov</font></a>, I found this technique in his <a href="https://github.com/ifsmirnov/jngen">jngen</a> library.</p></blockquote><p>Using two or more hashes is usually sufficient to protect from a direct birthday-attack. For two primes, there are <span class="math inline">\(N = p_1·p_2\)</span> possible hash values. The birthday-attack runs in <span class="math inline">\(O(\sqrt{N})\)</span>, which is <span class="math inline">\(\approx 10^{10}\)</span> for primes around <span class="math inline">\(10^9\)</span>. Moreover, the memory usage is more than <span class="math inline">\(\sqrt{ (2 \ln 2)N}\cdot 8\)</span> bytes (If you only store the hashes and the rng-seed), which is around 9.5 GB.</p><p>The key idea used to break multiple hashes is to break them one-by-one.</p><ul><li>First find an equal-length collision (by birthday-attack) for the first hash <span class="math inline">\(h_1\)</span>, i.e. two strings <span class="math inline">\(S, T, S \neq T\)</span> of equal length with <span class="math inline">\(h_1(S) = h_1(T)\)</span>. Note that strings of equal length built over the alphabet <span class="math inline">\(S, T\)</span> (i.e. by concatenation of some copies of <span class="math inline">\(S\)</span> with some copies of <span class="math inline">\(T\)</span> and vice-versa) will now hash to the same value under <span class="math inline">\(h_1\)</span>.</li><li>Then use <span class="math inline">\(S\)</span> and <span class="math inline">\(T\)</span> as the alphabet when searching for an equal-length collision (by birthday-attack again) for the second hash <span class="math inline">\(h_2\)</span>. The result will automatically be a collision for <span class="math inline">\(h_1\)</span> as well, as we used <span class="math inline">\(S, T\)</span> as the alphabet.</li></ul><p>This reduces the runtime <span class="math inline">\(O(\sqrt{p_1}+\sqrt{p_2} )\)</span> . Note that this also works for combinations of a 30-bit prime hash and a hash mod <span class="math inline">\(2^{64}\)</span> if we use the Thue–Morse sequence in place of the second birthday attack. Similarly, we can use tree- instead of birthday-attacks for larger modulos.</p><p>Another thing to note is that string length grows rapidly in the number of hashes. (Around <span class="math inline">\(2\log_{|\sum|}(\sqrt{ (2\ln 2)p_1} )\cdot\log_2 (\sqrt{ (2\ln 2)p_2} )\cdots \log_2(\sqrt{ (2\ln 2)p_k} )\)</span>, the alphabet size is reduced to <span class="math inline">\(2\)</span> after the first birthday-attack. The first iteration has a factor of <span class="math inline">\(2\)</span> in practice.) If we search for more than 2 strings with equal hash value in the intermediate steps, the alphabet size will be bigger, leading to shorter strings, but the runtime of the birthday-attacks gets slower (<span class="math inline">\(O(p^{\frac{2} {3} } )\)</span> for <span class="math inline">\(3\)</span> strings, for example.).</p><h2>Abusing bad randomization</h2><p>On codeforces, quite a lot of people randomize their hashes. (Un-)Fortunately, many of them do it an a suboptimal way. This section covers some of the ways people screw up their hash randomizations and ways to hack their code.</p><p>This section applies more generally to any type of randomized algorithm in an environment where other participants can hack your solutions.</p><h3>Fixed seed</h3><p>If the seed of the rng is fixed, it always produces the same sequence of random numbers. You can just run the code to see which numbers get randomly generated and then find an anti-hash test for those numbers.</p><h3>Picking from a small pool of bases(<code>rand()%100</code>)</h3><p>Note that <code>rand() % 100</code> produced at most 100 distinct values <span class="math inline">\([0,99]\)</span>. We can just find a separate anti-hash test for every one of them and then combine the tests into a single one. (The way your combine tests is problem-specific, but it works for most of the problems.)</p><h3>More issues with <code>rand()</code></h3><p>On codeforces, <code>rand()</code> produces only <span class="math inline">\(15\)</span>-bit values, so at most <span class="math inline">\(2^{15}\)</span> different values. While it may take a while to run <span class="math inline">\(2^{15}\)</span> birthday-attacks (estimated <span class="math inline">\(111\)</span> minutes for <span class="math inline">\(p = 10^9 + 7\)</span> using a single thread on my laptop), this can cause some big issues with some other randomized algorithms.</p><p>Edit: This type of hack might be feasible if we use multi-tree-attacks. For $ p =10^9+7,|\sum|=26$, running <span class="math inline">\(2^{15}\)</span> multi-tree attacks with <span class="math inline">\(m = 10^4\)</span> takes around <span class="math inline">\(2\)</span> minutes and produces an output of <span class="math inline">\(5.2\cdot 10^5\)</span> characters. This is still slightly to large for most problems, but could be split up into multiple hacks in an open hacking phase, for example.</p><p>In C++11 you can use <code>mt19937</code> and <code>uniform_int_distribution</code> instead of <code>rand()</code>.</p><h3>Low-precision time(<code>Time(NULL)</code>)</h3><p><code>Time(NULL)</code> only changes once per second. This can be exploited as follows</p><ol type="1"><li>Pick a timespan <span class="math inline">\(\Delta T\)</span>.</li><li>Find an upper bound <span class="math inline">\(T\)</span> for the time you’ll need to generate your tests.</li><li>Figure out the current value <span class="math inline">\(T_0\)</span> of <code>Time(NULL)</code> via custom invocation.</li><li>For <span class="math inline">\(t = 0,\cdots,(\Delta T) - 1\)</span>, replace <code>Time(NULL)</code> with <span class="math inline">\(T_0 + T + t\)</span> and generate an anti-test for this fixed seed.</li><li>Submit the hack at time <span class="math inline">\(T_0 + T\)</span>.</li></ol><p>If your hack gets executed within the next <span class="math inline">\(\Delta T\)</span> seconds, <code>Time(NULL)</code> will be a value for which you generated an anti-test, so the solution will fail.</p><h3>Random device on MinGW(<code>std::random_device</code>)</h3><p>Note that on codeforces specifically, <code>std::random_device</code> is deterministic and will produce the same sequence of numbers. Solutions using it can be hacked just like fixed seed solutions.</p><blockquote><p>本文选取自 <a href="https://codeforces.com/blog/entry/60442">Anti-rolling-hash test generation by lattice reduction</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于滚动 Hash 和反 Hash 测试背后的数学原理</title>
      <link href="/posts/951dcf71/"/>
      <url>/posts/951dcf71/</url>
      
        <content type="html"><![CDATA[<p>本博客假设读者熟悉滚动 Hash 的基本概念。有些部分涉及大量数学知识，但无需了解每个细节即可掌握大部分概念。</p><p>本博客主要关注如何选择滚动 Hash 参数以避免被 Hack ，以及如何选择不当的参数 Hack hash。</p><h2>设计难以破解的滚动 Hash</h2><h3>回顾滚动 Hash 和 Hash 碰撞</h3><p>回想一下，滚动 Hash 有两个参数 <span class="math inline">\((p,a)\)</span>，其中 <span class="math inline">\(p\)</span> 是模数，<span class="math inline">\(0\le a &lt; p\)</span> 是基数。 （我们将看到 <span class="math inline">\(p\)</span> 应该是一个大素数，并且 <span class="math inline">\(a\)</span> 应该大于字母表的大小。）</p><p>字符串 <span class="math inline">\(S=s_0\cdots s_{n-1}\)</span> 的 Hash 值由以下公式给出：</p><p><span class="math display">\[h(S) = (\sum^{n-1}_{i=0} a^{n-i-1} s_i) \mod P\]</span></p><p>现在，让我们考虑一个简单的问题：给定两个长度相等的字符串 <span class="math inline">\(S,T\)</span>，通过比较它们的 Hash 值 <span class="math inline">\(h(S), h(T)\)</span> 来判断它们是否相等。如果 <span class="math inline">\(h(S) = h(T)\)</span>，我们的算法将 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(T\)</span> 声明为相等。大多数滚动 Hash 解决方案都是基于对此子问题的多次调用或依赖于此类调用的正确性。</p><p>让我们将两个长度相等的字符串 <span class="math inline">\(S, T\)</span> 称为 <strong>等长碰撞</strong>（或 <strong>等长冲突</strong>），其中 <span class="math inline">\(S \neq T\)</span> 和 <span class="math inline">\(h(S) = h(T)\)</span>。我们希望避免 <strong>等长冲突</strong>，因为它们会导致我们的算法错误地将 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(T\)</span> 评估为相等。（请注意，我们的算法绝不会错误地将字符串评估为不同的。）对于固定参数和相当小的长度，字符串的数量远多于可能的 Hash 值，因此总是存在 <strong>等长冲突</strong>。因此，您可能会认为，对于任何滚动 Hash ，都有一些 Hack 导致 <strong>等长冲突</strong>。</p><p>幸运的是，随机化可以拯救我们。我们的算法不必固定 <span class="math inline">\((p, a)\)</span>，它可以根据某种方案随机选择。如果我们可以证明对于任意两个字符串 <span class="math inline">\(S, T\)</span>，<span class="math inline">\(S\neq T\)</span>，该方案会以高概率选择 <span class="math inline">\((p, a)\)</span>，使得 <span class="math inline">\(h(S) \neq h(T)\)</span>，则该方案是可靠的。请注意，概率空间仅包括方案内部的随机选择；输入 <span class="math inline">\((S, T)\)</span> 是任意的、固定的，不一定是随机的。 （如果您认为输入来自 Hack ，那么这意味着无论输入是什么，我们的解决方案都不会以高概率失败。）</p><p>我将向您展示两个可靠的方案。（请注意，方案可靠并不意味着您的实现很好。必须小心使用随机数生成器。）</p><h3>随机化基础</h3><blockquote><p>本部分基于 <a href="https://codeforces.com/profile/rng_58"><font color = "red">rng_58</font></a> 的 <a href="https://rng-58.blogspot.com/2017/02/hashing-and-probability-of-collision.html">博客</a>。他的帖子涵盖了更一般的 Hash 问题，值得一看。</p></blockquote><p>该方案使用 <span class="math inline">\(a\)</span> 个固定的 <strong>素数</strong> <span class="math inline">\(p\)</span>（即 <span class="math inline">\(10^9 + 7\)</span> 或 <span class="math inline">\(4\cdot 10^9 + 7\)</span>）并从 <span class="math inline">\([0,p-1]\)</span> 中均匀随机地选取 <span class="math inline">\(a\)</span>。令 <span class="math inline">\(A\)</span> 为选择 <span class="math inline">\(a\)</span> 的随机变量。</p><p>为了证明该方案是好的，考虑两个长度相等的字符串 <span class="math inline">\((S, T)\)</span> 并进行一些计算：</p><p><span class="math display">\[\begin{aligned}h(S)&amp;=h(T)\\(\sum_{i=0}^{n-1} A^{n-i-1} S_i) \mod p &amp; = (\sum_{i=0}^{n-1} A^{n-i-1} T_i) \mod p\end{aligned}\]</span></p><p>因此，我们有：</p><p><span class="math display">\[\sum_{i=0}^{n-1} A^{n-i-1} S_i \equiv \sum_{i=0}^{n-1} A^{n-i-1} T_i \pmod p\\\]</span></p><p>我们让 <span class="math inline">\(P(A)\)</span> 表示 <span class="math inline">\(A\)</span> 中次数为 <span class="math inline">\(\le n-1\)</span> 的多项式:</p><p><span class="math display">\[P(A) = \sum_{i=0}^{n-1} A^{n-i-1}(S_i-T_i) \equiv 0 \pmod p\]</span></p><p>当 <span class="math inline">\(S \neq T\)</span> 时，<span class="math inline">\(P\)</span> 非零。计算表明，当且仅当 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(P(A)\)</span> 的根时，<span class="math inline">\(h(S) = h(T)\)</span>。</p><p>由于 <span class="math inline">\(p\)</span> 是素数，并且我们正在进行 <span class="math inline">\(\mod p\)</span> 计算，因此我们正在一个域中工作。在一个域上，任何次数为 <span class="math inline">\(\le n - 1\)</span> 的多项式最多有 <span class="math inline">\(n-1\)</span> 个根。因此，最多有 <span class="math inline">\(n - 1\)</span> 个 a 选项导致 <span class="math inline">\(h(S) = h(T)\)</span>。因此：</p><p><span class="math display">\[Pr[h(S)=h(T)]=Pr[P(A)=0] \le \frac{n-1}{p}\]</span></p><p>因此，对于任何两个长度相等的字符串 <span class="math inline">\((S, T)\)</span>，它们形成等长碰撞的概率最多为 <span class="math inline">\(\frac{n-1}{p}\)</span>。对于 <span class="math inline">\(n = 10^5, p = 10^9 + 7\)</span>，这个概率大约是 <span class="math inline">\(10^{-4}\)</span>。选择较大的素数，例如 <span class="math inline">\(2^{31} - 1\)</span> 或 <span class="math inline">\(4\cdot 10^9 + 7\)</span> 可以稍微改善这一点，但需要更加注意溢出。</p><h3>边界的紧密性</h3><p>目前，这部分仅适用于具有平滑 <span class="math inline">\(p - 1\)</span> 的素数，因此它不适用于例如 <span class="math inline">\(p = 10^9 + 7\)</span>。找到一种可计算且在一般情况下有效的构造将会很有趣。</p><p>如果 <span class="math inline">\(n-1|p-1\)</span>，则此方案的边界 <span class="math inline">\(\frac{p-1}{p}\)</span> 实际上是紧的。考虑 <span class="math inline">\(S=ba...a\)</span> 和 <span class="math inline">\(T=aa...b\)</span>，其中 <span class="math inline">\(P(A)=A^{n-1}-1\)</span>。</p><p>由于 <span class="math inline">\(p\)</span> 为素数，<span class="math inline">\(\frac{\mathbb{Z}}{p\mathbb{Z}}\)</span> 是阶为 <span class="math inline">\(p - 1\)</span> 的循环群，因此存在阶为 <span class="math inline">\(n - 1\)</span> 的子群 <span class="math inline">\(G \subseteq \frac{\mathbb{Z}}{p\mathbb{Z}}\)</span>。任何 <span class="math inline">\(g\subseteq G\)</span> 都满足 <span class="math inline">\(g^{n - 1} = 1\)</span>，因此 <span class="math inline">\(P(A)\)</span> 有 <span class="math inline">\(n - 1\)</span> 个不同的根。</p><h3>随机化模数</h3><p>该方案固定基数 <span class="math inline">\(a \le |\sum|\)</span> 和边界 <span class="math inline">\(N &gt; a\)</span>，并从 <span class="math inline">\([N, 2N - 1]\)</span> 中均匀随机地选取一个 <strong>素数</strong> p。</p><p>为了证明该方案是好的，再次，考虑两个长度相等的字符串<span class="math inline">\((S, T)\)</span>并进行一些计算：</p><p><span class="math display">\[\begin{aligned}h(S)&amp;=h(T)\\(\sum_{i=0}^{n-1} a^{n-i-1} S_i) \mod p &amp; = (\sum_{i=0}^{n-1} a^{n-i-1} T_i) \mod p\end{aligned}\]</span></p><p>因此，我们有：</p><p><span class="math display">\[\sum_{i=0}^{n-1} a^{n-i-1} S_i \equiv \sum_{i=0}^{n-1} a^{n-i-1} T_i \pmod p\\\]</span></p><p>所以：</p><p><span class="math display">\[X = \sum_{i=0}^{n-1}a^{n-i-1}(S_i-T_i) \equiv 0 \pmod p\]</span></p><p>当 <span class="math inline">\(X \equiv 0 \pmod p,p|X\)</span> 时，我们选择一个足够大的值，<span class="math inline">\(X \neq 0\)</span>。此外，<span class="math inline">\(|X| &lt; a^n\)</span>。<span class="math inline">\([N, 2N - 1]\)</span> 中 <span class="math inline">\(X\)</span> 的不同素因数的数量上限由 <span class="math inline">\(\log_N (|X|) = \frac{n\ln (a)}{\ln N}\)</span> 给出。根据素数密度定理，<span class="math inline">\([N, 2N - 1]\)</span> 中大约有 <span class="math inline">\(\frac{X}{\ln{N}}\)</span> 个素数。因此：</p><p><span class="math display">\[Pr[h(S)=h(T)] = Pr[p|X] \le \sim \frac{n\ln(a)}{N}\]</span></p><p>请注意，此界限比随机化基数的界限稍差。当 <span class="math inline">\(n = 10^5、a = 26、N = 10^9\)</span> 时，该界限约为 <span class="math inline">\(3\cdot 10{-4}\)</span>。</p><h3>如何正确随机化</h3><p>以下是初始化随机数生成器的好方法。</p><ul><li><p>高精度时间。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrono::<span class="built_in">duration_cast</span>&lt;chrono::nanoseconds&gt;      (chrono::high_resolution_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">chrono::<span class="built_in">duration_cast</span>&lt;chrono::nanoseconds&gt;(chrono::steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br></pre></td></tr></table></figure><blockquote><p>两者之一都可以。（理论上，<code>high_resolution_clock</code> 应该更好，但它在 codeforces 上的精度却低于 <code>steady_clock</code>？？）</p></blockquote></li><li><p>处理器周期计数器</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_ia32_rdtsc();</span><br></pre></td></tr></table></figure></li><li><p>一些堆地址转换为整数</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">uintptr_t</span>) <span class="built_in">make_unique</span>&lt;<span class="type">char</span>&gt;().<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure></li><li><p>处理器随机性（需要 pragma 或 asm）（感谢 <a href="https://codeforces.com/profile/halyavin"><font color = "red">halyavin</font></a> <a href="https://codeforces.com/blog/entry/60442?#comment-443083">建议</a> 此。）</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pragma 版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC target (<span class="string">&quot;rdrnd&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">rdrand32</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> ret;</span><br><span class="line">    <span class="built_in">assert</span>(__builtin_ia32_rdrand32_step (&amp;ret));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// asm 版本</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">rd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> ret;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;rdrand %0&quot;</span> :<span class="string">&quot;=a&quot;</span>(ret) ::<span class="string">&quot;cc&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>如果您使用 C++11 样式的 rng（您应该使用），则可以使用上述组合：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seed_seq seq&#123;</span><br><span class="line">    (<span class="type">uint64_t</span>) chrono::<span class="built_in">duration_cast</span>&lt;chrono::nanoseconds&gt;(chrono::high_resolution_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>(),</span><br><span class="line">    (<span class="type">uint64_t</span>) __builtin_ia32_rdtsc(),</span><br><span class="line">    (<span class="type">uint64_t</span>) (<span class="type">uintptr_t</span>) <span class="built_in">make_unique</span>&lt;<span class="type">char</span>&gt;().<span class="built_in">get</span>()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">mt19937 <span class="title">rng</span><span class="params">(seq)</span></span>;</span><br><span class="line"><span class="type">int</span> base = <span class="built_in">uniform_int_distribution</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, p<span class="number">-1</span>)(rng);</span><br></pre></td></tr></table></figure><p>请注意，这确实会在内部丢弃参数中的高 32 位，但这实际上并不重要，因为低位更难预测（尤其是在第一种情况下使用 chrono）。</p><p><strong>请参阅“滥用不良随机化”部分，了解一些不良示例。</strong></p><h3>扩展到多个 Hash</h3><p>我们可以使用多个 Hash （即使使用相同的方案和相同的固定参数），并且只要随机样本是独立的， Hash 就是独立的。如果单个 Hash 失败的概率最多为 <span class="math inline">\(a_1,\cdots, a_k\)</span>，则所有 Hash 失败的概率最多为 <span class="math inline">\(\prod_{i=1}^k a_i\)</span>。</p><p>例如，如果我们使用两个 Hash ，其中 <span class="math inline">\(p = 10^9 + 7\)</span> 和随机化基数，则发生碰撞的概率最多为 <span class="math inline">\(10^{ - 8}\)</span>；对于四个 Hash ，它最多为 <span class="math inline">\(10 ^{- 16}\)</span>。这里，稍大素数的常数更为重要，对于 <span class="math inline">\(p = 2^{31} - 1\)</span>，概率约为 <span class="math inline">\(2.1\cdot 10^{ - 9}\)</span> 和 <span class="math inline">\(4.7\cdot 10^{ - 18}\)</span>。</p><h3>更大的模数</h3><p>使用更大的（即 60 位）素数将使碰撞的可能性更小，并且不会受到错误界限内 <span class="math inline">\(n\)</span> 累积因子的影响。但是，滚动 Hash 的计算变得更慢、更困难，因为 codeforces 上没有 <code>__int128</code>。</p><p>一个例外是梅森素数 <span class="math inline">\(p = 2^{61} - 1\)</span>；我们可以改用位移位来减少 <span class="math inline">\(\mod p\)</span>。 （感谢 <a href="https://codeforces.com/profile/dmkz"><font color = "blue">dmkz</font></a> 提出此建议。）以下代码不使用 <code>__int128</code> 计算 <span class="math inline">\(a\cdot b \mod p\)</span>，仅比使用模数的 <span class="math inline">\(30\)</span> 位 Hash 慢约 <span class="math inline">\(5\%\)</span>。</p><p>对于参数，条件 <span class="math inline">\(0\le a,b &lt; mod\)</span> 应该成立。然后返回值也满足此条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">uint64_t</span> mod = (<span class="number">1ull</span>&lt;&lt;<span class="number">61</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">modmul</span><span class="params">(<span class="type">uint64_t</span> a, <span class="type">uint64_t</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> l1 = (<span class="type">uint32_t</span>)a, h1 = a&gt;&gt;<span class="number">32</span>, l2 = (<span class="type">uint32_t</span>)b, h2 = b&gt;&gt;<span class="number">32</span>;</span><br><span class="line">    <span class="type">uint64_t</span> l = l1*l2, m = l1*h2 + l2*h1, h = h1*h2;</span><br><span class="line">    <span class="type">uint64_t</span> ret = (l&amp;mod) + (l&gt;&gt;<span class="number">61</span>) + (h &lt;&lt; <span class="number">3</span>) + (m &gt;&gt; <span class="number">29</span>) + (m &lt;&lt; <span class="number">35</span> &gt;&gt; <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    ret = (ret &amp; mod) + (ret&gt;&gt;<span class="number">61</span>);</span><br><span class="line">    ret = (ret &amp; mod) + (ret&gt;&gt;<span class="number">61</span>);</span><br><span class="line">    <span class="keyword">return</span> ret<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用无符号类型和 <span class="math inline">\(p=4\cdot 10^9 + 7\)</span> 可以获得较小的因子。</p><p>请注意，<span class="math inline">\(p=2^{64}\)</span>（unsigned long long 溢出）不是素数，无论随机化如何都可以被破解（见下文）。</p><h3>扩展到多个比较</h3><p>通常，滚动 Hash 值用于多个比较。如果我们仅基于 <span class="math inline">\(m\)</span> 次比较，并且一次比较失败的概率为 <span class="math inline">\(p\)</span>，则任何一次失败的概率最多为 <span class="math inline">\(m\cdot p\)</span>（根据联合界限）。请注意，当 <span class="math inline">\(m = 10^5\)</span> 时，我们至少需要两个或三个 Hash 才能使这个概率很小。</p><p>在估计成功所需的比较次数时，必须非常小心。如果我们对 Hash 进行排序或将它们放入一个集合中，我们需要有成对不同的 Hash ，因此对于 <span class="math inline">\(n\)</span> 个字符串，总共需要 <span class="math inline">\(\binom{n}{2}\)</span> 次比较成功。如果 <span class="math inline">\(n = 3\cdot 10^5\)</span>，<span class="math inline">\(m=4.5\cdot 10^9\)</span>，所以我们需要三个或四个 Hash （如果我们使用 <span class="math inline">\(p = 2^{61} - 1\)</span>，则只需要两个）。</p><h3>扩展到不同长度的字符串</h3><p>如果我们处理不同长度的字符串，我们可以通过在 Hash 中存储长度来避免比较它们。但是，如果我们假设 <strong>没有字符 Hash 为</strong> <span class="math inline">\(0\)</span>，则情况并非如此。在这种情况下，我们可以简单地想象我们在较短的字符串前面添加空字节以获得相同长度的字符串而不改变 Hash 值。那么上面的理论就适用了。（如果某个字符（即 <code>a</code>） Hash 为 <span class="math inline">\(0\)</span>，我们可能会生成看起来相同但在添加过程中并不相同的字符串（即 <code>a</code> 和 <code>aa</code>）。）</p><h2>计算反 Hash 测试</h2><p>本节介绍一些利用滚动 Hash 实现中常见错误的技术，主要用于破解其他解决方案。这里有一个表格，其中简要总结了这些方法。</p><table><thead><tr class="header"><th style="text-align: center;"><strong>名称</strong></th><th style="text-align: center;"><strong>用例</strong></th><th style="text-align: center;"><strong>运行时间</strong></th><th style="text-align: center;"><strong>字符串长度</strong></th><th style="text-align: center;"><strong>注释</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Thue-Morse 序列</td><td style="text-align: center;">带溢出的 Hash</td><td style="text-align: center;"><span class="math inline">\(O(1)\)</span></td><td style="text-align: center;"><span class="math inline">\(2^{10}\)</span></td><td style="text-align: center;">可同时适用于所有基数。</td></tr><tr class="even"><td style="text-align: center;">生日攻击</td><td style="text-align: center;">小模数</td><td style="text-align: center;"><span class="math inline">\(O(\sqrt{p}\log p)\)</span></td><td style="text-align: center;"><span class="math inline">\(\approx 2\log_{ \begin{vmatrix}\sum\end{vmatrix} }p\)</span></td><td style="text-align: center;">可以找到多个碰撞。</td></tr><tr class="odd"><td style="text-align: center;">树攻击</td><td style="text-align: center;">大模数</td><td style="text-align: center;"><span class="math inline">\(O(2^{\sqrt{p\lg p}})\)</span></td><td style="text-align: center;"><span class="math inline">\(O(2^{\sqrt{p\lg p}}+1)\)</span></td><td style="text-align: center;">更快；更长的字符串</td></tr><tr class="even"><td style="text-align: center;">多树攻击</td><td style="text-align: center;">大模数</td><td style="text-align: center;"><span class="math inline">\(O((2^{\sqrt{2\lg m p}}+\log_{ \begin{vmatrix}\sum\end{vmatrix}  } m)\cdot m\log m)\)</span></td><td style="text-align: center;"><span class="math inline">\(\approx O((2^{\sqrt{2\lg m p}}+\log_{        \begin{vmatrix}\sum\end{vmatrix} }m))\)</span></td><td style="text-align: center;">更慢；更短的字符串</td></tr><tr class="odd"><td style="text-align: center;">格子缩减</td><td style="text-align: center;">中大型字母表，多重 Hash</td><td style="text-align: center;"><span class="math inline">\(O(length^3)\)</span></td><td style="text-align: center;"><span class="math inline">\(\approx \sum_{i=0}^{n-1} \log_{ \begin{vmatrix} \sum \end{vmatrix}} (p_n)\)</span></td><td style="text-align: center;">对于 <span class="math inline">\(\begin{vmatrix}\sum\end{vmatrix} =26\)</span> 的结果很好，对多重 Hash 很有效。对二进制字母表很差。</td></tr><tr class="even"><td style="text-align: center;">组合</td><td style="text-align: center;">多重 Hash</td><td style="text-align: center;">单个运行时间的总和</td><td style="text-align: center;">单个字符串长度的乘积</td><td style="text-align: center;">结合了两种攻击。</td></tr></tbody></table><h3>单个 Hash</h3><h4>Thue–Morse 序列：带有无符号溢出的 Hash （<span class="math inline">\(p = 2^{64}\)</span>，<span class="math inline">\(q\)</span> 任意）</h4><p>一种适用于任何基数的反 Hash 测试是 Thue–Morse 序列，由以下代码生成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Q = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1</span> &lt;&lt; Q;</span><br><span class="line"><span class="function">std::string <span class="title">S</span><span class="params">(N, <span class="string">&#x27; &#x27;</span>)</span>, <span class="title">T</span><span class="params">(N, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    S[i] = <span class="string">&#x27;A&#x27;</span> + __builtin_popcount(i) % <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    T[i] = <span class="string">&#x27;B&#x27;</span> - __builtin_popcount(i) % <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>无论选择哪个基数，<span class="math inline">\(S\)</span>、<span class="math inline">\(T\)</span> 都会形成等长碰撞。</p><p>有关详细讨论，请参阅此 <a href="https://codeforces.com/blog/entry/4898">博客</a>。请注意，链接博客上的界限可以略微改进，因为对于奇数 <span class="math inline">\(X\)</span>，<span class="math inline">\(X^2 - 1\)</span> 总是可以被 <span class="math inline">\(8\)</span> 整除。 （因此我们可以使用 <span class="math inline">\(Q = 10\)</span> 而不是 <span class="math inline">\(Q = 11\)</span>。）</p><h4>生日攻击：使用 32 位素数和固定基数的 Hash （<span class="math inline">\(p &lt; 2^{32}\)</span> 固定，<span class="math inline">\(q\)</span> 固定）</h4><p>具有单个小素数的 Hash 可以通过生日悖论进行攻击。固定长度 <span class="math inline">\(l\)</span> 和字母表 <span class="math inline">\(d\)</span> 的大小，并随机均匀地选择长度为 <span class="math inline">\(l\)</span> 的 <span class="math inline">\(k\)</span> 个字符串。如果 <span class="math inline">\(l\)</span> 不太小，则生成的 Hash 值将大致均匀分布。根据生日悖论，我们挑选的所有字符串 Hash 值都不同的概率是：</p><p><span class="math display">\[\sum_{i=0}^{k-1}(1-\frac{i}{d}) &lt; \sum_{i=0}^{k-1}(e^{-\frac{i}{d}}) =e^{-\frac{k(k-1)}{2d}} &lt; e^{-\ln 2} = \frac{1}{2}\]</span></p><p>因此，概率为 <span class="math inline">\(&gt; \frac{1}{2}\)</span>，我们发现两个字符串有 Hash 到相同的值。通过重复此操作，我们可以在 <span class="math inline">\(O(\sqrt{p})\)</span> 中找到具有高概率的等长碰撞。实际上，生成的字符串可能非常小（对于 <span class="math inline">\(p = 10^9 + 7\)</span>，长度 $\approx 6 $ 和 <span class="math inline">\(d=62\)</span>，不确定如何限制其上限。）。</p><p>更一般地，我们可以使用与 <span class="math inline">\(r = m \cdot p^{1-\frac{1}{m}}\)</span> 相同的技术在 <span class="math inline">\(O(m\cdot p^{1-\frac{1}{m}})\)</span> 中计算具有相等 Hash 值的 <span class="math inline">\(m\)</span> 个字符串。</p><h4>树攻击：使用较大素数和固定基数（<span class="math inline">\(p\)</span> 固定，<span class="math inline">\(q\)</span> 固定）进行 Hash 运算</h4><blockquote><p>感谢 <a href="https://codeforces.com/profile/Kaban-5"><font color="red">Kaban-5</font></a> 和 <a href="https://codeforces.com/profile/pavel.savchenkov"><font color="red">pavel.savchenkov</font></a> 提供的 <a href="https://codeforces.com/blog/entry/17507?locale=ru#comment-223614">链接</a> 一些描述此想法的俄罗斯评论。</p></blockquote><p>对于较大的素数，生日攻击速度太慢。回想一下，对于两个长度相等的字符串 <span class="math inline">\((S, T)\)</span>：</p><p><span class="math display">\[h(S)=h(T)\]</span></p><p><span class="math display">\[\sum_{i=0}^{n-1}a^{n-i-1}(S_i-T_i) \equiv 0 \pmod{p}\]</span></p><p>我们设置 <span class="math inline">\(\alpha_i = S_i - T_i\)</span> 满足 <span class="math inline">\(-|\sum| \le \alpha_i \le |\sum|\)</span>。树攻击试图找到 <span class="math inline">\(\alpha_i \in\{-1,0,1\}\)</span> 使得：</p><p><span class="math display">\[\sum_{i=0}^{n-1} (a_{n-i-1} \mod p) \cdot \alpha_i = 0\]</span></p><p>攻击维护系数簇 <span class="math inline">\(C_1, ..., C_k\)</span>。集群 <span class="math inline">\(C\)</span> 的<strong>总和</strong> <span class="math inline">\(S(C)\)</span> 由以下公式给出：</p><p><span class="math display">\[S(C) = \sum_{i\in C} (a_{n-i-1} \mod p) \cdot \alpha_i\]</span></p><p>我们可以将两个集群 <span class="math inline">\(C_1\)</span> 和 <span class="math inline">\(C_2\)</span> 合并为总和为 <span class="math inline">\(S(C_1) - S(C_2)\)</span> 的集群 <span class="math inline">\(C_3\)</span>，方法是将 <span class="math inline">\(C_2\)</span> 中的所有 <span class="math inline">\(\alpha_i\)</span> 乘以 $ - 1$，并将 <span class="math inline">\(C_1\)</span> 和 <span class="math inline">\(C_2\)</span> 的系数集合并。此操作可以在恒定时间内实现，方法是将集群存储为二叉树，其中每个节点存储其总和；然后，合并操作为 <span class="math inline">\(C_3\)</span> 添加一个新节点，该节点具有子节点 <span class="math inline">\(C_1\)</span> 和 <span class="math inline">\(C_2\)</span>，总和为 <span class="math inline">\(S(C_1) - S(C_2)\)</span>。为了确保 <span class="math inline">\(S(C_3) \ge 0\)</span>，必要时交换 <span class="math inline">\(C_1\)</span> 和 <span class="math inline">\(C_2\)</span>。<span class="math inline">\(\alpha_i\)</span> 的值未明确存储，但可以通过遍历树在最后重新计算。</p><p>最初，我们从 <span class="math inline">\(n = 2k\)</span> 开始，每个 <span class="math inline">\(\alpha_i=1\)</span> 都在自己的集群中。在一个阶段中，我们首先按总和对集群进行排序，然后合并相邻的集群对。如果我们在任何时候遇到总和为 <span class="math inline">\(0\)</span> 的集群，我们将通过将不在该集群中的所有 <span class="math inline">\(\alpha_j\)</span> 设置为 <span class="math inline">\(0\)</span> 来完成。如果我们在 <span class="math inline">\(k\)</span> 个阶段后仍未完成，请使用更大的 <span class="math inline">\(k\)</span> 值重试。</p><p>对于哪些 <span class="math inline">\(k\)</span> 值，我们可以期望这有效？如果我们假设总和最初在 <span class="math inline">\([0,p-1]\)</span> 中均匀分布，则在阶段 <span class="math inline">\(i\)</span> 中，最大总和应该减少因子 <span class="math inline">\(\sim 2^{k-i}\)</span>。经过 <span class="math inline">\(k\)</span> 个阶段后，最大和约为 <span class="math inline">\(\frac{p}{2^{\binom{k}{2}}}\)</span>，因此 <span class="math inline">\(k\approx \sqrt{2\lg p}+1\)</span> 有效。这会在 <span class="math inline">\(O(n)\)</span> 时间内生成长度为 <span class="math inline">\(n=2^{\sqrt{2\lg p}+1}\)</span> 的字符串。（可以在论文“<a href="ftp://ftp.inf.ethz.ch/pub/crypto/publications/FlaPrz05.pdf">在预期多项式时间内解决中密度子集和问题</a>”第 2.2 节中找到更正式的分析。论文中的问题和算法略有不同，但方法相似。）</p><h5>多树攻击</h5><p>虽然树攻击运行速度非常快，但生成的字符串可能会变得有点长。 (<span class="math inline">\(n = 2048\)</span>，<span class="math inline">\(p = 2^{61} - 1\)</span>。) 我们可以花费更多时间来搜索更短的碰撞，方法是存储每个集群中可以获得的最小 <span class="math inline">\(m\)</span> 个和。（单树攻击只使用 <span class="math inline">\(m = 1\)</span>。）合并两个集群可以在 <span class="math inline">\(O(m\log m)\)</span> 中完成，使用最小堆和 <span class="math inline">\(2m\)</span> 指针遍历。为了尽快获得 <span class="math inline">\(m\)</span> 个字符串，我们允许所有值 <span class="math inline">\(\alpha_i\in[-|\sum|,|\sum|]\)</span> 并排除所有 <span class="math inline">\(\alpha_i\)</span> 都为零的简单情况。</p><p>分析 <span class="math inline">\(k\)</span> 的预期值以使其发挥作用非常困难。乐观地假设我们在 <span class="math inline">\(\log_{|\sum|}m\)</span> 步之后每个节点达到 <span class="math inline">\(m\)</span> 个总和，并且总和会像单树攻击一样减少，而且根据生日悖论，当它们变得小于 <span class="math inline">\(m^2\)</span> 时我们可以预期会发生碰撞，我们得到 <span class="math inline">\(k = \sqrt{2\frac{\lg p}{\lg m}}+\log_{|\sum|} m\)</span>。 （更现实的界限是 <span class="math inline">\(k=\frac{\lg p}{\lg m}+log_{|\sum|}m\)</span>，这可以通过考虑论文“<a href="https://www.semanticscholar.org/paper/On-Random-High-Density-Subset-Sums-Lyubashevsky/08d901a94599ab95b1138f0ee68c5d0cda31bd68?p2df">关于随机高密度子集总和</a>”中证明的界限中的生日悖论来获得，定理 3.1。）</p><p>在实践中，我们可以使用 <span class="math inline">\(m \approx 10^5\)</span> 来找到长度为 <span class="math inline">\(128\)</span> 的碰撞，其中 <span class="math inline">\(|\sum|=2\)</span>，<span class="math inline">\(p = 2^{61} - 1\)</span> 大约需要 0.4 秒。</p><h4>格子缩减攻击：对不太小的字母表进行单个或多个 Hash</h4><blockquote><p>感谢 <a href="https://codeforces.com/profile/hellman_"><font color="orange">hellman_</font></a> 提及此内容，请在此处查看他关于此主题的文章。<a href="https://galhacktictrendsetters.wordpress.com/2017/09/05/tokyo-westerns-ctf-2017-palindromes-pairs-challenge-phase/">此处</a> 也有其他人的文章。</p></blockquote><p>与树攻击一样，我们正在寻找 <span class="math inline">\(\alpha_i\in[-|\sum|,|\sum|]\)</span>，使得：</p><p><span class="math display">\[\sum_{i=0}^{n-1} (a_{n-i-1} \mod p) \cdot \alpha_i = 0\]</span></p><p>换成集合形式：</p><p><span class="math display">\[{\alpha_0,\cdots,a_{n-1},\beta} | \beta \equiv \sum_{i=0}^{n-1} (a_{n-i-1} \mod p)\cdot \alpha_i\]</span></p><p>形成一个格（嵌入在 <span class="math inline">\(\mathbb{R}^n\)</span> 子空间中的自由 <span class="math inline">\(\mathbb{Z}\)</span> 模块。）我们在格中寻找一个元素，使得 <span class="math inline">\(\beta = 0\)</span> 且 <span class="math inline">\(|\alpha_i| \le |\sum|\)</span>。我们可以通过考虑以下因素来惩罚 <span class="math inline">\(\beta\)</span> 的非零值：</p><p><span class="math display">\[\beta = 10^5((\sum_{i=0}^{n-1} (a_{n-i-1} \mod p)\cdot \alpha_i)) \mod p\]</span></p><p>然后我们寻求最小化 <span class="math inline">\(\max\{|\alpha_0|,\cdots,|a_{n-1}|,|\beta|\}\)</span>。不幸的是，这个优化问题相当困难，所以我们尝试最小化：</p><p><span class="math display">\[\alpha_0^2 + \cdots + \alpha_{n-1}^2 + \beta^2\]</span></p><p>结果问题仍然很难，可能是 NP 完全的，但有一些很好的近似算法可用。</p><p>与向量空间类似，我们可以在格中定义一个基。对于我们的情况，基础由以下公式给出：</p><p><span class="math display">\[\{e_\beta+10^5(a_{n-i-1} \mod p)e_{a_i} | 0\le i &lt; n\} \cup \{p\cdot 10^5e_\beta\}\]</span></p><p>格简化算法采用此基础并将其（通过具有行列式 <span class="math inline">\(\pm\)</span> 的可逆矩阵）转换为具有近似最短向量的另一个基础。实现它们非常困难（并且会受到精度错误或大数减速的影响），因此我决定使用 sage 中的内置实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;通过格子归约生成反滚动 Hash 测试</span></span><br><span class="line"><span class="string">原始代码由 Hellman_ 编写，由 dacin21 修改</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">anti_hash</span>(<span class="params">PAs, string_length, sigma, block_size = <span class="number">0</span>, MULTIPLIER = <span class="number">100000</span>, sigma_base = <span class="built_in">ord</span>(<span class="params"><span class="string">&#x27;a&#x27;</span></span>)</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(PAs)</span><br><span class="line">    N = string_length</span><br><span class="line">    As = [a <span class="keyword">for</span> p, a <span class="keyword">in</span> PAs]</span><br><span class="line">    Ps = [p <span class="keyword">for</span> p, a <span class="keyword">in</span> PAs]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;多项式 Hash 模数 &lt;n&gt; 素数&quot;&quot;&quot;</span></span><br><span class="line">        v = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        v = [(x * q + <span class="built_in">ord</span>(c))%p <span class="keyword">for</span> x, q, p <span class="keyword">in</span> <span class="built_in">zip</span>(v, As, Ps)]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tuple</span>(v % p <span class="keyword">for</span> v, p <span class="keyword">in</span> <span class="built_in">zip</span>(v, Ps))</span><br><span class="line"></span><br><span class="line">    mv = matrix (ZZ, N, N)</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> xrange(N) ：</span><br><span class="line">    <span class="keyword">for</span> x, q, p <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(n), As, Ps) 中：</span><br><span class="line">    mv[y,x] = <span class="built_in">pow</span>(q, N-y-<span class="number">1</span>, p);</span><br><span class="line"></span><br><span class="line">    m = matrix(ZZ, N + n, N + n)</span><br><span class="line">    <span class="comment"># 带项的子矩阵</span></span><br><span class="line">    m.set_block(<span class="number">0</span>, <span class="number">0</span>, MULTIPLIER * mv)</span><br><span class="line">    <span class="comment"># 模数减少</span></span><br><span class="line">    m.set_block(N, <span class="number">0</span>, MULTIPLIER * diagonal_matrix(Ps))</span><br><span class="line">    <span class="comment"># 项系数</span></span><br><span class="line">    m.set_block(<span class="number">0</span>, n, Identity_matrix(N))</span><br><span class="line">    <span class="comment"># 第 4 个子矩阵为零</span></span><br><span class="line"></span><br><span class="line">    m_reduced = m.LLL()</span><br><span class="line">    <span class="keyword">if</span> block_size &gt; <span class="number">0</span>:</span><br><span class="line">    m_reduced = m_reduced.BKZ(block_size = block_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> m_reduced:</span><br><span class="line">        <span class="built_in">print</span> row[:n], <span class="built_in">min</span>(row[n:]), <span class="string">&quot;~&quot;</span>, <span class="built_in">max</span>(row[n:])</span><br><span class="line">        delta = <span class="built_in">max</span>(<span class="built_in">abs</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> row[n:])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">set</span>(row[:n]) == &#123;<span class="number">0</span>&#125; <span class="keyword">and</span> delta &lt; sigma:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;发现碰撞！&quot;</span></span><br><span class="line">            s = [<span class="literal">None</span>] * N</span><br><span class="line">            t = [<span class="literal">None</span>] * N</span><br><span class="line">            <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(row[n:]):</span><br><span class="line">            a = sigma_base</span><br><span class="line">            b = a + <span class="built_in">abs</span>(v)</span><br><span class="line">            <span class="keyword">if</span> v &gt; <span class="number">0</span>:</span><br><span class="line">                a, b = b, a</span><br><span class="line">            s[i] = a</span><br><span class="line">            t[i] = b</span><br><span class="line">        s = <span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, s))</span><br><span class="line">        t = <span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, t))</span><br><span class="line">        <span class="built_in">print</span> s + <span class="string">&quot; &quot;</span> + t</span><br><span class="line">        <span class="comment"># print h(s)</span></span><br><span class="line">        <span class="comment"># print h(t)</span></span><br><span class="line">        <span class="keyword">assert</span> h(s) == h(t)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;无法找到碰撞，请尝试更大的 string_length&quot;</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;对于长度 &gt; 30，建议将 block_size 设置为 10 或 15&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;hash.in&quot;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> infile:</span><br><span class="line">        n, k, sigma = <span class="built_in">map</span>(<span class="built_in">int</span>, infile.readline().strip().split())</span><br><span class="line">        PAs = [<span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, infile.readline().strip().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        anti_hash(PAs, k, sigma)</span><br></pre></td></tr></table></figure><p>输入取自格式为 <code>hash.in</code> 的文件。要使用 BKZ 算法，请设置 <code>block_size</code> 参数。</p><p>输入格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n lenth sigma</span><br><span class="line">p_1 a_1</span><br><span class="line">...</span><br><span class="line">p_n a_n</span><br></pre></td></tr></table></figure><p>Sage 提供两种算法：LLL 和 BKZ，前者速度更快，但近似值更差，尤其是对于较长的字符串。分析它们很困难，所以我做了一些实验，固定 <span class="math inline">\(|\sum|=26\)</span>、<span class="math inline">\(p = 2^{61} - 1\)</span> 并随机固定 <span class="math inline">\(a_1,\cdots ,a_n\)</span>，并使用这两种算法搜索简短的反 Hash 测试。结果非常好。</p><p>LLL 算法：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n\)</span></th><th style="text-align: center;">最小长度</th><th style="text-align: center;">花费的时间（秒）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">12</td><td style="text-align: center;">0.02</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">23</td><td style="text-align: center;">0.04</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">34</td><td style="text-align: center;">0.08</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">48</td><td style="text-align: center;">0.18</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">60</td><td style="text-align: center;">0.34</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">77</td><td style="text-align: center;">0.75</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">301</td><td style="text-align: center;">5.14</td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: center;"><span class="math inline">\(&gt;1500\)</span></td><td style="text-align: center;"><span class="math inline">\(&gt;990\)</span></td></tr></tbody></table><p>对于 <span class="math inline">\(n = 8\)</span>，算法无法找到长度为 <span class="math inline">\(\le 1500\)</span> 的碰撞。</p><p>BKZ 算法，其中 <code>block_size = 10</code>:</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n\)</span></th><th style="text-align: center;">最小长度</th><th style="text-align: center;">所用时间（秒）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">12</td><td style="text-align: center;">0.02</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">23</td><td style="text-align: center;">0.04</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">33</td><td style="text-align: center;">0.09</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">45</td><td style="text-align: center;">0.21</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">57</td><td style="text-align: center;">0.58</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">72</td><td style="text-align: center;">1.12</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">88</td><td style="text-align: center;">2.59</td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: center;">108</td><td style="text-align: center;">5.33</td></tr></tbody></table><p><code>block_size = 15</code> 的 BKZ 算法：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n\)</span></th><th style="text-align: center;">最小长度</th><th style="text-align: center;">所用时间（秒）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">12</td><td style="text-align: center;">0.02</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">23</td><td style="text-align: center;">0.04</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">33</td><td style="text-align: center;">0.09</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">45</td><td style="text-align: center;">0.21</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">57</td><td style="text-align: center;">0.52</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">70</td><td style="text-align: center;">1.24</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">85</td><td style="text-align: center;">2.41</td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: center;">102</td><td style="text-align: center;">5.20</td></tr></tbody></table><p><code>block_size = 25</code> 的 BKZ 算法：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(n\)</span></th><th style="text-align: center;">最小长度</th><th style="text-align: center;">所用时间（秒）</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">12</td><td style="text-align: center;">0.02</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">23</td><td style="text-align: center;">0.04</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">33</td><td style="text-align: center;">0.10</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">46</td><td style="text-align: center;">0.58</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">57</td><td style="text-align: center;">1.14</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">70</td><td style="text-align: center;">3.67</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">84</td><td style="text-align: center;">6.96</td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: center;">96</td><td style="text-align: center;">26.70</td></tr></tbody></table><p>请注意，当 <span class="math inline">\(n &gt; 1\)</span> 时，此攻击对小（即二进制）字母表效果不佳，并且字符必须<strong>散列为连续</strong>值，因此如果用于组合攻击，这必须是第一次攻击。</p><h3>组合攻击：多个 Hash</h3><blockquote><p>本部分归功于 <a href="https://codeforces.com/profile/ifsmirnov"><font color="red">ifsmirnov</font></a>，我在他的 <a href="https://github.com/ifsmirnov/jngen">jngen</a> 库中找到了这种技术。</p></blockquote><p>使用两个或更多 Hash 通常足以防止直接生日攻击。 对于两个素数，有 <span class="math inline">\(N = p_1·p_2\)</span> 个可能的 Hash 值。 生日攻击在 <span class="math inline">\(O(\sqrt{N})\)</span> 中运行，对于大约 <span class="math inline">\(10^9\)</span> 的素数，这大约是 <span class="math inline">\(\approx 10^{10}\)</span>。 此外，内存使用量超过 <span class="math inline">\(\sqrt{(2 \ln 2)N}\cdot 8\)</span> 字节（如果您只存储 Hash 和 rng 种子），大约是 9.5 GB。</p><p>破解多个 Hash 的关键思想是逐个破解它们。</p><ul><li>首先为第一个 Hash <span class="math inline">\(h_1\)</span> 找到一个等长碰撞（通过生日攻击），即两个长度相等的字符串 <span class="math inline">\(S, T, S \neq T\)</span>，其中 <span class="math inline">\(h_1(S) = h_1(T)\)</span>。请注意，在字母表 <span class="math inline">\(S, T\)</span> 上构建的等长字符串（即通过将 <span class="math inline">\(S\)</span> 的一些副本与 <span class="math inline">\(T\)</span> 的一些副本连接起来，反之亦然）现在将在 <span class="math inline">\(h_1\)</span> 下散列为相同的值。</li><li>然后在为第二个 Hash <span class="math inline">\(h_2\)</span> 搜索等长碰撞（再次通过生日攻击）时使用 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(T\)</span> 作为字母表。结果也将自动成为 <span class="math inline">\(h_1\)</span> 的碰撞，因为我们使用 <span class="math inline">\(S, T\)</span> 作为字母表。</li></ul><p>这减少了运行时间 <span class="math inline">\(O(\sqrt{p_1}+\sqrt{p_2})\)</span> 。请注意，如果我们使用 Thue-Morse 序列代替第二个生日攻击，这也适用于 30 位素数 Hash 和 Hash 模 <span class="math inline">\(2^{64}\)</span> 的组合。同样，对于更大的模数，我们可以使用树攻击而不是生日攻击。</p><p>另一件需要注意的事情是，字符串长度会随着 Hash 数的增加而迅速增长。 （大约 <span class="math inline">\(2\log_{|\sum|}(\sqrt{(2\ln 2)p_1})\cdot\log_2 (\sqrt{(2\ln 2)p_2})\cdots \log_2(\sqrt{(2\ln 2)p_k})\)</span>，在第一次生日攻击后，字母表大小减少到 <span class="math inline">\(2\)</span>。实际上，第一次迭代的倍数为 <span class="math inline">\(2\)</span>。）如果我们在中间步骤中搜索 2 个以上具有相同 Hash 值的字符串，字母表大小将更大，从而导致字符串更短，但生日攻击的运行时间会变慢（例如，对于 <span class="math inline">\(3\)</span> 个字符串，运行时间为 <span class="math inline">\(O(p^{\frac{2}{3}})\)</span>）。</p><h2>滥用不良随机化</h2><p>在 codeforces 上，很多人会随机化他们的 Hash 值。（不幸）的是，他们中的许多人都以次优的方式进行。本节介绍了人们搞砸 Hash 随机化的一些方法以及破解其代码的方法。</p><p>本节更广泛地适用于其他参与者可以破解您的解决方案的环境中任何类型的随机算法。</p><h3>固定种子</h3><p>如果 rng 的种子是固定的，它总是会产生相同的随机数序列。您只需运行代码即可查看哪些数字是随机生成的，然后找到这些数字的反 Hash 测试。</p><h3>从一小群基数中挑选（<code>rand()%100</code>）</h3><p>请注意，<code>rand() % 100</code> 最多产生 100 个不同的值 <span class="math inline">\([0,99]\)</span>。我们可以为每个值找到一个单独的反 Hash 测试，然后将这些测试合并为一个。 （您的组合测试方式是针对特定问题的，但它适用于大多数问题。）</p><h3><code>rand()</code> 的更多问题</h3><p>在 codeforces 上，<code>rand()</code> 仅产生 <span class="math inline">\(15\)</span> 位值，因此最多产生 <span class="math inline">\(2^{15}\)</span> 个不同的值。虽然运行 <span class="math inline">\(2^{15}\)</span> 个生日攻击可能需要一段时间（在我的笔记本电脑上使用单个线程估计 <span class="math inline">\(p = 10^9 + 7\)</span> 需要 <span class="math inline">\(111\)</span> 分钟），但这可能会导致其他一些随机算法出现一些大问题。</p><p>编辑：如果我们使用多树攻击，这种类型的 Hack 攻击可能是可行的。对于 $ p =10^9+7,|\sum|=26$，运行 <span class="math inline">\(2^{15}\)</span> 多树攻击，其中 <span class="math inline">\(m = 10^4\)</span> 需要大约 <span class="math inline">\(2\)</span> 分钟，并产生 <span class="math inline">\(5.2\cdot 10^5\)</span> 个字符的输出。对于大多数问题来说，这仍然有点太大，但例如，可以在开放 Hack 阶段分成多个 Hack 攻击。</p><p>在 C++11 中，您可以使用 <code>mt19937</code> 和 <code>uniform_int_distribution</code> 代替 <code>rand()</code>。</p><h3>低精度时间（<code>Time(NULL)</code>）</h3><p><code>Time(NULL)</code> 每秒仅更改一次。可以按以下方式利用它</p><ol type="1"><li>选择一个时间跨度 <span class="math inline">\(\Delta T\)</span>。</li><li>找到生成测试所需时间的上限 <span class="math inline">\(T\)</span>。</li><li>通过自定义调用找出 <code>Time(NULL)</code> 的当前值 <span class="math inline">\(T_0\)</span>。</li><li>对于 <span class="math inline">\(t = 0,\cdots,(\Delta T) - 1\)</span>，将 <code>Time(NULL)</code> 替换为 <span class="math inline">\(T_0 + T + t\)</span>，并针对此固定种子生成反测试。</li><li>在时间 <span class="math inline">\(T_0 + T\)</span> 提交 hack。</li></ol><p>如果您的 hack 在接下来的 <span class="math inline">\(\Delta T\)</span> 秒内执行，<code>Time(NULL)</code> 将是您为其生成反测试的值，因此解决方案将失败。</p><h3>MinGW 上的随机设备（<code>std::random_device</code>）</h3><p>请注意，在 codeforces 上，<code>std::random_device</code> 是确定性的，将产生相同的数字序列。使用它的解决方案可以像固定种子解决方案一样被破解。</p><blockquote><p>本文翻译自 <a href="https://codeforces.com/blog/entry/60442">On the mathematics behind rolling hashes and anti-hash tests</a></p><p>转载请注明原文出处</p><p>警告：本文部分使用了 AI 翻译，可能存在不准确或错误的地方。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>splay</title>
      <link href="/posts/79d6ca4/"/>
      <url>/posts/79d6ca4/</url>
      
        <content type="html"><![CDATA[<h2>前言</h2><p>总所周知，平衡树是一个喜闻乐见的算法，它种类多样，功能强大，应用广泛。</p><h2>介绍</h2><p>Splay 树（伸展树），是一种平衡二叉查找树，它通过 <strong>Splay/伸展操作</strong> 不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，能够在<strong>均摊</strong> <span class="math inline">\(O(\log N)\)</span> 时间内完成 <strong>插入</strong>，<strong>查找</strong> 和 <strong>删除</strong> 操作，并且保持平衡而不至于退化为链。</p><p>Splay 树由 Daniel Sleator 和 Robert Tarjan 于 1985 年发明。</p><p>Splay 树的 <strong>基本思想</strong> 是：每次操作都将某节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质。</p><h2>操作</h2><h3>记号规定</h3><ul><li><span class="math inline">\(rt\)</span>：根节点</li><li><span class="math inline">\(tot\)</span>：树的总节点数</li><li><span class="math inline">\(fa_i\)</span>：节点 <span class="math inline">\(i\)</span> 的父节点</li><li><span class="math inline">\(ch_{i,0}\)</span>：节点 <span class="math inline">\(i\)</span> 的左孩子</li><li><span class="math inline">\(ch_{i,1}\)</span>：节点 <span class="math inline">\(i\)</span> 的右孩子</li><li><span class="math inline">\(val_i\)</span>：节点 <span class="math inline">\(i\)</span> 的值</li><li><span class="math inline">\(cnt_i\)</span>：值 <span class="math inline">\(i\)</span> 出现的次数</li><li><span class="math inline">\(sz_i\)</span>：以节点 <span class="math inline">\(i\)</span> 为根的子树的权值个数（包括重复权值）</li></ul><h3>基本操作</h3><ul><li><code>pushup(x)</code> ：更新节点的 <span class="math inline">\(sz\)</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; sz[x] = sz[son[x][<span class="number">0</span>]] + sz[son[x][<span class="number">1</span>]] + cnt[x]; &#125;</span><br></pre></td></tr></table></figure><ul><li><code>getson(x)</code> ：判断 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(fa_x\)</span> 的左儿子还是右儿子</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getson</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x == son[fa[x]][<span class="number">1</span>]; &#125;</span><br></pre></td></tr></table></figure><ul><li><code>clear(x)</code> ：销毁节点 <span class="math inline">\(x\)</span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; son[x][<span class="number">0</span>] = son[x][<span class="number">1</span>] = fa[x] = val[x] = cnt[x] = sz[x] = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><h3>旋转</h3><p>还记得 Splay 的基本思想吗：</p><blockquote><p>每次操作都将某节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质。</p></blockquote><p>因此旋转操作的本质为将某个节点上升一个位置。</p><p>因为 Splay 树是一颗二叉查找树，所以旋转需要保证 <strong>Splay 树的中序遍历不变</strong>。</p><p>在 Splay 中，旋转分为两种：<strong>左旋</strong> 和 <strong>右旋</strong>。</p><p>这里我们以右旋为例，详细讲解：</p><p>现在有一个节点 <span class="math inline">\(x\)</span>，有他的父节点 <span class="math inline">\(fx\)</span> 和爷爷节点 <span class="math inline">\(gx\)</span>（<span class="math inline">\(fa_{fa_x}\)</span>）。</p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_1.png" /></p><ol type="1"><li><p>将 <span class="math inline">\(x\)</span> 的 <strong>右儿子</strong> 设为 <span class="math inline">\(fx\)</span> 的 <strong>左儿子</strong>，并将它的父亲设为 <span class="math inline">\(fx\)</span>。</p><p><code>son[fx][0]=son[x][1],fa[son[x][1]] = fx;</code></p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_2.png" /></p></li><li><p>将 <span class="math inline">\(fx\)</span> 设为 <span class="math inline">\(x\)</span> 的 <strong>右儿子</strong>，并将它的父亲设为 <span class="math inline">\(x\)</span>。</p><p><code>son[x][1]=fx,fa[fx]=x;</code></p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_3.png" /></p></li><li><p>将 <span class="math inline">\(x\)</span> 设为 <span class="math inline">\(gx\)</span> 的 <strong>左儿子</strong>，并将它的父亲设为 <span class="math inline">\(gx\)</span>。</p><p><code>son[gx][1]=x,fa[x]=gx;</code></p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_4.png" /></p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fx = fa[x], gx = fa[fx];</span><br><span class="line">        <span class="type">bool</span> ch = <span class="built_in">getson</span>(x);</span><br><span class="line">        son[fx][ch] = son[x][ch ^ <span class="number">1</span>], fa[son[x][ch ^ <span class="number">1</span>]] = fx;</span><br><span class="line">        son[gx][<span class="built_in">getson</span>(fx)] = x, fa[x] = gx;</span><br><span class="line">        son[x][ch ^ <span class="number">1</span>] = fx, fa[fx] = x;</span><br><span class="line">        <span class="built_in">pushup</span>(fx), <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3>Splay/伸展操作</h3><p>Splay/伸展操作是 Splay 树的核心操作，它通过旋转操作将某节点旋转到根节点，并将其上升到树的最高层，使得整棵树仍然满足二叉查找树的性质。</p><p>同时，Splay 操作规定：每访问一个节点 <span class="math inline">\(x\)</span> 后都要强制将其旋转到根节点。</p><p>Splay 操作大体可以分为三种，一共六种情况。</p><p>规定记号：</p><ul><li><span class="math inline">\(x\)</span>：待旋转节点</li><li><span class="math inline">\(fx\)</span>：<span class="math inline">\(x\)</span> 的父节点</li><li><span class="math inline">\(gx\)</span>：<span class="math inline">\(fx\)</span> 的父节点</li></ul><ol type="1"><li><p><strong>zig</strong>：当 <span class="math inline">\(fx\)</span> 为根节点时操作，直接将 <span class="math inline">\(x\)</span> 左旋/右旋到根节点。</p></li><li><p><strong>zig-zig</strong>：当 <span class="math inline">\(fx\)</span> 与 <span class="math inline">\(x\)</span> 都在同一侧子树时操作（即 <span class="math inline">\(x\)</span>、<span class="math inline">\(fx\)</span>、<span class="math inline">\(gx\)</span> 在同一条线上），先将 <span class="math inline">\(fx\)</span> 左旋/右旋，再将 <span class="math inline">\(x\)</span> 右旋/左旋。</p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_10.png" /></p><p>先将 <span class="math inline">\(fx\)</span> 右旋</p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_5.png" /></p><p>再将 <span class="math inline">\(x\)</span> 左旋</p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_6.png" /></p></li><li><p><strong>zig-zag</strong>：当 <span class="math inline">\(fx\)</span> 与 <span class="math inline">\(x\)</span> 都在不同侧子树时操作（即 <span class="math inline">\(x\)</span>、<span class="math inline">\(fx\)</span>、<span class="math inline">\(gx\)</span> 在不同一条线上），先将 <span class="math inline">\(x\)</span> 右旋/左旋，再将 <span class="math inline">\(x\)</span> 左旋/右旋。</p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_7.png" /></p><p>先将 <span class="math inline">\(x\)</span> 左旋</p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_8.png" /></p><p>再将 <span class="math inline">\(x\)</span> 右旋</p><p><img src="https://raw.githubusercontent.com/xglight/photo/main/splay_9.png" /></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> tree </tag>
            
            <tag> splay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024.8.7-A</title>
      <link href="/posts/d6b6b810/"/>
      <url>/posts/d6b6b810/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="6ba4e69f79950d0dcc50144e0d62233b5bcec1e49d6d61751c495ccea1d6193e">93024cf999deb8d8b2919f7e109263d40f481a0a71ac66fdd435bdcff203e83e0ee766dc43a8861a7ef5e2592c1b67d5344391ee3122465f0d95ad28e38e1f0a9d3f25cd3ced49205aa25b01c1eca0a44bf2483eb35f6989f1f9576113a43bb89a6e46c6f41e5400d9fb30cd676e2150bdbaee305c124c440f35332ad26e9c0c5198bf7f67e3fdad9252a13ade0a5b3e4a6bfde4a4ff1063de7df69f43dbf483b2304d22dbf362961a15c838ae49607fff30e14300b543c5a23486b9de4e10c3347ac603702ce7136b463b21e406ba6165d22f008ab353c5a7ac02bc758e8025d06c15df6c1e9ffcfca212abc916658c3c5647f0002b789ac46a71e16ec90690c16b24f4e576e3576a6aeb825bf4dbb16de67646eddb82030de9ee6b266b687c26763093880e8a0b86e67942a8892a8cd4932986c809d16d3c7bba7524a2b2d4246ea01bf9714b3f9165101eca2f403473df5fc9d4e9da07c7a9fd97428cf6f97eaf792b6e173bb5087be2441aca5c7f05c2dd7d2087dca0adb863a73b794f9d9574dc924a1f27b509d03758d2ba85610b8939ab360392ede29bb6ff58bcb9aa0b02926e2074ddf919fab5b87beeaecff7f377bdece927863d693cee935ac1f01c1f03566964c7224ec50a915d2cb3b9295d0ead22e2eaafe65c64bda6145cd508798a0427d0fe51503307684668e709ddb054f4306889b35703bacbf7b5c0d44b81c78a547b3c32180cd1a865c4a89c724aac9e13dcd5639d241b8b0e95f601265c3178728dfedbb1fe07cd1dda7138874613a080cfb2defa36e596c90680b666113844b87d7bfa88d5ad818eea027037efe7dd15d164320510e816065eacf9790fafeec83fef48c2f24a1a46238e4bdce8c2975a76da540d40b27f63b68daed3745e6d88d3f0a433ec16f9ddcfe51948ccdfadb69ae033799bb387169d3270873cb9be9d57c2c9dad37d22af5de026</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> school </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好文收集</title>
      <link href="/posts/516cc39d/"/>
      <url>/posts/516cc39d/</url>
      
        <content type="html"><![CDATA[<h2>介绍</h2><p>这里放了很多不错的文章。</p><h2>字符串</h2><ul><li><a href="https://codeforces.com/blog/entry/129538">A tool for hacking rolling hashes with fixed modulos and bases</a></li><li><a href="https://codeforces.com/blog/entry/60442">On the mathematics behind rolling hashes and anti-hash tests</a></li></ul><h2>图论</h2><ul><li><a href="https://www.cnblogs.com/cjjsb/p/9771868.html">2-SAT 超入门讲解</a></li></ul><h2>数学</h2><ul><li><a href="https://www.cnblogs.com/Hanghang007/p/18159136">组合数学和线性代数</a></li><li><a href="https://blog.cyx2009.top/archives/OLS/">正交拉丁方的构造与应用</a></li></ul><h2>文化课</h2><ul><li><a href="https://www.luogu.com.cn/article/ubd4ucn3">高中数学笔记</a></li></ul><h2>其他</h2><ul><li><a href="https://blog.anxy.top/posts/5.html">Alist 美化</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毒瘤题收集</title>
      <link href="/posts/244d3e22/"/>
      <url>/posts/244d3e22/</url>
      
        <content type="html"><![CDATA[<h2>前言</h2><p>也许是一个很不错的题单。</p><blockquote><p>在<a href="https://uoj.ac/problem/98">未来的程序·改</a>中，我们面临着诸多挑战，包括<a href="https://loj.ac/p/2288">大葱的神力</a>、<a href="Https://www.luogu.com.cn/problem/P8422">德州消消乐</a>、<a href="Https://www.luogu.com.cn/problem/P5645">斗地主</a>等游戏的<a href="https://www.luogu.com.cn/problem/P5370">主斗地</a>技能。与此同时，<a href="https://www.luogu.com.cn/problem/P7196">灭鼠行动</a>和<a href="https://www.luogu.com.cn/problem/P4911">河童重工的计算机</a>技术也在飞速发展。<a href="https://www.luogu.com.cn/problem/P7610">群星连结</a>让我们与<a href="https://www.luogu.com.cn/problem/P3695">CYaRon!语</a>一起探索宇宙的奥秘，而<a href="https://www.luogu.com.cn/problem/P3798">辉夜姬的十道难题</a>则考验着我们的智慧。在<a href="https://www.luogu.com.cn/problem/P2337">喵星人的入侵</a>中，我们像<a href="https://www.luogu.com.cn/problem/P5822">大航海时代</a>的探险家一样，勇敢决战于<a href="https://www.luogu.com.cn/problem/P1737">旷野大计算</a>之中。</p></blockquote><blockquote><p>在<a href="https://www.luogu.com.cn/problem/P9141">乱西星上的空战</a>中，<a href="https://www.luogu.com.cn/problem/P3693">琪露诺的冰雪小屋</a>成了我们唯一的避难所。面对<a href="https://www.luogu.com.cn/problem/P4426">毒瘤</a>般的困难，我们需要掌握<a href="https://www.luogu.com.cn/problem/P5608">文化课</a>的知识，从<a href="https://www.luogu.com.cn/problem/T346974">helloworld</a>开始，逐步<a href="https://www.luogu.com.cn/problem/T347033">迭代幂次</a>，解决<a href="https://www.luogu.com.cn/problem/T347591">六则运算</a>，最终战胜<a href="https://www.luogu.com.cn/problem/P2482">猪国杀</a>的封锁。在组合数问题和鸭棋的博弈中，我们像魔兽世界的英雄一样，击败杀蚂蚁的敌人，建设大美江湖。</p></blockquote><blockquote><p>最终，我们用<a href="https://www.luogu.com.cn/problem/P7075">儒略日</a>的算法记录下这一切的辉煌历程。</p></blockquote><h2>题单</h2><ul><li><a href="https://www.luogu.com.cn/training/3210#information">保证有一大堆你不知道的珂怕的码农题大集合</a></li></ul><h2>题目</h2><ul><li><a href="https://uoj.ac/problem/98">集训队互测2015 未来程序·改</a></li><li><a href="https://www.luogu.com.cn/problem/P4920">WC2015 未来程序</a></li><li><a href="https://www.luogu.com.cn/problem/P4604">WC2017 挑战</a></li><li><a href="https://atcoder.jp/contests/birthday0410/tasks/birthday0410_x">Atcoder AT_birthday0410_x この问题はほんとうにひどい问题であるため，できれば先に他の问题のほうをお楽しみいただければと思っておりまして，ですので他の问题を通し終えて暇になり，かつその暇を</a></li><li><a href="https://loj.ac/p/3233">POI2019 R1 Pisarze</a></li><li><a href="https://loj.ac/p/2288">THUWC2017 大葱的神力</a></li><li><a href="https://www.luogu.com.cn/problem/UVA10966">UVA10966 3KP-BASH Project</a></li><li><a href="https://www.luogu.com.cn/problem/P8422">THUPC2022 决赛 德州消消乐</a></li><li><a href="https://www.luogu.com.cn/problem/P4118">Ynoi2018 末日时在做什么？有没有空？可以来拯救吗？</a></li><li><a href="https://www.luogu.com.cn/problem/P2540">NOIP2015 斗地主 加强版</a></li><li><a href="https://www.luogu.com.cn/problem/P5370">PKUSC2018 主斗地</a></li><li><a href="https://www.luogu.com.cn/problem/P5645">PKUWC2018 斗地主</a></li><li><a href="https://www.luogu.com.cn/problem/P7196">CTSC2002 灭鼠行动</a></li><li><a href="https://www.luogu.com.cn/problem/P4911">Luogu P4911 河童重工的计算机</a></li><li><a href="https://www.luogu.com.cn/problem/P3695">Luogu P3695 CYaRon!语</a></li><li><a href="https://www.luogu.com.cn/problem/P7610">THUPC2021 群星连结</a></li><li><a href="https://www.luogu.com.cn/problem/UVA12413">UVA12413 Big Decimal Calculator</a></li><li><a href="https://www.luogu.com.cn/problem/P7827">RdOI R3 附加 ACP-I</a></li><li><a href="https://www.luogu.com.cn/problem/P3798">Luogu P3798 辉夜姬的十道难题</a></li><li><a href="https://www.luogu.com.cn/problem/P2337">SCOI2012 喵星人的入侵</a></li><li><a href="https://www.luogu.com.cn/problem/P5822">L&amp;K R-03 大航海时代</a></li><li><a href="https://www.luogu.com.cn/problem/P5511">Luogu P5511 决战</a></li><li><a href="https://www.luogu.com.cn/problem/P1737">NOI2016 旷野大计算</a></li><li><a href="https://www.luogu.com.cn/problem/UVA12313">UVA12313 A Tiny Raytracer</a></li><li><a href="https://www.luogu.com.cn/problem/UVA12423">UVA12423 (Last) Mua(III) - Full Interpreter</a></li><li><a href="https://www.luogu.com.cn/problem/UVA12422">UVA12422 (Kengdie) Mua (II) - Expression Evaluator</a></li><li><a href="https://codeforces.com/problemset/problem/1545/E2">Codefoces 1545 E2</a></li><li><a href="https://www.luogu.com.cn/problem/P9141">THUPC2023 初赛 乱西星上的空战</a></li><li><a href="https://www.luogu.com.cn/problem/P3693">Luogu P3693 琪露诺的冰雪小屋</a></li><li><a href="https://www.luogu.com.cn/problem/P4426">HNOI/AHOI2018 毒瘤</a></li><li><a href="https://www.luogu.com.cn/problem/P5608">Ynoi2013 文化课</a></li><li><a href="https://www.luogu.com.cn/problem/T346974">Luogu T346974 helloworld 加强版</a></li><li><a href="https://www.luogu.com.cn/problem/T347033">Luogu T347033 迭代幂次</a></li><li><a href="https://www.luogu.com.cn/problem/T347591">Luogu T347591 六则运算</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024.8.5-A</title>
      <link href="/posts/d5326c7e/"/>
      <url>/posts/d5326c7e/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="ea9c13092b123d4302e4df0abe965b88a5489652e1b369695623c37d389ab0d9">93024cf999deb8d8b2919f7e109263d436f7768a67e3b41578a0afeefd292b2d341f6f7c75faa11626a27a9f13d1a5bb76e147e88d486aba7cc9b72b55824ef659ac8de6e34127f555df6915efcb35a22a4135ca63bf2f4a0921a5f8c6a10edeb53c5c499cfc214a606286873e6474bd539ccb890cbeb356ec09a1db625b9a6fa2019a566475909336e751216ac818535300661585e6ebee624d625ca2809d0ea405c27902b472b9fa9c876b178de59e73375409aed421004733bd94248ba43e0c3dde97a1b62030715b587db0eb851e8e443e074b915322bbaaa529632918662ef3204483313c8559839fa800c44a8aa702250ce3cd0910eebf0445b032ce5b095394b8fbe70543b9cca53146b980e36c0299ea8e6419b17d1bd760529fb1804c2a78c9b670c02f04180d1f4f558f9992b7676a6c4173e2d89d957e676589b4d344e43b13556d2a48ac4336abbc2e9bf09d99d00755b145dc298dade52007575226fd2fd332e8ae6477609a721b17de4059dce396d90c8f828677a26ddfe2d803d22d51da92ba83e885fe8da95c5d117137864490c1a0bbf079efdd3c30e9142d3eb7f294db934fc9ea96d85c1773ba02ad3d7b7111f74509de72d10f2221d2592c4aefce30f4ba9d3d3c60fcf89041c1e8b1dab41a8e8ebcf5bfc420314e9f638e0a799396c293cf6441298530d814f8837a0f952e1908199ef0e72f0c0991aa988c27fe40d0e4b035b06904164ea08bb60d87e7bb96ab5bc90e415a71a23ae3f42c46ce8a7397eade9e194d357b44f14e84f2d76444ed1521345b3bbf7f5921869f18632801803682c23d2c0450832caab09b77436df1631c2e55ea7f5b01b2ea9b4c1b42d9a34dc30d4b38134c82eb4c6b1a0af8c83d164d80f6f34623a9570133cebb4bc88eb6122e9d55159facd57fc1f4a89595609d95f9eb37a992b86fdf857f2fab0057eebf4fa84271ff608f98bc6edf493403257218ddae24ca0c8346e97bfbfc904b694af07f266507ae4a03d3198224938be60d333c1f66577a0e5ac0a97f45069ea0352d3858be8561786d08bc4cd2bd66702497bfaa29dd9763ccaf9d7434bdf1a0de6ddb1865e7ce03e7c10ed75445c87e478968f7f256a9e5d9f4e838cfde4a182283729e01ca2160f9dfbc090540d6d4f358635b6b0c773a4d4a05b0f3eeeb1d2323efbfe1308a6957981aca844c566a5b419bf2d4f2103109077329366a50deb4e33de5c10cdb92afc0de020a1a85db372fc43e23a0d981f99d59c37e1ce8a0a880cd671ea3685b10134b536e21d3c4a6b1fda031f014751a07d7a8696194424a08a4dd21ca2e7168cd4722c53a4ac9975a97ac4aed22ff4fff88bc0c65227f5ca3bcf9103900721019afac2591a9e347adae2d494279e19736f875ac26189a37dd238de89cbccaa2e7cda130788dc1d9934d90620a6e92801e4c028a98d4d80d5cf7b9493439cb58e52e0d8b89a389a8d19be010f6f7775ad56e94d5e7e1d617ab8f35bf9d9abff7002ae4212bbbbd51926639e90f6eec9c72bb84e805b9afddd2418766bca4d92dbd61e2bf94452a7cde66bd268685a2d30ce0fcafbf826857a46d355e460bf9e13b1f483e0c812569c0c1a26b34d27d9594ddf25189981b0ea036f6d91cb2d7b23eeae82afb087e873e594eb6cea43ddd5b6d42a1a02e95ec5d506a14f6d0ba434fcf7e7b62cabe7563903495f9f199175f685ff3409de7997b6287bf39648458104dfe8d1f4962891271af846fe8f10c4563e43ab42f0b10ebb8f6634c6616b49ee46a699ea816c6f9117cc0dfd3bca2bac1c25781a318b3c090d9c604a3e58705b55e71c5d3b5a6fae8b5dc0b7da6a4f227f56d57021d9c66fcb5777676ac8608c63224ad1d0208eb53bda299d09b807b4c97931280c0823a135b7fdf1f6a3a3c5063731c483cadda17fcc6fa00a73216b5a266682b977335593e5285dae519859c75e902e69d9663fce2de8ba273442fc27c7c56874e6ee653b855483b518072ee60a54625fec5d801549d6ac57677a34778b565e16c93215c867ac2170a59e832d163a42a91339a48caae4b499b4feed06c9331a493c575229a68c745d76d7d11942af62400273bc0a7e8d8ceddbab1b24ccbc6e04a08ee90ac61f8561b8902fe9da64ebe4ef89228ee12c31c25c1c6f8aac7550201fe7cbefdbcd5d83fb3e14625d955b339c95b5208919fd580748f0e29d3fe1908bc3d1366a1fe7d60c9e3375edc7c02690e773b8b1eff0d9ba6da9e90b6c56d676dc672b061fd4a9f806df76a3e16f2069df548de9bca94</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> school </tag>
            
            <tag> divide-and-conquer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024.8.1-A</title>
      <link href="/posts/d23bc4a2/"/>
      <url>/posts/d23bc4a2/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="f5663544b997cc2ef9e6f14ed2aa1829e960c38956e774c4b36c3a1eff49baf7">93024cf999deb8d8b2919f7e109263d411cdbf526b88909db0a4d584ae62ae5bc99943b1a96f3acf85dfa0faa4a272221a198a14f20d6f621dbbf39c8274552418b9f6ae15e994a85b41dc9c37e1479e945a5471ecbcc0c129bafdbc3e49574485758140d431eb2a5152408ae4248c68d148e5c55f52dac18bc3d2f3c4e3fecfcfb86a46618944188576901776dbf9a547320e49baa33d0d442788bfa8bea337a8dca95c23bf1967904f23b79ecb1f959861938f9c29ebab651ba717d19bc70031df481123c2039b619d11bc3785e166d477b686e9db82c4b79719c5d155277d929b0178b79177eb74f02735071a52beb10476b86c0da6e99391fc9b2553d7eda8b5041ed477c7de481f1ecea98cdf3dcd082fc9da38e615787614b2d6e36a46339b168d98c5eade317df497af1e06a046ccb0b94b99ef500a2141d08a2e285d46aaef2c73cfd456df756c02081db3b0299939e02689111ab721c0fccb0ffb68c3fffad1255002b7e2cf4b13244020f7fcbd99f16fd342ef3929d6e08fff79aafda3117ae011340b37057c139b3777ac4d39fbd10b57a9011f18779b3308ff68a67d63079940da520cde4f026afd6b4385b8287d277e608f87aa158e13bd7fc100b976af5b111ea0a6aa2d339b4d1b4453de5eabf00d3faa49783988cc22ea650c77a0d36a7682a53c637c7df74c7e627edc2f7d75860d51cc24c035c1a7e89eb6f7c502c47b23d88c1821cf5c414bfad2e7e3a1caa5e50493dddada81a8aa593fd48e19fe14bacc0e70a7a154a95c076a67134a5e95510fb0d03e4a321226d8b7752b6d95ebef6b42b9ced94b2fb42ff921f049d2e3aec3d402da1b8208e1f09e6b7d86f7ae15765d1a55de98674955b7dd128a88cd0e97427b50a6964322e53a76e69e38454c0ee48d7e5c8982cea4cefd89a471cf05d6f030882653e5b4c45dff32a971c10151143567ea6eb95050d6519b6a7cceac88bfa98979b55ea064f93a6ede34cdceef3b546c9eba4ce80bdf42df35cb791379cf5e7ddfa4a1307a07364adf597a9afc33ac47a2f0ed481a662ffe41ff998dc450c41bc6f7eb7dabcee3ef083af5b6f7f0d3306903df74b16145c3be4cd968adf04448b53de8aeeded5646d20aa001471db3208ae703ac826662e9569bf62fcb850e1ddef559603c840eca5105bff3218f9ad02fa1ee3f7b3d36011bd6c7813389f14ef2ca7eb727860f7769680da958259f16a9b005e492b9dc5984dc16dbeff1d43f2901c0230e7519fd49dd33af8438771448b77f0460d2247bc74900115fe04a9f34975eb05f843169bff658b638c152d23acb53a2096fb6ad5c7c59c91973c6c9a5d1d26d9bb59a1b169cb006899f701611aff0c82c1df86c1dcfb3163e4cc00456de590fbcfb94f5ca590fecb6a5d6dcc1210539941b256d5a9ec28857cb62e72752f0a6087f4b5aff79e0f03c05c75a0d6e90d0636f2405df3e1d3557a1ae3f07284256a32cbc9ffd54e0d9f31026dcc99909c2ef84ae17e9a732adabdb8b2ae08f7fed931c0dffa182e71199ee5e7dda27b400122c9211baafac742cb55c051b1f17efd010753989b20eb4e54c24ef7ab4dff3734eebf71215b1ca84e31387a842853f156a7d13a0a3531181a26698f78b66c5203ce5b3d72035d0c657a0af1562919bf8057df679e7f99f34caa4a85025f6d29cbd7ab569285526cf955fe01d1a5e26bf80fdb732cedea0186f68d6f9e01da37537ff5b37441a3169099f8d6e83fa8a5eed6f49e9eb9f7ff6fe5d10827fc735c643e1256e51b9065989b3f38d9ceb02568b4a75b69bbc61cc2326bfa8d0185569a4f3a39d9534fe03acb4fdf9fa35f873a5122f29c35ddd012864dc85baff5a5bcb78454249178b92c07518276f30691d9cecd49e009180549ff66156202977df9f051f061f769a2396e44603e1413a6949ff8ce1730cfb67f17753ed2845dca5f693a9b02cc5da401162f2aad4dc9cbdca8f3f3b67c50b5a5001070384124d870461052dd38bcd5506a8f944b81cb3999c856dc7c41a90b7866398a081d949ea638f03c3d97e32b5c0de645d6724029d350a9fb6a834df3570649155d8f9768b67537987974ce7ec3b83231c4752742e3ff49c053691367d947c41d878b273d1f8512dd17770a55f9f73252006bff6daa4bd3250bcd936b6d33d0f555f2292c4e967440960b015ed56dd652f7ea48e1c6717652aa0af58ffeaf695930a410e48d04d67369aeedd1fc0ff4c33148d0a4c3d0d58761c1ad2b00048b4bec2d36650ff7f915fedbe37f164196f31a54614f11960d84149e23bd847a916d3a67b151c81828029783e66a16b33f88d36363b5db24aff5e6d6f0fa02e2c0d356f3f1c272736fe7a8ff6a09828da41e58e4a56a19e9c4aae88c1335664d6245b94d366b9d76f74572cc01432ba8840c7dd19f6f1bf34a8e03d0d742da60cbd82103ff99cf41a71e2974f6d70880868ba37bfc2155d2d0088e7012fbb86568e14a4d922823778d894246f4b1a7a58ce80441d2d92435b0d0d542ef967e010aa1c9c359af00cb735a1f9ee38c7b6dcbe2ddf919dc617f11d7f8dae6115f0257b58d2411bc060cea470e6403a1b56bacdd832fb75352a857434f1aedc6bdb75d6949fe7f31aa3faa2a353afaf14ce93f4db4609f0f9e2ca00348cfc283d0a96a384c657f2df6182956fdbb1b9253ffbf755f2458a57237207d74bc645d53e357f3b73c29dee756a02bd58e23799d62ff6126129f0de185301a653c0b632308efc9a77a5635e2aa7e23b3aa34f4b5870b2dfde30ab5e7128ec9e3f565c024f44f938ff181227640d072da46b0a1b48ab283aad9186586964cc329c47b4c40f820f3a96a533fa286f7dc998d05d8ddaff5fb72100f2d08ddba19d73d25dd90b675defa2e580c5ecdcb59680e100565ae335c680cd349b7aabb0b80c6913fb4a52bb2cf53fdd700d71d9f2b19a1b5a6b5d58f924e0510657bcea3247f91db2518acc78f6a221df5886b76890d447a0a88298eac204699b0259e1b516bd1acec4980def6a019bead30d1436cf403cc1a24fc85b90c666c435b52dc5f5446375cd364a238b0edc10bd9e3b93db29d5861ef3a0035022f7bab99cce4607e0b59f5b2a4f2316e987110a39cda36f64c5f3acf5b6b2a89f1dfb1b8916976c5b97b1b1fa5b4fc1ab9ed8859d7a009088be6d307f3a8f837fff2894497522356397c2af7519f565258f65d95ae2fe34a879e4342429cc8b26c2dd</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> segtree </tag>
            
            <tag> math </tag>
            
            <tag> bst </tag>
            
            <tag> school </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024.7.31-A</title>
      <link href="/posts/6cf8636a/"/>
      <url>/posts/6cf8636a/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="5c463a19126b8bb39417cf441d25a1e82b4cc9363d47f31b8be5ccdc7f2e68bc">93024cf999deb8d8b2919f7e109263d436f7768a67e3b41578a0afeefd292b2d04085ee996e110abf8ffa55e252b09d817cd4e397f2c44524d1a2cb77179b9b0f18dd5d98d4d157d5984a15079551994e859800465c4578aaee94485a8096e7bd2b70407415a3f54d75cbdcff24c6fa6f03e17c98b3ba687d9d97617554d3f22d19bf85d2446e804e7adb7b7ef712aa6013554c67b76c2b396c222a9a6ed90f715039c4579d4e7612dbddb82e56c7d053e6f0a3ee42b9457874875519a43147e4dcc3e637c49d3c133095431e4045b64d79e040854f55845d8fed157e00eae2bdbe3a5277e57af9033b5704bc0f9af05755f7e2231468ddedbef34ee5fecd4d62e47910f6a60aaa05e1345691286d03f6737cabcf9d5bbda27f6e067b64d168955f6f5a23bd082e6c1fc1aaf0059c8ca421f52bbd0837468c6aeaa23ce22f802c3667abe537fa092712a1ccb96987d7886cbb021f13f9dd5f176725cafb583a829b929e4bbc1597f39e6ed0cdcc8004bdd752a51d56618498014ce5f374820cf08b0787e7666828371e943c57bd5ed272bc0ea4489b84016d9daa2274932359b8b3f4d3b211efb15e0b85ada6e0dd448f6a6d2415d83f52361d7363fdeff4b60773af6307605b478d087d595f7caddc7f76a8b75f5e858f2fc6af82e03f0678c2f04630310463fd9c6d36d75c179e4c18cff9f3176babc390c450ec20af82d67f7b719f4fa7547c44e2f1067f9360126b870febcb1075461edda3734a3754a936e4f9c4ac9576736fdfc58b10d630eb0fada32c7f5f0b794bf215e8e1ae6bd8b801d634815ee27a1868fa58bff830d31ff79b95b2f2741482769666eef603a3de77ec1a2aa3575f559cfe2c840decc0e52287774af38d67aff38035d6254017e004e2f1ad2012fac3dc52c7c2766fc83871f41696b469a87e439f07c3870ddbb9327b824c06c0b22a8b4f1db1ecf037fa424e5b45a30f819e82b11f322ea7f1d26d3fa70a250e11796c972fbe2cc8b5754f2bb0af05dda915224a44974f9d3e714058666f48f7f2e4e8c2d5d7127917d4160bd186cd4b4e3de4b88c3977e9e4544da02a5820f5a56081ad2bead1d69ea14c900eeb9ee91769718a720caf20b037b8b6566e8d65e71282868958d5605e75ce85a60bea2f33c1cce5c2c118f5e77baa8e8212f918d14668cca52c38a404f20af313a76e5196b76d926c15628d596d97138b35fd823a0a659343467acb9f1529f01dee9cd60d85af8f6139b66bf2d57ee47a0e967e07401a3b5ea8ba63b3ac47fcdb7321be5950e923a38078b07891f91c52edfcdbf5c458c2887b181d775aeec418e66dec605d96eff5cd888066aaf73cf0ff20deae18dd6245c7a7061af0b24bd5292fedae44c11b163cb234d0b1a6c41dc1319df4e8254212796efd97219344577ff79f70198cb7d275315f440cf1c02df4276069c2025648969272fb4109f7fd77e9cc6dbe7bf40a71b48f29af9dcb1eda8624ba1c971df2494e79d5e1ea191a87598d5baf5fc041b6ad21e693df0d3e261d44bfaff00b4d1fcb9018913992091c38192703a6e15830b2bc2260946a6c0ab39664380b57f76af26ca367bd16477acc55cc065ce03b9d40ca883d10e96c514f60ff1929dad30745aa1312fef2590a8acf93b5e2714eadf28c642f42b092827462a135ad1df8efa382e84c3b645f21edf31320fc770e8ec9629a02862b1cba7cfda7daca7ad77600b146de37a0593adb2076af6311ed2abe71c3d5a0ba5713541aca87292f61d32286c80c497014334190eabe7728f0bf3d836b10dd188ee84f739f89858a8435d6729fbcbab2fe46c5d3dfbc5b7d3f4197d1c98d9af0e2801b5a99f195581c2b0807650341ae1d4dbb5d7f4d2410f2ca09d1ca0f5b9eb7e63559ff70c79b1350100ea516ac4ce09e14bd43f67e7cee48318410379d1337052f1390cabec55e1af32de81626cafce712d32ae21095f5c1b0ce99c7ec1c518cf06b252bcf7d158f8fe0f38e1027465990b3a3a7fc1b7873efbd58615714b8efb2d6a79dd97a6e98bb2e5f00bdd380802bea8135b29228089f064f8628eaf27d5a1d69469c3c9b090361d83eee1f724045cba211e99b308f192674b8e28e2262a809fbe193c207605b7abc9961abed8aaf371b43df8767c79fff38fb8793bd198091bf4c88cd3cb46985a6fd971ea4f08e354da75a9044deea715ac3bab32b8f674643cc0be84a57a1049fc86de3b4f0a501168af8b04e4172fd97c9f1a985f1630fc04d802d07d04b2f9177f8fa55f9ba280522a55cb3178dfc480b0b054bcb2c266dd838bf74751579fbf81d3aba84051aa2cd4e068d5898c7f85119b50a3a1f175631e5da10b37a84be8bfe098d5c82a7fefa02cefb3e9a9ab363a343ce61a32f49b559b3cc6db51518447be314c87354361e120e346aa21f19aa10a6c0aae41c4fa1baba1fe81460694ca952f3d03746f692dbeae7a07458f8d4972c29e34d450cff6ef892f76224d260fbf26235f6e8ccd4c1cc025a198be199ab1ebb9eceb06816e24ee627fb8f119387aafe61297866a0cf5a156a7c928d2bb64a6d9d70e68ff74467b24d4a40dc2e1c7bb072d6943077cb8e1e29543293b6fe755a3f5ddef99151a33e2f765a2971176ea6be0ae96518ff3811a779584a62c88084b03a36a4c9680c81a961786c3fc4c2b9254c65946400647fdd7597764b6e4fa55cfad8eaba7519b11f75e4a8de9cdbd6c9df3288b45913260aa7d2526cfd699bf84e01f3c6bcd1c3123c2b8fb2889df277adf98d37ddab367f79244c8ac1f83ac8be52a89789ef6562784a5785a92375b3e6a137354d00a9002264f43aa4702ae941ad63587021f13ae038865ae7f3073301b7a6fe3adce2d77d013f2a033be1923bf3b9ae5f5ebab2344de2cd9f6ccbe56ef36d065d270b369caab8a6d67fc55f5bcd07c38923e212f43794eab7058ee66933dec84ad61282a5e09cd1c95642015682c9e7fbf00ff866c79910f7592e6355668853c50dacd5ec101979fac6174fbb84e429fd8869e0345c10bc485d54f3912519e0a5718424fdab25d6b45335417770129b9af1abd48ecc32d20ecd1142b923110d36e7fa7d38c2aa1ee434ea477dfa4632628747298ec6a1425fcba152a2b6a38879a327cab6d99f39f1e85e0591f18f72c9cf4f1246e8c2280b98434d2b1f4ecd7e36c73d0c2c1248073319cadc238ed238923568879adbade64699ba278014ec613a6ee489e466eaec97ace92d761fcd5e916a0a3e38404de8af6c32491127a6899bf5089c153aa463334f7cc20fcf891fde3979a226be7703347c5a0bd261de46f8f18d54e392572f67ed24c848afbbef5c7085c61c39e0e905a617a65290b96707b3a4bdda1c7ab32559f83e6433eda0cd495192228557897d4f38f67731164b8928acbbcfc1da332dc0597d1ac73743ebc7a735ec14a115bd6e99a2ac145f53494176cc9e38a381a29a378cc95be971f6f132350e7bcbb9555a63f83dbba18d1610e9e74ef31508a60283c0d1bb51c3d7bdfd3a80ca75d094418085c48e3436bdcc2682a58699df83668c4c17a1271b3f4e48caa77856e6a25339f39439f647875c2f4d2995cbe08a80f3cfe6ae31c2ec329cb199bbb4e0c8ecdad162b5bbb0cbc9a4db9b8c3dc4a156b12d56a428977955d63b8e4fd685116daccf6f0f6af4918de74bac1b2f2ba22336a2be9d069b3a3f806611f56583cfa47f03d661a9b4dec17c36f0847634f7bfca464021ff26ed1f7e4b7c1e0b4623c42cff6aa31cfb8aeda5b883ef2c3fcf02a4e284993023f0ab15d1463c133083ad306c38524529c7d9570636db485d97d3f6eb112d8cd7918acbfffab49c830e726bc7cd47642d1cb4d23d34890be54aedb2be74ac1e2507ead248ad3f227e9ce3ce230aa068035d5a445c6f7e2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> segtree </tag>
            
            <tag> school </tag>
            
            <tag> dp </tag>
            
            <tag> PST </tag>
            
            <tag> binary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024.7.30-A</title>
      <link href="/posts/6d3a095d/"/>
      <url>/posts/6d3a095d/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误。" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="dd993aa0b7d5d4b5c0166cd9389ad82b0a4385d3198aa46fb0589adf44f99238">93024cf999deb8d8b2919f7e109263d436f7768a67e3b41578a0afeefd292b2d8ac204ff950b9fb603ae950a53c8cc8fbefc36414dcca034f3e9d7a41b65fb4baafa1e0eca3c1da665865342bca166ed8fa38401b7499d3c96feeaf473ddee3dace0b6671fadc9c916b764ca8de175f86c50890f18afe9a5519586ca9aea6b6d0149422d0c9c066d155094e70f53d53522c86a6824898e3448e415b55c36eb2173d0b5bd848b3ae5ba58767add14e8fa98f8a8eeabac198126e1557737e3280ad8d855b350b81239e828c3c4b748dc2bc7f8bf08bc6e5245416aad6ed070f436cd761a6531835788a646b22555e7971d7d28a375d3948a8f6286a5201ebbeb346e8b1937576e3abf69d9dc3bd4d7b4150162482758f83fb8f0b7b86718dfdc8e837275f2bebc8d273c805a27a2ae5f09417b439614d037cddcee716e62986dcdb36e00ccdd12e759f721a8cf517462b7f0d836b84bc366a859b31402804ec65a00db2a3118144799139622a332e542ef2bae881f5b78e076d80af83a68299fd15fdd4db6640ac3877a8818a45ccff8392cf7534f7c97e9b3fa695536525d74f31fadf8af55d283eca428ac3e50b55b3389d8deee788465da35864f4f698f609bb42ba73a1b89e48e89b2488f252b7bddb782ddda068ba95d8d9b9858105f17ead1a8c005e5bdafb5b5e69544330f8329e931f2604edbb0e89b472f64e0a05b9f0ff296538bce191ae2e15fe6f3e68cda041b5ea1b0e32a1ca0a96bd2a5781b45faa5ddfce9140783a9020674b9f3f2f02fb004d653c0d59dfe8dd8f73ba2b058f9f8b5e72f157412f9105d67aaa5ad76bf3c7bab7fd8201b933d5e622f3bfa168462318fd3cbd1dd9cc14d664ae9f5a244c941ad0252a2326804fc853f2618be7b88a5178ce51865e0be74e5d1ad6473985a439bf01516f706dcb8945322e003175cab7696f12f492fb7b1fdc7bce71ce30b7de24b0c7b47005142d3c749a6c7e4576f2346d66af686430f715ff649016730043f97da40b57e1886f1de8686d3fa6454c7d489ec13aecaac978581c442c29cb2882ecc2c243a92049d8ede9c14376d5a43ecaa7bfb38a22191f4389f688b965a36f9bb5e4932dfe52cae03708a6f76513d267639cf51b0d9bc7763c121ab6c2a8a189cd7bdeb5042bdedf0f326889b4de8e0a2874e8be02076bd9d43db90656047f15215f4fbfd6b9e860d06bf2abbd7eb1c0840406cc3b352bb32428a206ff57d14d8888fd394248fdd068ed34b780f69ad7b67557257bfc6015aa3631abe0488dec91134d6a355833c5963aad53b31454e444d5c163305b1f5c8136153809fd5975a6af49c41d8b03d6bfc8099619e459d00175c0eff8181399acc3f5cf8a95250504b2496c754b4dc7514350b74a0285885b122cba0501bd853cf769fbab5b0553d1c707127ab2aaf20f0012a06770ff76ed2ae9af5c6824d8ec99afedd7cfc7ccc45ac96a06f78baa03bcaab0cb648e75257287528e8476dcaf7cf62f80bbf8eeff876f54ef645dca494f88421e590091b71231178b2bf3cbd0cf5fb2d2b083ea94012cecabdf19489b57a4613ddc55d95db3dfd27deb2c2a11da458b6d9eb066ded8280dc67c2b26008eeafab41851791a77d695331d91186e6760210a25402c9945fe068ea64826a603c7ec7bf657fe73eeada680a7b181299f3c9638e8b0357c9daf89f15c6da6fc68f0fca7a0932fde77a3617682d1964a1e97dcc272f65136e3816d6648f5f36fe47faaeb707c020988091b6b788b4112f30bf06463708cdc7a504e0bfd0017cf0e9bf583ca5ce077277fa6e2a791f4ad506c14418e7adfa8ed84ec5c88c5659285743ec70aa001344978a4adc12b3242988c1ebdcf4a8e81e369133715609940c0b25f55650723c1ff4cad01473c73e75926cc3bf81511cb6e78f6fbed3293587901e863bc18fb0492bda78c92b29b0dd996a6d07cf7f4a85347517e1677cb89014f6ace5acabf7d090ce5187aa04820613535220308dfdaf6cc60666039bb48e3540a1383b2870fec05e69871984de51c1892aedf00940790e6d92cde5fbb13170eae04b12d26ab306bd4d75641c357fe5</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-shrink">      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> solutions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> segtree </tag>
            
            <tag> school </tag>
            
            <tag> divide-and-conquer </tag>
            
            <tag> BIT </tag>
            
            <tag> network-flow </tag>
            
            <tag> greedy </tag>
            
            <tag> PST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串 Hash 的攻击</title>
      <link href="/posts/9379dc77/"/>
      <url>/posts/9379dc77/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>强烈建议尝试 <a href="https://www.luogu.com.cn/problem/U461211">Luogu U461211 字符串 Hash（数据加强）</a></p></div><h2>前言</h2><p>某天看到同学打 <strong>字符串hash</strong>，发现还在用 <strong>腐朽</strong> 的 <strong>单模数hash</strong>。</p><p>为了帮助他改进码风，我决定 <strong>卡炸hash</strong>。</p><h2>一、大模数哈希</h2><h3>1.前言</h3><p>我们知道，要想卡掉 hash，本质上就是让两个字符串有相同的 hash 值，我们称为<strong>哈希碰撞</strong>。</p><p>假设 hash 中每个值生成概率相同，则碰撞概率取决于两个因素：</p><ul><li>取值空间大小</li><li>hash 的计算次数</li></ul><p>这个问题在数学中有一个经典的问题，叫 <a href="https://baike.baidu.com/item/%E7%94%9F%E6%97%A5%E6%82%96%E8%AE%BA/2715290">生日问题</a>。</p><p>简单来说，就是在一个有 d 人的班中，有人生日相同的概率为多少。</p><p>实际上，这个问题的答案并没有想象中的小，下面是部分概率： | 人数 | 概率 | | :—: | :——: | | 23 | <span class="math inline">\(50\%\)</span> | | 50 | <span class="math inline">\(97\%\)</span> | | 70 | <span class="math inline">\(99.9\%\)</span> |</p><h3>2.计算冲突概率</h3><p>我们设 hash 的取值空间为 d，计算次数为 n。 则 hash 不冲突的概率为：</p><p><span class="math display">\[\overline{p}(n,d) = 1 \cdot \left (1 - \frac{1}{d} \right) \cdot \left ( 1- \frac{2}{d}\right) \cdots \left ( 1- \frac{n-1}{d}\right)\]</span></p><p>经过亿点点的数学计算，他可以变为：</p><p><span class="math display">\[\frac{d!}{d^n\left(d-n\right)!}\]</span></p><p>则 hash 冲突概率为：</p><p><span class="math display">\[p(n,d)=1-\frac{d!}{d^n\left(d-n\right)!}\]</span></p><p>但是，这个太丑了，计算也太复杂了，我们换种方法。</p><p>根据泰勒公式：</p><p><span class="math display">\[\exp(x) = \sum_{k=0}^{\infty}\frac{x^k}{k!}=1+x+\frac{x^2}{2}+\frac{x^3}{6}+\frac{x^4}{24}+\cdots\]</span></p><p>当 <span class="math inline">\(x\)</span> 为一个极小的值，那么 <span class="math inline">\(\exp(x)\approx1+x\)</span></p><p>将上面 hash 不冲突的原始公式带入：</p><p><span class="math display">\[\overline{p}(n,d) = 1 \cdot \exp(-\frac{1}{d}) \cdot \exp(-\frac{2}{d}) \cdots \exp(-\frac{n-1}{d})\]</span></p><p>化简得：</p><p><span class="math display">\[\overline{p}(n,d) = \exp(-\frac{n(n-1)}{2d})\]</span></p><p>则 hash 冲突的概率为：</p><p><span class="math display">\[p(n,d) = 1-\exp(-\frac{n(n-1)}{2d})\]</span></p><h3>3.卡 Hash</h3><p>言归正传，注意这个公式：</p><p><span class="math display">\[p(n,d) = 1-\exp(-\frac{n(n-1)}{2d})\]</span></p><p>我们只要使 d（取值空间）比模数大，并找一个 n（计算次数），使得 <span class="math inline">\(p(n,d)\)</span> 尽量为 1，就完成了。</p><p>例：</p><p>对于字符集为大小写字母及其数字，我们设模数为 <span class="math inline">\(10^9+7\)</span>：</p><p><span class="math inline">\(\log_{62}10^9+7\approx6\)</span></p><p><span class="math inline">\(p(10^6,6^{62})\approx0.9\)</span></p><p>所以共有 <span class="math inline">\(10^6\)</span> 个字符串，每个字符串长度为 6 就是个不错的数据。</p><h2>二、自然溢出 Hash</h2><p>我们知道，这种 Hash 是形如 <span class="math inline">\(hs = hs \cdot base + s[i]\)</span>，分情况讨论。</p><h3>1.base 为偶数</h3><p>这种简单，构造两个长度相同且大于64，并只有首字母不同的字符串，形如：</p><p><span class="math inline">\(aaa...a\)</span></p><p><span class="math inline">\(baa...a\)</span></p><h3>2.base 为奇数</h3><p>定义 <span class="math inline">\(!s_i\)</span> 为 <span class="math inline">\(s_i\)</span> 的倒串,<span class="math inline">\(hash_i\)</span> 为 <span class="math inline">\(s_i\)</span> 的 Hash 值,<span class="math inline">\(!hash_i\)</span> 为 <span class="math inline">\(!s_i\)</span> 的 Hash 值。</p><p>例如： <span class="math inline">\(s_i=abbab\)</span></p><p>则：<span class="math inline">\(!s_i=baaba\)</span></p><p>设 <span class="math inline">\(s_1 = a\)</span></p><p>之后不断构造 <span class="math inline">\(s_i=s_{i-1}+!s_{i-1}\)</span> 就有：</p><p><span class="math display">\[hash_i = hash_{i-1}\cdot base^{2^{i-2}} + !hash_{i-1}\\!hash_{i} = !hash_{i-1}\cdot base^{2^{i-2}}+hash_{i-1}\]</span></p><p>尝试相减：</p><p><span class="math display">\[\begin{align*}&amp;hash_i - !hash_i\\=\ &amp;hash_{i-1}\cdot base^{2^{i-2}} + !hash_{i-1}-(!hash_{i-1}\cdot base^{2^{i-2}}+hash_{i-1})\\=\ &amp;(hash_{i-1}-!hash_{i-1})\cdot (base^{2^{i-2}}-1)\end{align*}\]</span></p><p>发现出现了 <span class="math inline">\(2^i\)</span>，但是原式太复杂，尝试换元：</p><p>设：</p><p><span class="math inline">\(f_i = hash_i - !hash_i\)</span></p><p><span class="math inline">\(g_i = base^{2^{i-2}-1}\)</span></p><p>带回原式：</p><p><span class="math display">\[\begin{align*}f_i &amp;= f_{i-1} \cdot g_i\\&amp;=f_1 \cdot g_1 \cdot g_2 \cdots g_{i-1}\\\end{align*}\]</span></p><p>因为 <span class="math inline">\(base^{2^{i-2}}\)</span> 一定是奇数，所以 <span class="math inline">\(g_i\)</span> 一定是偶数。</p><p>所以：</p><p><span class="math display">\[2^{i-1} | f_i\]</span></p><p>但这样太大了，<span class="math inline">\(i-1\ge 64\)</span> 才能卡掉，继续化简。</p><p><span class="math display">\[g_i = base^{2^{i-2}-1} = (base_{2^{i-2}}-1)\cdot(base^{2^{i-2}}+1)\\\]</span></p><p><span class="math display">\[\begin{align*}\therefore &amp; 2^i | g_i\\&amp;2^2\cdot2^2\cdot2^3\cdots2^{i-1} | f_i\\&amp;2^{i(i-1)/2} | f_i\end{align*}\]</span></p><p>即当 <span class="math inline">\(i=12\)</span> 时就可以使 <span class="math inline">\(2^{64} | hash_i - !hash_i\)</span> 达到要求。</p><p><span class="math inline">\(s_{12}\)</span> 和 <span class="math inline">\(!s_{12}\)</span> 就是我们要的两个字符串。</p><p>参考：</p><p><a href="https://www.cnblogs.com/Hs-black/p/12219270.html">毒瘤养成记1: 如何卡hash</a></p><p><a href="https://www.ruanyifeng.com/blog/2018/09/hash-collision-and-birthday-attack.html">哈希碰撞与生日攻击</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hash </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AC 自动机</title>
      <link href="/posts/850042a0/"/>
      <url>/posts/850042a0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>很多人在第一次看到这个东西的时侯是非常兴奋的。不过这个自动机叫作 <code>Automaton</code>，不是 <code>Automation</code>，这里的 <code>AC</code> 也不是 <code>Accepted</code>，而是 <code>Aho–Corasick</code>（Alfred V. Aho, Margaret J. Corasick. 1975）。</p></blockquote><h2>前置</h2><p>Trie （字典树）</p><p>KMP （只要失配指针的思想即可）</p><h2>定义</h2><p>AC 自动机是 <strong>以 Trie (字典树) 的结构为基础</strong>，结合 <strong>KMP (字符串匹配) 的思想</strong> 建立的自动机，用于解决多模式匹配等任务。</p><h2>构建</h2><p>先简单解释一下：</p><p>AC 自动机由两部分组成：</p><ol type="1"><li><p>将模式串构造成一棵普通的 Trie。</p></li><li><p>利用 KMP 思想构造失配指针。</p></li></ol><h3>失配指针</h3><p>同 KMP 一样，AC 自动机同样构造一个 fail 用于失配时的跳转指针。</p><p>但 AC 自动机的 fail 指向当前状态的最长后缀。</p><p>定义如下变量：</p><p>当前节点 <code>u</code>，<code>u</code> 的父亲节点 <code>p</code>，<code>p</code> 和 <code>u</code> 间用一条字符 <code>c</code> 连接。</p><p>字典树的边集 <code>tr</code>。（<span class="math inline">\(tr[u][c]\)</span> 表示节点 <code>u</code> 的 <code>c</code> 出边的点）</p><p>假设所有深度小于 <code>u</code> 的 fail 指针均已求得。</p><ol type="1"><li><p>若 <span class="math inline">\(tr[fail[p]][c]\)</span> 存在，则让 <span class="math inline">\(fail[u]=tr[fail[p]][c]\)</span>。</p></li><li><p>否则，找到 <span class="math inline">\(fail[fail[p]]\)</span>，重复 1 的过程，直到根节点。</p></li><li><p>如果还没有，令 <span class="math inline">\(fial[u]=root\)</span>。（<span class="math inline">\(root\)</span> 表示根节点）</p></li></ol><h3>自动机</h3><p>AC 自动机通过 <strong>一个</strong> BFS 函数实现 fail 和 自动机 的构建。</p><p>定义如下变量：</p><p>字典树的边集 <code>tr</code>。（<span class="math inline">\(tr[u][c]\)</span> 表示节点 <code>u</code> 的 <code>c</code> 出边的点）</p><ol type="1"><li><p>将根节点的所有子节点入队。</p></li><li><p>对于队头 <code>u</code>，遍历字符集，设当前遍历到 <code>i</code>。</p><ol type="1"><li><p>若 <span class="math inline">\(tr[u][i]\)</span> 存在，则将 <span class="math inline">\(fail[tr[u][i]]=tr[fail[u]][i]\)</span>。</p></li><li><p>否则，令 <span class="math inline">\(tr[u][i]=tr[fail[u]][i]\)</span>。</p></li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (nd[<span class="number">0</span>].son[i]) q.<span class="built_in">push</span>(nd[<span class="number">0</span>].son[i]);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (nd[u].son[i])</span><br><span class="line">                nd[nd[u].son[i]].fail = nd[nd[u].fail].son[i], q.<span class="built_in">push</span>(nd[u].son[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nd[u].son[i] = nd[nd[u].fail].son[i];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>匹配</h3><p>遍历文本串 <code>T</code>，设当前点为 <code>u</code>：</p><ol type="1"><li>利用 fail 找到所有匹配的模式串，累加，清零。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; t[i]; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c = t[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            u = nd[u].son[c];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = u; j &amp;&amp; nd[j].e != <span class="number">-1</span>; j = nd[j].fail)</span><br><span class="line">                sum += nd[j].e, nd[j].e = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3>例题</h3><h4><a href="https://www.luogu.com.cn/problem/P3808">P3808 AC 自动机（简单版）</a></h4><p>直接套 AC 自动机。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">int</span> son[<span class="number">30</span>], fail, e;</span><br><span class="line">    &#125; nd[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i]; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!nd[u].son[c]) nd[u].son[c] = ++cnt;</span><br><span class="line">            u = nd[u].son[c];</span><br><span class="line">        &#125;</span><br><span class="line">        nd[u].e++;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (nd[<span class="number">0</span>].son[i]) q.<span class="built_in">push</span>(nd[<span class="number">0</span>].son[i]);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span> (nd[u].son[i])</span><br><span class="line">                    nd[nd[u].son[i]].fail = nd[nd[u].fail].son[i], q.<span class="built_in">push</span>(nd[u].son[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nd[u].son[i] = nd[nd[u].fail].son[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; t[i]; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c = t[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            u = nd[u].son[c];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = u; j &amp;&amp; nd[j].e != <span class="number">-1</span>; j = nd[j].fail)</span><br><span class="line">                sum += nd[j].e, nd[j].e = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ac;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>), ac.<span class="built_in">insert</span>(s);</span><br><span class="line">    ac.<span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ac.<span class="built_in">query</span>(s));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><a href="https://www.luogu.com.cn/problem/P3796">P3796 AC 自动机（简单版 II）</a></h4><p>基本思路一样。</p><p>多记录两个东西：</p><ol type="1"><li><p>每个模式串在字典树中结束的位置</p></li><li><p>每个字典树上的点匹配到模式串的次数</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">156</span>, T = <span class="number">1e6</span> + <span class="number">6</span>, S = N * <span class="number">80</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt, ans[N];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">int</span> son[<span class="number">30</span>], fail, idx, val;</span><br><span class="line">    &#125; nd[S];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(nd, <span class="number">0</span>, <span class="keyword">sizeof</span> nd);</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="built_in">sizeof</span>(ans));</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i]; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!nd[u].son[c]) nd[u].son[c] = ++cnt;</span><br><span class="line">            u = nd[u].son[c];</span><br><span class="line">        &#125;</span><br><span class="line">        nd[u].idx = id;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (nd[<span class="number">0</span>].son[i]) q.<span class="built_in">push</span>(nd[<span class="number">0</span>].son[i]);</span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span> (nd[u].son[i])</span><br><span class="line">                    nd[nd[u].son[i]].fail = nd[nd[u].fail].son[i], q.<span class="built_in">push</span>(nd[u].son[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nd[u].son[i] = nd[nd[u].fail].son[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; t[i]; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c = t[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            u = nd[u].son[c];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = u; j; j = nd[j].fail) nd[j].val++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++)</span><br><span class="line">            <span class="keyword">if</span> (nd[i].idx) sum = <span class="built_in">max</span>(sum, nd[i].val), ans[nd[i].idx] = nd[i].val;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ac;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N][<span class="number">100</span>], t[T];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i] + <span class="number">1</span>), ac.<span class="built_in">insert</span>(s[i], i);</span><br><span class="line">        ac.<span class="built_in">build</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> x = ac.<span class="built_in">query</span>(t);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> (ac.ans[i] == x) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">        ac.<span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>优化</h2><p>在 AC 自动机中，会一直跳 fail 寻找匹配，但这样效率极低。</p><p>考虑优化：</p><p>先考虑 fail 的特性：一定是一棵树。</p><p>而我们 AC 自动机的匹配就可以转化为在 fail 树上的链求和问题。</p><p>这里提供两种思路。</p><p>例题：<a href="https://www.luogu.com.cn/problem/P5357">P5357 【模板】AC 自动机</a></p><h3>拓扑优化（快）</h3><p>考虑预先记录所有跳的 fail，最后一并求和。</p><p>于是按照 fail 树建图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, S = <span class="number">2e5</span> + <span class="number">5</span>, T = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> s[S], t[T];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>, ans[N], f[N], in[N];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">int</span> son[<span class="number">27</span>], fail, f, ans;</span><br><span class="line">    &#125; nd[N];</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i]; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!nd[u].son[c]) nd[u].son[c] = ++cnt;</span><br><span class="line">            u = nd[u].son[c];</span><br><span class="line">        &#125;</span><br><span class="line">        f[id] = (nd[u].f) ? nd[u].f : nd[u].f = id;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) nd[<span class="number">0</span>].son[i] = <span class="number">1</span>;</span><br><span class="line">        nd[<span class="number">1</span>].fail = <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> fail = nd[u].fail;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> v = nd[u].son[i];</span><br><span class="line">                <span class="keyword">if</span> (!v) &#123;</span><br><span class="line">                    nd[u].son[i] = nd[fail].son[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nd[v].fail = nd[fail].son[i], in[nd[fail].son[i]]++;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">            <span class="keyword">if</span> (!in[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            ans[nd[u].f] = nd[u].ans;</span><br><span class="line">            <span class="type">int</span> fail = nd[u].fail;</span><br><span class="line">            nd[fail].ans += nd[u].ans;</span><br><span class="line">            <span class="keyword">if</span> (!--in[fail]) q.<span class="built_in">push</span>(fail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i]; i++) u = nd[u].son[s[i] - <span class="string">&#x27;a&#x27;</span>], nd[u].ans++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ac;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>), ac.<span class="built_in">insert</span>(s, i);</span><br><span class="line">    ac.<span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t + <span class="number">1</span>);</span><br><span class="line">    ac.<span class="built_in">query</span>(t), ac.<span class="built_in">topsort</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ac.ans[ac.f[i]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>子树求和（慢）</h3><p>先子树求和，最后累加。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, S = <span class="number">2e5</span> + <span class="number">5</span>, T = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[S], t[T];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ACM</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">        <span class="type">int</span> son[<span class="number">30</span>], val, fail, hd;</span><br><span class="line">        dq idx;</span><br><span class="line">    &#125; nd[S];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> to, nt;</span><br><span class="line">    &#125; e[S];</span><br><span class="line">    <span class="type">int</span> rt, acnt, tot;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = rt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i]; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!nd[u].son[c]) nd[u].son[c] = ++acnt;</span><br><span class="line">            u = nd[u].son[c];</span><br><span class="line">        &#125;</span><br><span class="line">        nd[u].idx.<span class="built_in">push_back</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dq q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (nd[rt].son[i]) q.<span class="built_in">push_back</span>(nd[rt].son[i]);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++)</span><br><span class="line">                <span class="keyword">if</span> (nd[u].son[i]) &#123;</span><br><span class="line">                    nd[nd[u].son[i]].fail = nd[nd[u].fail].son[i];</span><br><span class="line">                    q.<span class="built_in">push_back</span>(nd[u].son[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    nd[u].son[i] = nd[nd[u].fail].son[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> u = rt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i]; i++) &#123;</span><br><span class="line">            <span class="type">int</span> c = s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">            u = nd[u].son[c], nd[u].val++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123; e[++tot] = &#123;v, nd[u].hd&#125;, nd[u].hd = tot; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nd[x].hd; i; i = e[i].nt) &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i].to;</span><br><span class="line">            <span class="built_in">dfs</span>(v);</span><br><span class="line">            nd[x].val += nd[v].val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nd[x].idx) cnt[i] += nd[x].val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">failtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= acnt; u++) <span class="built_in">add</span>(nd[u].fail, u);</span><br><span class="line">        <span class="built_in">dfs</span>(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ac;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        ac.<span class="built_in">insert</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">    ac.<span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, t + <span class="number">1</span>);</span><br><span class="line">    ac.<span class="built_in">query</span>(t), ac.<span class="built_in">failtr</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>后记</h2><p>这篇文章是近半年未写算法后的第一篇文章，很不容易，希望大家多支持。</p><p>参考 : <a href="https://oi-wiki.org/string/ac-automaton/#kmp-%E8%87%AA%E5%8A%A8%E6%9C%BA">AC 自动机 - OI Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典树</title>
      <link href="/posts/eea60a6a/"/>
      <url>/posts/eea60a6a/</url>
      
        <content type="html"><![CDATA[<h2>定义</h2><p>字典树 ( trie )，将多个字符串进行 <strong>树</strong> 一样的处理，从而快速查找的一种算法。</p><h2>实现</h2><p>如图，我们依次加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ab</span><br><span class="line">aba</span><br><span class="line">ba</span><br><span class="line">caaa</span><br><span class="line">cab</span><br><span class="line">cba</span><br><span class="line">cc</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/xglight/photo/main/trie1.png" /></p><p>我们以边代表字母，结点之间的路径就为字符串</p><p>就得到了这棵树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> string </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oi梗</title>
      <link href="/posts/c45bdb96/"/>
      <url>/posts/c45bdb96/</url>
      
        <content type="html"><![CDATA[<p>模拟只会猜题意，贪心只能过样例。数学上来先打表，DP一般看规律。</p><p>组合数学靠运气，计算几何瞎暴力。图论一顿套模板，数论只会GCD。</p><hr /><p>骗分过样例，暴力出奇迹。暴搜挂着机，打表出省一。N方过百万，暴力踩标算。肥修赛大象，只是代码短。</p><p>想要骗到分，一定有方法。图论背模板，数论背公式。动规背方程，高精背代码，要是都不会，干脆输样例。</p><hr /><p>10年OI一场空，没开long long见祖宗</p><hr /><p>高级算法：可持久化非确定状态AC自动分块维护线段平衡仙人掌优化最小费用最大流预处理混合图上莫比乌斯反演莫队带花舞蹈链并查集树状数组套主席树预处理动态DP分治FFT求多项式逆元对数函数的指数函数用可持久化并查集合并最小费用循环流上插头DP</p><hr /><p>模拟只会猜题意，贪心只能过样例。</p><p>数学上来先打表，动规一般看规律。</p><p>组合数学靠运气，计算几何瞎暴力。</p><p>图论一顿套模板， 数论只会GCD。</p><p>递归递推伤不起，搜索茫然TLE。</p><p>分治做得像枚举，暴力枚举数第一</p><p>数据结构干瞪眼，怒刷水题找信心。</p><p>涨姿势也不容易，考试一来全懵逼。</p><p>怎么进队拿国一?看懂洛谷A+B。</p><hr /><p>刷题是一种出路， 枚举是一种思想。</p><p>打表是一种勇气，搜索是一种信仰。</p><p>剪枝是一种精神，骗分是一种日常。</p><p>爆零是一种宿命，WA是一种绝望。</p><p>TLE是一种痛苦，RE是一种放弃。</p><p>UKE是一种无奈，AC是一种原谅。</p><p>弃赛是一种颓废，AK是一种梦想。</p><p>吊打是一种必然，进队是一种奢望。</p><hr /><p>AC=Answer Coarse=粗劣的答案</p><p>AC: Answer Accidently = 意外的答案</p><p>WA=Wonderful Answer=好答案</p><p>TLE=Time Limit Enough=时间充裕</p><p>MLE=Memory Limit Enough=内存充裕</p><p>CE=Compile Easily=轻松通过编译</p><p>PC：Past Compile = 通过编译</p><p>RE=Run Excellently=完美运行</p><p>RE：Right Enough = 太过正确</p><p>UKE=Unbelievably Keep Enough Score=难以置信地保持足够的分数</p><p>UKE=United<sub>Kingdom</sub>Error=United Kingdom Error=英国的错误(不关我事)</p><p>AU=All~Unaccepted=全都不正确</p><p>AK=All~knwon=全部已知(数据)</p><p>OLE：Output Limit Enough = 输出充裕</p><p>UKE:Unknown Exactness = 不明情况地正确</p>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀函数</title>
      <link href="/posts/23c3ef31/"/>
      <url>/posts/23c3ef31/</url>
      
        <content type="html"><![CDATA[<h2>前置</h2><h3>子串</h3><p>字符串中连续的一段。</p><h3>前缀</h3><p>指从字符串开头到某个位置结束的特殊子串</p><h3>真前缀</h3><p>指从字符串开头到某个位置结束的特殊子串（不包含字符串本身）</p><h3>后缀</h3><p>指从某个位置开始到字符串结尾的特殊子串</p><h3>真后缀</h3><p>指从某个位置开始到字符串结尾的特殊子串（不包含字符串本身）</p><h2>定义</h2><p>对于一个长 <span class="math inline">\(n\)</span> 的字符串 <span class="math inline">\(s\)</span>，我们设 <span class="math inline">\(i\)</span> 位的前缀函数为 <span class="math inline">\(\pi_i\)</span></p><ol type="1"><li><p>若 <span class="math inline">\(s\)</span> 的子串 <span class="math inline">\(0\sim i\)</span> 有一对相等的<strong>真前缀</strong>与<strong>真后缀</strong>，则 <span class="math inline">\(\pi_i\)</span> 为真前缀（真后缀）的长度。</p></li><li><p>若不止一对相等的，令 <span class="math inline">\(\pi_i\)</span> 为最长的长度。</p></li><li><p>若没有，则 <span class="math inline">\(\pi_i=0\)</span></p></li><li><p><span class="math inline">\(\pi_0=0\)</span></p></li></ol><h2>计算方法</h2><h3>朴素（暴力）</h3><p>枚举：<span class="math inline">\(O(n^3)\)</span></p><h3>优化一</h3><p>简单思考一下，<span class="math inline">\(\pi_{i+1}\)</span> 的值至多为 <span class="math inline">\(\pi_i+1\)</span></p><p><span class="math inline">\(O(n^2)\)</span></p><h2>优化二</h2><p>在寻找真前缀与真后缀时，我们会枚举一个长度 <span class="math inline">\(j\)</span></p><p>当匹配失败时，我们希望找到仅次于 <span class="math inline">\(j\)</span> 的长度 <span class="math inline">\(j^{(2)}\)</span>，其中 <span class="math inline">\(j^{(2)}\)</span> 我们希望他满足前缀性质。</p><p>所以，<span class="math inline">\(j^{(n)}=\pi_{j^{n-1}-1}\)</span></p><p><span class="math inline">\(O(n)\)</span></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数论合集</title>
      <link href="/posts/cfd8ddf5/"/>
      <url>/posts/cfd8ddf5/</url>
      
        <content type="html"><![CDATA[<h2>素数（质数）</h2><h3>定义</h3><blockquote><p>只有两个因数的数叫做质因数（1和它本身）</p></blockquote><blockquote><p><span class="math inline">\(1\)</span> 既不是素数也不是合数</p></blockquote><h3>判断素数</h3><h4>朴素算法</h4><p>枚举 <span class="math inline">\(2-(n-1)\)</span>的所有数字，判断其是否能被整除，时间复杂度：<span class="math inline">\(\color{orange}O(n)\)</span></p><p>或者可以优化一下，枚举区间改成 <span class="math inline">\(2-\sqrt{n}\)</span>，时间复杂度：<span class="math inline">\(\color{orange}O(\sqrt{n})\)</span></p><h4>埃式筛法</h4><p>对于多个大数，朴素算法显然慢了</p><p>对于求多个质数，我们可以运用标记思想</p><p>我们知道，对于一个 <span class="math inline">\(x\in Z\)</span>，它的倍数一定是约数</p><p>所以我们可以从小到大的枚举 <span class="math inline">\(n\)</span> 内的质数，标记它的倍数，没被标的即是质数</p><p>时间复杂度：<span class="math inline">\(\color{orange}O(n\, In\, In\,n)\)</span>（<span class="math inline">\(In\, n\)</span>表示<span class="math inline">\(log_en\)</span>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N],ss[N],cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ssai</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">2</span>;i&lt;=x;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i]) ss[++cnt]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ss[cnt]*j&gt;n) <span class="keyword">break</span>;</span><br><span class="line">            f[ss[cnt]*j]=<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">ssai</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ss[i]); </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>欧拉筛法（线性筛法）</h4><p>我们回忆一下埃式筛法，对于一个约数，它可能被多个素数标记，浪费了时间</p><p>那么欧拉筛法就只让一个约数被他最小的质因子标记</p><p>时间复杂度：<span class="math inline">\(\color{orange}O(n)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N],ss[N],cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ssou</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i]) ss[++cnt]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ss[j]*i&gt;n) <span class="keyword">break</span>;</span><br><span class="line">            f[i*ss[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%ss[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">ssou</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ss[i]);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=red>注意，以上两个筛法都是求<span class="math inline">\(\color{red}1-n\)</span>中的素数</font></p><h3>分解质因数</h3><p><sub><sub>这还不简单</sub></sub></p><blockquote><p>算数基本定理（唯一分解定理）:任何一个约数都可以被分解成几个素数相乘的形式</p></blockquote><p>根据这条定理，我们可以采用试除法</p><p>从 <span class="math inline">\(2-\sqrt{n}\)</span> 枚举 <span class="math inline">\(n\)</span> 的质数 ，遇到素数就一直除以它，直到不能整除为止，并记录除的次数</p><p><font color=red>最后若<span class="math inline">\(\color{red}n&gt;0\)</span>，也要算一个素数</font></p><p>时间复杂度：<span class="math inline">\(\color{orange}O(logn)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dpf</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x);i++)</span><br><span class="line">        <span class="keyword">while</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">            x/=i;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>) sum++;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> ans=<span class="built_in">dpf</span>(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>合数</h2><p>合数，通俗理解：不是素数的正整数就是合数（1 除外）</p><h3>定义</h3><blockquote><p>除了 1 和它本身之外还有其他因数的数叫合数</p></blockquote><blockquote><p>1 既不是素数也不是合数</p></blockquote><h3>判断合数</h3><p><sub><sub>应该没有这种题吧</sub></sub></p><p>先用欧拉筛法，加个标记，没被标的即使合数</p><p><sub><sub>这么简单，不用放代码吧</sub></sub></p><h3>求约数个数</h3><blockquote><p>约约数个数定理:对于一个大于 1 的正整数可以 <strong>分解质因数</strong>：</p><p><span class="math inline">\(n=\prod\limits_{i=1}^{k}p_i^{a_i}=p_1^{a_1}*p_2^{a_2}*\dots *p_k^{a_k}\)</span></p><p>则 1 的约数个数为：</p><p><span class="math inline">\(f(n)=\prod\limits_{i=1}^{k}(a_i+1)=(a_1+1)*(a_2+1)*\dots*(a_k+1）\)</span></p></blockquote><p>这里给出证明：</p><blockquote><p>由约数的定义可得：<span class="math inline">\(p_1^{a_1}\)</span>有<span class="math inline">\(p_1^0,p_1^1,p_1^2\dots p_1^{a_1}\)</span>这些约数，共有<span class="math inline">\((a_1+1)\)</span>个</p><p>同理，<span class="math inline">\(p_2^{a_2}\)</span>有<span class="math inline">\((a_2+1)\)</span>个约数，<span class="math inline">\(\dots p_k^{a_k}\)</span>有<span class="math inline">\((a_k+1)\)</span>个约数</p><p><span class="math inline">\(\therefore p_1^{a_1}\)</span>中有<span class="math inline">\((a_1+1)\)</span>个因子，<span class="math inline">\(\dots p_k^{a_k}\)</span>中有<span class="math inline">\((a_k+1)\)</span>个因子</p><p>乘法原理可得：<span class="math inline">\(f_n=(a_1+1)*(a_2+1)*\dots*(a_k+1)\)</span></p></blockquote><p>时间复杂度：<span class="math inline">\(\color{orange}O(\sqrt{n})\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dpf</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>,sum=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x);i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">            x/=i;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        sum*=(cnt<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>) sum*=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> ans=<span class="built_in">dpf</span>(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你要求所有约数,用质因数一个个乘吧</p><p>时间复杂度：<span class="math inline">\(\color{orange}O(n)\)</span></p><h2>公约数&amp;公倍数</h2><h3>公约数</h3><h4>定义</h4><blockquote><p>若 x 同时是 a 和 b 的约数，则称 x 是 a 与 b 的公约数</p></blockquote><h3>公倍数</h3><h4>定义</h4><blockquote><p>若 a 和 b 同时是 x 的约数，则称 x 是 a 与 b 的公倍数</p></blockquote><h3>最大公约数</h3><h4>定义</h4><blockquote><p>若 x 是 a 和 b 的公约数且 x 最大，则称 x 是 a 和 b 的最大公约数</p><p><span class="math inline">\(gcd(a,b)=x\)</span></p></blockquote><h4>求最大公约数</h4><blockquote><p><span class="math inline">\(gcd(a,b)=gcd(b,a\,mod\,b)\)</span></p></blockquote><p>证明：</p><blockquote><p>设 <span class="math inline">\(a=bk+c\)</span>，则 <span class="math inline">\(c=a\, mod\, b\)</span></p><p>设 <span class="math inline">\(d\,|\,a,a\,|\,b\)</span>，则 <span class="math inline">\(c=a-bk,\frac{c}{d}=\frac{a}{d}-\frac{b}{d}k\)</span></p><p>反过来，</p><p>设 <span class="math inline">\(d\,|\,b,d\,|\,(a\,mod\,b)\)</span></p><p>则 <span class="math inline">\(\frac{a\,mod\,b}{d}=\frac{a}{d}-\frac{b}{d}k\)</span></p><p>移项得：<span class="math inline">\(\frac{a\,mod\,b}{d}+\frac{b}{d}k=\frac{a}{d}\)</span></p><p>显然，<span class="math inline">\(\frac{a\,mod\,b}{d}\in Z\)</span></p><p><span class="math inline">\(\therefore \frac{a}{d}\in Z\)</span>，即 <span class="math inline">\(d\,|\,a\)</span></p><p>得证</p></blockquote><p>时间复杂度：<span class="math inline">\(\color{orange}O(logn)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="type">int</span> ans=<span class="built_in">gcd</span>(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>补充</h4><p>若 <span class="math inline">\(\gcd(a,b)=1\)</span>，我们称这两个数 <strong>互质</strong></p><p>即最大的公约数为 1</p><h3>最小公倍数</h3><h4>定义</h4><blockquote><p>若 x 是 a 和 b 的公倍数且 x 最小，则称 x 是 a 和 b 的最小公倍数</p><p><span class="math inline">\(lcm(a,b)=x\)</span></p></blockquote><h4>求最小公倍数</h4><blockquote><p><span class="math inline">\(a*b=\gcd(a,b)*lcm(a,b)\)</span></p></blockquote><p>证明：</p><blockquote><p>设 <span class="math inline">\(a=p_1^{k_{a_1}}p_2^{k_{a_2}}\dots p_s^{k_{a_s}},b=p_1^{k_{b_1}}p_2^{k_{b_2}}\dots p_s^{k_{b_s}}\)</span></p><p>则 <span class="math inline">\(gcd(a,b)=p_1^{min(k_{a_1},k_{b_1})}p_2^{min(k_{a_2},k_{b_2})}\dots p_s^{min(k_{a_s},k_{b_s})}\)</span></p><p><span class="math inline">\(lcm(a,b)=p_1^{max(k_{a_1},k_{b_1})}p_2^{max(k_{a_2},k_{b_2})}\dots p_s^{max(k_{a_s},k_{b_s})}\)</span></p><p><span class="math inline">\(\because k_a+k_b=min(k_a,k_b)+max(k_a,k_b)\)</span></p><p><span class="math inline">\(\therefore a*b=gcd(a,b)*lcm(a,b)\)</span></p></blockquote><p>时间复杂度：<span class="math inline">\(\color{orange}O(logn)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="type">int</span> ans=<span class="built_in">gcd</span>(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a*b/ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>欧拉函数</h2><h3>定义</h3><blockquote><p>欧拉函数，即 <span class="math inline">\(\varphi(n)\)</span>，表示小于等于 n 且与 n 互质数的个数</p><p>即 <span class="math inline">\(\varphi(n)=\sum\limits_{i=1}^n[gcd(i,n)=1]\)</span></p></blockquote><h3>性质</h3><h4>积性函数</h4><h2>逆元</h2>]]></content>
      
      
      <categories>
          
          <category> summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="/posts/7cab1e06/"/>
      <url>/posts/7cab1e06/</url>
      
        <content type="html"><![CDATA[<h2>定义</h2><p>二叉搜索树是一棵二叉树，具有以下定义：</p><ul><li><p>若二叉搜索树的左子树不为空，则其左子树上所有点的附加权值均小于其根节点的值。</p></li><li><p>若二叉搜索树的右子树不为空，则其右子树上所有点的附加权值均大于其根节点的值。</p></li><li><p>二叉搜索树的左右子树均为二叉搜索树。</p></li></ul><h2>一些操作</h2><p>先看变量：</p><p><span class="math inline">\(lc_x\)</span>：x点的左儿子</p><p><span class="math inline">\(rc_x\)</span>：x点的右二子</p><p><span class="math inline">\(val_x\)</span>：x点的值</p><p><span class="math inline">\(cnt_x\)</span>：x点值的数量</p><p><span class="math inline">\(siz_x\)</span>：x点子树的数量</p><h3>插入</h3><p>向树中插入一个值</p><p>递归插入</p><ol type="1"><li><p>与当前节点比较，若权值小于它，加入左子树，反之加入右子树</p></li><li><p>若当前点权值与插入值一样，当前点 <span class="math inline">\(cnt++\)</span></p></li><li><p>若当前节点为空，将节点设为当前节点</p></li></ol><p>插入时注意更新变量</p><p><font color=red>不要忘记更新父节点的儿子</font></p><h3>删除</h3><p>在树中删除一个值</p><ol type="1"><li><p>先在树中查找该值节点</p></li><li><p>设改点为 <span class="math inline">\(x\)</span>，分类讨论</p><ol type="1"><li><p>若 <span class="math inline">\(cnt_x&gt;1\)</span>，将 <span class="math inline">\(cnt_x--\)</span></p></li><li><p>若 <span class="math inline">\(cnt_x=1\)</span></p><ol type="1"><li><p>若该点是叶子节点（没有儿子），删除该节点</p></li><li><p>若该点只有一个儿子，返回它的儿子</p></li><li><p>若该点有两个儿子，返回左子树的最大值或右子树的最小值</p></li></ol></li></ol></li></ol><h3>查找最大/最小值</h3><p>查最小值一直往左儿子跳</p><p>查最大值一直往右儿子跳</p><h3>查找排名为 k 的元素</h3><p>设当前节点为 <span class="math inline">\(x\)</span>，分类讨论</p><ol type="1"><li><p>若其左子树大小 <span class="math inline">\(\ge k\)</span>，查找其左子树</p></li><li><p>若其左子树大小在 <span class="math inline">\(k-cnt_x到k-1\)</span>中，返回<span class="math inline">\(x\)</span></p></li><li><p>若其左子树大小 <span class="math inline">\(&lt;k-cnt\)</span>，查找其右子树</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>operator浅谈</title>
      <link href="/posts/24055d74/"/>
      <url>/posts/24055d74/</url>
      
        <content type="html"><![CDATA[<h2>前言</h2><p><span class="math inline">\(operator\)</span>，即c++的重载运算符。</p><p>可以理解为定义了一个符号的运算规则，用来更方便处理<u>高精度</u>等特定运算。</p><h2>使用须知</h2><p><span class="math inline">\(=\)</span>赋值运算符、<span class="math inline">\([]\)</span>下标运算符、<span class="math inline">\(()\)</span>函数调用运算符、<span class="math inline">\(-&gt;\)</span>成员访问运算符。</p><p><strong>只能作为类成员重载，不能作为友元函数。</strong></p><p>还有，重载后无优先级，可以打括号。</p><p>Finally，你不应该重载 <span class="math inline">\(\&amp;\&amp;\;\|\|\;\&amp;\)</span> 运算符，他们在程序中有重要的作用。</p><h2>使用</h2><p>你应该把他定义在结构体里，他不会对结构体外的运算符产生影响。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;结构体名&#125; <span class="keyword">operator</span> &#123;运算符&#125;(&#123;运算符&#125;)&#123; </span><br><span class="line">&#123;重载规则&#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h2>例题</h2><p>单讲不好讲，上一道例题：高精度a+b</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">high</span> &#123;</span><br><span class="line">  <span class="type">int</span> len, o[<span class="number">1005</span>];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(o, <span class="number">0</span>, <span class="built_in">sizeof</span>(o));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">in</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">1005</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ch), len = <span class="built_in">strlen</span>(ch);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">      o[len - i] = (ch[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, o[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">high <span class="keyword">operator</span>+(high a, high b) &#123;</span><br><span class="line">  high c;</span><br><span class="line">  c.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">while</span> (c.len &lt;= a.len || c.len &lt;= b.len) &#123;</span><br><span class="line">    c.len++;</span><br><span class="line">    c.o[c.len] += (a.o[c.len] + b.o[c.len]);</span><br><span class="line">    c.o[c.len + <span class="number">1</span>] += (c.o[c.len] / <span class="number">10</span>);</span><br><span class="line">    c.o[c.len] %= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!c.o[c.len] &amp;&amp; c.len &gt; <span class="number">1</span>)</span><br><span class="line">    c.len--;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  high x, y;</span><br><span class="line">  x.<span class="built_in">in</span>(), y.<span class="built_in">in</span>();</span><br><span class="line">  high z = x + y;</span><br><span class="line">  z.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该好理解。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流--Dinic</title>
      <link href="/posts/cd3d697/"/>
      <url>/posts/cd3d697/</url>
      
        <content type="html"><![CDATA[<h2>过程</h2><p>整体来说，<strong>Dinic</strong> 是不断 <strong>BFS 分层</strong> 和 <strong>DFS 增广</strong> 的过程。</p><h3>BFS 分层</h3><p>每个点的 <strong>层数</strong> 即为它到源点的最短距离，源点的 <strong>层数</strong> 为 <span class="math inline">\(0\)</span>。</p><p>通过它，我们可以发现：</p><ol type="1"><li>当汇点没有 <strong>层数</strong> 时，算法结束。</li><li>当每次搜索只搜比当前点 <strong>层数</strong> 多一的点，我们找到的肯定是最短的增广路。</li></ol><h3>DFS 增广</h3><p><span class="math inline">\(S\)</span> 指源点，<span class="math inline">\(T\)</span> 指汇点，<span class="math inline">\(c_i\)</span> 指边 <span class="math inline">\(i\)</span> 的剩余容量。</p><p>运用分层，我们可以轻易的找到最短增广路。</p><p>从起点开始，每次往下进行搜索，只搜比当前 <strong>层数</strong> 多一的点，当搜到 <span class="math inline">\(T\)</span> 点，结束 <strong>DFS</strong> ，继续 <strong>BFS</strong> 分层。</p><h2>优化</h2><h3>多路增广</h3><p>该优化可让你一次搜到多条增广路。</p><p>当你从某个点回退到上一个点时，若该点还有剩余流量，那我们就考虑对其再进行 <strong>DFS</strong>。</p><h3>当前弧优化</h3><p>该优化可帮你避免不必要的搜索。</p><p>我们知道，当一条边剩余容量为 <span class="math inline">\(0\)</span> 时，他就没有用了。</p><p>这时，我们可以考虑避免对这些边的搜索，把头指针指向下一条边就可以了。</p><p>同时，对于一次 <strong>DFS</strong>，它搜过的边不会再搜第二次，我们运用这个更新指针数组。</p><p><font color=red><strong>BFS</strong> 要更新指针数组</font>。</p><p>时间复杂度：<span class="math inline">\(O(n^2m)\)</span>，该复杂度是理论上限，一般会更小。</p><h2>特殊情况</h2><p>这里只给出结论，证明看 <a href="https://oi-wiki.org/graph/flow/max-flow/#%E7%89%B9%E6%AE%8A%E6%83%85%E5%BD%A2%E4%B8%8B%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">OI-Wiki</a>。</p><p>若图中所有边容量为 <span class="math inline">\(1\)</span>，Dinic 的复杂度为 <span class="math inline">\(\textstyle O(m\min\{m^{\frac{1}{2}},n^{\frac{2}{3}}\})\)</span>。</p><p>若在图中所有边容量为 <span class="math inline">\(1\)</span> 的基础上，除源汇点外每个结点 <span class="math inline">\(u\)</span> 都满足出度为 <span class="math inline">\(1\)</span> 或入度为 <span class="math inline">\(1\)</span>，复杂度为 <span class="math inline">\(O(mn^{\frac{1}{2}})\)</span>。</p><h2>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">205</span>, M = <span class="number">5005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> ll LLINF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> v, nt;</span><br><span class="line">        ll c;</span><br><span class="line">    &#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> hd[N], tot = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll c)</span> </span>&#123; e[++tot] = &#123;v, hd[u], c&#125;, hd[u] = tot; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">uadd</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll c)</span> </span>&#123; <span class="built_in">add</span>(u, v, c), <span class="built_in">add</span>(v, u, <span class="number">0</span>); &#125;</span><br><span class="line">&#125; g;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Dinic &#123;</span><br><span class="line"><span class="type">int</span> S, T;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> dep[N], cur[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fill</span>(vis, vis + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(S);</span><br><span class="line">    dep[S] = <span class="number">0</span>, vis[S] = <span class="number">1</span>, cur[S] = g.hd[S];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = g.hd[u]; i; i = g.e[i].nt) &#123;</span><br><span class="line">            <span class="type">int</span> v = g.e[i].v;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; g.e[i].c) &#123;</span><br><span class="line">                dep[v] = dep[u] + <span class="number">1</span>, cur[v] = g.hd[v]; <span class="comment">// 注意还原 cur</span></span><br><span class="line">                vis[v] = <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vis[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, ll f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == T || f == <span class="number">0</span>) <span class="keyword">return</span> f;</span><br><span class="line"></span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cur[u]; i; i = g.e[i].nt) &#123;</span><br><span class="line">        <span class="type">int</span> v = g.e[i].v;</span><br><span class="line">        cur[u] = i; <span class="comment">// 当前弧优化</span></span><br><span class="line">        <span class="keyword">if</span> (dep[v] == dep[u] + <span class="number">1</span> &amp;&amp; g.e[i].c) &#123;</span><br><span class="line">            ll t = <span class="built_in">dfs</span>(v, <span class="built_in">min</span>(f, g.e[i].c));</span><br><span class="line">            <span class="keyword">if</span> (t) &#123;</span><br><span class="line">                g.e[i].c -= t, g.e[i ^ <span class="number">1</span>].c += t;</span><br><span class="line">                res += t, f -= t;</span><br><span class="line">                <span class="keyword">if</span> (!f) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">flow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>()) flow += <span class="built_in">dfs</span>(S, LLINF);</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace Dinic</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>), cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; Dinic::S &gt;&gt; Dinic::T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++) &#123;</span><br><span class="line">        ll c;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; c;</span><br><span class="line">        g.<span class="built_in">uadd</span>(u, v, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; Dinic::<span class="built_in">flow</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://oi-wiki.org/graph/flow/max-flow/">oi-wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> network-flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流--ISAP</title>
      <link href="/posts/fc28d770/"/>
      <url>/posts/fc28d770/</url>
      
        <content type="html"><![CDATA[<p>ISAP 和 Dinic 十分相似，应该比较好懂。</p><p>GAP 则是 ISAP 的优化。</p><h2>简介</h2><p>ISAP 算法，也是运用 <strong>BFS 分层</strong> 和 <strong>DFS 搜索</strong>。</p><p>与 Dinic 区别有两点：</p><ol type="1"><li>只用了一次 BFS 分层，后续层数更新随着 DFS 一起</li><li>因为某些原因，DFS 需要反跑（汇点-&gt;源点）</li></ol><h2>过程</h2><p>因为 ISAP 的 DFS 需要反跑，知道大家肯定打不习惯。</p><p>于是，我们可以反跑 BFS 分层，就可以正跑 DFS（反跑时汇点层数为 0）。</p><p>DFS 时，过程与 Dinic 基本相同，这里不详细展开。</p><h3>更新层数</h3><p>设 <span class="math inline">\(i\)</span> 点的层数为 <span class="math inline">\(d_i\)</span>。</p><p>当我们结束了一次 dfs（没有路可走），我们就要更新层数。</p><p>遍历 <span class="math inline">\(i\)</span> 的所有连点，找到连点中最小的层数，记为 <span class="math inline">\(mind\)</span>，则 <span class="math inline">\(d_i=mind+1\)</span>。</p><p>若点 <span class="math inline">\(i\)</span> 没有连点，则 <span class="math inline">\(d_i=n\)</span>。</p><p>当 <span class="math inline">\(d_s\ge n\)</span>，增广路已被搜完，结束循环。</p><h2>优化</h2><h3>当前弧优化</h3><p>详见 <a href="https://xglight.netlify.app/posts/cd3d697/">Dinic</a>。</p><h3>GAP</h3><p>在 ISAP 算法的基础上，我们加一个数组 <span class="math inline">\(num\)</span>，表示层数为 <span class="math inline">\(i\)</span> 的点有多少个。</p><p>更新层数时同时也更新 <span class="math inline">\(num\)</span>。</p><p>若一次更新后，<span class="math inline">\(num_i=0\)</span>，说明图中出现断层，不需要再搜索，直接退出。</p><h2>时间复杂度</h2><p>时间复杂度：<span class="math inline">\(O(n^2m)\)</span>。</p><p>虽然它与 Dinic 有着同样的理论复杂度，但实际上，GAP 在稠密图上更为优秀，Dinic 在稀疏图上更为优秀。</p><p>但是由于 Dinic 实在太好打了，而且网络流的题目一般 <span class="math inline">\(n\le 300\)</span>，所以一般用 Dinic 就行了。</p><h2>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1205</span>, M = <span class="number">120005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> ll LLINF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> v, nt;</span><br><span class="line">        ll c;</span><br><span class="line">    &#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> hd[N], tot = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll c)</span> </span>&#123; e[++tot] = &#123;v, hd[u], c&#125;, hd[u] = tot; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">uadd</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll c)</span> </span>&#123; <span class="built_in">add</span>(u, v, c), <span class="built_in">add</span>(v, u, <span class="number">0</span>); &#125;</span><br><span class="line">&#125; g;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> GAP &#123;</span><br><span class="line"><span class="type">int</span> S, T;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cur[N], dep[N], num[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> prep[N], pree[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(T);</span><br><span class="line"></span><br><span class="line">    dep[T] = <span class="number">0</span>, vis[T] = <span class="number">1</span>, cur[T] = g.hd[T], num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = g.hd[u]; i; i = g.e[i].nt) &#123;</span><br><span class="line">            <span class="type">int</span> v = g.e[i].v;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; g.e[i ^ <span class="number">1</span>].c) &#123;</span><br><span class="line">                cur[v] = g.hd[v];</span><br><span class="line">                dep[v] = dep[u] + <span class="number">1</span>, vis[v] = <span class="number">1</span>, num[dep[v]]++;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">flow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    ll ans = <span class="number">0</span>, sum = LLINF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cur[i] = g.hd[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> u = S;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dep[S] &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u == T) &#123;</span><br><span class="line">            ans += sum;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x = T; x != S; x = prep[x]) &#123;</span><br><span class="line">                <span class="type">int</span> i = pree[x];</span><br><span class="line">                g.e[i].c -= sum, g.e[i ^ <span class="number">1</span>].c += sum;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            u = S, sum = LLINF;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = cur[u]; i; i = g.e[i].nt) &#123;</span><br><span class="line">            <span class="type">int</span> v = g.e[i].v;</span><br><span class="line">            <span class="keyword">if</span> (g.e[i].c &amp;&amp; dep[u] == dep[v] + <span class="number">1</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                cur[u] = i;</span><br><span class="line">                prep[v] = u, pree[v] = i;</span><br><span class="line">                sum = <span class="built_in">min</span>(sum, g.e[i].c);</span><br><span class="line">                u = v;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = g.hd[u]; i; i = g.e[i].nt) &#123;</span><br><span class="line">                <span class="type">int</span> v = g.e[i].v;</span><br><span class="line">                <span class="keyword">if</span> (g.e[i].c) cnt = <span class="built_in">min</span>(cnt, dep[v]);</span><br><span class="line">            &#125;</span><br><span class="line">            --num[dep[u]], dep[u] = cnt + <span class="number">1</span>, num[dep[u]]++;</span><br><span class="line">            <span class="keyword">if</span> (num[dep[u]] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            cur[u] = g.hd[u];</span><br><span class="line">            <span class="keyword">if</span> (u != S) u = prep[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace GAP</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; GAP::S &gt;&gt; GAP::T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++) &#123;</span><br><span class="line">        ll c;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; c, g.<span class="built_in">uadd</span>(u, v, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; GAP::<span class="built_in">flow</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://oi-wiki.org//graph/flow/max-flow/">oi-wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> network-flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流--EK</title>
      <link href="/posts/e15a293a/"/>
      <url>/posts/e15a293a/</url>
      
        <content type="html"><![CDATA[<h2>简介</h2><p><strong>EK</strong> 算法，即 <strong>Edmonds-Karp</strong> 动能算法，是求解最大流的基本算法。</p><h2>反向边</h2><p><strong>反向边</strong> 是帮助程序能发现更优解。</p><details class="toggle" ><summary class="toggle-button" style="">例子</summary><div class="toggle-content"><p>例：</p><p>发现了一条 <span class="math inline">\(* \rightarrow A \rightarrow B \rightarrow *\)</span> 的 <strong>增广路</strong>。</p><p>但后面发现分成两条：</p><p><span class="math inline">\(* \rightarrow C \rightarrow B \rightarrow *\)</span></p><p><span class="math inline">\(* \rightarrow A \rightarrow D \rightarrow *\)</span></p><p>这样比原方案更优。</p></div></details><p>所以要建立一条 <strong>反向边</strong>，<span class="math inline">\(B \rightarrow A\)</span>，让流过去的水能够流回来。</p><h2>建立反向边</h2><h3>链式前向星（链表）</h3><p>在添加 <strong>正向边</strong> 时，也把 <strong>反向边</strong> 给添加（容量为0）。</p><p>这样对于第 i 条边的 <strong>反向边</strong> 是 <span class="math inline">\(i\oplus 1\)</span>（编号请从偶数开始存）</p><h3>邻接矩阵</h3><p>易。</p><h2>过程</h2><p>整体来说，<span class="math inline">\(EK\)</span> 就是一个不断 <strong>BFS</strong> 和 <strong>增广</strong> 的过程。</p><p>下文中，<span class="math inline">\(S\)</span> 指源点，<span class="math inline">\(T\)</span> 指汇点，<span class="math inline">\(c_i\)</span> 指边可通过的容量，<span class="math inline">\(l_i\)</span> 指点 <span class="math inline">\(i\)</span> 的流量。</p><h3>BFS</h3><p>每次从源点出发，进行搜索，若寻找到 <span class="math inline">\(T\)</span>，结束 <strong>BFS</strong> 进行增广。</p><p>假设现在我们要从 <span class="math inline">\(x \rightarrow u\)</span>：</p><ol type="1"><li>先判断是否能到达 <span class="math inline">\(u\)</span>，即 <span class="math inline">\(u\)</span> 是第一次到达且边的可通过的容量大于 <span class="math inline">\(0\)</span>。</li><li>更新 <span class="math inline">\(l_u=min(l_x,c_i)\)</span>。</li><li>记录这条边，最后要反跑找到的路径以更新容量，注意，此时不能直接更新流量，因为不确定该增广路的最大可流流量。</li><li>遇到 <span class="math inline">\(T\)</span> 后，跳出 <strong>BFS</strong>，即找到任意一条增广路就跳出。</li></ol><h3>增广</h3><p>反跑增广路。</p><p>此时 <span class="math inline">\(l_t\)</span> 即为该增广路的最大可流流量。</p><p>所以正向边的可通过容量 <span class="math inline">\(-l_t\)</span>，即反向边的可通过容量 <span class="math inline">\(+l_t\)</span>。</p><p>答案显然也 <span class="math inline">\(+l_t\)</span>。</p><p>就这样不断 <strong>BFS</strong> 和 <strong>增广</strong>，直到跑不到 <span class="math inline">\(T\)</span>。</p><p>时间复杂度：<span class="math inline">\(O(nm^2)\)</span>。</p><h2>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, M = <span class="number">2e6</span> + <span class="number">5</span>; <span class="comment">// 点数，边数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> ll LLINF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> v, nt;</span><br><span class="line">        ll c; <span class="comment">// 可通过流量</span></span><br><span class="line">    &#125; e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> hd[N], tot = <span class="number">1</span>; <span class="comment">// 注意从 2 开始对边编号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll c)</span> </span>&#123; e[++tot] = &#123;v, hd[u], c&#125;, hd[u] = tot; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">uadd</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll c)</span> </span>&#123; <span class="built_in">add</span>(u, v, c), <span class="built_in">add</span>(v, u, <span class="number">0</span>); &#125;</span><br><span class="line">&#125; g;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> EK &#123;</span><br><span class="line"><span class="type">int</span> S, T;             <span class="comment">// 源点，汇点</span></span><br><span class="line"><span class="type">int</span> prep[N], pree[N]; <span class="comment">// 前驱点，前驱边</span></span><br><span class="line">ll l[N];</span><br><span class="line"><span class="function">ll <span class="title">flow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ph;</span><br><span class="line">        q.<span class="built_in">push</span>(S);</span><br><span class="line">        l[S] = LLINF;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>(), ph.<span class="built_in">push_back</span>(u);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = g.hd[u]; i; i = g.e[i].nt) &#123;</span><br><span class="line">                <span class="type">int</span> v = g.e[i].v;</span><br><span class="line">                <span class="keyword">if</span> (!l[v] &amp;&amp; g.e[i].c) &#123;</span><br><span class="line">                    prep[v] = u, pree[v] = i;</span><br><span class="line">                    l[v] = <span class="built_in">min</span>(l[u], g.e[i].c);</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l[T]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!l[T]) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u : ph) l[u] = <span class="number">0</span>; <span class="comment">// 重置边的流量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = T; u != S; u = prep[u]) &#123;</span><br><span class="line">            <span class="type">int</span> i = pree[u];</span><br><span class="line">            g.e[i].c -= l[T], g.e[i ^ <span class="number">1</span>].c += l[T];</span><br><span class="line">        &#125;</span><br><span class="line">        res += l[T];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace EK</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; EK::S &gt;&gt; EK::T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v, c; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; c;</span><br><span class="line">        g.<span class="built_in">uadd</span>(u, v, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; EK::<span class="built_in">flow</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://oi-wiki.org//graph/flow/max-flow/">oi-wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> network-flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流--概念篇</title>
      <link href="/posts/7f952e35/"/>
      <url>/posts/7f952e35/</url>
      
        <content type="html"><![CDATA[<h2>网络</h2><p>网络表示一个有向图（可能有环），<span class="math inline">\(G=(V,E)\)</span>。</p><p>每条边 <span class="math inline">\((u,v)\in E\)</span> 都有一个权值 <span class="math inline">\(c(u,v)\)</span>，称之为容量，对于 <span class="math inline">\((u,v)\notin E\)</span>，均有 <span class="math inline">\(c(u,v)=0\)</span>。</p><p>其中有两个点，<span class="math inline">\(s\in V\)</span> 源点（没有入度）和 <span class="math inline">\(t\in V\)</span> 汇点。（没有出度）</p><h2>流</h2><p>设 <span class="math inline">\(f(u,v)\)</span> 定义在二元组 <span class="math inline">\((u\in V,v\in V)\)</span> 上的实数函数且满足：</p><ol type="1"><li>容量限制：对于每条边，流经该边的流量不得超过该边的容量，即 <span class="math inline">\(f(u,v)\le c(u,v)\)</span>。</li><li>斜对称性：每条边的流量与其相反边的流量之和为 <span class="math inline">\(0\)</span>，即 <span class="math inline">\(f(u,v)=-f(v,u)\)</span>。</li><li>流守恒性：从源点流出的流量等于汇点流入的流量，即 <span class="math inline">\(\forall x\in V-{s,t}, {\textstyle \sum_{(u,x)\in E}}f(u,x)={\textstyle \sum_{x,v\in E}}f(x,v)\)</span>。</li></ol><p>那么 <span class="math inline">\(f\)</span> 称为网络 <span class="math inline">\(G\)</span> 的流函数。对于 <span class="math inline">\((u,v)\in E\)</span>，<span class="math inline">\(f(u,v)\)</span>称为边的 <strong>流量</strong>，<span class="math inline">\(c(u,v)-f(u,v)\)</span> 称为边的 <strong>剩余容量</strong>。</p><p>整个网络的流量为：<span class="math inline">\(\sum_{(s,v)\in E}f(s,v)\)</span>，即 <strong>从源点发出的所有流量之和</strong>。</p><p>一般而言也可以把网络流理解为整个图的流量，而这个流量必满足上述三个性质。</p><details class="toggle" ><summary class="toggle-button" style="">流函数的完整定义</summary><div class="toggle-content"><p><span class="math display">\[f(u,v) =   \begin{cases}f(u,v) &amp; (u,v)\in E\\-f(v,u) &amp; (v,u)\in E\\0 &amp; (u,v)\notin E,(v,u)\notin E\end{cases}\]</span></p></div></details><h2>网络流的常见问题</h2><p>网络流问题中常见的有以下三种：最大流，最小割，费用流。</p><h3>最大流</h3><p>我们有一张图，要求从源点流向汇点的最大流量（可以有很多条路到达汇点）。</p><h3>最小费用最大流</h3><p>每条边都有一个费用，代表单位流量流过这条边的开销。我们要在求出最大流的同时，要求花费的费用最小。</p><h3>最小割</h3><p>割其实就是删边的意思，就是割掉 <span class="math inline">\(X\)</span> 条边来让 <span class="math inline">\(S\)</span> 跟 <span class="math inline">\(T\)</span> 不互通。我们要求 <span class="math inline">\(X\)</span> 条边加起来的流量总和最小。</p><h2>残量网络</h2><p>一条边的 <strong>剩余容量</strong> 指条边还可以通过的流量，即 <span class="math inline">\(c(u,v)-f(u,v)\)</span>，在实际应用中，我们也通常只关心剩余容量。</p><p>对于流函数 <span class="math inline">\(f\)</span>，<span class="math inline">\(G_f\)</span> 残量网络是网络 <span class="math inline">\(G\)</span> 中所有结点 <strong>和剩余容量大于 <span class="math inline">\(0\)</span></strong> 的边构成的子图。</p><p>形式化的定义，即 <span class="math inline">\(G_f=(V_f=V,E_f=\left\{(u,v)\in E,c_f(u,v)&gt;0\right\})\)</span>。</p><p>注意，剩余容量大于 <span class="math inline">\(0\)</span> 的边可能不在原图 <span class="math inline">\(G\)</span> 中（根据容量、剩余容量的定义以及流函数的斜对称性得到）。可以理解为，残量网络中包括了那些还剩了流量空间的边构成的图，也包括虚边（即反向边）。</p><h2>增广路</h2><p>在原图 G 中若一条从源点到汇点的路径上所有边的 <strong>剩余容量都大于0</strong> 这条路被称为增广路。</p><p>或者说，在残量网络 <span class="math inline">\(G_f\)</span> 中，一条从源点到汇点的路径被称为增广路。</p><p>参考：<a href="https://oi-wiki.org//graph/flow/max-flow/">OI WIKI</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> network-flow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵</title>
      <link href="/posts/7d16c0e9/"/>
      <url>/posts/7d16c0e9/</url>
      
        <content type="html"><![CDATA[<h2>定义</h2><p>矩阵是一个 <span class="math inline">\(n\)</span> 行 <span class="math inline">\(m\)</span> 列的的表格</p><p>也可以看成一个二维数组</p><h2>矩阵乘法</h2><h3>方法</h3><p>设 <span class="math inline">\(A\)</span> 为 <span class="math inline">\(m*d\)</span> 的矩阵，<span class="math inline">\(B\)</span> 为 <span class="math inline">\(d*n\)</span> 的矩阵</p><p><span class="math inline">\(C=A*B\)</span></p><p>则 <span class="math inline">\(C\)</span> 为 <span class="math inline">\(m*n\)</span> 的矩阵</p><p><span class="math inline">\(C_{i,j}=\sum\limits_{k=1}^{d}A_{i,k}*B_{k,j}\)</span></p><p>即：</p><p><span class="math inline">\(\begin{bmatrix}a1&amp;a2\\a3&amp;a4\end{bmatrix}*\begin{bmatrix}  b1&amp;b2\\b3&amp;b4\end{bmatrix}=\begin{bmatrix}c1&amp;c2\\c3&amp;c4\end{bmatrix}\)</span></p><p><span class="math inline">\(c1=a1*b1+a2*b3\)</span></p><p><span class="math inline">\(c2=a1*b2+a2*b4\)</span></p><p><span class="math inline">\(c3=a3*b1+a4*b3\)</span></p><p><span class="math inline">\(c4=a3*b2+a4*b4\)</span></p><p>例：</p><p><span class="math inline">\(\begin{bmatrix}5&amp;5 \\6&amp;7\end{bmatrix}*\begin{bmatrix}3&amp;2 \\7&amp;4\end{bmatrix}=\begin{bmatrix}50&amp;30 \\67&amp;40\end{bmatrix}\)</span></p><p><span class="math inline">\(50=5*3+5*7\)</span></p><p><span class="math inline">\(30=5*2+5*4\)</span></p><p><span class="math inline">\(67=6*3+7*7\)</span></p><p><span class="math inline">\(40=6*2+7*4\)</span></p><h3>定律</h3><p>结合律：<span class="math inline">\((A*B)*C=A*(B*C)\)</span></p><p><font color=red>没有交换律，<span class="math inline">\(\color{red}A*B\neq B*A\)</span>，矩阵内的数也不能随意交换</font></p><h3>矩阵快速幂</h3><p>其实就是快速幂……</p><p>为了方便，可以重载运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="type">int</span> mx[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">in</span><span class="params">(matrix &amp;x)</span></span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x.n,&amp;x.m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=x.n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">1</span>;j&lt;=x.m;j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x.mx[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(matrix x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=x.n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">1</span>;j&lt;=x.m;j++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x.mx[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(matrix &amp;x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">104</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">104</span>;j++) x.mx[i][j]=<span class="number">0</span>;</span><br><span class="line">        x.n=x.m=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">matrix <span class="keyword">operator</span> *(matrix x,matrix y)&#123;</span><br><span class="line">    matrix z;</span><br><span class="line">    z.<span class="built_in">init</span>(z);</span><br><span class="line">    z.n=x.n,z.m=y.m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=z.n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=z.m;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=x.m;k++)&#123;</span><br><span class="line">                z.mx[i][j]+=(x.mx[i][k]*y.mx[k][j])%mod,z.mx[i][j]%=mod;</span><br><span class="line">              &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">matrix <span class="title">fp</span><span class="params">(matrix x,<span class="type">long</span> <span class="type">long</span> p)</span></span>&#123;</span><br><span class="line">    matrix z;</span><br><span class="line">    z.<span class="built_in">init</span>(z);</span><br><span class="line">    z.n=x.n,z.m=x.m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=z.n;i++) z.mx[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p&amp;<span class="number">1</span>) z=z*x;</span><br><span class="line">        x=x*x;</span><br><span class="line">        p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line">matrix a,b,c;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a.<span class="built_in">init</span>(a),b.<span class="built_in">init</span>(b);</span><br><span class="line">    a.<span class="built_in">in</span>(a),b.<span class="built_in">in</span>(b);</span><br><span class="line">    a.<span class="built_in">print</span>(a);</span><br><span class="line">    b.<span class="built_in">print</span>(b);</span><br><span class="line">    c=a*b;</span><br><span class="line">    c.<span class="built_in">print</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>应用</h2><h3>求斐波那契数列的第<span class="math inline">\(n\)</span>项</h3><p>我们都知道：<span class="math inline">\(f_n=f_{n-1}+f_{n-2}\)</span></p><p>但当 <span class="math inline">\(n\)</span> 非常大时，这个会 TLE</p><p>所以我们可以运用矩阵乘法的思想，先上公式</p><p><span class="math inline">\(\begin{bmatrix}f_n&amp;f_{n-1}\end{bmatrix}=\begin{bmatrix}f_{n-1}&amp;f_{n-2}\end{bmatrix}*\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}\)</span></p><p>我们再来推一遍：</p><p><span class="math inline">\(f_n=f_{n-1}+f_{n-2}\\f_{n-1}=f_{n-1}\)</span></p><p>接着，我们把 <span class="math inline">\(A\)</span> 设为 <span class="math inline">\(\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}\)</span></p><p><span class="math inline">\(即A=\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}\)</span></p><p>那不难推出：</p><p><span class="math inline">\(\begin{bmatrix}f_n&amp;f_{n-1}\end{bmatrix}=\begin{bmatrix}f_{n-2}&amp;f_{n-3}\end{bmatrix}*A^2\)</span></p><p>继续往下一直推：</p><p><span class="math inline">\(\begin{bmatrix}f_n&amp;f_{n-1}\end{bmatrix}=\begin{bmatrix}f_2&amp;f_1\end{bmatrix}*A^{n-2}\)</span></p><p>这样，我们就可以用 <span class="math inline">\(O\left(\log n\right)\)</span> 的复杂度求出斐波那契数列的第 n 项</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> nn,mod=<span class="number">10000000007</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n,m;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mx[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">in</span><span class="params">(matrix &amp;x)</span></span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x.n,&amp;x.m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=x.n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">1</span>;j&lt;=x.m;j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x.mx[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(matrix x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=x.n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">1</span>;j&lt;=x.m;j++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x.mx[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(matrix &amp;x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">104</span>;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">104</span>;j++) x.mx[i][j]=<span class="number">0</span>;</span><br><span class="line">        x.n=x.m=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">matrix <span class="keyword">operator</span> *(matrix x,matrix y)&#123;</span><br><span class="line">    matrix z;</span><br><span class="line">    z.<span class="built_in">init</span>(z);</span><br><span class="line">    z.n=x.n,z.m=y.m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=z.n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=z.m;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=x.m;k++)&#123;</span><br><span class="line">                z.mx[i][j]+=(x.mx[i][k]*y.mx[k][j])%mod,z.mx[i][j]%=mod;</span><br><span class="line">              &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">matrix <span class="title">fp</span><span class="params">(matrix x,<span class="type">long</span> <span class="type">long</span> p)</span></span>&#123;</span><br><span class="line">    matrix z;</span><br><span class="line">    z.<span class="built_in">init</span>(z);</span><br><span class="line">    z.n=x.n,z.m=x.m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=z.n;i++) z.mx[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p&amp;<span class="number">1</span>) z=z*x;</span><br><span class="line">        x=x*x;</span><br><span class="line">        p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line">matrix a,f;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;nn);</span><br><span class="line">    f.<span class="built_in">init</span>(f),a.<span class="built_in">init</span>(a);</span><br><span class="line">    f.n=<span class="number">1</span>,f.m=<span class="number">2</span>;</span><br><span class="line">    f.mx[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>,f.mx[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    a.m=a.n=<span class="number">2</span>;</span><br><span class="line">    a.mx[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>,a.mx[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    a.mx[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>,a.mx[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    a=<span class="built_in">fp</span>(a,nn<span class="number">-2</span>);</span><br><span class="line">    f=f*a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f.mx[<span class="number">1</span>][<span class="number">1</span>]%mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>求斐波那契数列前n项的和</h3><p>先来波证明：</p><p>设 <span class="math inline">\(S_n\)</span> 为斐波那契数列前 <span class="math inline">\(n\)</span> 项和</p><p><span class="math inline">\(S_n=f_1+f_2+\dots +f_{n-1}+f_n\)</span></p><p>将右式变一下</p><p><span class="math inline">\(S_n=\textcolor{red}{f_2}+f_1+f_2+\dots +f_{n-1}+f_n-\textcolor{red}{f_2}\)</span></p><p><span class="math inline">\(\because f_n=f_{n-1}+f_{n-2}\)</span></p><p><span class="math inline">\(\therefore S_n=f_3+f_2+f_3+f_4+\dots +f_{n-1}+f_n-f_2\)</span></p><p><span class="math inline">\(\therefore S_n=f_4+f_3+f_4+f_5+\dots +f_{n-1}+f_n-f_2\)</span></p><p>以此类推：</p><p><span class="math inline">\(S_n=f_{n+1}+f_n-f_2\)</span></p><p>即 <span class="math inline">\(S_n=f_{n+1}+f_n-1\)</span></p><p>或 <span class="math inline">\(S_n=f_{n+2}-1\)</span></p><p>不知各位看懂了没？</p><p>得到了最后一条式子，应该都会了吧</p><h3>求斐波那契数列第x项到第y项的和</h3><p>前缀和思想</p><p>求 <span class="math inline">\(S_y\)</span> 与 <span class="math inline">\(S_{x-1}\)</span> 再一减</p><p>完事</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 爬虫获取随机二次元图片</title>
      <link href="/posts/bacd02e2/"/>
      <url>/posts/bacd02e2/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>不想看的可直接到 <code>实践</code> 部分拿源码。</p></div><div class="note info flat"><p>本文将以 Python 3.9 环境下进行爬虫实践。</p></div><p>此文顺便作为 Python 爬虫入门教程，主要介绍 Python 爬虫的原理、使用方法、实践。</p><h2>爬虫简介</h2><p>爬虫（Web Crawler）是一种按照一定的规则，自动地抓取互联网信息的程序或者脚本。它是一种高效的网络数据采集工具，可以用来获取大量的有用信息。</p><h2>前言</h2><p>Python 是一种高级的、跨平台的、解释型的编程语言，它有着丰富的网络爬虫库，可以用来进行网络数据采集，而且便于书写和阅读，十分方便。</p><div class="note info flat"><p>本文将以 Python 3.9 环境下进行爬虫实践。</p></div><h2>前置</h2><h3>Python 3.9 安装</h3><p>此处不再赘述，请自行安装 Python 3.9 环境，可以在网络上搜索相关教程。</p><h3>安装第三方库</h3><p>本文使用到的第三方库有：</p><ul><li>requests：用于发送 HTTP 请求</li><li>BeautifulSoup4：用于解析 HTML 文档</li></ul><p>pip 安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure><h2>爬虫原理</h2><p>爬虫的原理是模拟浏览器行为，向服务器发送 HTTP 请求，获取网页内容，然后分析网页内容，提取有效信息。</p><p>HTTP 请求有多种，常用的有两种 GET 和 POST。</p><ul><li>GET 请求：浏览器地址栏输入网址，按下回车后，浏览器会向服务器发送 GET 请求，获取网页内容。简单来说，<strong>就是获取信息</strong>。</li><li>POST 请求：表单提交，浏览器会向服务器发送 POST 请求，提交表单数据。简单来说，<strong>就是提交信息</strong>。</li></ul><p>本文仅介绍 GET 请求的爬虫实践。</p><h2>入门</h2><h3>requests 库</h3><p>requests 库是 Python 中用于发送 HTTP 请求的库，可以发送 GET 请求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://example.com&#x27;</span></span><br><span class="line"></span><br><span class="line">response = requests.get(url = url) <span class="comment"># 发送 GET 请求</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(response.status_code)  <span class="comment"># 打印响应状态码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(response.text)  <span class="comment"># 打印响应内容</span></span><br></pre></td></tr></table></figure><h4>requests.get() 方法</h4><p><code>requests.get()</code> 方法返回一个 Response 对象，包含了服务器响应的状态码、内容等信息，下面是部分常用参数说明。</p><table><thead><tr class="header"><th style="text-align: center;">参数</th><th style="text-align: center;">接受类型</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">url</td><td style="text-align: center;"><code>str</code></td><td style="text-align: center;">请求的 URL 地址</td></tr><tr class="even"><td style="text-align: center;">headers</td><td style="text-align: center;"><code>dict</code></td><td style="text-align: center;">请求头信息</td></tr><tr class="odd"><td style="text-align: center;">timeout</td><td style="text-align: center;"><code>int</code></td><td style="text-align: center;">超时时间(秒，超时后停止)</td></tr></tbody></table><p><code>headers</code> 参数可以设置请求头信息，就是浏览器的唯一身份标识，比如 User-Agent、Cookie 等，可以通过 <a href="https://tool.ip138.com/useragent/">https://tool.ip138.com/useragent/</a> 获取 <code>User-Agent</code> 值，一般也只需要 <code>User-Agent</code> 即可。</p><p>设置方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;sample user agent&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">&#x27;https://example.com&#x27;</span></span><br><span class="line">response = requests.get(url = url, headers = headers)</span><br></pre></td></tr></table></figure><h4>响应状态码</h4><p>响应状态码（status code）是 HTTP 协议中用于表示请求状态的三位数字代码，常见的有：</p><ul><li>2xx: 成功</li><li>3xx: 重定向</li><li>4xx: 客户端错误</li><li>5xx: 服务器错误</li></ul><h4>响应内容</h4><p>响应内容（response content）是服务器返回给客户端的内容，可以是 HTML 文档、JSON 数据、图片、视频等。</p><p><code>response.text</code> 属性可以获取响应内容的文本形式，<code>response.content</code> 属性可以获取响应内容的字节形式。</p><h3>BeautifulSoup4 库</h3><p>BeautifulSoup4 库是 Python 中用于解析 HTML 文档的库，可以提取 HTML 文档中的有效信息。</p><p>简单示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">html = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Example&lt;/title&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;h1&gt;Hello World&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;This is a paragraph.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)  <span class="comment"># 解析 HTML 文档</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.title)  <span class="comment"># 打印 title 标签内容</span></span><br><span class="line"><span class="built_in">print</span>(soup.body)  <span class="comment"># 打印 body 标签内容</span></span><br><span class="line"><span class="built_in">print</span>(soup.body.h1.text)  <span class="comment"># 打印 h1 标签内容</span></span><br></pre></td></tr></table></figure><h4>html 文档结构</h4><p>先介绍一下 html 文档的结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;html&gt;</code> 标签是 HTML 文档的根标签，包含了整个文档的结构。</li><li><code>&lt;head&gt;</code> 标签包含了文档的元信息，比如标题、关键字、描述、作者、脚本等。</li><li><code>&lt;body&gt;</code> 标签包含了文档的主要内容，比如文本、图片、视频、表格等。</li><li><code>&lt;title&gt;</code> 标签包含了文档的标题。</li></ul><p>对于一个 html 元素，比如 <code>&lt;h1&gt;Hello World&lt;/h1&gt;</code>，它的父标签是 <code>&lt;body&gt;</code>，它的兄弟标签是 <code>&lt;p&gt;This is a paragraph.&lt;/p&gt;</code>，他的内容是 “Hello World”。</p><p>一个 html 元素能有一些属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://example.com&quot;</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment"><!-- 超链接 --></span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://example.com/image.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Example Image&quot;</span>&gt;</span> <span class="comment"><!-- 图片 --></span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;example&quot;</span>&gt;</span> <span class="comment"><!-- 输入框 --></span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;example&quot;</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment"><!-- 类名为 "example" 的段落 --></span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment"><!-- id 为 "example" 的段落 --></span></span><br></pre></td></tr></table></figure><h4>解析方法</h4><p>下面是一些简单的解析方法：</p><table><thead><tr class="header"><th style="text-align: center;">方法</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>find('tag')</code></td><td style="text-align: center;">查找第一个匹配的标签</td></tr><tr class="even"><td style="text-align: center;"><code>find(name = "example")</code></td><td style="text-align: center;">查找第一个 name 属性值为 “example” 的标签</td></tr><tr class="odd"><td style="text-align: center;"><code>find_all('tag')</code></td><td style="text-align: center;">查找所有匹配的标签</td></tr><tr class="even"><td style="text-align: center;"><code>find_all(name = "example")</code></td><td style="text-align: center;">查找所有 name 属性值为 “example” 的标签</td></tr><tr class="odd"><td style="text-align: center;"><code>find_parent('tag')</code></td><td style="text-align: center;">查找 tag 标签的父标签</td></tr><tr class="even"><td style="text-align: center;"><code>find_next_sibling()</code></td><td style="text-align: center;">查找下一个兄弟标签</td></tr><tr class="odd"><td style="text-align: center;"><code>find_previous_sibling()</code></td><td style="text-align: center;">查找上一个兄弟标签</td></tr></tbody></table><div class="note info flat"><p>在 <code>name = "example"</code> 中，因为 <code>class</code> 是 Python 的关键字，所以用 <code>_class</code> 替代。</p></div><h3>示例</h3><p>下面是一个简单的爬虫示例，爬取 <a href="https://www.python.org">https://www.python.org</a> 首页的标题、链接、描述、图片等信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.python.org&#x27;</span></span><br><span class="line"></span><br><span class="line">response = requests.get(url = url)</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(response.text, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line"></span><br><span class="line">title = soup.find(<span class="string">&#x27;h1&#x27;</span>, class_ = <span class="string">&#x27;page-title&#x27;</span>).text.strip()  <span class="comment"># 标题</span></span><br><span class="line">description = soup.find(<span class="string">&#x27;meta&#x27;</span>, attrs = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;description&#x27;</span>&#125;)[<span class="string">&#x27;content&#x27;</span>]  <span class="comment"># 描述</span></span><br><span class="line">image = soup.find(<span class="string">&#x27;img&#x27;</span>, class_ = <span class="string">&#x27;logo&#x27;</span>)[<span class="string">&#x27;src&#x27;</span>]  <span class="comment"># 图片</span></span><br><span class="line">links = [a[<span class="string">&#x27;href&#x27;</span>] <span class="keyword">for</span> a <span class="keyword">in</span> soup.find_all(<span class="string">&#x27;a&#x27;</span>, class_ = <span class="string">&#x27;headerlink&#x27;</span>)]  <span class="comment"># 链接</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;标题：&#x27;</span>, title)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;描述：&#x27;</span>, description)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;图片：&#x27;</span>, image)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;链接：&#x27;</span>, links)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">标题： Welcome to Python.org</span><br><span class="line">描述： The official home of the Python Programming Language</span><br><span class="line">图片： https://www.python.org/static/img/python-logo@2x.png</span><br><span class="line">链接： [&#x27;https://www.python.org/downloads/&#x27;, &#x27;https://www.python.org/downloads/source/&#x27;, &#x27;https://www.python.org/downloads/windows/&#x27;, &#x27;https://www.python.org/downloads/mac-osx/&#x27;, &#x27;https://www.python.org/downloads/linux/&#x27;, &#x27;https://www.python.org/doc/&#x27;, &#x27;https://www.python.org/doc/essays/&#x27;, &#x27;https://www.python.org/doc/essays/blurb/&#x27;, &#x27;https://www.python.org/doc/essays/ppt/&#x27;, &#x27;https://www.python.org/community/&#x27;, &#x27;https://www.python.org/community/sigs/&#x27;, &#x27;https://www.python.org/community/lists/&#x27;, &#x27;https://www.python.org/community/awards/&#x27;, &#x27;https://www.python.org/psf/&#x27;, &#x27;https://www.python.org/psf/records/&#x27;, &#x27;https://www.python.org/jobs/&#x27;, &#x27;https://www.python.org/events/&#x27;, &#x27;https://www.python.org/events/python-events/&#x27;, &#x27;https://www.python.org/events/python-user-group/&#x27;, &#x27;https://www.python.org/events/python-events/past/&#x27;, &#x27;https://www.python.org/events/python-events/upcoming/&#x27;, &#x27;https://www.python.org/events/python-events/calendar/&#x27;, &#x27;https://www.python.org/events/python-events/python-events-calendar/&#x27;, &#x27;https://www.python.org/events/python-events/python-events-calendar/&#x27;]</span><br></pre></td></tr></table></figure><h2>进阶</h2><p>有时候我们会抱怨，爬虫速度太慢，有没有办法提高爬虫速度，就怪在了 Python 的运行速度上？</p><p>实际上，网络爬虫的速度主要取决于网络的连接速率，对于小项目 Python 的速度是足够的。</p><p>但是网络的连接速率并不是无限的，所以我们需要考虑如何提高爬虫的速度。</p><h3>多线程</h3><p>多线程是提高爬虫速度的一种方法，它可以让多个线程同时运行，同时发送多个网络请求，从而提高爬虫的速度。</p><p>Python 的 <code>threading</code> 库提供了多线程的支持，我们可以用它来实现多线程爬虫。</p><p>这里建议使用线程池，线程池可以管理线程，可以自动分配线程，减少线程创建和销毁的开销。</p><p>需要库：<code>concurrent.futures</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_page</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="comment"># 获取信息</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://example.com/&#x27;</span></span><br><span class="line"></span><br><span class="line">url_list = [url + <span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>)]  <span class="comment"># 构造 URL 列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">20</span>) <span class="keyword">as</span> executor: <span class="comment"># max_workers 线程数</span></span><br><span class="line">    futures = [executor.submit(get_page, url) <span class="keyword">for</span> url <span class="keyword">in</span> url_list] <span class="comment"># 构造线程池</span></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(futures):</span><br><span class="line">        <span class="keyword">if</span> future.done():</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = future.result() <span class="comment"># 函数返回值</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(e))</span><br></pre></td></tr></table></figure><h3>浏览器指纹</h3><p>对于一些网站会增加一些反爬虫机制，浏览器指纹是一种通过分析浏览器特征来判断其是否为正常浏览器的一种方法。</p><p>通过浏览器指纹我们可以绕开一些反爬虫机制，比如通过浏览器指纹来判断是否为正常浏览器。</p><p>这里使用第三方库 <code>curl_cffi</code> 来获取浏览器指纹。</p><p>pip 安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install curl_cffi</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> curl_cffi <span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://example.com&#x27;</span></span><br><span class="line"></span><br><span class="line">r = requests.get(url = url, impersonate=<span class="string">&quot;chrome101&quot;</span>) <span class="comment"># impersonate 指定浏览器</span></span><br></pre></td></tr></table></figure><h2>实践</h2><p>这里使用随机图片 API 来获取随机二次元图片。</p><p>API 网址大全：<a href="https://blog.jixiaob.cn/?post=93">https://blog.jixiaob.cn/?post=93</a></p><p>这里以 <a href="https://api.lolicon.app/#/setu">https://api.lolicon.app/#/setu</a> 为例。</p><h3>API 介绍</h3><p>API 是 Application Programming Interface 的缩写，它是一些预先定义的函数，通过这些函数，我们可以访问到一些服务或资源。</p><p>一般请求 API 可以添加一些参数。</p><p>例如对于 API : <code>example.com/api?key=value</code>，我们可以添加参数 <code>key=value</code> 来指定请求的条件。</p><p>对于多个参数，我们可以用 <code>&amp;</code> 连接，例如 <code>example.com/api?key1=value1&amp;key2=value2</code>。</p><h3>爬虫实践</h3><div class="tabs"><div class="nav-tabs no-default"></div><div class="tab-contents"></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
